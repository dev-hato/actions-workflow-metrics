import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toCommandValue = toCommandValue;
  exports.toCommandProperties = toCommandProperties;
  function toCommandValue(input) {
    if (input === null || input === undefined) {
      return "";
    } else if (typeof input === "string" || input instanceof String) {
      return input;
    }
    return JSON.stringify(input);
  }
  function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
      return {};
    }
    return {
      title: annotationProperties.title,
      file: annotationProperties.file,
      line: annotationProperties.startLine,
      endLine: annotationProperties.endLine,
      col: annotationProperties.startColumn,
      endColumn: annotationProperties.endColumn
    };
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.issueCommand = issueCommand;
  exports.issue = issue;
  var os = __importStar(__require("os"));
  var utils_1 = require_utils();
  function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  var CMD_STRING = "::";

  class Command {
    constructor(command, properties, message) {
      if (!command) {
        command = "missing.command";
      }
      this.command = command;
      this.properties = properties;
      this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = true;
        for (const key in this.properties) {
          if (this.properties.hasOwnProperty(key)) {
            const val = this.properties[key];
            if (val) {
              if (first) {
                first = false;
              } else {
                cmdStr += ",";
              }
              cmdStr += `${key}=${escapeProperty(val)}`;
            }
          }
        }
      }
      cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
      return cmdStr;
    }
  }
  function escapeData(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.issueFileCommand = issueFileCommand;
  exports.prepareKeyValueMessage = prepareKeyValueMessage;
  var crypto2 = __importStar(__require("crypto"));
  var fs = __importStar(__require("fs"));
  var os = __importStar(__require("os"));
  var utils_1 = require_utils();
  function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
      throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
      throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${crypto2.randomUUID()}`;
    const convertedValue = (0, utils_1.toCommandValue)(value);
    if (key.includes(delimiter)) {
      throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
      throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getProxyUrl = getProxyUrl;
  exports.checkBypass = checkBypass;
  function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl)) {
      return;
    }
    const proxyVar = (() => {
      if (usingSsl) {
        return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        return process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
    })();
    if (proxyVar) {
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    } else {
      return;
    }
  }
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
      return true;
    }
    const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
        return true;
      }
    }
    return false;
  }
  function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username);
      this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS((exports) => {
  var net = __require("net");
  var tls = __require("tls");
  var http = __require("http");
  var https = __require("https");
  var events = __require("events");
  var assert = __require("assert");
  var util = __require("util");
  exports.httpOverHttp = httpOverHttp;
  exports.httpsOverHttp = httpsOverHttp;
  exports.httpOverHttps = httpOverHttps;
  exports.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port, localAddress) {
      var options2 = toOptions(host, port, localAddress);
      for (var i = 0, len = self2.requests.length;i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === options2.host && pending.port === options2.port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
    var self2 = this;
    var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push(options);
      return;
    }
    self2.createSocket(options, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      req.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, options);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: false,
      headers: {
        host: options.host + ":" + options.port
      }
    });
    if (options.localAddress) {
      connectOptions.localAddress = options.localAddress;
    }
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode !== 200) {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        socket.destroy();
        var error = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug("got illegal response body from proxy");
        socket.destroy();
        var error = new Error("got illegal response body from proxy");
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
        return;
      }
      debug("tunneling connection has established");
      self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
      return cb(socket);
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug(`tunneling socket could not be established, cause=%s
`, cause.message, cause.stack);
      var error = new Error("tunneling socket could not be established, " + "cause=" + cause.message);
      error.code = "ECONNRESET";
      options.request.emit("error", error);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) {
      return;
    }
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var hostHeader = options.request.getHeader("host");
      var tlsOptions = mergeOptions({}, self2.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
      });
      var secureSocket = tls.connect(0, tlsOptions);
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function toOptions(host, port, localAddress) {
    if (typeof host === "string") {
      return {
        host,
        port,
        localAddress
      };
    }
    return host;
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length;i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length;j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== undefined) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {};
  }
  exports.debug = debug;
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kBody: Symbol("abstracted request body"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kResume: Symbol("resume"),
    kOnError: Symbol("on error"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable"),
    kListeners: Symbol("listeners"),
    kHTTPContext: Symbol("http context"),
    kMaxConcurrentStreams: Symbol("max concurrent streams"),
    kNoProxyAgent: Symbol("no proxy agent"),
    kHttpProxyAgent: Symbol("http proxy agent"),
    kHttpsProxyAgent: Symbol("https proxy agent")
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  var kUndiciError = Symbol.for("undici.error.UND_ERR");

  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kUndiciError] === true;
    }
    [kUndiciError] = true;
  }
  var kConnectTimeoutError = Symbol.for("undici.error.UND_ERR_CONNECT_TIMEOUT");

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kConnectTimeoutError] === true;
    }
    [kConnectTimeoutError] = true;
  }
  var kHeadersTimeoutError = Symbol.for("undici.error.UND_ERR_HEADERS_TIMEOUT");

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHeadersTimeoutError] === true;
    }
    [kHeadersTimeoutError] = true;
  }
  var kHeadersOverflowError = Symbol.for("undici.error.UND_ERR_HEADERS_OVERFLOW");

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHeadersOverflowError] === true;
    }
    [kHeadersOverflowError] = true;
  }
  var kBodyTimeoutError = Symbol.for("undici.error.UND_ERR_BODY_TIMEOUT");

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kBodyTimeoutError] === true;
    }
    [kBodyTimeoutError] = true;
  }
  var kResponseStatusCodeError = Symbol.for("undici.error.UND_ERR_RESPONSE_STATUS_CODE");

  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers, body) {
      super(message);
      this.name = "ResponseStatusCodeError";
      this.message = message || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseStatusCodeError] === true;
    }
    [kResponseStatusCodeError] = true;
  }
  var kInvalidArgumentError = Symbol.for("undici.error.UND_ERR_INVALID_ARG");

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInvalidArgumentError] === true;
    }
    [kInvalidArgumentError] = true;
  }
  var kInvalidReturnValueError = Symbol.for("undici.error.UND_ERR_INVALID_RETURN_VALUE");

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInvalidReturnValueError] === true;
    }
    [kInvalidReturnValueError] = true;
  }
  var kAbortError = Symbol.for("undici.error.UND_ERR_ABORT");

  class AbortError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "The operation was aborted";
      this.code = "UND_ERR_ABORT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kAbortError] === true;
    }
    [kAbortError] = true;
  }
  var kRequestAbortedError = Symbol.for("undici.error.UND_ERR_ABORTED");

  class RequestAbortedError extends AbortError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestAbortedError] === true;
    }
    [kRequestAbortedError] = true;
  }
  var kInformationalError = Symbol.for("undici.error.UND_ERR_INFO");

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInformationalError] === true;
    }
    [kInformationalError] = true;
  }
  var kRequestContentLengthMismatchError = Symbol.for("undici.error.UND_ERR_REQ_CONTENT_LENGTH_MISMATCH");

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestContentLengthMismatchError] === true;
    }
    [kRequestContentLengthMismatchError] = true;
  }
  var kResponseContentLengthMismatchError = Symbol.for("undici.error.UND_ERR_RES_CONTENT_LENGTH_MISMATCH");

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseContentLengthMismatchError] === true;
    }
    [kResponseContentLengthMismatchError] = true;
  }
  var kClientDestroyedError = Symbol.for("undici.error.UND_ERR_DESTROYED");

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kClientDestroyedError] === true;
    }
    [kClientDestroyedError] = true;
  }
  var kClientClosedError = Symbol.for("undici.error.UND_ERR_CLOSED");

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kClientClosedError] === true;
    }
    [kClientClosedError] = true;
  }
  var kSocketError = Symbol.for("undici.error.UND_ERR_SOCKET");

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kSocketError] === true;
    }
    [kSocketError] = true;
  }
  var kNotSupportedError = Symbol.for("undici.error.UND_ERR_NOT_SUPPORTED");

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kNotSupportedError] === true;
    }
    [kNotSupportedError] = true;
  }
  var kBalancedPoolMissingUpstreamError = Symbol.for("undici.error.UND_ERR_BPL_MISSING_UPSTREAM");

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kBalancedPoolMissingUpstreamError] === true;
    }
    [kBalancedPoolMissingUpstreamError] = true;
  }
  var kHTTPParserError = Symbol.for("undici.error.UND_ERR_HTTP_PARSER");

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : undefined;
      this.data = data ? data.toString() : undefined;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHTTPParserError] === true;
    }
    [kHTTPParserError] = true;
  }
  var kResponseExceededMaxSizeError = Symbol.for("undici.error.UND_ERR_RES_EXCEEDED_MAX_SIZE");

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseExceededMaxSizeError] === true;
    }
    [kResponseExceededMaxSizeError] = true;
  }
  var kRequestRetryError = Symbol.for("undici.error.UND_ERR_REQ_RETRY");

  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      this.name = "RequestRetryError";
      this.message = message || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data;
      this.headers = headers;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestRetryError] === true;
    }
    [kRequestRetryError] = true;
  }
  var kResponseError = Symbol.for("undici.error.UND_ERR_RESPONSE");

  class ResponseError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      this.name = "ResponseError";
      this.message = message || "Response error";
      this.code = "UND_ERR_RESPONSE";
      this.statusCode = code;
      this.data = data;
      this.headers = headers;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseError] === true;
    }
    [kResponseError] = true;
  }
  var kSecureProxyConnectionError = Symbol.for("undici.error.UND_ERR_PRX_TLS");

  class SecureProxyConnectionError extends UndiciError {
    constructor(cause, message, options) {
      super(message, { cause, ...options ?? {} });
      this.name = "SecureProxyConnectionError";
      this.message = message || "Secure Proxy Connection failed";
      this.code = "UND_ERR_PRX_TLS";
      this.cause = cause;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kSecureProxyConnectionError] === true;
    }
    [kSecureProxyConnectionError] = true;
  }
  module.exports = {
    AbortError,
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError,
    ResponseError,
    SecureProxyConnectionError
  };
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS((exports, module) => {
  var headerNameLowerCasedRecord = {};
  var wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    const key = wellknownHeaderNames[i];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  module.exports = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
});

// node_modules/undici/lib/core/tree.js
var require_tree = __commonJS((exports, module) => {
  var {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  } = require_constants();

  class TstNode {
    value = null;
    left = null;
    middle = null;
    right = null;
    code;
    constructor(key, value, index) {
      if (index === undefined || index >= key.length) {
        throw new TypeError("Unreachable");
      }
      const code = this.code = key.charCodeAt(index);
      if (code > 127) {
        throw new TypeError("key must be ascii string");
      }
      if (key.length !== ++index) {
        this.middle = new TstNode(key, value, index);
      } else {
        this.value = value;
      }
    }
    add(key, value) {
      const length = key.length;
      if (length === 0) {
        throw new TypeError("Unreachable");
      }
      let index = 0;
      let node = this;
      while (true) {
        const code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (node.code === code) {
          if (length === ++index) {
            node.value = value;
            break;
          } else if (node.middle !== null) {
            node = node.middle;
          } else {
            node.middle = new TstNode(key, value, index);
            break;
          }
        } else if (node.code < code) {
          if (node.left !== null) {
            node = node.left;
          } else {
            node.left = new TstNode(key, value, index);
            break;
          }
        } else if (node.right !== null) {
          node = node.right;
        } else {
          node.right = new TstNode(key, value, index);
          break;
        }
      }
    }
    search(key) {
      const keylength = key.length;
      let index = 0;
      let node = this;
      while (node !== null && index < keylength) {
        let code = key[index];
        if (code <= 90 && code >= 65) {
          code |= 32;
        }
        while (node !== null) {
          if (code === node.code) {
            if (keylength === ++index) {
              return node;
            }
            node = node.middle;
            break;
          }
          node = node.code < code ? node.left : node.right;
        }
      }
      return null;
    }
  }

  class TernarySearchTree {
    node = null;
    insert(key, value) {
      if (this.node === null) {
        this.node = new TstNode(key, value, 0);
      } else {
        this.node.add(key, value);
      }
    }
    lookup(key) {
      return this.node?.search(key)?.value ?? null;
    }
  }
  var tree = new TernarySearchTree;
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
    tree.insert(key, key);
  }
  module.exports = {
    TernarySearchTree,
    tree
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { kDestroyed, kBodyUsed, kListeners, kBody } = require_symbols();
  var { IncomingMessage } = __require("node:http");
  var stream = __require("node:stream");
  var net = __require("node:net");
  var { Blob: Blob2 } = __require("node:buffer");
  var nodeUtil = __require("node:util");
  var { stringify } = __require("node:querystring");
  var { EventEmitter: EE } = __require("node:events");
  var { InvalidArgumentError } = require_errors();
  var { headerNameLowerCasedRecord } = require_constants();
  var { tree } = require_tree();
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  function wrapRequestBody(body) {
    if (isStream(body)) {
      if (bodyLength(body) === 0) {
        body.on("data", function() {
          assert(false);
        });
      }
      if (typeof body.readableDidRead !== "boolean") {
        body[kBodyUsed] = false;
        EE.prototype.on.call(body, "data", function() {
          this[kBodyUsed] = true;
        });
      }
      return body;
    } else if (body && typeof body.pipeTo === "function") {
      return new BodyAsyncIterable(body);
    } else if (body && typeof body !== "string" && !ArrayBuffer.isView(body) && isIterable(body)) {
      return new BodyAsyncIterable(body);
    } else {
      return body;
    }
  }
  function nop() {}
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    if (object === null) {
      return false;
    } else if (object instanceof Blob2) {
      return true;
    } else if (typeof object !== "object") {
      return false;
    } else {
      const sTag = object[Symbol.toStringTag];
      return (sTag === "Blob" || sTag === "File") && (("stream" in object) && typeof object.stream === "function" || ("arrayBuffer" in object) && typeof object.arrayBuffer === "function");
    }
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function isValidPort(port) {
    const value = parseInt(port, 10);
    return value === Number(port) && value >= 0 && value <= 65535;
  }
  function isHttpOrHttpsPrefixed(value) {
    return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
      let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin[origin.length - 1] === "/") {
        origin = origin.slice(0, origin.length - 1);
      }
      if (path && path[0] !== "/") {
        path = `/${path}`;
      }
      return new URL(`${origin}${path}`);
    }
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert(typeof host === "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body) {
    if (body == null) {
      return 0;
    } else if (isStream(body)) {
      const state = body._readableState;
      return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body)) {
      return body.size != null ? body.size : null;
    } else if (isBuffer(body)) {
      return body.byteLength;
    }
    return null;
  }
  function isDestroyed(body) {
    return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      queueMicrotask(() => {
        stream2.emit("error", err);
      });
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  }
  function headerNameToString(value) {
    return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function bufferToLowerCasedHeaderName(value) {
    return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function parseHeaders(headers, obj) {
    if (obj === undefined)
      obj = {};
    for (let i = 0;i < headers.length; i += 2) {
      const key = headerNameToString(headers[i]);
      let val = obj[key];
      if (val) {
        if (typeof val === "string") {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1].toString("utf8"));
      } else {
        const headersValue = headers[i + 1];
        if (typeof headersValue === "string") {
          obj[key] = headersValue;
        } else {
          obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
        }
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers) {
    const len = headers.length;
    const ret = new Array(len);
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    let key;
    let val;
    let kLen = 0;
    for (let n = 0;n < headers.length; n += 2) {
      key = headers[n];
      val = headers[n + 1];
      typeof key !== "string" && (key = key.toString());
      typeof val !== "string" && (val = val.toString("utf8"));
      kLen = key.length;
      if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
        hasContentLength = true;
      } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = n + 1;
      }
      ret[n] = key;
      ret[n + 1] = val;
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body) {
    return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
  }
  function isErrored(body) {
    return !!(body && stream.isErrored(body));
  }
  function isReadable(body) {
    return !!(body && stream.isReadable(body));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  function ReadableStreamFrom(iterable) {
    let iterator;
    return new ReadableStream({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          queueMicrotask(() => {
            controller.close();
            controller.byobRequest?.respond(0);
          });
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          if (buf.byteLength) {
            controller.enqueue(new Uint8Array(buf));
          }
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      },
      type: "bytes"
    });
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.addListener("abort", listener);
    return () => signal.removeListener("abort", listener);
  }
  var hasToWellFormed = typeof String.prototype.toWellFormed === "function";
  var hasIsWellFormed = typeof String.prototype.isWellFormed === "function";
  function toUSVString(val) {
    return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
  }
  function isUSVString(val) {
    return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
  }
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return c >= 33 && c <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0) {
      return false;
    }
    for (let i = 0;i < characters.length; ++i) {
      if (!isTokenCharCode(characters.charCodeAt(i))) {
        return false;
      }
    }
    return true;
  }
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function isValidHeaderValue(characters) {
    return !headerCharRegex.test(characters);
  }
  function parseRangeHeader(range) {
    if (range == null || range === "")
      return { start: 0, end: null, size: null };
    const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  function addListener(obj, name, listener) {
    const listeners = obj[kListeners] ??= [];
    listeners.push([name, listener]);
    obj.on(name, listener);
    return obj;
  }
  function removeAllListeners(obj) {
    for (const [name, listener] of obj[kListeners] ?? []) {
      obj.removeListener(name, listener);
    }
    obj[kListeners] = null;
  }
  function errorRequest(client, request, err) {
    try {
      request.onError(err);
      assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  }
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  var normalizedMethodRecordsBase = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  var normalizedMethodRecords = {
    ...normalizedMethodRecordsBase,
    patch: "patch",
    PATCH: "PATCH"
  };
  Object.setPrototypeOf(normalizedMethodRecordsBase, null);
  Object.setPrototypeOf(normalizedMethodRecords, null);
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isUSVString,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    bufferToLowerCasedHeaderName,
    addListener,
    removeAllListeners,
    errorRequest,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    addAbortListener,
    isValidHTTPToken,
    isValidHeaderValue,
    isTokenCharCode,
    parseRangeHeader,
    normalizedMethodRecordsBase,
    normalizedMethodRecords,
    isValidPort,
    isHttpOrHttpsPrefixed,
    nodeMajor,
    nodeMinor,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    wrapRequestBody
  };
});

// node_modules/undici/lib/core/diagnostics.js
var require_diagnostics = __commonJS((exports, module) => {
  var diagnosticsChannel = __require("node:diagnostics_channel");
  var util = __require("node:util");
  var undiciDebugLog = util.debuglog("undici");
  var fetchDebuglog = util.debuglog("fetch");
  var websocketDebuglog = util.debuglog("websocket");
  var isClientSet = false;
  var channels = {
    beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
    connected: diagnosticsChannel.channel("undici:client:connected"),
    connectError: diagnosticsChannel.channel("undici:client:connectError"),
    sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
    create: diagnosticsChannel.channel("undici:request:create"),
    bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
    headers: diagnosticsChannel.channel("undici:request:headers"),
    trailers: diagnosticsChannel.channel("undici:request:trailers"),
    error: diagnosticsChannel.channel("undici:request:error"),
    open: diagnosticsChannel.channel("undici:websocket:open"),
    close: diagnosticsChannel.channel("undici:websocket:close"),
    socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
    ping: diagnosticsChannel.channel("undici:websocket:ping"),
    pong: diagnosticsChannel.channel("undici:websocket:pong")
  };
  if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
    const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
    diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt;
      debuglog("connecting to %s using %s%s", `${host}${port ? `:${port}` : ""}`, protocol, version);
    });
    diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt;
      debuglog("connected to %s using %s%s", `${host}${port ? `:${port}` : ""}`, protocol, version);
    });
    diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
      const {
        connectParams: { version, protocol, port, host },
        error
      } = evt;
      debuglog("connection to %s using %s%s errored - %s", `${host}${port ? `:${port}` : ""}`, protocol, version, error.message);
    });
    diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
      const {
        request: { method, path, origin }
      } = evt;
      debuglog("sending request to %s %s/%s", method, origin, path);
    });
    diagnosticsChannel.channel("undici:request:headers").subscribe((evt) => {
      const {
        request: { method, path, origin },
        response: { statusCode }
      } = evt;
      debuglog("received response to %s %s/%s - HTTP %d", method, origin, path, statusCode);
    });
    diagnosticsChannel.channel("undici:request:trailers").subscribe((evt) => {
      const {
        request: { method, path, origin }
      } = evt;
      debuglog("trailers received from %s %s/%s", method, origin, path);
    });
    diagnosticsChannel.channel("undici:request:error").subscribe((evt) => {
      const {
        request: { method, path, origin },
        error
      } = evt;
      debuglog("request to %s %s/%s errored - %s", method, origin, path, error.message);
    });
    isClientSet = true;
  }
  if (websocketDebuglog.enabled) {
    if (!isClientSet) {
      const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
      diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debuglog("connecting to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
      });
      diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debuglog("connected to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
      });
      diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host },
          error
        } = evt;
        debuglog("connection to %s%s using %s%s errored - %s", host, port ? `:${port}` : "", protocol, version, error.message);
      });
      diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
        const {
          request: { method, path, origin }
        } = evt;
        debuglog("sending request to %s %s/%s", method, origin, path);
      });
    }
    diagnosticsChannel.channel("undici:websocket:open").subscribe((evt) => {
      const {
        address: { address, port }
      } = evt;
      websocketDebuglog("connection opened %s%s", address, port ? `:${port}` : "");
    });
    diagnosticsChannel.channel("undici:websocket:close").subscribe((evt) => {
      const { websocket, code, reason } = evt;
      websocketDebuglog("closed connection to %s - %s %s", websocket.url, code, reason);
    });
    diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((err) => {
      websocketDebuglog("connection errored - %s", err.message);
    });
    diagnosticsChannel.channel("undici:websocket:ping").subscribe((evt) => {
      websocketDebuglog("ping received");
    });
    diagnosticsChannel.channel("undici:websocket:pong").subscribe((evt) => {
      websocketDebuglog("pong received");
    });
  }
  module.exports = {
    channels
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var assert = __require("node:assert");
  var {
    isValidHTTPToken,
    isValidHeaderValue,
    isStream,
    destroy,
    isBuffer,
    isFormDataLike,
    isIterable,
    isBlobLike,
    buildURL,
    validateHandler,
    getServerName,
    normalizedMethodRecords
  } = require_util();
  var { channels } = require_diagnostics();
  var { headerNameLowerCasedRecord } = require_constants();
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue,
      servername
    }, handler) {
      if (typeof path !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.test(path)) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      this.abort = null;
      if (body == null) {
        this.body = null;
      } else if (isStream(body)) {
        this.body = body;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (isBuffer(body)) {
        this.body = body.byteLength ? body : null;
      } else if (ArrayBuffer.isView(body)) {
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      } else if (body instanceof ArrayBuffer) {
        this.body = body.byteLength ? Buffer.from(body) : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {
        this.body = body;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? buildURL(path, query) : path;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = [];
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(this, headers[i], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        if (headers[Symbol.iterator]) {
          for (const header of headers) {
            if (!Array.isArray(header) || header.length !== 2) {
              throw new InvalidArgumentError("headers must be in key-value pair format");
            }
            processHeader(this, header[0], header[1]);
          }
        } else {
          const keys = Object.keys(headers);
          for (let i = 0;i < keys.length; ++i) {
            processHeader(this, keys[i], headers[keys[i]]);
          }
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      validateHandler(handler, method, upgrade);
      this.servername = servername || getServerName(this.host);
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onResponseStarted() {
      return this[kHandler].onResponseStarted?.();
    }
    onHeaders(statusCode, headers, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
  }
  function processHeader(request, key, val) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === undefined) {
      return;
    }
    let headerName = headerNameLowerCasedRecord[key];
    if (headerName === undefined) {
      headerName = key.toLowerCase();
      if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {
        throw new InvalidArgumentError("invalid header key");
      }
    }
    if (Array.isArray(val)) {
      const arr = [];
      for (let i = 0;i < val.length; i++) {
        if (typeof val[i] === "string") {
          if (!isValidHeaderValue(val[i])) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          }
          arr.push(val[i]);
        } else if (val[i] === null) {
          arr.push("");
        } else if (typeof val[i] === "object") {
          throw new InvalidArgumentError(`invalid ${key} header`);
        } else {
          arr.push(`${val[i]}`);
        }
      }
      val = arr;
    } else if (typeof val === "string") {
      if (!isValidHeaderValue(val)) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
    } else if (val === null) {
      val = "";
    } else {
      val = `${val}`;
    }
    if (request.host === null && headerName === "host") {
      if (typeof val !== "string") {
        throw new InvalidArgumentError("invalid host header");
      }
      request.host = val;
    } else if (request.contentLength === null && headerName === "content-length") {
      request.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request.contentType === null && headerName === "content-type") {
      request.contentType = val;
      request.headers.push(key, val);
    } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
      throw new InvalidArgumentError(`invalid ${headerName} header`);
    } else if (headerName === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      }
      if (value === "close") {
        request.reset = true;
      }
    } else if (headerName === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request.headers.push(key, val);
    }
  }
  module.exports = Request;
});

// node_modules/undici/lib/dispatcher/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...args) {
      const interceptors = Array.isArray(args[0]) ? args[0] : args;
      let dispatch = this.dispatch.bind(this);
      for (const interceptor of interceptors) {
        if (interceptor == null) {
          continue;
        }
        if (typeof interceptor !== "function") {
          throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
        }
        dispatch = interceptor(dispatch);
        if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
          throw new TypeError("invalid interceptor");
        }
      }
      return new ComposedDispatcher(this, dispatch);
    }
  }

  class ComposedDispatcher extends Dispatcher {
    #dispatcher = null;
    #dispatch = null;
    constructor(dispatcher, dispatch) {
      super();
      this.#dispatcher = dispatcher;
      this.#dispatch = dispatch;
    }
    dispatch(...args) {
      this.#dispatch(...args);
    }
    close(...args) {
      return this.#dispatcher.close(...args);
    }
    destroy(...args) {
      return this.#dispatcher.destroy(...args);
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/dispatcher/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors();
  var { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = require_symbols();
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1;i >= 0; i--) {
          const interceptor = this[kInterceptors][i];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError;
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1;i >= 0; i--) {
        dispatch = this[kInterceptors][i](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError;
        }
        if (this[kClosed]) {
          throw new ClientClosedError;
        }
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
        return false;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/util/timers.js
var require_timers = __commonJS((exports, module) => {
  var fastNow = 0;
  var RESOLUTION_MS = 1000;
  var TICK_MS = (RESOLUTION_MS >> 1) - 1;
  var fastNowTimeout;
  var kFastTimer = Symbol("kFastTimer");
  var fastTimers = [];
  var NOT_IN_LIST = -2;
  var TO_BE_CLEARED = -1;
  var PENDING = 0;
  var ACTIVE = 1;
  function onTick() {
    fastNow += TICK_MS;
    let idx = 0;
    let len = fastTimers.length;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer._state === PENDING) {
        timer._idleStart = fastNow - TICK_MS;
        timer._state = ACTIVE;
      } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
        timer._state = TO_BE_CLEARED;
        timer._idleStart = -1;
        timer._onTimeout(timer._timerArg);
      }
      if (timer._state === TO_BE_CLEARED) {
        timer._state = NOT_IN_LIST;
        if (--len !== 0) {
          fastTimers[idx] = fastTimers[len];
        }
      } else {
        ++idx;
      }
    }
    fastTimers.length = len;
    if (fastTimers.length !== 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTick, TICK_MS);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  }

  class FastTimer {
    [kFastTimer] = true;
    _state = NOT_IN_LIST;
    _idleTimeout = -1;
    _idleStart = -1;
    _onTimeout;
    _timerArg;
    constructor(callback, delay, arg) {
      this._onTimeout = callback;
      this._idleTimeout = delay;
      this._timerArg = arg;
      this.refresh();
    }
    refresh() {
      if (this._state === NOT_IN_LIST) {
        fastTimers.push(this);
      }
      if (!fastNowTimeout || fastTimers.length === 1) {
        refreshTimeout();
      }
      this._state = PENDING;
    }
    clear() {
      this._state = TO_BE_CLEARED;
      this._idleStart = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, arg) {
      return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
    },
    clearTimeout(timeout) {
      if (timeout[kFastTimer]) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    },
    setFastTimeout(callback, delay, arg) {
      return new FastTimer(callback, delay, arg);
    },
    clearFastTimeout(timeout) {
      timeout.clear();
    },
    now() {
      return fastNow;
    },
    tick(delay = 0) {
      fastNow += delay - RESOLUTION_MS + 1;
      onTick();
      onTick();
    },
    reset() {
      fastNow = 0;
      fastTimers.length = 0;
      clearTimeout(fastNowTimeout);
      fastNowTimeout = null;
    },
    kFastTimer
  };
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  var net = __require("node:net");
  var assert = __require("node:assert");
  var util = require_util();
  var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
  var timers = require_timers();
  function noop() {}
  var tls;
  var SessionCache;
  if (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
        this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== undefined && ref.deref() === undefined) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = __require("node:tls");
        }
        servername = servername || options.servername || util.getServerName(host) || null;
        const sessionKey = servername || hostname;
        assert(sessionKey);
        const session = customSession || sessionCache.get(sessionKey) || null;
        port = port || 443;
        socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        port = port || 80;
        socket = net.connect({
          highWaterMark: 64 * 1024,
          ...options,
          localAddress,
          port,
          host: hostname
        });
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop;
    }
    let s1 = null;
    let s2 = null;
    const fastTimer = timers.setFastTimeout(() => {
      s1 = setImmediate(() => {
        s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
      });
    }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  } : (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop;
    }
    let s1 = null;
    const fastTimer = timers.setFastTimeout(() => {
      s1 = setImmediate(() => {
        onConnectTimeout(socketWeakRef.deref(), opts);
      });
    }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer);
      clearImmediate(s1);
    };
  };
  function onConnectTimeout(socket, opts) {
    if (socket == null) {
      return;
    }
    let message = "Connect Timeout Error";
    if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
      message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
    } else {
      message += ` (attempted address: ${opts.hostname}:${opts.port},`;
    }
    message += ` timeout: ${opts.timeout}ms)`;
    util.destroy(socket, new ConnectTimeoutError(message));
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enumToMap = undefined;
  function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  }
  exports.enumToMap = enumToMap;
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
  var utils_1 = require_utils2();
  var ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2["OK"] = 0] = "OK";
    ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
    ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
    ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
    ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR2[ERROR2["USER"] = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
    TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
    TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
    FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
    FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
    FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
    METHODS2[METHODS2["GET"] = 1] = "GET";
    METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
    METHODS2[METHODS2["POST"] = 3] = "POST";
    METHODS2[METHODS2["PUT"] = 4] = "PUT";
    METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
    METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
    METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
    METHODS2[METHODS2["COPY"] = 8] = "COPY";
    METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
    METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
    METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
    METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
    METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
    METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
    METHODS2[METHODS2["BIND"] = 16] = "BIND";
    METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
    METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
    METHODS2[METHODS2["ACL"] = 19] = "ACL";
    METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
    METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
    METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
    METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
    METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
    METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
    METHODS2[METHODS2["LINK"] = 31] = "LINK";
    METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
    METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
    METHODS2[METHODS2["PRI"] = 34] = "PRI";
    METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
    METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
    METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
    METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
    METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
    METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
    FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = 65;i <= 90; i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i = 128;i <= 255; i++) {
    exports.URL_CHAR.push(i);
  }
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  module.exports = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK07MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB3QE2AhwLBgAgABAyC5otAQt/IwBBEGsiCiQAQaTQACgCACIJRQRAQeTTACgCACIFRQRAQfDTAEJ/NwIAQejTAEKAgISAgIDAADcCAEHk0wAgCkEIakFwcUHYqtWqBXMiBTYCAEH40wBBADYCAEHI0wBBADYCAAtBzNMAQYDUBDYCAEGc0ABBgNQENgIAQbDQACAFNgIAQazQAEF/NgIAQdDTAEGArAM2AgADQCABQcjQAGogAUG80ABqIgI2AgAgAiABQbTQAGoiAzYCACABQcDQAGogAzYCACABQdDQAGogAUHE0ABqIgM2AgAgAyACNgIAIAFB2NAAaiABQczQAGoiAjYCACACIAM2AgAgAUHU0ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM1ARBwasDNgIAQajQAEH00wAoAgA2AgBBmNAAQcCrAzYCAEGk0ABBiNQENgIAQcz/B0E4NgIAQYjUBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBjNAAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBtNAAaiIBIABBvNAAaigCACIAKAIIIgNGBEBBjNAAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQZTQACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBtNAAaiIBIAJBvNAAaigCACICKAIIIgNGBEBBjNAAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQbTQAGohAEGg0AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGM0AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQaDQACAENgIAQZTQACAFNgIADBELQZDQACgCACILRQ0BIAtoQQJ0QbzSAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBnNAAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQZDQACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBvNIAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbzSAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBlNAAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGc0AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBlNAAKAIAIgMgBE8EQEGg0AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQZTQACACNgIAQaDQACAANgIAIAFBCGohAQwPC0GY0AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBpNAAIAA2AgBBmNAAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QeTTACgCAARAQezTACgCAAwBC0Hw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBDGpBcHFB2KrVqgVzNgIAQfjTAEEANgIAQcjTAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEH80wBBMDYCAAwPCwJAQcTTACgCACIBRQ0AQbzTACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUH80wBBMDYCAAwPC0HI0wAtAABBBHENBAJAAkAgCQRAQczTACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQMyIAQX9GDQUgAiEGQejTACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQcTTACgCACIDBEBBvNMAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDMiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDMhACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQezTACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQM0F/RwRAIAAgBmohBiABIQAMBwtBACAGaxAzGgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtByNMAQcjTACgCAEEEcjYCAAsgAkH+////B0sNASACEDMhAEEAEDMhASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBvNMAQbzTACgCACAGaiIBNgIAQcDTACgCACABSQRAQcDTACABNgIACwJAAkACQEGk0AAoAgAiAgRAQczTACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBnNAAKAIAIgFBAEcgACABT3FFBEBBnNAAIAA2AgALQQAhAUHQ0wAgBjYCAEHM0wAgADYCAEGs0ABBfzYCAEGw0ABB5NMAKAIANgIAQdjTAEEANgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBqNAAQfTTACgCADYCAEGY0AAgATYCAEGk0AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBmNAAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBqNAAQfTTACgCADYCAEGY0AAgADYCAEGk0AAgAzYCACACIAdqQTg2AgQMAQsgAEGc0AAoAgBJBEBBnNAAIAA2AgALIAAgBmohA0HM0wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBzNMAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGk0AAgBDYCAEGY0ABBmNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQaDQACgCACAGRgRAQaDQACAENgIAQZTQAEGU0AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAc2AgAgA0EQakHU0wApAgA3AgAgA0HM0wApAgA3AghB1NMAIANBCGo2AgBB0NMAIAY2AgBBzNMAIAA2AgBB2NMAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIDcUUEQEGM0AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEGQ0AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGQ0AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBmNAAKAIAIgEgBE0NAEGk0AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGY0AAgATYCAEGk0AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUH80wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBvNIAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASABQQN2dCIBcUUEQEGM0AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbzSAGohAEGQ0AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGQ0AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEG80gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQZDQACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUG00ABqIQACf0GM0AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYzQACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBvNIAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBkNAAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBvNIAaiICKAIAIABGBEAgAiADNgIAIAMNAUGQ0AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBtNAAaiEBQaDQACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYzQACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0Gg0AAgBzYCAEGU0AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfzTAEEwNgIAQX8PCyAAQRB0DwsACwvcPyIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64");
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  module.exports = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK77MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQd0BNgIcCwYAIAAQMguaLQELfyMAQRBrIgokAEGk0AAoAgAiCUUEQEHk0wAoAgAiBUUEQEHw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBCGpBcHFB2KrVqgVzIgU2AgBB+NMAQQA2AgBByNMAQQA2AgALQczTAEGA1AQ2AgBBnNAAQYDUBDYCAEGw0AAgBTYCAEGs0ABBfzYCAEHQ0wBBgKwDNgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNQEQcGrAzYCAEGo0ABB9NMAKAIANgIAQZjQAEHAqwM2AgBBpNAAQYjUBDYCAEHM/wdBODYCAEGI1AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYzQACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQbTQAGoiASAAQbzQAGooAgAiACgCCCIDRgRAQYzQACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GU0AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQbTQAGoiASACQbzQAGooAgAiAigCCCIDRgRAQYzQACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUG00ABqIQBBoNAAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBjNAAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGg0AAgBDYCAEGU0AAgBTYCAAwRC0GQ0AAoAgAiC0UNASALaEECdEG80gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZzQACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGQ0AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbzSAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEG80gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQZTQACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBnNAAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQZTQACgCACIDIARPBEBBoNAAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GU0AAgAjYCAEGg0AAgADYCACABQQhqIQEMDwtBmNAAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQaTQACAANgIAQZjQACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0Hk0wAoAgAEQEHs0wAoAgAMAQtB8NMAQn83AgBB6NMAQoCAhICAgMAANwIAQeTTACAKQQxqQXBxQdiq1aoFczYCAEH40wBBADYCAEHI0wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB/NMAQTA2AgAMDwsCQEHE0wAoAgAiAUUNAEG80wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB/NMAQTA2AgAMDwtByNMALQAAQQRxDQQCQAJAIAkEQEHM0wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDMiAEF/Rg0FIAIhBkHo0wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUHE0wAoAgAiAwRAQbzTACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhAzIgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhAzIQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHs0wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDNBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQMxoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQcjTAEHI0wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAzIQBBABAzIQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbzTAEG80wAoAgAgBmoiATYCAEHA0wAoAgAgAUkEQEHA0wAgATYCAAsCQAJAAkBBpNAAKAIAIgIEQEHM0wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZzQACgCACIBQQBHIAAgAU9xRQRAQZzQACAANgIAC0EAIQFB0NMAIAY2AgBBzNMAIAA2AgBBrNAAQX82AgBBsNAAQeTTACgCADYCAEHY0wBBADYCAANAIAFByNAAaiABQbzQAGoiAjYCACACIAFBtNAAaiIDNgIAIAFBwNAAaiADNgIAIAFB0NAAaiABQcTQAGoiAzYCACADIAI2AgAgAUHY0ABqIAFBzNAAaiICNgIAIAIgAzYCACABQdTQAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQZjQACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQajQAEH00wAoAgA2AgBBmNAAIAA2AgBBpNAAIAM2AgAgAiAHakE4NgIEDAELIABBnNAAKAIASQRAQZzQACAANgIACyAAIAZqIQNBzNMAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQczTACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBpNAAIAQ2AgBBmNAAQZjQACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0Gg0AAoAgAgBkYEQEGg0AAgBDYCAEGU0ABBlNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGo0ABB9NMAKAIANgIAQZjQACABNgIAQaTQACAHNgIAIANBEGpB1NMAKQIANwIAIANBzNMAKQIANwIIQdTTACADQQhqNgIAQdDTACAGNgIAQczTACAANgIAQdjTAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQbTQAGohAAJ/QYzQACgCACIBQQEgBUEDdnQiA3FFBEBBjNAAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEG80gBqIQBBkNAAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBkNAAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQZjQACgCACIBIARNDQBBpNAAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBmNAAIAE2AgBBpNAAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB/NMAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbzSAGoiAygCACAGRgRAIAMgADYCACAADQFBkNAAQZDQACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQbTQAGohAAJ/QYzQACgCACICQQEgAUEDdnQiAXFFBEBBjNAAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEG80gBqIQBBkNAAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBkNAAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBvNIAaiICKAIAIANGBEAgAiAANgIAIAANAUGQ0AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIFcUUEQEGM0AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQZDQACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbzSAGoiAigCACAARgRAIAIgAzYCACADDQFBkNAAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQbTQAGohAUGg0AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGM0AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBoNAAIAc2AgBBlNAAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEH80wBBMDYCAEF/DwsgAEEQdA8LAAsL3D8iAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64");
});

// node_modules/undici/lib/web/fetch/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var corsSafeListedMethods = ["GET", "HEAD", "POST"];
  var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  var nullBodyStatus = [101, 204, 205, 304];
  var redirectStatus = [301, 302, 303, 307, 308];
  var redirectStatusSet = new Set(redirectStatus);
  var badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "4190",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6679",
    "6697",
    "10080"
  ];
  var badPortsSet = new Set(badPorts);
  var referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  var referrerPolicySet = new Set(referrerPolicy);
  var requestRedirect = ["follow", "manual", "error"];
  var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  var safeMethodsSet = new Set(safeMethods);
  var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  var requestCredentials = ["omit", "same-origin", "include"];
  var requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  var requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ];
  var requestDuplex = [
    "half"
  ];
  var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  var forbiddenMethodsSet = new Set(forbiddenMethods);
  var subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  var subresourceSet = new Set(subresource);
  module.exports = {
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
});

// node_modules/undici/lib/web/fetch/global.js
var require_global = __commonJS((exports, module) => {
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === undefined) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/web/fetch/data-url.js
var require_data_url = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var encoder = new TextEncoder;
  var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
  var HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
  var ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
  var HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(",", input, position);
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body);
      body = forgivingBase64(stringBody);
      if (body === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    if (!hashLength && href.endsWith("#")) {
      return serialized.slice(0, -1);
    }
    return serialized;
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  function hexByteToNumber(byte) {
    return byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55;
  }
  function percentDecode(input) {
    const length = input.length;
    const output = new Uint8Array(length);
    let j = 0;
    for (let i = 0;i < length; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[j++] = byte;
      } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
        output[j++] = 37;
      } else {
        output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
        i += 2;
      }
    }
    return length === j ? output : output.subarray(0, j);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(";", input, position);
      } else {
        parameterValue = collectASequenceOfCodePointsFast(";", input, position);
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data.length;
    if (dataLength % 4 === 0) {
      if (data.charCodeAt(dataLength - 1) === 61) {
        --dataLength;
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
        }
      }
    }
    if (dataLength % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
      return "failure";
    }
    const buffer = Buffer.from(data, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  function isASCIIWhitespace(char) {
    return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      while (lead < str.length && predicate(str.charCodeAt(lead)))
        lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(str.charCodeAt(trail)))
        trail--;
    }
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  function isomorphicDecode(input) {
    const length = input.length;
    if ((2 << 15) - 1 > length) {
      return String.fromCharCode.apply(null, input);
    }
    let result = "";
    let i = 0;
    let addition = (2 << 15) - 1;
    while (i < length) {
      if (i + addition > length) {
        addition = length - i;
      }
      result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
    }
    return result;
  }
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    if (mimeType.subtype.endsWith("+json")) {
      return "application/json";
    }
    if (mimeType.subtype.endsWith("+xml")) {
      return "application/xml";
    }
    return "";
  }
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType,
    removeChars,
    removeHTTPWhitespace,
    minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS,
    isomorphicDecode
  };
});

// node_modules/undici/lib/web/fetch/webidl.js
var require_webidl = __commonJS((exports, module) => {
  var { types, inspect } = __require("node:util");
  var { markAsUncloneable } = __require("node:worker_threads");
  var { toUSVString } = require_util();
  var webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts) {
    if (opts?.strict !== false) {
      if (!(V instanceof I)) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    } else {
      if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
        header: ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.markAsUncloneable = markAsUncloneable || (() => {});
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts?.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts?.clamp === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.util.Stringify = function(V) {
    const type = webidl.util.Type(V);
    switch (type) {
      case "Symbol":
        return `Symbol(${V.description})`;
      case "Object":
        return inspect(V);
      case "String":
        return `"${V}"`;
      default:
        return `${V}`;
    }
  };
  webidl.sequenceConverter = function(converter) {
    return (V, prefix, argument, Iterable) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
        });
      }
      const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
      const seq = [];
      let index = 0;
      if (method === undefined || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is not iterable.`
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (const key of keys2) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, prefix, argument, opts) => {
      if (opts?.strict !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary, prefix, argument) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (!Object.hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = Object.hasOwn(options, "defaultValue");
        if (hasDefault && value !== null) {
          value ??= defaultValue();
        }
        if (required || hasDefault || value !== undefined) {
          value = converter(value, prefix, `${argument}.${key}`);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V, prefix, argument) => {
      if (V === null) {
        return V;
      }
      return converter(V, prefix, argument);
    };
  };
  webidl.converters.DOMString = function(V, prefix, argument, opts) {
    if (V === null && opts?.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a DOMString.`
      });
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V, prefix, argument) {
    const x = webidl.converters.DOMString(V, prefix, argument);
    for (let index = 0;index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "signed", undefined, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned", undefined, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned", undefined, prefix, argument);
    return x;
  };
  webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.resizable || V.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${name} ("${webidl.util.Stringify(V)}")`,
        types: [T.name]
      });
    }
    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${name} is not a DataView.`
      });
    }
    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, prefix, name, opts) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false });
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false });
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false });
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${name} ("${webidl.util.Stringify(V)}")`,
      types: ["BufferSource"]
    });
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/web/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var zlib = __require("node:zlib");
  var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants3();
  var { getGlobalOrigin } = require_global();
  var { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require_data_url();
  var { performance: performance2 } = __require("node:perf_hooks");
  var { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require_util();
  var assert = __require("node:assert");
  var { isUint8Array } = __require("node:util/types");
  var { webidl } = require_webidl();
  var supportedHashes = [];
  var crypto2;
  try {
    crypto2 = __require("node:crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {}
  function responseURL(response) {
    const urlList = response.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status)) {
      return null;
    }
    let location = response.headersList.get("location", true);
    if (location !== null && isValidHeaderValue(location)) {
      if (!isValidEncodedURL(location)) {
        location = normalizeBinaryStringToUtf8(location);
      }
      location = new URL(location, responseURL(response));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function isValidEncodedURL(url) {
    for (let i = 0;i < url.length; ++i) {
      const code = url.charCodeAt(i);
      if (code > 126 || code < 32) {
        return false;
      }
    }
    return true;
  }
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  function requestBadPort(request) {
    const url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  var isValidHeaderName = isValidHTTPToken;
  function isValidHeaderValue(potentialValue) {
    return (potentialValue[0] === "\t" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "\t" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes(`
`) || potentialValue.includes("\r") || potentialValue.includes("\x00")) === false;
  }
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy", true) ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length;i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header, true);
  }
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (serializedOrigin === "client" || serializedOrigin === undefined) {
      return;
    }
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      request.headersList.append("origin", serializedOrigin, true);
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        default:
      }
      request.headersList.append("origin", serializedOrigin, true);
    }
  }
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
      return {
        domainLookupStartTime: defaultStartTime,
        domainLookupEndTime: defaultStartTime,
        connectionStartTime: defaultStartTime,
        connectionEndTime: defaultStartTime,
        secureConnectionStartTime: defaultStartTime,
        ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
      };
    }
    return {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance2.now(), crossOriginIsolatedCapability);
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request) {
    const policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL) {
      referrerSource = request.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    assert(url instanceof URL);
    url = new URL(url);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:")
      return true;
    if (url.protocol === "file:")
      return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto2 === undefined) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    const result = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i = 1;i < metadataList.length; ++i) {
      const metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i = 0;i < metadataList.length; ++i) {
      if (metadataList[i].algo === algorithm) {
        metadataList[pos++] = metadataList[i];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i = 0;i < actualValue.length; ++i) {
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === undefined) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result === "string");
    return result;
  }
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {

    class FastIterableIterator {
      #target;
      #kind;
      #index;
      constructor(target, kind) {
        this.#target = target;
        this.#kind = kind;
        this.#index = 0;
      }
      next() {
        if (typeof this !== "object" || this === null || !(#target in this)) {
          throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        }
        const index = this.#index;
        const values = this.#target[kInternalIterator];
        const len = values.length;
        if (index >= len) {
          return {
            value: undefined,
            done: true
          };
        }
        const { [keyIndex]: key, [valueIndex]: value } = values[index];
        this.#index = index + 1;
        let result;
        switch (this.#kind) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return {
          value: result,
          done: false
        };
      }
    }
    delete FastIterableIterator.prototype.constructor;
    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
    Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: false,
        enumerable: false,
        configurable: true,
        value: `${name} Iterator`
      },
      next: { writable: true, enumerable: true, configurable: true }
    });
    return function(target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
    const properties = {
      keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function keys() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key");
        }
      },
      values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function values() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "value");
        }
      },
      entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function entries() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key+value");
        }
      },
      forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function forEach(callbackfn, thisArg = globalThis) {
          webidl.brandCheck(this, object);
          webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
          if (typeof callbackfn !== "function") {
            throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);
          }
          for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
            callbackfn.call(thisArg, value, key, this);
          }
        }
      }
    };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: properties.entries.value
      }
    });
  }
  async function fullyReadBody(body, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      successSteps(await readAllBytes(reader));
    } catch (e) {
      errorSteps(e);
    }
  }
  function isReadableStreamLike(stream) {
    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
      controller.byobRequest?.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
        throw err;
      }
    }
  }
  var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    assert(!invalidIsomorphicEncodeValueRegex.test(input));
    return input;
  }
  async function readAllBytes(reader) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  function simpleRangeHeaderValue(value, allowWhitespace) {
    const data = value;
    if (!data.startsWith("bytes")) {
      return "failure";
    }
    const position = { position: 5 };
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    if (data.charCodeAt(position.position) !== 61) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    const rangeStart = collectASequenceOfCodePoints((char) => {
      const code = char.charCodeAt(0);
      return code >= 48 && code <= 57;
    }, data, position);
    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    if (data.charCodeAt(position.position) !== 45) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    const rangeEnd = collectASequenceOfCodePoints((char) => {
      const code = char.charCodeAt(0);
      return code >= 48 && code <= 57;
    }, data, position);
    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    if (position.position < data.length) {
      return "failure";
    }
    if (rangeEndValue === null && rangeStartValue === null) {
      return "failure";
    }
    if (rangeStartValue > rangeEndValue) {
      return "failure";
    }
    return { rangeStartValue, rangeEndValue };
  }
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    contentRange += isomorphicEncode(`${rangeStart}`);
    contentRange += "-";
    contentRange += isomorphicEncode(`${rangeEnd}`);
    contentRange += "/";
    contentRange += isomorphicEncode(`${fullLength}`);
    return contentRange;
  }

  class InflateStream extends Transform {
    #zlibOptions;
    constructor(zlibOptions) {
      super();
      this.#zlibOptions = zlibOptions;
    }
    _transform(chunk, encoding, callback) {
      if (!this._inflateStream) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(this.#zlibOptions) : zlib.createInflateRaw(this.#zlibOptions);
        this._inflateStream.on("data", this.push.bind(this));
        this._inflateStream.on("end", () => this.push(null));
        this._inflateStream.on("error", (err) => this.destroy(err));
      }
      this._inflateStream.write(chunk, encoding, callback);
    }
    _final(callback) {
      if (this._inflateStream) {
        this._inflateStream.end();
        this._inflateStream = null;
      }
      callback();
    }
  }
  function createInflate(zlibOptions) {
    return new InflateStream(zlibOptions);
  }
  function extractMimeType(headers) {
    let charset = null;
    let essence = null;
    let mimeType = null;
    const values = getDecodeSplit("content-type", headers);
    if (values === null) {
      return "failure";
    }
    for (const value of values) {
      const temporaryMimeType = parseMIMEType(value);
      if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
        continue;
      }
      mimeType = temporaryMimeType;
      if (mimeType.essence !== essence) {
        charset = null;
        if (mimeType.parameters.has("charset")) {
          charset = mimeType.parameters.get("charset");
        }
        essence = mimeType.essence;
      } else if (!mimeType.parameters.has("charset") && charset !== null) {
        mimeType.parameters.set("charset", charset);
      }
    }
    if (mimeType == null) {
      return "failure";
    }
    return mimeType;
  }
  function gettingDecodingSplitting(value) {
    const input = value;
    const position = { position: 0 };
    const values = [];
    let temporaryValue = "";
    while (position.position < input.length) {
      temporaryValue += collectASequenceOfCodePoints((char) => char !== '"' && char !== ",", input, position);
      if (position.position < input.length) {
        if (input.charCodeAt(position.position) === 34) {
          temporaryValue += collectAnHTTPQuotedString(input, position);
          if (position.position < input.length) {
            continue;
          }
        } else {
          assert(input.charCodeAt(position.position) === 44);
          position.position++;
        }
      }
      temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
      values.push(temporaryValue);
      temporaryValue = "";
    }
    return values;
  }
  function getDecodeSplit(name, list) {
    const value = list.get(name, true);
    if (value === null) {
      return null;
    }
    return gettingDecodingSplitting(value);
  }
  var textDecoder = new TextDecoder;
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }

  class EnvironmentSettingsObjectBase {
    get baseUrl() {
      return getGlobalOrigin();
    }
    get origin() {
      return this.baseUrl?.origin;
    }
    policyContainer = makePolicyContainer();
  }

  class EnvironmentSettingsObject {
    settingsObject = new EnvironmentSettingsObjectBase;
  }
  var environmentSettingsObject = new EnvironmentSettingsObject;
  module.exports = {
    isAborted,
    isCancelled,
    isValidEncodedURL,
    createDeferredPromise,
    ReadableStreamFrom,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    iteratorMixin,
    createIterator,
    isValidHeaderName,
    isValidHeaderValue,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    simpleRangeHeaderValue,
    buildContentRange,
    parseMetadata,
    createInflate,
    extractMimeType,
    getDecodeSplit,
    utf8DecodeBytes,
    environmentSettingsObject
  };
});

// node_modules/undici/lib/web/fetch/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kDispatcher: Symbol("dispatcher")
  };
});

// node_modules/undici/lib/web/fetch/file.js
var require_file = __commonJS((exports, module) => {
  var { Blob: Blob2, File: File2 } = __require("node:buffer");
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();

  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      const n = fileName;
      const t = options.type;
      const d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  function isFileLike(object) {
    return object instanceof File2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  module.exports = { FileLike, isFileLike };
});

// node_modules/undici/lib/web/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  var { isBlobLike, iteratorMixin } = require_util2();
  var { kState } = require_symbols2();
  var { kEnumerableProperty } = require_util();
  var { FileLike, isFileLike } = require_file();
  var { webidl } = require_webidl();
  var { File: NativeFile } = __require("node:buffer");
  var nodeUtil = __require("node:util");
  var File2 = globalThis.File ?? NativeFile;

  class FormData2 {
    constructor(form) {
      webidl.util.markAsUncloneable(this);
      if (form !== undefined) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.append";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "value", { strict: false }) : webidl.converters.USVString(value, prefix, "value");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "filename") : undefined;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.get";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.getAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.set";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "name", { strict: false }) : webidl.converters.USVString(value, prefix, "name");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "name") : undefined;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    [nodeUtil.inspect.custom](depth, options) {
      const state = this[kState].reduce((a, b) => {
        if (a[b.name]) {
          if (Array.isArray(a[b.name])) {
            a[b.name].push(b.value);
          } else {
            a[b.name] = [a[b.name], b.value];
          }
        } else {
          a[b.name] = b.value;
        }
        return a;
      }, { __proto__: null });
      options.depth ??= depth;
      options.colors ??= true;
      const output = nodeUtil.formatWithOptions(options, state);
      return `FormData ${output.slice(output.indexOf("]") + 2)}`;
    }
  }
  iteratorMixin("FormData", FormData2, kState, "name", "value");
  Object.defineProperties(FormData2.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    getAll: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value === "string") {} else {
      if (!isFileLike(value)) {
        value = value instanceof Blob ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== undefined) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = value instanceof NativeFile ? new File2([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  }
  module.exports = { FormData: FormData2, makeEntry };
});

// node_modules/undici/lib/web/fetch/formdata-parser.js
var require_formdata_parser = __commonJS((exports, module) => {
  var { isUSVString, bufferToLowerCasedHeaderName } = require_util();
  var { utf8DecodeBytes } = require_util2();
  var { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require_data_url();
  var { isFileLike } = require_file();
  var { makeEntry } = require_formdata();
  var assert = __require("node:assert");
  var { File: NodeFile } = __require("node:buffer");
  var File2 = globalThis.File ?? NodeFile;
  var formDataNameBuffer = Buffer.from('form-data; name="');
  var filenameBuffer = Buffer.from("; filename");
  var dd = Buffer.from("--");
  var ddcrlf = Buffer.from(`--\r
`);
  function isAsciiString(chars) {
    for (let i = 0;i < chars.length; ++i) {
      if ((chars.charCodeAt(i) & ~127) !== 0) {
        return false;
      }
    }
    return true;
  }
  function validateBoundary(boundary) {
    const length = boundary.length;
    if (length < 27 || length > 70) {
      return false;
    }
    for (let i = 0;i < length; ++i) {
      const cp = boundary.charCodeAt(i);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
        return false;
      }
    }
    return true;
  }
  function multipartFormDataParser(input, mimeType) {
    assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    const boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === undefined) {
      return "failure";
    }
    const boundary = Buffer.from(`--${boundaryString}`, "utf8");
    const entryList = [];
    const position = { position: 0 };
    while (input[position.position] === 13 && input[position.position + 1] === 10) {
      position.position += 2;
    }
    let trailing = input.length;
    while (input[trailing - 1] === 10 && input[trailing - 2] === 13) {
      trailing -= 2;
    }
    if (trailing !== input.length) {
      input = input.subarray(0, trailing);
    }
    while (true) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
        position.position += boundary.length;
      } else {
        return "failure";
      }
      if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
        return entryList;
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      }
      position.position += 2;
      const result = parseMultipartFormDataHeaders(input, position);
      if (result === "failure") {
        return "failure";
      }
      let { name, filename, contentType, encoding } = result;
      position.position += 2;
      let body;
      {
        const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) {
          return "failure";
        }
        body = input.subarray(position.position, boundaryIndex - 4);
        position.position += body.length;
        if (encoding === "base64") {
          body = Buffer.from(body.toString(), "base64");
        }
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
      let value;
      if (filename !== null) {
        contentType ??= "text/plain";
        if (!isAsciiString(contentType)) {
          contentType = "";
        }
        value = new File2([body], filename, { type: contentType });
      } else {
        value = utf8DecodeBytes(Buffer.from(body));
      }
      assert(isUSVString(name));
      assert(typeof value === "string" && isUSVString(value) || isFileLike(value));
      entryList.push(makeEntry(name, value, filename));
    }
  }
  function parseMultipartFormDataHeaders(input, position) {
    let name = null;
    let filename = null;
    let contentType = null;
    let encoding = null;
    while (true) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) {
        if (name === null) {
          return "failure";
        }
        return { name, filename, contentType, encoding };
      }
      let headerName = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 58, input, position);
      headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
      if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
        return "failure";
      }
      if (input[position.position] !== 58) {
        return "failure";
      }
      position.position++;
      collectASequenceOfBytes((char) => char === 32 || char === 9, input, position);
      switch (bufferToLowerCasedHeaderName(headerName)) {
        case "content-disposition": {
          name = filename = null;
          if (!bufferStartsWith(input, formDataNameBuffer, position)) {
            return "failure";
          }
          position.position += 17;
          name = parseMultipartFormDataName(input, position);
          if (name === null) {
            return "failure";
          }
          if (bufferStartsWith(input, filenameBuffer, position)) {
            let check = position.position + filenameBuffer.length;
            if (input[check] === 42) {
              position.position += 1;
              check += 1;
            }
            if (input[check] !== 61 || input[check + 1] !== 34) {
              return "failure";
            }
            position.position += 12;
            filename = parseMultipartFormDataName(input, position);
            if (filename === null) {
              return "failure";
            }
          }
          break;
        }
        case "content-type": {
          let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          contentType = isomorphicDecode(headerValue);
          break;
        }
        case "content-transfer-encoding": {
          let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          encoding = isomorphicDecode(headerValue);
          break;
        }
        default: {
          collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
        }
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
    }
  }
  function parseMultipartFormDataName(input, position) {
    assert(input[position.position - 1] === 34);
    let name = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 34, input, position);
    if (input[position.position] !== 34) {
      return null;
    } else {
      position.position++;
    }
    name = new TextDecoder().decode(name).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"');
    return name;
  }
  function collectASequenceOfBytes(condition, input, position) {
    let start = position.position;
    while (start < input.length && condition(input[start])) {
      ++start;
    }
    return input.subarray(position.position, position.position = start);
  }
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0;
    let trail = buf.length - 1;
    if (leading) {
      while (lead < buf.length && predicate(buf[lead]))
        lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(buf[trail]))
        trail--;
    }
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  function bufferStartsWith(buffer, start, position) {
    if (buffer.length < start.length) {
      return false;
    }
    for (let i = 0;i < start.length; i++) {
      if (start[i] !== buffer[position.position + i]) {
        return false;
      }
    }
    return true;
  }
  module.exports = {
    multipartFormDataParser,
    validateBoundary
  };
});

// node_modules/undici/lib/web/fetch/body.js
var require_body = __commonJS((exports, module) => {
  var util = require_util();
  var {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody,
    extractMimeType,
    utf8DecodeBytes
  } = require_util2();
  var { FormData: FormData2 } = require_formdata();
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();
  var { Blob: Blob2 } = __require("node:buffer");
  var assert = __require("node:assert");
  var { isErrored, isDisturbed } = __require("node:stream");
  var { isArrayBuffer } = __require("node:util/types");
  var { serializeAMimeType } = require_data_url();
  var { multipartFormDataParser } = require_formdata_parser();
  var random;
  try {
    const crypto2 = __require("node:crypto");
    random = (max) => crypto2.randomInt(0, max);
  } catch {
    random = (max) => Math.floor(Math.random(max));
  }
  var textEncoder = new TextEncoder;
  function noop() {}
  var hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
  var streamRegistry;
  if (hasFinalizationRegistry) {
    streamRegistry = new FinalizationRegistry((weakRef) => {
      const stream = weakRef.deref();
      if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
        stream.cancel("Response object has been garbage collected").catch(noop);
      }
    });
  }
  function extractBody(object, keepalive = false) {
    let stream = null;
    if (object instanceof ReadableStream) {
      stream = object;
    } else if (isBlobLike(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream({
        async pull(controller) {
          const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
          if (buffer.byteLength) {
            controller.enqueue(buffer);
          }
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {},
        type: "bytes"
      });
    }
    assert(isReadableStreamLike(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util.isFormDataLike(object)) {
      const boundary = `----formdata-undici-0${`${random(100000000000)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`);
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"` + `\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
` + `Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--\r
`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = `multipart/form-data; boundary=${boundary}`;
    } else if (isBlobLike(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util.isDisturbed(object) || object.locked) {
        throw new TypeError("Response body object should not be disturbed or locked");
      }
      stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
              controller.byobRequest?.respond(0);
            });
          } else {
            if (!isErrored(stream)) {
              const buffer = new Uint8Array(value);
              if (buffer.byteLength) {
                controller.enqueue(buffer);
              }
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: "bytes"
      });
    }
    const body = { stream, source, length };
    return [body, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (object instanceof ReadableStream) {
      assert(!util.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  }
  function cloneBody(instance, body) {
    const [out1, out2] = body.stream.tee();
    body.stream = out1;
    return {
      stream: out2,
      length: body.length,
      source: body.source
    };
  }
  function throwIfAborted(state) {
    if (state.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance) {
    const methods = {
      blob() {
        return consumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === null) {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance);
      },
      formData() {
        return consumeBody(this, (value) => {
          const mimeType = bodyMimeType(this);
          if (mimeType !== null) {
            switch (mimeType.essence) {
              case "multipart/form-data": {
                const parsed = multipartFormDataParser(value, mimeType);
                if (parsed === "failure") {
                  throw new TypeError("Failed to parse body as FormData.");
                }
                const fd = new FormData2;
                fd[kState] = parsed;
                return fd;
              }
              case "application/x-www-form-urlencoded": {
                const entries = new URLSearchParams(value.toString());
                const fd = new FormData2;
                for (const [name, value2] of entries) {
                  fd.append(name, value2);
                }
                return fd;
              }
            }
          }
          throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
        }, instance);
      },
      bytes() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes);
        }, instance);
      }
    };
    return methods;
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function consumeBody(object, convertBytesToJSValue, instance) {
    webidl.brandCheck(object, instance);
    if (bodyUnusable(object)) {
      throw new TypeError("Body is unusable: Body has already been read");
    }
    throwIfAborted(object[kState]);
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(Buffer.allocUnsafe(0));
      return promise.promise;
    }
    await fullyReadBody(object[kState].body, successSteps, errorSteps);
    return promise.promise;
  }
  function bodyUnusable(object) {
    const body = object[kState].body;
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(requestOrResponse) {
    const headers = requestOrResponse[kState].headersList;
    const mimeType = extractMimeType(headers);
    if (mimeType === "failure") {
      return null;
    }
    return mimeType;
  }
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody,
    streamRegistry,
    hasFinalizationRegistry,
    bodyUnusable
  };
});

// node_modules/undici/lib/dispatcher/client-h1.js
var require_client_h1 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var util = require_util();
  var { channels } = require_diagnostics();
  var timers = require_timers();
  var {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kClient,
    kParser,
    kBlocking,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kMaxRequests,
    kCounter,
    kMaxResponseSize,
    kOnError,
    kResume,
    kHTTPContext
  } = require_symbols();
  var constants = require_constants2();
  var EMPTY_BUF = Buffer.alloc(0);
  var FastBuffer = Buffer[Symbol.species];
  var addListener = util.addListener;
  var removeAllListeners = util.removeAllListeners;
  var extractBody;
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : undefined;
    let mod;
    try {
      mod = await WebAssembly.compile(require_llhttp_simd_wasm());
    } catch (e) {
      mod = await WebAssembly.compile(llhttpWasmData || require_llhttp_wasm());
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert(currentParser.ptr === p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert(currentParser.ptr === p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert(currentParser.ptr === p);
          return currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var USE_NATIVE_TIMER = 0;
  var USE_FAST_TIMER = 1;
  var TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
  var TIMEOUT_BODY = 4 | USE_FAST_TIMER;
  var TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
      this.llhttp = exports2;
      this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(delay, type) {
      if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
        if (this.timeout) {
          timers.clearTimeout(this.timeout);
          this.timeout = null;
        }
        if (delay) {
          if (type & USE_FAST_TIMER) {
            this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
          } else {
            this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
            this.timeout.unref();
          }
        }
        this.timeoutValue = delay;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.timeoutType = type;
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null);
      assert(currentParser == null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      this.timeout && timers.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      request.onResponseStarted();
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10) {
        const headerName = util.bufferToLowerCasedHeaderName(key);
        if (headerName === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (headerName === "connection") {
          this.connection += buf.toString();
        }
      } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util.destroy(this.socket, new HeadersOverflowError);
      }
    }
    onUpgrade(head) {
      const { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      assert(client[kSocket] === socket);
      assert(!socket.destroyed);
      assert(!this.paused);
      assert((headers.length & 1) === 0);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(request.upgrade || request.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      removeAllListeners(socket);
      client[kSocket] = null;
      client[kHTTPContext] = null;
      client[kQueue][client[kRunningIdx]++] = null;
      client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      client[kResume]();
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client, socket, headers, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request.upgrade) {
        util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
        return -1;
      }
      assert(this.timeoutType === TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request.method === "CONNECT") {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert((this.headers.length & 1) === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
      if (request.aborted) {
        return -1;
      }
      if (request.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        client[kResume]();
      }
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util.destroy(socket, new ResponseExceededMaxSizeError);
        return -1;
      }
      this.bytesRead += buf.length;
      if (request.onData(buf) === false) {
        return constants.ERROR.PAUSED;
      }
    }
    onMessageComplete() {
      const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      assert(statusCode >= 100);
      assert((this.headers.length & 1) === 0);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util.destroy(socket, new ResponseContentLengthMismatchError);
        return -1;
      }
      request.onComplete(headers);
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert(client[kRunning] === 0);
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (socket[kReset] && client[kRunning] === 0) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (client[kPipelining] == null || client[kPipelining] === 1) {
        setImmediate(() => client[kResume]());
      } else {
        client[kResume]();
      }
    }
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client, paused } = parser.deref();
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
        assert(!paused, "cannot be paused while waiting for headers");
        util.destroy(socket, new HeadersTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!paused) {
        util.destroy(socket, new BodyTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
      util.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  async function connectH1(client, socket) {
    client[kSocket] = socket;
    if (!llhttpInstance) {
      llhttpInstance = await llhttpPromise;
      llhttpPromise = null;
    }
    socket[kNoRef] = false;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kBlocking] = false;
    socket[kParser] = new Parser(client, socket, llhttpInstance);
    addListener(socket, "error", function(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      const parser = this[kParser];
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err;
      this[kClient][kOnError](err);
    });
    addListener(socket, "readable", function() {
      const parser = this[kParser];
      if (parser) {
        parser.readMore();
      }
    });
    addListener(socket, "end", function() {
      const parser = this[kParser];
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    });
    addListener(socket, "close", function() {
      const client2 = this[kClient];
      const parser = this[kParser];
      if (parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client2[kSocket] = null;
      client2[kHTTPContext] = null;
      if (client2.destroyed) {
        assert(client2[kPending] === 0);
        const requests = client2[kQueue].splice(client2[kRunningIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client2, request, err);
        }
      } else if (client2[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client2[kQueue][client2[kRunningIdx]];
        client2[kQueue][client2[kRunningIdx]++] = null;
        util.errorRequest(client2, request, err);
      }
      client2[kPendingIdx] = client2[kRunningIdx];
      assert(client2[kRunning] === 0);
      client2.emit("disconnect", client2[kUrl], [client2], err);
      client2[kResume]();
    });
    let closed = false;
    socket.on("close", () => {
      closed = true;
    });
    return {
      version: "h1",
      defaultPipelining: 1,
      write(...args) {
        return writeH1(client, ...args);
      },
      resume() {
        resumeH1(client);
      },
      destroy(err, callback) {
        if (closed) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy(request) {
        if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return true;
        }
        if (request) {
          if (client[kRunning] > 0 && !request.idempotent) {
            return true;
          }
          if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
            return true;
          }
          if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {
            return true;
          }
        }
        return false;
      }
    };
  }
  function resumeH1(client) {
    const socket = client[kSocket];
    if (socket && !socket.destroyed) {
      if (client[kSize] === 0) {
        if (!socket[kNoRef] && socket.unref) {
          socket.unref();
          socket[kNoRef] = true;
        }
      } else if (socket[kNoRef] && socket.ref) {
        socket.ref();
        socket[kNoRef] = false;
      }
      if (client[kSize] === 0) {
        if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
        }
      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
          const request = client[kQueue][client[kRunningIdx]];
          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];
          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
        }
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH1(client, request) {
    const { method, path, host, upgrade, blocking, reset } = request;
    let { body, headers, contentLength } = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
    if (util.isFormDataLike(body)) {
      if (!extractBody) {
        extractBody = require_body().extractBody;
      }
      const [bodyStream, contentType] = extractBody(body);
      if (request.contentType == null) {
        headers.push("content-type", contentType);
      }
      body = bodyStream.stream;
      contentLength = bodyStream.length;
    } else if (util.isBlobLike(body) && request.contentType == null && body.type) {
      headers.push("content-type", body.type);
    }
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    const bodyLength = util.bodyLength(body);
    contentLength = bodyLength ?? contentLength;
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        util.errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    const socket = client[kSocket];
    const abort = (err) => {
      if (request.aborted || request.completed) {
        return;
      }
      util.errorRequest(client, request, err || new RequestAbortedError);
      util.destroy(body);
      util.destroy(socket, new InformationalError("aborted"));
    };
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path} HTTP/1.1\r
`;
    if (typeof host === "string") {
      header += `host: ${host}\r
`;
    } else {
      header += client[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client[kPipelining] && !socket[kReset]) {
      header += `connection: keep-alive\r
`;
    } else {
      header += `connection: close\r
`;
    }
    if (Array.isArray(headers)) {
      for (let n = 0;n < headers.length; n += 2) {
        const key = headers[n + 0];
        const val = headers[n + 1];
        if (Array.isArray(val)) {
          for (let i = 0;i < val.length; i++) {
            header += `${key}: ${val[i]}\r
`;
          }
        } else {
          header += `${key}: ${val}\r
`;
        }
      }
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request, headers: header, socket });
    }
    if (!body || bodyLength === 0) {
      writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isBuffer(body)) {
      writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === "function") {
        writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);
      } else {
        writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);
      }
    } else if (util.isStream(body)) {
      writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isIterable(body)) {
      writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else {
      assert(false);
    }
    return true;
  }
  function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    let finished = false;
    const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body.resume) {
        body.resume();
      }
    };
    const onClose = function() {
      queueMicrotask(() => {
        body.removeListener("error", onFinished);
      });
      if (!finished) {
        const err = new RequestAbortedError;
        queueMicrotask(() => onFinished(err));
      }
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util.destroy(body, err);
      } else {
        util.destroy(body);
      }
    };
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
    if (body.resume) {
      body.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
    if (body.errorEmitted ?? body.errored) {
      setImmediate(() => onFinished(body.errored));
    } else if (body.endEmitted ?? body.readableEnded) {
      setImmediate(() => onFinished(null));
    }
    if (body.closeEmitted ?? body.closed) {
      setImmediate(onClose);
    }
  }
  function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    try {
      if (!body) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
      }
      request.onRequestSent();
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(buffer);
      socket.uncork();
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload && request.reset !== false) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }

  class AsyncWriter {
    constructor({ abort, socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket;
      this.request = request;
      this.contentLength = contentLength;
      this.client = client;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      this.abort = abort;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        }
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      request.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write(`\r
0\r
\r
`, "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        } else {
          process.emitWarning(new RequestContentLengthMismatchError);
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      client[kResume]();
    }
    destroy(err) {
      const { socket, client, abort } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client[kRunning] <= 1, "pipeline should only contain this request");
        abort(err);
      }
    }
  }
  module.exports = connectH1;
});

// node_modules/undici/lib/dispatcher/client-h2.js
var require_client_h2 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { pipeline } = __require("node:stream");
  var util = require_util();
  var {
    RequestContentLengthMismatchError,
    RequestAbortedError,
    SocketError,
    InformationalError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kClient,
    kRunning,
    kPending,
    kQueue,
    kPendingIdx,
    kRunningIdx,
    kError,
    kSocket,
    kStrictContentLength,
    kOnError,
    kMaxConcurrentStreams,
    kHTTP2Session,
    kResume,
    kSize,
    kHTTPContext
  } = require_symbols();
  var kOpenStreams = Symbol("open streams");
  var extractBody;
  var h2ExperimentalWarned = false;
  var http2;
  try {
    http2 = __require("node:http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2;
  function parseH2Headers(headers) {
    const result = [];
    for (const [name, value] of Object.entries(headers)) {
      if (Array.isArray(value)) {
        for (const subvalue of value) {
          result.push(Buffer.from(name), Buffer.from(subvalue));
        }
      } else {
        result.push(Buffer.from(name), Buffer.from(value));
      }
    }
    return result;
  }
  async function connectH2(client, socket) {
    client[kSocket] = socket;
    if (!h2ExperimentalWarned) {
      h2ExperimentalWarned = true;
      process.emitWarning("H2 support is experimental, expect them to change at any time.", {
        code: "UNDICI-H2"
      });
    }
    const session = http2.connect(client[kUrl], {
      createConnection: () => socket,
      peerMaxConcurrentStreams: client[kMaxConcurrentStreams]
    });
    session[kOpenStreams] = 0;
    session[kClient] = client;
    session[kSocket] = socket;
    util.addListener(session, "error", onHttp2SessionError);
    util.addListener(session, "frameError", onHttp2FrameError);
    util.addListener(session, "end", onHttp2SessionEnd);
    util.addListener(session, "goaway", onHTTP2GoAway);
    util.addListener(session, "close", function() {
      const { [kClient]: client2 } = this;
      const { [kSocket]: socket2 } = client2;
      const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket2));
      client2[kHTTP2Session] = null;
      if (client2.destroyed) {
        assert(client2[kPending] === 0);
        const requests = client2[kQueue].splice(client2[kRunningIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client2, request, err);
        }
      }
    });
    session.unref();
    client[kHTTP2Session] = session;
    socket[kHTTP2Session] = session;
    util.addListener(socket, "error", function(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kError] = err;
      this[kClient][kOnError](err);
    });
    util.addListener(socket, "end", function() {
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    });
    util.addListener(socket, "close", function() {
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (this[kHTTP2Session] != null) {
        this[kHTTP2Session].destroy(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    });
    let closed = false;
    socket.on("close", () => {
      closed = true;
    });
    return {
      version: "h2",
      defaultPipelining: Infinity,
      write(...args) {
        return writeH2(client, ...args);
      },
      resume() {
        resumeH2(client);
      },
      destroy(err, callback) {
        if (closed) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy() {
        return false;
      }
    };
  }
  function resumeH2(client) {
    const socket = client[kSocket];
    if (socket?.destroyed === false) {
      if (client[kSize] === 0 && client[kMaxConcurrentStreams] === 0) {
        socket.unref();
        client[kHTTP2Session].unref();
      } else {
        socket.ref();
        client[kHTTP2Session].ref();
      }
    }
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttp2FrameError(type, code, id) {
    if (id === 0) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
  }
  function onHttp2SessionEnd() {
    const err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
    this.destroy(err);
    util.destroy(this[kSocket], err);
  }
  function onHTTP2GoAway(code) {
    const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${code}`, util.getSocketInfo(this));
    const client = this[kClient];
    client[kSocket] = null;
    client[kHTTPContext] = null;
    if (this[kHTTP2Session] != null) {
      this[kHTTP2Session].destroy(err);
      this[kHTTP2Session] = null;
    }
    util.destroy(this[kSocket], err);
    if (client[kRunningIdx] < client[kQueue].length) {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      util.errorRequest(client, request, err);
      client[kPendingIdx] = client[kRunningIdx];
    }
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    client[kResume]();
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH2(client, request) {
    const session = client[kHTTP2Session];
    const { method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
    let { body } = request;
    if (upgrade) {
      util.errorRequest(client, request, new Error("Upgrade not supported for H2"));
      return false;
    }
    const headers = {};
    for (let n = 0;n < reqHeaders.length; n += 2) {
      const key = reqHeaders[n + 0];
      const val = reqHeaders[n + 1];
      if (Array.isArray(val)) {
        for (let i = 0;i < val.length; i++) {
          if (headers[key]) {
            headers[key] += `,${val[i]}`;
          } else {
            headers[key] = val[i];
          }
        }
      } else {
        headers[key] = val;
      }
    }
    let stream;
    const { hostname, port } = client[kUrl];
    headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
    headers[HTTP2_HEADER_METHOD] = method;
    const abort = (err) => {
      if (request.aborted || request.completed) {
        return;
      }
      err = err || new RequestAbortedError;
      util.errorRequest(client, request, err);
      if (stream != null) {
        util.destroy(stream, err);
      }
      util.destroy(body, err);
      client[kQueue][client[kRunningIdx]++] = null;
      client[kResume]();
    };
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "CONNECT") {
      session.ref();
      stream = session.request(headers, { endStream: false, signal });
      if (stream.id && !stream.pending) {
        request.onUpgrade(null, null, stream);
        ++session[kOpenStreams];
        client[kQueue][client[kRunningIdx]++] = null;
      } else {
        stream.once("ready", () => {
          request.onUpgrade(null, null, stream);
          ++session[kOpenStreams];
          client[kQueue][client[kRunningIdx]++] = null;
        });
      }
      stream.once("close", () => {
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0)
          session.unref();
      });
      return true;
    }
    headers[HTTP2_HEADER_PATH] = path;
    headers[HTTP2_HEADER_SCHEME] = "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (util.isFormDataLike(body)) {
      extractBody ??= require_body().extractBody;
      const [bodyStream, contentType] = extractBody(body);
      headers["content-type"] = contentType;
      body = bodyStream.stream;
      contentLength = bodyStream.length;
    }
    if (contentLength == null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 || !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        util.errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null) {
      assert(body, "no body must not have content length");
      headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    const shouldEndStream = method === "GET" || method === "HEAD" || body === null;
    if (expectContinue) {
      headers[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers, { endStream: shouldEndStream, signal });
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      });
      writeBodyH2();
    }
    ++session[kOpenStreams];
    stream.once("response", (headers2) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
      request.onResponseStarted();
      if (request.aborted) {
        const err = new RequestAbortedError;
        util.errorRequest(client, request, err);
        util.destroy(stream, err);
        return;
      }
      if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
    });
    stream.once("end", () => {
      if (stream.state?.state == null || stream.state.state < 6) {
        request.onComplete([]);
      }
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
      abort(new InformationalError("HTTP/2: stream half-closed (remote)"));
      client[kQueue][client[kRunningIdx]++] = null;
      client[kPendingIdx] = client[kRunningIdx];
      client[kResume]();
    });
    stream.once("close", () => {
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
    });
    stream.once("error", function(err) {
      abort(err);
    });
    stream.once("frameError", (type, code) => {
      abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
    });
    return true;
    function writeBodyH2() {
      if (!body || contentLength === 0) {
        writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload);
      } else if (util.isBuffer(body)) {
        writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload);
        } else {
          writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
        }
      } else if (util.isStream(body)) {
        writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength);
      } else if (util.isIterable(body)) {
        writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
      } else {
        assert(false);
      }
    }
  }
  function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    try {
      if (body != null && util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        h2stream.cork();
        h2stream.write(body);
        h2stream.uncork();
        h2stream.end();
        request.onBodySent(body);
      }
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      request.onRequestSent();
      client[kResume]();
    } catch (error) {
      abort(error);
    }
  }
  function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    const pipe = pipeline(body, h2stream, (err) => {
      if (err) {
        util.destroy(pipe, err);
        abort(err);
      } else {
        util.removeAllListeners(pipe);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      }
    });
    util.addListener(pipe, "data", onPipeData);
    function onPipeData(chunk) {
      request.onBodySent(chunk);
    }
  }
  async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      h2stream.cork();
      h2stream.write(buffer);
      h2stream.uncork();
      h2stream.end();
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    h2stream.on("close", onDrain).on("drain", onDrain);
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        const res = h2stream.write(chunk);
        request.onBodySent(chunk);
        if (!res) {
          await waitForDrain();
        }
      }
      h2stream.end();
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    } finally {
      h2stream.off("close", onDrain).off("drain", onDrain);
    }
  }
  module.exports = connectH2;
});

// node_modules/undici/lib/handler/redirect-handler.js
var require_redirect_handler = __commonJS((exports, module) => {
  var util = require_util();
  var { kBodyUsed } = require_symbols();
  var assert = __require("node:assert");
  var { InvalidArgumentError } = require_errors();
  var EE = __require("node:events");
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util.validateHandler(handler, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      this.redirectionLimitReached = false;
      if (util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort) {
      this.abort = abort;
      this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
      if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        if (this.request) {
          this.request.abort(new Error("max redirects"));
        }
        this.redirectionLimitReached = true;
        this.abort(new Error("max redirects"));
        return;
      }
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      }
      const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) {} else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  function parseLocation(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i = 0;i < headers.length; i += 2) {
      if (headers[i].length === 8 && util.headerNameToString(headers[i]) === "location") {
        return headers[i + 1];
      }
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util.headerNameToString(header) === "host";
    }
    if (removeContent && util.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
          ret.push(headers[i], headers[i + 1]);
        }
      }
    } else if (headers && typeof headers === "object") {
      for (const key of Object.keys(headers)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers[key]);
        }
      }
    } else {
      assert(headers == null, "headers must be an object or an array");
    }
    return ret;
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirect-interceptor.js
var require_redirect_interceptor = __commonJS((exports, module) => {
  var RedirectHandler = require_redirect_handler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler);
      };
    };
  }
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/dispatcher/client.js
var require_client = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var net = __require("node:net");
  var http = __require("node:http");
  var util = require_util();
  var { channels } = require_diagnostics();
  var Request = require_request();
  var DispatcherBase = require_dispatcher_base();
  var {
    InvalidArgumentError,
    InformationalError,
    ClientDestroyedError
  } = require_errors();
  var buildConnector = require_connect();
  var {
    kUrl,
    kServerName,
    kClient,
    kBusy,
    kConnect,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kOnError,
    kHTTPContext,
    kMaxConcurrentStreams,
    kResume
  } = require_symbols();
  var connectH1 = require_client_h1();
  var connectH2 = require_client_h2();
  var deprecatedInterceptorWarned = false;
  var kClosedResolve = Symbol("kClosedResolve");
  var noop = () => {};
  function getPipelining(client) {
    return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;
  }

  class Client extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      maxConcurrentStreams,
      allowH2
    } = {}) {
      super();
      if (keepAlive !== undefined) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect2
        });
      }
      if (interceptors?.Client && Array.isArray(interceptors.Client)) {
        this[kInterceptors] = interceptors.Client;
        if (!deprecatedInterceptorWarned) {
          deprecatedInterceptorWarned = true;
          process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", {
            code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"
          });
        }
      } else {
        this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })];
      }
      this[kUrl] = util.parseOrigin(url);
      this[kConnector] = connect2;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2000 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
      this[kHTTPContext] = null;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
      this[kResume] = (sync) => resume(this, sync);
      this[kOnError] = (err) => onError(this, err);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      this[kResume](true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy]() {
      return Boolean(this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const origin = opts.origin || this[kUrl].origin;
      const request = new Request(origin, opts, handler);
      this[kQueue].push(request);
      if (this[kResuming]) {} else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
        this[kResuming] = 1;
        queueMicrotask(() => resume(this));
      } else {
        this[kResume](true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (this[kSize]) {
          this[kClosedResolve] = resolve;
        } else {
          resolve(null);
        }
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(this, request, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve(null);
        };
        if (this[kHTTPContext]) {
          this[kHTTPContext].destroy(err, callback);
          this[kHTTPContext] = null;
        } else {
          queueMicrotask(callback);
        }
        this[kResume]();
      });
    }
  }
  var createRedirectInterceptor = require_redirect_interceptor();
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        util.errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  async function connect(client) {
    assert(!client[kConnecting]);
    assert(!client[kHTTPContext]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert(net.isIP(ip));
      hostname = ip;
    }
    client[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client[kHTTPContext]?.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject(err);
          } else {
            resolve(socket2);
          }
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", noop), new ClientDestroyedError);
        return;
      }
      assert(socket);
      try {
        client[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client, socket) : await connectH1(client, socket);
      } catch (err) {
        socket.destroy().on("error", noop);
        throw err;
      }
      client[kConnecting] = false;
      socket[kCounter] = 0;
      socket[kMaxRequests] = client[kMaxRequests];
      socket[kClient] = client;
      socket[kError] = null;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      }
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed) {
        return;
      }
      client[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          const request = client[kQueue][client[kPendingIdx]++];
          util.errorRequest(client, request, err);
        }
      } else {
        onError(client, err);
      }
      client.emit("connectionError", client[kUrl], [client], err);
    }
    client[kResume]();
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain", client[kUrl], [client]);
  }
  function resume(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync) {
    while (true) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve]();
        client[kClosedResolve] = null;
        return;
      }
      if (client[kHTTPContext]) {
        client[kHTTPContext].resume();
      }
      if (client[kBusy]) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          queueMicrotask(() => emitDrain(client));
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (client[kPending] === 0) {
        return;
      }
      if (client[kRunning] >= (getPipelining(client) || 1)) {
        return;
      }
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) {
          return;
        }
        client[kServerName] = request.servername;
        client[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
          client[kHTTPContext] = null;
          resume(client);
        });
      }
      if (client[kConnecting]) {
        return;
      }
      if (!client[kHTTPContext]) {
        connect(client);
        return;
      }
      if (client[kHTTPContext].destroyed) {
        return;
      }
      if (client[kHTTPContext].busy(request)) {
        return;
      }
      if (!request.aborted && client[kHTTPContext].write(request)) {
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  module.exports = Client;
});

// node_modules/undici/lib/dispatcher/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  var kSize = 2048;
  var kMask = kSize - 1;

  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === undefined)
        return null;
      this.list[this.bottom] = undefined;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  module.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer;
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// node_modules/undici/lib/dispatcher/pool-stats.js
var require_pool_stats = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
  var kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/undici/lib/dispatcher/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var FixedQueue = require_fixed_queue();
  var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
  var PoolStats = require_pool_stats();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kGetDispatcher = Symbol("get dispatcher");
  var kAddClient = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue;
      this[kClients] = [];
      this[kQueued] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool[kNeedDrain]) {
          pool[kNeedDrain] = false;
          pool.emit("drain", origin, [pool, ...targets]);
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty()) {
        await Promise.all(this[kClients].map((c) => c.close()));
      } else {
        await new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    async[kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      await Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      const dispatcher = this[kGetDispatcher]();
      if (!dispatcher) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher.dispatch(opts, handler)) {
        dispatcher[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client);
      if (this[kNeedDrain]) {
        queueMicrotask(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client[kUrl], [this, client]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        const idx = this[kClients].indexOf(client);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/dispatcher/pool.js
var require_pool = __commonJS((exports, module) => {
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base();
  var Client = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl, kInterceptors } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kFactory] = factory;
      this.on("connectionError", (origin2, targets, error) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      for (const client of this[kClients]) {
        if (!client[kNeedDrain]) {
          return client;
        }
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
        return dispatcher;
      }
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/dispatcher/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors();
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base();
  var Pool = require_pool();
  var { kUrl, kInterceptors } = require_symbols();
  var { parseOrigin } = require_util();
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  var kCurrentWeight = Symbol("kCurrentWeight");
  var kIndex = Symbol("kIndex");
  var kWeight = Symbol("kWeight");
  var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  var kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (a === 0)
      return b;
    while (b !== 0) {
      const t = b;
      b = a % b;
      a = t;
    }
    return a;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
        return this;
      }
      const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool);
      pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      });
      pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client of this[kClients]) {
        client[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      let result = 0;
      for (let i = 0;i < this[kClients].length; i++) {
        result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
      }
      this[kGreatestCommonDivisor] = result;
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
      if (pool) {
        this[kRemoveClient](pool);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError;
      }
      const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
      if (!dispatcher) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
          return pool;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/dispatcher/agent.js
var require_agent = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors();
  var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
  var DispatcherBase = require_dispatcher_base();
  var Pool = require_pool();
  var Client = require_client();
  var util = require_util();
  var createRedirectInterceptor = require_redirect_interceptor();
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect && typeof connect !== "function") {
        connect = { ...connect };
      }
      this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util.deepClone(options), connect };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = new Map;
      this[kOnDrain] = (origin, targets) => {
        this.emit("drain", origin, [this, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        this.emit("connect", origin, [this, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        this.emit("disconnect", origin, [this, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        this.emit("connectionError", origin, [this, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const client of this[kClients].values()) {
        ret += client[kRunning];
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      let dispatcher = this[kClients].get(key);
      if (!dispatcher) {
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, dispatcher);
      }
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      const closePromises = [];
      for (const client of this[kClients].values()) {
        closePromises.push(client.close());
      }
      this[kClients].clear();
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      const destroyPromises = [];
      for (const client of this[kClients].values()) {
        destroyPromises.push(client.destroy(err));
      }
      this[kClients].clear();
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/dispatcher/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  var { kProxy, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
  var { URL: URL2 } = __require("node:url");
  var Agent = require_agent();
  var Pool = require_pool();
  var DispatcherBase = require_dispatcher_base();
  var { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require_errors();
  var buildConnector = require_connect();
  var Client = require_client();
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");
  var kTunnelProxy = Symbol("tunnel proxy");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  var noop = () => {};
  function defaultAgentFactory(origin, opts) {
    if (opts.connections === 1) {
      return new Client(origin, opts);
    }
    return new Pool(origin, opts);
  }

  class Http1ProxyWrapper extends DispatcherBase {
    #client;
    constructor(proxyUrl, { headers = {}, connect, factory }) {
      super();
      if (!proxyUrl) {
        throw new InvalidArgumentError("Proxy URL is mandatory");
      }
      this[kProxyHeaders] = headers;
      if (factory) {
        this.#client = factory(proxyUrl, { connect });
      } else {
        this.#client = new Client(proxyUrl, { connect });
      }
    }
    [kDispatch](opts, handler) {
      const onHeaders = handler.onHeaders;
      handler.onHeaders = function(statusCode, data, resume) {
        if (statusCode === 407) {
          if (typeof handler.onError === "function") {
            handler.onError(new InvalidArgumentError("Proxy Authentication Required (407)"));
          }
          return;
        }
        if (onHeaders)
          onHeaders.call(this, statusCode, data, resume);
      };
      const {
        origin,
        path = "/",
        headers = {}
      } = opts;
      opts.path = origin + path;
      if (!("host" in headers) && !("Host" in headers)) {
        const { host } = new URL2(origin);
        headers.host = host;
      }
      opts.headers = { ...this[kProxyHeaders], ...headers };
      return this.#client[kDispatch](opts, handler);
    }
    async[kClose]() {
      return this.#client.close();
    }
    async[kDestroy](err) {
      return this.#client.destroy(err);
    }
  }

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super();
      if (!opts || typeof opts === "object" && !(opts instanceof URL2) && !opts.uri) {
        throw new InvalidArgumentError("Proxy uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      const { proxyTunnel = true } = opts;
      const url = this.#getUrl(opts);
      const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
      this[kProxy] = { uri: href, protocol };
      this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      this[kTunnelProxy] = proxyTunnel;
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      const agentFactory = opts.factory || defaultAgentFactory;
      const factory = (origin2, options) => {
        const { protocol: protocol2 } = new URL2(origin2);
        if (!this[kTunnelProxy] && protocol2 === "http:" && this[kProxy].protocol === "http:") {
          return new Http1ProxyWrapper(this[kProxy].uri, {
            headers: this[kProxyHeaders],
            connect,
            factory: agentFactory
          });
        }
        return agentFactory(origin2, options);
      };
      this[kClient] = clientFactory(url, { connect });
      this[kAgent] = new Agent({
        ...opts,
        factory,
        connect: async (opts2, callback) => {
          let requestedPath = opts2.host;
          if (!opts2.port) {
            requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedPath,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host: opts2.host
              },
              servername: this[kProxyTls]?.servername || proxyHostname
            });
            if (statusCode !== 200) {
              socket.on("error", noop).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
              callback(new SecureProxyConnectionError(err));
            } else {
              callback(err);
            }
          }
        }
      });
    }
    dispatch(opts, handler) {
      const headers = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers);
      if (headers && !("host" in headers) && !("Host" in headers)) {
        const { host } = new URL2(opts.origin);
        headers.host = host;
      }
      return this[kAgent].dispatch({
        ...opts,
        headers
      }, handler);
    }
    #getUrl(opts) {
      if (typeof opts === "string") {
        return new URL2(opts);
      } else if (opts instanceof URL2) {
        return opts;
      } else {
        return new URL2(opts.uri);
      }
    }
    async[kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      const headersPair = {};
      for (let i = 0;i < headers.length; i += 2) {
        headersPair[headers[i]] = headers[i + 1];
      }
      return headersPair;
    }
    return headers;
  }
  function throwIfProxyAuthIsSent(headers) {
    const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/dispatcher/env-http-proxy-agent.js
var require_env_http_proxy_agent = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require_symbols();
  var ProxyAgent = require_proxy_agent();
  var Agent = require_agent();
  var DEFAULT_PORTS = {
    "http:": 80,
    "https:": 443
  };
  var experimentalWarned = false;

  class EnvHttpProxyAgent extends DispatcherBase {
    #noProxyValue = null;
    #noProxyEntries = null;
    #opts = null;
    constructor(opts = {}) {
      super();
      this.#opts = opts;
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
          code: "UNDICI-EHPA"
        });
      }
      const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
      this[kNoProxyAgent] = new Agent(agentOpts);
      const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
      if (HTTP_PROXY) {
        this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
      } else {
        this[kHttpProxyAgent] = this[kNoProxyAgent];
      }
      const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
      if (HTTPS_PROXY) {
        this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
      } else {
        this[kHttpsProxyAgent] = this[kHttpProxyAgent];
      }
      this.#parseNoProxy();
    }
    [kDispatch](opts, handler) {
      const url = new URL(opts.origin);
      const agent = this.#getProxyAgentForUrl(url);
      return agent.dispatch(opts, handler);
    }
    async[kClose]() {
      await this[kNoProxyAgent].close();
      if (!this[kHttpProxyAgent][kClosed]) {
        await this[kHttpProxyAgent].close();
      }
      if (!this[kHttpsProxyAgent][kClosed]) {
        await this[kHttpsProxyAgent].close();
      }
    }
    async[kDestroy](err) {
      await this[kNoProxyAgent].destroy(err);
      if (!this[kHttpProxyAgent][kDestroyed]) {
        await this[kHttpProxyAgent].destroy(err);
      }
      if (!this[kHttpsProxyAgent][kDestroyed]) {
        await this[kHttpsProxyAgent].destroy(err);
      }
    }
    #getProxyAgentForUrl(url) {
      let { protocol, host: hostname, port } = url;
      hostname = hostname.replace(/:\d*$/, "").toLowerCase();
      port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
      if (!this.#shouldProxy(hostname, port)) {
        return this[kNoProxyAgent];
      }
      if (protocol === "https:") {
        return this[kHttpsProxyAgent];
      }
      return this[kHttpProxyAgent];
    }
    #shouldProxy(hostname, port) {
      if (this.#noProxyChanged) {
        this.#parseNoProxy();
      }
      if (this.#noProxyEntries.length === 0) {
        return true;
      }
      if (this.#noProxyValue === "*") {
        return false;
      }
      for (let i = 0;i < this.#noProxyEntries.length; i++) {
        const entry = this.#noProxyEntries[i];
        if (entry.port && entry.port !== port) {
          continue;
        }
        if (!/^[.*]/.test(entry.hostname)) {
          if (hostname === entry.hostname) {
            return false;
          }
        } else {
          if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
            return false;
          }
        }
      }
      return true;
    }
    #parseNoProxy() {
      const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
      const noProxySplit = noProxyValue.split(/[,\s]/);
      const noProxyEntries = [];
      for (let i = 0;i < noProxySplit.length; i++) {
        const entry = noProxySplit[i];
        if (!entry) {
          continue;
        }
        const parsed = entry.match(/^(.+):(\d+)$/);
        noProxyEntries.push({
          hostname: (parsed ? parsed[1] : entry).toLowerCase(),
          port: parsed ? Number.parseInt(parsed[2], 10) : 0
        });
      }
      this.#noProxyValue = noProxyValue;
      this.#noProxyEntries = noProxyEntries;
    }
    get #noProxyChanged() {
      if (this.#opts.noProxy !== undefined) {
        return false;
      }
      return this.#noProxyValue !== this.#noProxyEnv;
    }
    get #noProxyEnv() {
      return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
    }
  }
  module.exports = EnvHttpProxyAgent;
});

// node_modules/undici/lib/handler/retry-handler.js
var require_retry_handler = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { kRetryHandlerDefaultRetry } = require_symbols();
  var { RequestRetryError } = require_errors();
  var {
    isDisturbed,
    parseHeaders,
    parseRangeHeader,
    wrapRequestBody
  } = require_util();
  function calculateRetryAfterHeader(retryAfter) {
    const current = Date.now();
    return new Date(retryAfter).getTime() - current;
  }

  class RetryHandler {
    constructor(opts, handlers) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        methods,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch;
      this.handler = handlers.handler;
      this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
      this.abort = null;
      this.aborted = false;
      this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1000,
        minTimeout: minTimeout ?? 500,
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE",
          "UND_ERR_SOCKET"
        ]
      };
      this.retryCount = 0;
      this.retryCountCheckpoint = 0;
      this.start = 0;
      this.end = null;
      this.etag = null;
      this.resume = null;
      this.handler.onConnect((reason) => {
        this.aborted = true;
        if (this.abort) {
          this.abort(reason);
        } else {
          this.reason = reason;
        }
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent) {
        this.handler.onRequestSent();
      }
    }
    onUpgrade(statusCode, headers, socket) {
      if (this.handler.onUpgrade) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
    }
    onConnect(abort) {
      if (this.aborted) {
        abort(this.reason);
      } else {
        this.abort = abort;
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      const { statusCode, code, headers } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        minTimeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions;
      const { counter } = state;
      if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers?.["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1000;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
      setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers = parseHeaders(rawHeaders);
      this.retryCount += 1;
      if (statusCode >= 300) {
        if (this.retryOpts.statusCodes.includes(statusCode) === false) {
          return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
        } else {
          this.abort(new RequestRetryError("Request failed", statusCode, {
            headers,
            data: {
              count: this.retryCount
            }
          }));
          return false;
        }
      }
      if (this.resume != null) {
        this.resume = null;
        if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
          this.abort(new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
            headers,
            data: { count: this.retryCount }
          }));
          return false;
        }
        const contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange) {
          this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
            headers,
            data: { count: this.retryCount }
          }));
          return false;
        }
        if (this.etag != null && this.etag !== headers.etag) {
          this.abort(new RequestRetryError("ETag mismatch", statusCode, {
            headers,
            data: { count: this.retryCount }
          }));
          return false;
        }
        const { start, size, end = size - 1 } = contentRange;
        assert(this.start === start, "content-range mismatch");
        assert(this.end == null || this.end === end, "content-range mismatch");
        this.resume = resume;
        return true;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range = parseRangeHeader(headers["content-range"]);
          if (range == null) {
            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
          }
          const { start, size, end = size - 1 } = range;
          assert(start != null && Number.isFinite(start), "content-range mismatch");
          assert(end != null && Number.isFinite(end), "invalid content-length");
          this.start = start;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) - 1 : null;
        }
        assert(Number.isFinite(this.start));
        assert(this.end == null || Number.isFinite(this.end), "invalid content-length");
        this.resume = resume;
        this.etag = headers.etag != null ? headers.etag : null;
        if (this.etag != null && this.etag.startsWith("W/")) {
          this.etag = null;
        }
        return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      const err = new RequestRetryError("Request failed", statusCode, {
        headers,
        data: { count: this.retryCount }
      });
      this.abort(err);
      return false;
    }
    onData(chunk) {
      this.start += chunk.length;
      return this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      this.retryCount = 0;
      return this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err);
      }
      if (this.retryCount - this.retryCountCheckpoint > 0) {
        this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
      } else {
        this.retryCount += 1;
      }
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, onRetry.bind(this));
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err2);
        }
        if (this.start !== 0) {
          const headers = { range: `bytes=${this.start}-${this.end ?? ""}` };
          if (this.etag != null) {
            headers["if-match"] = this.etag;
          }
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              ...headers
            }
          };
        }
        try {
          this.retryCountCheckpoint = this.retryCount;
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  module.exports = RetryHandler;
});

// node_modules/undici/lib/dispatcher/retry-agent.js
var require_retry_agent = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var RetryHandler = require_retry_handler();

  class RetryAgent extends Dispatcher {
    #agent = null;
    #options = null;
    constructor(agent, options = {}) {
      super(options);
      this.#agent = agent;
      this.#options = options;
    }
    dispatch(opts, handler) {
      const retry = new RetryHandler({
        ...opts,
        retryOptions: this.#options
      }, {
        dispatch: this.#agent.dispatch.bind(this.#agent),
        handler
      });
      return this.#agent.dispatch(opts, retry);
    }
    close() {
      return this.#agent.close();
    }
    destroy() {
      return this.#agent.destroy();
    }
  }
  module.exports = RetryAgent;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { Readable } = __require("node:stream");
  var { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require_errors();
  var util = require_util();
  var { ReadableStreamFrom } = require_util();
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("kAbort");
  var kContentType = Symbol("kContentType");
  var kContentLength = Symbol("kContentLength");
  var noop = () => {};

  class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      contentLength,
      highWaterMark = 64 * 1024
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kContentLength] = contentLength;
      this[kReading] = false;
    }
    destroy(err) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    _destroy(err, callback) {
      if (!this[kReading]) {
        setImmediate(() => {
          callback(err);
        });
      } else {
        callback(err);
      }
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async bytes() {
      return consume(this, "bytes");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    async dump(opts) {
      let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024;
      const signal = opts?.signal;
      if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
        throw new InvalidArgumentError("signal must be an AbortSignal");
      }
      signal?.throwIfAborted();
      if (this._readableState.closeEmitted) {
        return null;
      }
      return await new Promise((resolve, reject) => {
        if (this[kContentLength] > limit) {
          this.destroy(new AbortError);
        }
        const onAbort = () => {
          this.destroy(signal.reason ?? new AbortError);
        };
        signal?.addEventListener("abort", onAbort);
        this.on("close", function() {
          signal?.removeEventListener("abort", onAbort);
          if (signal?.aborted) {
            reject(signal.reason ?? new AbortError);
          } else {
            resolve(null);
          }
        }).on("error", noop).on("data", function(chunk) {
          limit -= chunk.length;
          if (limit <= 0) {
            this.destroy();
          }
        }).resume();
      });
    }
  }
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  }
  function isUnusable(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream, type) {
    assert(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      if (isUnusable(stream)) {
        const rState = stream._readableState;
        if (rState.destroyed && rState.closeEmitted === false) {
          stream.on("error", (err) => {
            reject(err);
          }).on("close", () => {
            reject(new TypeError("unusable"));
          });
        } else {
          reject(rState.errored ?? new TypeError("unusable"));
        }
      } else {
        queueMicrotask(() => {
          stream[kConsume] = {
            type,
            stream,
            resolve,
            reject,
            length: 0,
            body: []
          };
          stream.on("error", function(err) {
            consumeFinish(this[kConsume], err);
          }).on("close", function() {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError);
            }
          });
          consumeStart(stream[kConsume]);
        });
      }
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    if (state.bufferIndex) {
      const start = state.bufferIndex;
      const end = state.buffer.length;
      for (let n = start;n < end; n++) {
        consumePush(consume2, state.buffer[n]);
      }
    } else {
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {}
  }
  function chunksDecode(chunks, length) {
    if (chunks.length === 0 || length === 0) {
      return "";
    }
    const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
    const bufferLength = buffer.length;
    const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
    return buffer.utf8Slice(start, bufferLength);
  }
  function chunksConcat(chunks, length) {
    if (chunks.length === 0 || length === 0) {
      return new Uint8Array(0);
    }
    if (chunks.length === 1) {
      return new Uint8Array(chunks[0]);
    }
    const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
    let offset = 0;
    for (let i = 0;i < chunks.length; ++i) {
      const chunk = chunks[i];
      buffer.set(chunk, offset);
      offset += chunk.length;
    }
    return buffer;
  }
  function consumeEnd(consume2) {
    const { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(chunksDecode(body, length));
      } else if (type === "json") {
        resolve(JSON.parse(chunksDecode(body, length)));
      } else if (type === "arrayBuffer") {
        resolve(chunksConcat(body, length).buffer);
      } else if (type === "blob") {
        resolve(new Blob(body, { type: stream[kContentType] }));
      } else if (type === "bytes") {
        resolve(chunksConcat(body, length));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
  module.exports = { Readable: BodyReadable, chunksDecode };
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var {
    ResponseStatusCodeError
  } = require_errors();
  var { chunksDecode } = require_readable();
  var CHUNK_LIMIT = 128 * 1024;
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [];
    let length = 0;
    try {
      for await (const chunk of body) {
        chunks.push(chunk);
        length += chunk.length;
        if (length > CHUNK_LIMIT) {
          chunks = [];
          length = 0;
          break;
        }
      }
    } catch {
      chunks = [];
      length = 0;
    }
    const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`;
    if (statusCode === 204 || !contentType || !length) {
      queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)));
      return;
    }
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    let payload;
    try {
      if (isContentTypeApplicationJson(contentType)) {
        payload = JSON.parse(chunksDecode(chunks, length));
      } else if (isContentTypeText(contentType)) {
        payload = chunksDecode(chunks, length);
      }
    } catch {} finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)));
  }
  var isContentTypeApplicationJson = (contentType) => {
    return contentType.length > 15 && contentType[11] === "/" && contentType[0] === "a" && contentType[1] === "p" && contentType[2] === "p" && contentType[3] === "l" && contentType[4] === "i" && contentType[5] === "c" && contentType[6] === "a" && contentType[7] === "t" && contentType[8] === "i" && contentType[9] === "o" && contentType[10] === "n" && contentType[12] === "j" && contentType[13] === "s" && contentType[14] === "o" && contentType[15] === "n";
  };
  var isContentTypeText = (contentType) => {
    return contentType.length > 4 && contentType[4] === "/" && contentType[0] === "t" && contentType[1] === "e" && contentType[2] === "x" && contentType[3] === "t";
  };
  module.exports = {
    getResolveErrorBodyCallback,
    isContentTypeApplicationJson,
    isContentTypeText
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { Readable } = require_readable();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("node:async_hooks");

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.method = method;
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      this.signal = signal;
      this.reason = null;
      this.removeAbortListener = null;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      if (this.signal) {
        if (this.signal.aborted) {
          this.reason = this.signal.reason ?? new RequestAbortedError;
        } else {
          this.removeAbortListener = util.addAbortListener(this.signal, () => {
            this.reason = this.signal.reason ?? new RequestAbortedError;
            if (this.res) {
              util.destroy(this.res.on("error", util.nop), this.reason);
            } else if (this.abort) {
              this.abort(this.reason);
            }
            if (this.removeAbortListener) {
              this.res?.off("close", this.removeAbortListener);
              this.removeAbortListener();
              this.removeAbortListener = null;
            }
          });
        }
      }
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
      const contentType = parsedHeaders["content-type"];
      const contentLength = parsedHeaders["content-length"];
      const res = new Readable({
        resume,
        abort,
        contentType,
        contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
        highWaterMark
      });
      if (this.removeAbortListener) {
        res.on("close", this.removeAbortListener);
      }
      this.callback = null;
      this.res = res;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body: res,
            context
          });
        }
      }
    }
    onData(chunk) {
      return this.res.push(chunk);
    }
    onComplete(trailers) {
      util.parseHeaders(trailers, this.trailers);
      this.res.push(null);
    }
    onError(err) {
      const { res, callback, body, opaque } = this;
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util.destroy(res, err);
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
      if (this.removeAbortListener) {
        res?.off("close", this.removeAbortListener);
        this.removeAbortListener();
        this.removeAbortListener = null;
      }
    }
  }
  function request(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  var { addAbortListener } = require_util();
  var { RequestAbortedError } = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort(self2[kSignal]?.reason);
    } else {
      self2.reason = self2[kSignal]?.reason ?? new RequestAbortedError;
    }
    removeSignal(self2);
  }
  function addSignal(self2, signal) {
    self2.reason = null;
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { finished, PassThrough } = __require("node:stream");
  var { InvalidArgumentError, InvalidReturnValueError } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("node:async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough;
        this.callback = null;
        this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        if (factory === null) {
          return;
        }
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState?.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  function stream(opts, factory, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = stream;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("node:stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { AsyncResource } = __require("node:async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("node:assert");
  var kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body } = this;
          if (body?.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError;
          }
          if (abort && err) {
            abort();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { ret, res } = this;
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(!res, "pipeline cannot be retried");
      assert(!ret.destroyed);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError);
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  }
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module.exports = pipeline;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  var { InvalidArgumentError, SocketError } = require_errors();
  var { AsyncResource } = __require("node:async_hooks");
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("node:assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      assert(statusCode === 101);
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function upgrade(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { AsyncResource } = __require("node:async_hooks");
  var { InvalidArgumentError, SocketError } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers = rawHeaders;
      if (headers != null) {
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function connect(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();
  var kMockNotMatchedError = Symbol.for("undici.error.UND_MOCK_ERR_MOCK_NOT_MATCHED");

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kMockNotMatchedError] === true;
    }
    [kMockNotMatchedError] = true;
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  var { MockNotMatchedError } = require_mock_errors();
  var {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols();
  var { buildURL } = require_util();
  var { STATUS_CODES } = __require("node:http");
  var {
    types: {
      isPromise
    }
  } = __require("node:util");
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  }
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers[i + 1];
        }
      }
      return;
    } else if (typeof headers.get === "function") {
      return headers.get(key);
    } else {
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers) {
    const clone = headers.slice();
    const entries = [];
    for (let index = 0;index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers)) {
        headers = buildHeadersFromArray(headers);
      }
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function safeUrl(path) {
    if (typeof path !== "string") {
      return path;
    }
    const pathSegments = path.split("?");
    if (pathSegments.length !== 2) {
      return path;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path, method, body, headers }) {
    const pathMatch = matchValue(mockDispatch2.path, path);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (data instanceof Uint8Array) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      const headers = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function buildKey(opts) {
    const { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  }
  function generateKeyValues(data) {
    const keys = Object.keys(data);
    const result = [];
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      const value = data[key];
      const name = Buffer.from(`${key}`);
      if (Array.isArray(value)) {
        for (let j = 0;j < value.length; ++j) {
          result.push(name, Buffer.from(`${value[j]}`));
        }
      } else {
        result.push(name, Buffer.from(`${value}`));
      }
    }
    return result;
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body) {
    const buffers = [];
    for await (const data of body) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body);
      const responseHeaders = generateKeyValues(headers);
      const responseTrailers = generateKeyValues(trailers);
      handler.onConnect?.((err) => handler.onError(err), null);
      handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData?.(Buffer.from(responseData));
      handler.onComplete?.(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {}
    return true;
  }
  function buildMockDispatch() {
    const agent = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            const netConnect = agent[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function buildMockOptions(opts) {
    if (opts) {
      const { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName,
    buildHeadersFromArray
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  var { buildURL } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData({ statusCode, data, responseOptions }) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(replyParameters) {
      if (typeof replyParameters.statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    reply(replyOptionsCallbackOrStatusCode) {
      if (typeof replyOptionsCallbackOrStatusCode === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyOptionsCallbackOrStatusCode(opts);
          if (typeof resolvedData !== "object" || resolvedData === null) {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
          this.validateReplyParameters(replyParameters2);
          return {
            ...this.createMockScopeDispatchData(replyParameters2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const replyParameters = {
        statusCode: replyOptionsCallbackOrStatusCode,
        data: arguments[1] === undefined ? "" : arguments[1],
        responseOptions: arguments[2] === undefined ? {} : arguments[2]
      };
      this.validateReplyParameters(replyParameters);
      const dispatchData = this.createMockScopeDispatchData(replyParameters);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error) {
      if (typeof error === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers;
      return this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify } = __require("node:util");
  var Client = require_client();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockClient extends Client {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify } = __require("node:util");
  var Pool = require_pool();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  var plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count) {
      const one = count === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var { Console } = __require("node:console");
  var PERSISTENT = process.versions.icu ? "" : "Y ";
  var NOT_PERSISTENT = process.versions.icu ? "" : "N ";
  module.exports = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }));
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols();
  var Agent = require_agent();
  var {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols();
  var MockClient = require_mock_client();
  var MockPool = require_mock_pool();
  var { matchValue, buildMockOptions } = require_mock_utils();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var Dispatcher = require_dispatcher();
  var Pluralizer = require_pluralizer();
  var PendingInterceptorsFormatter = require_pending_interceptors_formatter();

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts?.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent = opts?.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent;
      this[kClients] = agent[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher) {
        dispatcher = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher);
      }
      return dispatcher;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, dispatcher);
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const client = this[kClients].get(origin);
      if (client) {
        return client;
      }
      if (typeof origin !== "string") {
        const dispatcher = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher);
        return dispatcher;
      }
      for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
          dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError } = require_errors();
  var Agent = require_agent();
  if (getGlobalDispatcher() === undefined) {
    setGlobalDispatcher(new Agent);
  }
  function setGlobalDispatcher(agent) {
    if (!agent || typeof agent.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/undici/lib/handler/decorator-handler.js
var require_decorator_handler = __commonJS((exports, module) => {
  module.exports = class DecoratorHandler {
    #handler;
    constructor(handler) {
      if (typeof handler !== "object" || handler === null) {
        throw new TypeError("handler must be an object");
      }
      this.#handler = handler;
    }
    onConnect(...args) {
      return this.#handler.onConnect?.(...args);
    }
    onError(...args) {
      return this.#handler.onError?.(...args);
    }
    onUpgrade(...args) {
      return this.#handler.onUpgrade?.(...args);
    }
    onResponseStarted(...args) {
      return this.#handler.onResponseStarted?.(...args);
    }
    onHeaders(...args) {
      return this.#handler.onHeaders?.(...args);
    }
    onData(...args) {
      return this.#handler.onData?.(...args);
    }
    onComplete(...args) {
      return this.#handler.onComplete?.(...args);
    }
    onBodySent(...args) {
      return this.#handler.onBodySent?.(...args);
    }
  };
});

// node_modules/undici/lib/interceptor/redirect.js
var require_redirect = __commonJS((exports, module) => {
  var RedirectHandler = require_redirect_handler();
  module.exports = (opts) => {
    const globalMaxRedirections = opts?.maxRedirections;
    return (dispatch) => {
      return function redirectInterceptor(opts2, handler) {
        const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts2;
        if (!maxRedirections) {
          return dispatch(opts2, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts2, handler);
        return dispatch(baseOpts, redirectHandler);
      };
    };
  };
});

// node_modules/undici/lib/interceptor/retry.js
var require_retry = __commonJS((exports, module) => {
  var RetryHandler = require_retry_handler();
  module.exports = (globalOpts) => {
    return (dispatch) => {
      return function retryInterceptor(opts, handler) {
        return dispatch(opts, new RetryHandler({ ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } }, {
          handler,
          dispatch
        }));
      };
    };
  };
});

// node_modules/undici/lib/interceptor/dump.js
var require_dump = __commonJS((exports, module) => {
  var util = require_util();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var DecoratorHandler = require_decorator_handler();

  class DumpHandler extends DecoratorHandler {
    #maxSize = 1024 * 1024;
    #abort = null;
    #dumped = false;
    #aborted = false;
    #size = 0;
    #reason = null;
    #handler = null;
    constructor({ maxSize }, handler) {
      super(handler);
      if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
        throw new InvalidArgumentError("maxSize must be a number greater than 0");
      }
      this.#maxSize = maxSize ?? this.#maxSize;
      this.#handler = handler;
    }
    onConnect(abort) {
      this.#abort = abort;
      this.#handler.onConnect(this.#customAbort.bind(this));
    }
    #customAbort(reason) {
      this.#aborted = true;
      this.#reason = reason;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers = util.parseHeaders(rawHeaders);
      const contentLength = headers["content-length"];
      if (contentLength != null && contentLength > this.#maxSize) {
        throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${this.#maxSize})`);
      }
      if (this.#aborted) {
        return true;
      }
      return this.#handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
    }
    onError(err) {
      if (this.#dumped) {
        return;
      }
      err = this.#reason ?? err;
      this.#handler.onError(err);
    }
    onData(chunk) {
      this.#size = this.#size + chunk.length;
      if (this.#size >= this.#maxSize) {
        this.#dumped = true;
        if (this.#aborted) {
          this.#handler.onError(this.#reason);
        } else {
          this.#handler.onComplete([]);
        }
      }
      return true;
    }
    onComplete(trailers) {
      if (this.#dumped) {
        return;
      }
      if (this.#aborted) {
        this.#handler.onError(this.reason);
        return;
      }
      this.#handler.onComplete(trailers);
    }
  }
  function createDumpInterceptor({ maxSize: defaultMaxSize } = {
    maxSize: 1024 * 1024
  }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { dumpMaxSize = defaultMaxSize } = opts;
        const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize }, handler);
        return dispatch(opts, dumpHandler);
      };
    };
  }
  module.exports = createDumpInterceptor;
});

// node_modules/undici/lib/interceptor/dns.js
var require_dns = __commonJS((exports, module) => {
  var { isIP } = __require("node:net");
  var { lookup } = __require("node:dns");
  var DecoratorHandler = require_decorator_handler();
  var { InvalidArgumentError, InformationalError } = require_errors();
  var maxInt = Math.pow(2, 31) - 1;

  class DNSInstance {
    #maxTTL = 0;
    #maxItems = 0;
    #records = new Map;
    dualStack = true;
    affinity = null;
    lookup = null;
    pick = null;
    constructor(opts) {
      this.#maxTTL = opts.maxTTL;
      this.#maxItems = opts.maxItems;
      this.dualStack = opts.dualStack;
      this.affinity = opts.affinity;
      this.lookup = opts.lookup ?? this.#defaultLookup;
      this.pick = opts.pick ?? this.#defaultPick;
    }
    get full() {
      return this.#records.size === this.#maxItems;
    }
    runLookup(origin, opts, cb) {
      const ips = this.#records.get(origin.hostname);
      if (ips == null && this.full) {
        cb(null, origin.origin);
        return;
      }
      const newOpts = {
        affinity: this.affinity,
        dualStack: this.dualStack,
        lookup: this.lookup,
        pick: this.pick,
        ...opts.dns,
        maxTTL: this.#maxTTL,
        maxItems: this.#maxItems
      };
      if (ips == null) {
        this.lookup(origin, newOpts, (err, addresses) => {
          if (err || addresses == null || addresses.length === 0) {
            cb(err ?? new InformationalError("No DNS entries found"));
            return;
          }
          this.setRecords(origin, addresses);
          const records = this.#records.get(origin.hostname);
          const ip = this.pick(origin, records, newOpts.affinity);
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (origin.port !== "") {
            port = `:${origin.port}`;
          } else {
            port = "";
          }
          cb(null, `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`);
        });
      } else {
        const ip = this.pick(origin, ips, newOpts.affinity);
        if (ip == null) {
          this.#records.delete(origin.hostname);
          this.runLookup(origin, opts, cb);
          return;
        }
        let port;
        if (typeof ip.port === "number") {
          port = `:${ip.port}`;
        } else if (origin.port !== "") {
          port = `:${origin.port}`;
        } else {
          port = "";
        }
        cb(null, `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`);
      }
    }
    #defaultLookup(origin, opts, cb) {
      lookup(origin.hostname, {
        all: true,
        family: this.dualStack === false ? this.affinity : 0,
        order: "ipv4first"
      }, (err, addresses) => {
        if (err) {
          return cb(err);
        }
        const results = new Map;
        for (const addr of addresses) {
          results.set(`${addr.address}:${addr.family}`, addr);
        }
        cb(null, results.values());
      });
    }
    #defaultPick(origin, hostnameRecords, affinity) {
      let ip = null;
      const { records, offset } = hostnameRecords;
      let family;
      if (this.dualStack) {
        if (affinity == null) {
          if (offset == null || offset === maxInt) {
            hostnameRecords.offset = 0;
            affinity = 4;
          } else {
            hostnameRecords.offset++;
            affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
          }
        }
        if (records[affinity] != null && records[affinity].ips.length > 0) {
          family = records[affinity];
        } else {
          family = records[affinity === 4 ? 6 : 4];
        }
      } else {
        family = records[affinity];
      }
      if (family == null || family.ips.length === 0) {
        return ip;
      }
      if (family.offset == null || family.offset === maxInt) {
        family.offset = 0;
      } else {
        family.offset++;
      }
      const position = family.offset % family.ips.length;
      ip = family.ips[position] ?? null;
      if (ip == null) {
        return ip;
      }
      if (Date.now() - ip.timestamp > ip.ttl) {
        family.ips.splice(position, 1);
        return this.pick(origin, hostnameRecords, affinity);
      }
      return ip;
    }
    setRecords(origin, addresses) {
      const timestamp = Date.now();
      const records = { records: { 4: null, 6: null } };
      for (const record of addresses) {
        record.timestamp = timestamp;
        if (typeof record.ttl === "number") {
          record.ttl = Math.min(record.ttl, this.#maxTTL);
        } else {
          record.ttl = this.#maxTTL;
        }
        const familyRecords = records.records[record.family] ?? { ips: [] };
        familyRecords.ips.push(record);
        records.records[record.family] = familyRecords;
      }
      this.#records.set(origin.hostname, records);
    }
    getHandler(meta, opts) {
      return new DNSDispatchHandler(this, meta, opts);
    }
  }

  class DNSDispatchHandler extends DecoratorHandler {
    #state = null;
    #opts = null;
    #dispatch = null;
    #handler = null;
    #origin = null;
    constructor(state, { origin, handler, dispatch }, opts) {
      super(handler);
      this.#origin = origin;
      this.#handler = handler;
      this.#opts = { ...opts };
      this.#state = state;
      this.#dispatch = dispatch;
    }
    onError(err) {
      switch (err.code) {
        case "ETIMEDOUT":
        case "ECONNREFUSED": {
          if (this.#state.dualStack) {
            this.#state.runLookup(this.#origin, this.#opts, (err2, newOrigin) => {
              if (err2) {
                return this.#handler.onError(err2);
              }
              const dispatchOpts = {
                ...this.#opts,
                origin: newOrigin
              };
              this.#dispatch(dispatchOpts, this);
            });
            return;
          }
          this.#handler.onError(err);
          return;
        }
        case "ENOTFOUND":
          this.#state.deleteRecord(this.#origin);
        default:
          this.#handler.onError(err);
          break;
      }
    }
  }
  module.exports = (interceptorOpts) => {
    if (interceptorOpts?.maxTTL != null && (typeof interceptorOpts?.maxTTL !== "number" || interceptorOpts?.maxTTL < 0)) {
      throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
    }
    if (interceptorOpts?.maxItems != null && (typeof interceptorOpts?.maxItems !== "number" || interceptorOpts?.maxItems < 1)) {
      throw new InvalidArgumentError("Invalid maxItems. Must be a positive number and greater than zero");
    }
    if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) {
      throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
    }
    if (interceptorOpts?.dualStack != null && typeof interceptorOpts?.dualStack !== "boolean") {
      throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
    }
    if (interceptorOpts?.lookup != null && typeof interceptorOpts?.lookup !== "function") {
      throw new InvalidArgumentError("Invalid lookup. Must be a function");
    }
    if (interceptorOpts?.pick != null && typeof interceptorOpts?.pick !== "function") {
      throw new InvalidArgumentError("Invalid pick. Must be a function");
    }
    const dualStack = interceptorOpts?.dualStack ?? true;
    let affinity;
    if (dualStack) {
      affinity = interceptorOpts?.affinity ?? null;
    } else {
      affinity = interceptorOpts?.affinity ?? 4;
    }
    const opts = {
      maxTTL: interceptorOpts?.maxTTL ?? 1e4,
      lookup: interceptorOpts?.lookup ?? null,
      pick: interceptorOpts?.pick ?? null,
      dualStack,
      affinity,
      maxItems: interceptorOpts?.maxItems ?? Infinity
    };
    const instance = new DNSInstance(opts);
    return (dispatch) => {
      return function dnsInterceptor(origDispatchOpts, handler) {
        const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
        if (isIP(origin.hostname) !== 0) {
          return dispatch(origDispatchOpts, handler);
        }
        instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
          if (err) {
            return handler.onError(err);
          }
          let dispatchOpts = null;
          dispatchOpts = {
            ...origDispatchOpts,
            servername: origin.hostname,
            origin: newOrigin,
            headers: {
              host: origin.hostname,
              ...origDispatchOpts.headers
            }
          };
          dispatch(dispatchOpts, instance.getHandler({ origin, dispatch, handler }, origDispatchOpts));
        });
        return true;
      };
    };
  };
});

// node_modules/undici/lib/web/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols();
  var { kEnumerableProperty } = require_util();
  var {
    iteratorMixin,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2();
  var { webidl } = require_webidl();
  var assert = __require("node:assert");
  var util = __require("node:util");
  var kHeadersMap = Symbol("headers map");
  var kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
      --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
      ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers, object) {
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; ++i) {
        const header = object[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i = 0;i < keys.length; ++i) {
        appendHeader(headers, keys[i], object[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (getHeadersGuard(headers) === "immutable") {
      throw new TypeError("immutable");
    }
    return getHeadersList(headers).append(name, value, false);
  }
  function compareHeaderName(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    contains(name, isLowerCase) {
      return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    append(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        (this.cookies ??= []).push(value);
      }
    }
    set(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name, isLowerCase) {
      this[kHeadersSortedMap] = null;
      if (!isLowerCase)
        name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this[kHeadersMap].delete(name);
    }
    get(name, isLowerCase) {
      return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers = {};
      if (this[kHeadersMap].size !== 0) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers[name] = value;
        }
      }
      return headers;
    }
    rawValues() {
      return this[kHeadersMap].values();
    }
    get entriesList() {
      const headers = [];
      if (this[kHeadersMap].size !== 0) {
        for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {
          if (lowerName === "set-cookie") {
            for (const cookie of this.cookies) {
              headers.push([name, cookie]);
            }
          } else {
            headers.push([name, value]);
          }
        }
      }
      return headers;
    }
    toSortedArray() {
      const size = this[kHeadersMap].size;
      const array = new Array(size);
      if (size <= 32) {
        if (size === 0) {
          return array;
        }
        const iterator = this[kHeadersMap][Symbol.iterator]();
        const firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value];
        assert(firstValue[1].value !== null);
        for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;i < size; ++i) {
          value = iterator.next().value;
          x = array[i] = [value[0], value[1].value];
          assert(x[1] !== null);
          left = 0;
          right = i;
          while (left < right) {
            pivot = left + (right - left >> 1);
            if (array[pivot][0] <= x[0]) {
              left = pivot + 1;
            } else {
              right = pivot;
            }
          }
          if (i !== pivot) {
            j = i;
            while (j > left) {
              array[j] = array[--j];
            }
            array[left] = x;
          }
        }
        if (!iterator.next().done) {
          throw new TypeError("Unreachable");
        }
        return array;
      } else {
        let i = 0;
        for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
          array[i++] = [name, value];
          assert(value !== null);
        }
        return array.sort(compareHeaderName);
      }
    }
  }

  class Headers {
    #guard;
    #headersList;
    constructor(init = undefined) {
      webidl.util.markAsUncloneable(this);
      if (init === kConstruct) {
        return;
      }
      this.#headersList = new HeadersList;
      this.#guard = "none";
      if (init !== undefined) {
        init = webidl.converters.HeadersInit(init, "Headers contructor", "init");
        fill(this, init);
      }
    }
    append(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.append");
      const prefix = "Headers.append";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      return appendHeader(this, name, value);
    }
    delete(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
      const prefix = "Headers.delete";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      if (!this.#headersList.contains(name, false)) {
        return;
      }
      this.#headersList.delete(name, false);
    }
    get(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.get");
      const prefix = "Headers.get";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.get(name, false);
    }
    has(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.has");
      const prefix = "Headers.has";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.contains(name, false);
    }
    set(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.set");
      const prefix = "Headers.set";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value,
          type: "header value"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      this.#headersList.set(name, value, false);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      const list = this.#headersList.cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this.#headersList[kHeadersSortedMap]) {
        return this.#headersList[kHeadersSortedMap];
      }
      const headers = [];
      const names = this.#headersList.toSortedArray();
      const cookies = this.#headersList.cookies;
      if (cookies === null || cookies.length === 1) {
        return this.#headersList[kHeadersSortedMap] = names;
      }
      for (let i = 0;i < names.length; ++i) {
        const { 0: name, 1: value } = names[i];
        if (name === "set-cookie") {
          for (let j = 0;j < cookies.length; ++j) {
            headers.push([name, cookies[j]]);
          }
        } else {
          headers.push([name, value]);
        }
      }
      return this.#headersList[kHeadersSortedMap] = headers;
    }
    [util.inspect.custom](depth, options) {
      options.depth ??= depth;
      return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;
    }
    static getHeadersGuard(o) {
      return o.#guard;
    }
    static setHeadersGuard(o, guard) {
      o.#guard = guard;
    }
    static getHeadersList(o) {
      return o.#headersList;
    }
    static setHeadersList(o, list) {
      o.#headersList = list;
    }
  }
  var { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
  Reflect.deleteProperty(Headers, "getHeadersGuard");
  Reflect.deleteProperty(Headers, "setHeadersGuard");
  Reflect.deleteProperty(Headers, "getHeadersList");
  Reflect.deleteProperty(Headers, "setHeadersList");
  iteratorMixin("Headers", Headers, kHeadersSortedMap, 0, 1);
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object") {
      const iterator = Reflect.get(V, Symbol.iterator);
      if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) {
        try {
          return getHeadersList(V).entriesList;
        } catch {}
      }
      if (typeof iterator === "function") {
        return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
      }
      return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    compareHeaderName,
    Headers,
    HeadersList,
    getHeadersGuard,
    setHeadersGuard,
    setHeadersList,
    getHeadersList
  };
});

// node_modules/undici/lib/web/fetch/response.js
var require_response = __commonJS((exports, module) => {
  var { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require_headers();
  var { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = require_body();
  var util = require_util();
  var nodeUtil = __require("node:util");
  var { kEnumerableProperty } = util;
  var {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode,
    environmentSettingsObject: relevantRealm
  } = require_util2();
  var {
    redirectStatusSet,
    nullBodyStatus
  } = require_constants3();
  var { kState, kHeaders } = require_symbols2();
  var { webidl } = require_webidl();
  var { FormData: FormData2 } = require_formdata();
  var { URLSerializer } = require_data_url();
  var { kConstruct } = require_symbols();
  var assert = __require("node:assert");
  var { types } = __require("node:util");
  var textEncoder = new TextEncoder("utf-8");

  class Response {
    static error() {
      const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
      return responseObject;
    }
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, "Response.json");
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
      const body = extractBody(bytes);
      const responseObject = fromInnerResponse(makeResponse({}), "response");
      initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
      return responseObject;
    }
    static redirect(url, status = 302) {
      webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
      } catch (err) {
        throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError(`Invalid status code ${status}`);
      }
      const responseObject = fromInnerResponse(makeResponse({}), "immutable");
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value, true);
      return responseObject;
    }
    constructor(body = null, init = {}) {
      webidl.util.markAsUncloneable(this);
      if (body === kConstruct) {
        return;
      }
      if (body !== null) {
        body = webidl.converters.BodyInit(body);
      }
      init = webidl.converters.ResponseInit(init);
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers(kConstruct);
      setHeadersGuard(this[kHeaders], "response");
      setHeadersList(this[kHeaders], this[kState].headersList);
      let bodyWithType = null;
      if (body != null) {
        const [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      webidl.brandCheck(this, Response);
      return this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    get redirected() {
      webidl.brandCheck(this, Response);
      return this[kState].urlList.length > 1;
    }
    get status() {
      webidl.brandCheck(this, Response);
      return this[kState].status;
    }
    get ok() {
      webidl.brandCheck(this, Response);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      webidl.brandCheck(this, Response);
      return this[kState].statusText;
    }
    get headers() {
      webidl.brandCheck(this, Response);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      webidl.brandCheck(this, Response);
      if (bodyUnusable(this)) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      if (hasFinalizationRegistry && this[kState].body?.stream) {
        streamRegistry.register(this, new WeakRef(this[kState].body.stream));
      }
      return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response) {
    if (response.internalResponse) {
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    }
    const newResponse = makeResponse({ ...response, body: null });
    if (response.body != null) {
      newResponse.body = cloneBody(newResponse, response.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList,
      urlList: init?.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function isNetworkError(response) {
    return response.type === "error" && response.status === 0;
  }
  function makeFilteredResponse(response, state) {
    state = {
      internalResponse: response,
      ...state
    };
    return new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response, type) {
    if (type === "basic") {
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response[kHeaders], init.headers);
    }
    if (body) {
      if (nullBodyStatus.includes(response.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${response.status}`
        });
      }
      response[kState].body = body.body;
      if (body.type != null && !response[kState].headersList.contains("content-type", true)) {
        response[kState].headersList.append("content-type", body.type, true);
      }
    }
  }
  function fromInnerResponse(innerResponse, guard) {
    const response = new Response(kConstruct);
    response[kState] = innerResponse;
    response[kHeaders] = new Headers(kConstruct);
    setHeadersList(response[kHeaders], innerResponse.headersList);
    setHeadersGuard(response[kHeaders], guard);
    if (hasFinalizationRegistry && innerResponse.body?.stream) {
      streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
    }
    return response;
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, name);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, prefix, name, { strict: false });
    }
    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
      return webidl.converters.BufferSource(V, prefix, name);
    }
    if (util.isFormDataLike(V)) {
      return webidl.converters.FormData(V, prefix, name, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V, prefix, name);
    }
    return webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function(V, prefix, argument) {
    if (V instanceof ReadableStream) {
      return webidl.converters.ReadableStream(V, prefix, argument);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    isNetworkError,
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse,
    fromInnerResponse
  };
});

// node_modules/undici/lib/web/fetch/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      if (dispatcher.on) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
    unregister(key) {}
  }
  module.exports = function() {
    if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
      process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return { WeakRef, FinalizationRegistry };
  };
});

// node_modules/undici/lib/web/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  var { extractBody, mixinBody, cloneBody, bodyUnusable } = require_body();
  var { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require_headers();
  var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
  var util = require_util();
  var nodeUtil = __require("node:util");
  var {
    isValidHTTPToken,
    sameOrigin,
    environmentSettingsObject
  } = require_util2();
  var {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants3();
  var { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
  var { kHeaders, kSignal, kState, kDispatcher } = require_symbols2();
  var { webidl } = require_webidl();
  var { URLSerializer } = require_data_url();
  var { kConstruct } = require_symbols();
  var assert = __require("node:assert");
  var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("node:events");
  var kAbortController = Symbol("abortController");
  var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });
  var dependentControllerMap = new WeakMap;
  function buildAbort(acRef) {
    return abort;
    function abort() {
      const ac = acRef.deref();
      if (ac !== undefined) {
        requestFinalizer.unregister(abort);
        this.removeEventListener("abort", abort);
        ac.abort(this.reason);
        const controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== undefined) {
          if (controllerList.size !== 0) {
            for (const ref of controllerList) {
              const ctrl = ref.deref();
              if (ctrl !== undefined) {
                ctrl.abort(this.reason);
              }
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  var patchMethodWarning = false;

  class Request {
    constructor(input, init = {}) {
      webidl.util.markAsUncloneable(this);
      if (input === kConstruct) {
        return;
      }
      const prefix = "Request constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      input = webidl.converters.RequestInfo(input, prefix, "input");
      init = webidl.converters.RequestInit(init, prefix, "init");
      let request = null;
      let fallbackMode = null;
      const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        this[kDispatcher] = init.dispatcher;
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        }
        request = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        this[kDispatcher] = init.dispatcher || input[kDispatcher];
        assert(input instanceof Request);
        request = input[kState];
        signal = input[kSignal];
      }
      const origin = environmentSettingsObject.settingsObject.origin;
      let window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
        window2 = request.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: environmentSettingsObject.settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request.mode === "navigate") {
          request.mode = "same-origin";
        }
        request.reloadNavigation = false;
        request.historyNavigation = false;
        request.origin = "client";
        request.referrer = "client";
        request.referrerPolicy = "";
        request.url = request.urlList[request.urlList.length - 1];
        request.urlList = [request.url];
      }
      if (init.referrer !== undefined) {
        const referrer = init.referrer;
        if (referrer === "") {
          request.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
            request.referrer = "client";
          } else {
            request.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== undefined) {
        request.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== undefined) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request.mode = mode;
      }
      if (init.credentials !== undefined) {
        request.credentials = init.credentials;
      }
      if (init.cache !== undefined) {
        request.cache = init.cache;
      }
      if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
        throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      }
      if (init.redirect !== undefined) {
        request.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request.integrity = String(init.integrity);
      }
      if (init.keepalive !== undefined) {
        request.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== undefined) {
        let method = init.method;
        const mayBeNormalized = normalizedMethodRecords[method];
        if (mayBeNormalized !== undefined) {
          request.method = mayBeNormalized;
        } else {
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          const upperCase = method.toUpperCase();
          if (forbiddenMethodsSet.has(upperCase)) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizedMethodRecordsBase[upperCase] ?? method;
          request.method = method;
        }
        if (!patchMethodWarning && request.method === "patch") {
          process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          });
          patchMethodWarning = true;
        }
      }
      if (init.signal !== undefined) {
        signal = init.signal;
      }
      this[kState] = request;
      const ac = new AbortController;
      this[kSignal] = ac.signal;
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = buildAbort(acRef);
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(1500, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(1500, signal);
            }
          } catch {}
          util.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort }, abort);
        }
      }
      this[kHeaders] = new Headers(kConstruct);
      setHeadersList(this[kHeaders], request.headersList);
      setHeadersGuard(this[kHeaders], "request");
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method)) {
          throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
        }
        setHeadersGuard(this[kHeaders], "request-no-cors");
      }
      if (initHasKey) {
        const headersList = getHeadersList(this[kHeaders]);
        const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers instanceof HeadersList) {
          for (const { name, value } of headers.rawValues()) {
            headersList.append(name, value, false);
          }
          headersList.cookies = headers.cookies;
        } else {
          fillHeaders(this[kHeaders], headers);
        }
      }
      const inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        initBody = extractedBody;
        if (contentType && !getHeadersList(this[kHeaders]).contains("content-type", true)) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request.mode !== "same-origin" && request.mode !== "cors") {
          throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        }
        request.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (bodyUnusable(input)) {
          throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
        }
        const identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      webidl.brandCheck(this, Request);
      return this[kState].method;
    }
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this[kState].url);
    }
    get headers() {
      webidl.brandCheck(this, Request);
      return this[kHeaders];
    }
    get destination() {
      webidl.brandCheck(this, Request);
      return this[kState].destination;
    }
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this[kState].referrerPolicy;
    }
    get mode() {
      webidl.brandCheck(this, Request);
      return this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      webidl.brandCheck(this, Request);
      return this[kState].cache;
    }
    get redirect() {
      webidl.brandCheck(this, Request);
      return this[kState].redirect;
    }
    get integrity() {
      webidl.brandCheck(this, Request);
      return this[kState].integrity;
    }
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this[kState].keepalive;
    }
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].historyNavigation;
    }
    get signal() {
      webidl.brandCheck(this, Request);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    clone() {
      webidl.brandCheck(this, Request);
      if (bodyUnusable(this)) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const ac = new AbortController;
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        let list = dependentControllerMap.get(this.signal);
        if (list === undefined) {
          list = new Set;
          dependentControllerMap.set(this.signal, list);
        }
        const acRef = new WeakRef(ac);
        list.add(acRef);
        util.addAbortListener(ac.signal, buildAbort(acRef));
      }
      return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Request);
  function makeRequest(init) {
    return {
      method: init.method ?? "GET",
      localURLsOnly: init.localURLsOnly ?? false,
      unsafeRequest: init.unsafeRequest ?? false,
      body: init.body ?? null,
      client: init.client ?? null,
      reservedClient: init.reservedClient ?? null,
      replacesClientId: init.replacesClientId ?? "",
      window: init.window ?? "client",
      keepalive: init.keepalive ?? false,
      serviceWorkers: init.serviceWorkers ?? "all",
      initiator: init.initiator ?? "",
      destination: init.destination ?? "",
      priority: init.priority ?? null,
      origin: init.origin ?? "client",
      policyContainer: init.policyContainer ?? "client",
      referrer: init.referrer ?? "client",
      referrerPolicy: init.referrerPolicy ?? "",
      mode: init.mode ?? "no-cors",
      useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
      credentials: init.credentials ?? "same-origin",
      useCredentials: init.useCredentials ?? false,
      cache: init.cache ?? "default",
      redirect: init.redirect ?? "follow",
      integrity: init.integrity ?? "",
      cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: init.parserMetadata ?? "",
      reloadNavigation: init.reloadNavigation ?? false,
      historyNavigation: init.historyNavigation ?? false,
      userActivation: init.userActivation ?? false,
      taintedOrigin: init.taintedOrigin ?? false,
      redirectCount: init.redirectCount ?? 0,
      responseTainting: init.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
      done: init.done ?? false,
      timingAllowFailed: init.timingAllowFailed ?? false,
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
  }
  function cloneRequest(request) {
    const newRequest = makeRequest({ ...request, body: null });
    if (request.body != null) {
      newRequest.body = cloneBody(newRequest, request.body);
    }
    return newRequest;
  }
  function fromInnerRequest(innerRequest, signal, guard) {
    const request = new Request(kConstruct);
    request[kState] = innerRequest;
    request[kSignal] = signal;
    request[kHeaders] = new Headers(kConstruct);
    setHeadersList(request[kHeaders], innerRequest.headersList);
    setHeadersGuard(request[kHeaders], guard);
    return request;
  }
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V, prefix, argument) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, argument);
    }
    if (V instanceof Request) {
      return webidl.converters.Request(V, prefix, argument);
    }
    return webidl.converters.USVString(V, prefix, argument);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, "RequestInit", "signal", { strict: false }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any
    }
  ]);
  module.exports = { Request, makeRequest, fromInnerRequest, cloneRequest };
});

// node_modules/undici/lib/web/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var {
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse,
    fromInnerResponse
  } = require_response();
  var { HeadersList } = require_headers();
  var { Request, cloneRequest } = require_request2();
  var zlib = __require("node:zlib");
  var {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme,
    clampAndCoarsenConnectionTimingInfo,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType
  } = require_util2();
  var { kState, kDispatcher } = require_symbols2();
  var assert = __require("node:assert");
  var { safelyExtractBody, extractBody } = require_body();
  var {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet
  } = require_constants3();
  var EE = __require("node:events");
  var { Readable, pipeline, finished } = __require("node:stream");
  var { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = require_util();
  var { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require_data_url();
  var { getGlobalDispatcher } = require_global2();
  var { webidl } = require_webidl();
  var { STATUS_CODES } = __require("node:http");
  var GET_OR_HEAD = ["GET", "HEAD"];
  var defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
  var resolveObjectURL;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    abort(error) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      this.connection?.destroy(error);
      this.emit("terminated", error);
    }
  }
  function handleFetchDone(response) {
    finalizeAndReportTiming(response, "fetch");
  }
  function fetch2(input, init = undefined) {
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request.serviceWorkers = "none";
    }
    let responseObject = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(requestObject.signal, () => {
      locallyAborted = true;
      assert(controller != null);
      controller.abort(requestObject.signal.reason);
      const realResponse = responseObject?.deref();
      abortFetch(p, request, realResponse, requestObject.signal.reason);
    });
    const processResponse = (response) => {
      if (locallyAborted) {
        return;
      }
      if (response.aborted) {
        abortFetch(p, request, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response.type === "error") {
        p.reject(new TypeError("fetch failed", { cause: response.error }));
        return;
      }
      responseObject = new WeakRef(fromInnerResponse(response, "immutable"));
      p.resolve(responseObject.deref());
      p = null;
    };
    controller = fetching({
      request,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: requestObject[kDispatcher]
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted) {
      return;
    }
    if (!response.urlList?.length) {
      return;
    }
    const originalURL = response.urlList[0];
    let timingInfo = response.timingInfo;
    let cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response.timingInfo = timingInfo;
    markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);
  }
  var markResourceTiming = performance.markResourceTiming;
  function abortFetch(p, request, responseObject, error) {
    if (p) {
      p.reject(error);
    }
    if (request.body != null && isReadable(request.body?.stream)) {
      request.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream)) {
      response.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher = getGlobalDispatcher()
  }) {
    assert(dispatcher);
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request.client != null) {
      taskDestination = request.client.globalObject;
      crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    }
    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currentTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request.body || request.body.stream);
    if (request.window === "client") {
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    }
    if (request.origin === "client") {
      request.origin = request.client.origin;
    }
    if (request.policyContainer === "client") {
      if (request.client != null) {
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      } else {
        request.policyContainer = makePolicyContainer();
      }
    }
    if (!request.headersList.contains("accept", true)) {
      const value = "*/*";
      request.headersList.append("accept", value, true);
    }
    if (!request.headersList.contains("accept-language", true)) {
      request.headersList.append("accept-language", "*", true);
    }
    if (request.priority === null) {}
    if (subresourceSet.has(request.destination)) {}
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request = fetchParams.request;
    let response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
      response = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
    if (requestBadPort(request) === "blocked") {
      response = makeNetworkError("bad port");
    }
    if (request.referrerPolicy === "") {
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    }
    if (request.referrer !== "no-referrer") {
      request.referrer = determineRequestsReferrer(request);
    }
    if (response === null) {
      response = await (async () => {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
          request.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          }
          request.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response;
    }
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors") {}
      if (request.responseTainting === "basic") {
        response = filterResponse(response, "basic");
      } else if (request.responseTainting === "cors") {
        response = filterResponse(response, "cors");
      } else if (request.responseTainting === "opaque") {
        response = filterResponse(response, "opaque");
      } else {
        assert(false);
      }
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request.urlList);
    }
    if (!request.timingAllowFailed) {
      response.timingAllowPassed = true;
    }
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range", true)) {
      response = internalResponse = makeNetworkError();
    }
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = __require("node:buffer").resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blob = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blob)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const response = makeResponse();
        const fullLength = blob.size;
        const serializedFullLength = isomorphicEncode(`${fullLength}`);
        const type = blob.type;
        if (!request.headersList.contains("range", true)) {
          const bodyWithType = extractBody(blob);
          response.statusText = "OK";
          response.body = bodyWithType[0];
          response.headersList.set("content-length", serializedFullLength, true);
          response.headersList.set("content-type", type, true);
        } else {
          response.rangeRequested = true;
          const rangeHeader = request.headersList.get("range", true);
          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
          if (rangeValue === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
          if (rangeStart === null) {
            rangeStart = fullLength - rangeEnd;
            rangeEnd = rangeStart + rangeEnd - 1;
          } else {
            if (rangeStart >= fullLength) {
              return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
            }
            if (rangeEnd === null || rangeEnd >= fullLength) {
              rangeEnd = fullLength - 1;
            }
          }
          const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
          const slicedBodyWithType = extractBody(slicedBlob);
          response.body = slicedBodyWithType[0];
          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
          response.status = 206;
          response.statusText = "Partial Content";
          response.headersList.set("content-length", serializedSlicedLength, true);
          response.headersList.set("content-type", type, true);
          response.headersList.set("content-range", contentRange, true);
        }
        return Promise.resolve(response);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response));
    }
  }
  function fetchFinale(fetchParams, response) {
    let timingInfo = fetchParams.timingInfo;
    const processResponseEndOfBody = () => {
      const unsafeEndTime = Date.now();
      if (fetchParams.request.destination === "document") {
        fetchParams.controller.fullTimingInfo = timingInfo;
      }
      fetchParams.controller.reportTimingSteps = () => {
        if (fetchParams.request.url.protocol !== "https:") {
          return;
        }
        timingInfo.endTime = unsafeEndTime;
        let cacheState = response.cacheState;
        const bodyInfo = response.bodyInfo;
        if (!response.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo(timingInfo);
          cacheState = "";
        }
        let responseStatus = 0;
        if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
          responseStatus = response.status;
          const mimeType = extractMimeType(response.headersList);
          if (mimeType !== "failure") {
            bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
          }
        }
        if (fetchParams.request.initiatorType != null) {
          markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        }
      };
      const processResponseEndOfBodyTask = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
        if (fetchParams.request.initiatorType != null) {
          fetchParams.controller.reportTimingSteps();
        }
      };
      queueMicrotask(() => processResponseEndOfBodyTask());
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => {
        fetchParams.processResponse(response);
        fetchParams.processResponse = null;
      });
    }
    const internalResponse = response.type === "error" ? response : response.internalResponse ?? response;
    if (internalResponse.body == null) {
      processResponseEndOfBody();
    } else {
      finished(internalResponse.body.stream, () => {
        processResponseEndOfBody();
      });
    }
  }
  async function httpFetch(fetchParams) {
    const request = fetchParams.request;
    let response = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all") {}
    if (response === null) {
      if (request.redirect === "follow") {
        request.serviceWorkers = "none";
      }
      actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
      if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request, response) === "failure") {
        request.timingAllowFailed = true;
      }
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual") {
        fetchParams.controller.connection.destroy(undefined, false);
      }
      if (request.redirect === "error") {
        response = makeNetworkError("unexpected redirect");
      } else if (request.redirect === "manual") {
        response = actualResponse;
      } else if (request.redirect === "follow") {
        response = await httpRedirectFetch(fetchParams, response);
      } else {
        assert(false);
      }
    }
    response.timingInfo = timingInfo;
    return response;
  }
  function httpRedirectFetch(fetchParams, response) {
    const request = fetchParams.request;
    const actualResponse = response.internalResponse ? response.internalResponse : response;
    let locationURL;
    try {
      locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
      if (locationURL == null) {
        return response;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request.redirectCount += 1;
    if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    }
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET";
      request.body = null;
      for (const headerName of requestBodyHeader) {
        request.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL)) {
      request.headersList.delete("authorization", true);
      request.headersList.delete("proxy-authorization", true);
      request.headersList.delete("cookie", true);
      request.headersList.delete("host", true);
    }
    if (request.body != null) {
      assert(request.body.source != null);
      request.body = safelyExtractBody(request.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response = null;
    const httpCache = null;
    const revalidatingFlag = false;
    if (request.window === "no-window" && request.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request;
    } else {
      httpRequest = cloneRequest(request);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
    }
    if (contentLength != null && httpRequest.keepalive) {}
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent", true)) {
      httpRequest.headersList.append("user-agent", defaultUserAgent);
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
      httpRequest.headersList.append("cache-control", "max-age=0", true);
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma", true)) {
        httpRequest.headersList.append("pragma", "no-cache", true);
      }
      if (!httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "no-cache", true);
      }
    }
    if (httpRequest.headersList.contains("range", true)) {
      httpRequest.headersList.append("accept-encoding", "identity", true);
    }
    if (!httpRequest.headersList.contains("accept-encoding", true)) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
      }
    }
    httpRequest.headersList.delete("host", true);
    if (includeCredentials) {}
    if (httpCache == null) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") {}
    if (response == null) {
      if (httpRequest.cache === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
      if (revalidatingFlag && forwardResponse.status === 304) {}
      if (response == null) {
        response = forwardResponse;
      }
    }
    response.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range", true)) {
      response.rangeRequested = true;
    }
    response.requestIncludesCredentials = includeCredentials;
    if (response.status === 407) {
      if (request.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
    }
    if (isAuthenticationFetch) {}
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err, abort = true) {
        if (!this.destroyed) {
          this.destroyed = true;
          if (abort) {
            this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      }
    };
    const request = fetchParams.request;
    let response = null;
    const timingInfo = fetchParams.timingInfo;
    const httpCache = null;
    if (httpCache == null) {
      request.cache = "no-store";
    }
    const newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket") {} else {}
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = async () => {
      await fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      if (!isCancelled(fetchParams)) {
        fetchParams.controller.abort(reason);
      }
    };
    const stream = new ReadableStream({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      },
      type: "bytes"
    });
    response.body = { stream, source: null, length: null };
    fetchParams.controller.onAborted = onAborted;
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? undefined : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = undefined;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === undefined) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        const buffer = new Uint8Array(bytes);
        if (buffer.byteLength) {
          fetchParams.controller.controller.enqueue(buffer);
        }
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : undefined
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response;
    function dispatch({ body }) {
      const url = requestCurrentURL(request);
      const agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : undefined
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          const { connection } = fetchParams.controller;
          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
          if (connection.destroyed) {
            abort(new DOMException("The operation was aborted.", "AbortError"));
          } else {
            fetchParams.controller.on("terminated", abort);
            this.abort = connection.abort = abort;
          }
          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onResponseStarted() {
          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onHeaders(status, rawHeaders, resume, statusText) {
          if (status < 200) {
            return;
          }
          let location = "";
          const headersList = new HeadersList;
          for (let i = 0;i < rawHeaders.length; i += 2) {
            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
          }
          location = headersList.get("location", true);
          this.body = new Readable({ read: resume });
          const decoders = [];
          const willFollow = location && request.redirect === "follow" && redirectStatusSet.has(status);
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
            const contentEncoding = headersList.get("content-encoding", true);
            const codings = contentEncoding ? contentEncoding.toLowerCase().split(",") : [];
            const maxContentEncodings = 5;
            if (codings.length > maxContentEncodings) {
              reject(new Error(`too many content-encodings in response: ${codings.length}, maximum allowed is ${maxContentEncodings}`));
              return true;
            }
            for (let i = codings.length - 1;i >= 0; --i) {
              const coding = codings[i].trim();
              if (coding === "x-gzip" || coding === "gzip") {
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "deflate") {
                decoders.push(createInflate({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress({
                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                }));
              } else {
                decoders.length = 0;
                break;
              }
            }
          }
          const onError = this.onError.bind(this);
          resolve({
            status,
            statusText,
            headersList,
            body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
              if (err) {
                this.onError(err);
              }
            }).on("error", onError) : this.body.on("error", onError)
          });
          return true;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) {
            return;
          }
          const bytes = chunk;
          timingInfo.encodedBodySize += bytes.byteLength;
          return this.body.push(bytes);
        },
        onComplete() {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          if (fetchParams.controller.onAborted) {
            fetchParams.controller.off("terminated", fetchParams.controller.onAborted);
          }
          fetchParams.controller.ended = true;
          this.body.push(null);
        },
        onError(error) {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          this.body?.destroy(error);
          fetchParams.controller.terminate(error);
          reject(error);
        },
        onUpgrade(status, rawHeaders, socket) {
          if (status !== 101) {
            return;
          }
          const headersList = new HeadersList;
          for (let i = 0;i < rawHeaders.length; i += 2) {
            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
          }
          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList,
            socket
          });
          return true;
        }
      }));
    }
  }
  module.exports = {
    fetch: fetch2,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/web/fileapi/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/undici/lib/web/fileapi/progressevent.js
var require_progressevent = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type, "ProgressEvent constructor", "type");
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/undici/lib/web/fileapi/encoding.js
var require_encoding = __commonJS((exports, module) => {
  function getEncoding(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  module.exports = {
    getEncoding
  };
});

// node_modules/undici/lib/web/fileapi/util.js
var require_util4 = __commonJS((exports, module) => {
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols3();
  var { ProgressEvent } = require_progressevent();
  var { getEncoding } = require_encoding();
  var { serializeAMimeType, parseMIMEType } = require_data_url();
  var { types } = __require("node:util");
  var { StringDecoder } = __require("string_decoder");
  var { btoa: btoa2 } = __require("node:buffer");
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream = blob.stream();
    const reader = stream.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  }
  function fireAProgressEvent(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL += btoa2(decoder.write(chunk));
        }
        dataURL += btoa2(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName) {
          encoding = getEncoding(encodingName);
        }
        if (encoding === "failure" && mimeType) {
          const type2 = parseMIMEType(mimeType);
          if (type2 !== "failure") {
            encoding = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding === "failure") {
          encoding = "UTF-8";
        }
        return decode(bytes, encoding);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  }
  function decode(ioQueue, encoding) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  }
  function combineByteSequences(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  }
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/undici/lib/web/fileapi/filereader.js
var require_filereader = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util4();
  var {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols3();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = undefined) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsText");
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding !== undefined) {
        encoding = webidl.converters.DOMString(encoding, "FileReader.readAsText", "encoding");
      }
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/undici/lib/web/cache/symbols.js
var require_symbols4 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: require_symbols().kConstruct
  };
});

// node_modules/undici/lib/web/cache/util.js
var require_util5 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { URLSerializer } = require_data_url();
  var { isValidHeaderName } = require_util2();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function getFieldValues(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (isValidHeaderName(value)) {
        values.push(value);
      }
    }
    return values;
  }
  module.exports = {
    urlEquals,
    getFieldValues
  };
});

// node_modules/undici/lib/web/cache/cache.js
var require_cache = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { urlEquals, getFieldValues } = require_util5();
  var { kEnumerableProperty, isDisturbed } = require_util();
  var { webidl } = require_webidl();
  var { Response, cloneResponse, fromInnerResponse } = require_response();
  var { Request, fromInnerRequest } = require_request2();
  var { kState } = require_symbols2();
  var { fetching } = require_fetch();
  var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
  var assert = __require("node:assert");

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.match";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      const p = this.#internalMatchAll(request, options, 1);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.matchAll";
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      return this.#internalMatchAll(request, options);
    }
    async add(request) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.add";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      const requests = [request];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.addAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const responsePromises = [];
      const requestList = [];
      for (let request of requests) {
        if (request === undefined) {
          throw webidl.errors.conversionFailed({
            prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        }
        request = webidl.converters.RequestInfo(request);
        if (typeof request === "string") {
          continue;
        }
        const r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request of requests) {
        const r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response of responses) {
        const operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(undefined);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.put";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      response = webidl.converters.Response(response, prefix, "response");
      let innerRequest = null;
      if (request instanceof Request) {
        innerRequest = request[kState];
      } else {
        innerRequest = new Request(request)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(undefined);
      }
      const operations = [];
      const operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request instanceof Request) {
        r = request[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request === "string");
        r = new Request(request)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async keys(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.keys";
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request2 of requests) {
          const requestObject = fromInnerRequest(request2, new AbortController().signal, "immutable");
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    #batchCacheOperations(operations) {
      const cache = this.#relevantRequestResponseList;
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
    #internalMatchAll(request, options, maxResponses = Infinity) {
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const responses = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = fromInnerResponse(response, "immutable");
        responseList.push(responseObject.clone());
        if (responseList.length >= maxResponses) {
          break;
        }
      }
      return Object.freeze(responseList);
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/web/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { Cache } = require_cache();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class CacheStorage {
    #caches = new Map;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache = new Cache(kConstruct, cacheList);
          return await cache.match(request, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache = new Cache(kConstruct, cacheList);
          const response = await cache.match(request, options);
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.has(cacheName);
    }
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.open";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      if (this.#caches.has(cacheName)) {
        const cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      const cache = [];
      this.#caches.set(cacheName, cache);
      return new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.delete(cacheName);
    }
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/web/cookies/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var maxAttributeValueSize = 1024;
  var maxNameValuePairSize = 4096;
  module.exports = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
});

// node_modules/undici/lib/web/cookies/util.js
var require_util6 = __commonJS((exports, module) => {
  function isCTLExcludingHtab(value) {
    for (let i = 0;i < value.length; ++i) {
      const code = value.charCodeAt(i);
      if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
        return true;
      }
    }
    return false;
  }
  function validateCookieName(name) {
    for (let i = 0;i < name.length; ++i) {
      const code = name.charCodeAt(i);
      if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 60 || code === 62 || code === 64 || code === 44 || code === 59 || code === 58 || code === 92 || code === 47 || code === 91 || code === 93 || code === 63 || code === 61 || code === 123 || code === 125) {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    let len = value.length;
    let i = 0;
    if (value[0] === '"') {
      if (len === 1 || value[len - 1] !== '"') {
        throw new Error("Invalid cookie value");
      }
      --len;
      ++i;
    }
    while (i < len) {
      const code = value.charCodeAt(i++);
      if (code < 33 || code > 126 || code === 34 || code === 44 || code === 59 || code === 92) {
        throw new Error("Invalid cookie value");
      }
    }
  }
  function validateCookiePath(path) {
    for (let i = 0;i < path.length; ++i) {
      const code = path.charCodeAt(i);
      if (code < 32 || code === 127 || code === 59) {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  var IMFDays = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  var IMFMonths = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var IMFPaddedNumbers = Array(61).fill(0).map((_2, i) => i.toString().padStart(2, "0"));
  function toIMFDate(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  module.exports = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify
  };
});

// node_modules/undici/lib/web/cookies/parse.js
var require_parse = __commonJS((exports, module) => {
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
  var { isCTLExcludingHtab } = require_util6();
  var { collectASequenceOfCodePointsFast } = require_data_url();
  var assert = __require("node:assert");
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/web/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var { parseSetCookie } = require_parse();
  var { stringify } = require_util6();
  var { webidl } = require_webidl();
  var { Headers } = require_headers();
  function getCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, "getCookies");
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookie = headers.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers, name, attributes) {
    webidl.brandCheck(headers, Headers, { strict: false });
    const prefix = "deleteCookie";
    webidl.argumentLengthCheck(arguments, 2, prefix);
    name = webidl.converters.DOMString(name, prefix, "name");
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers, {
      name,
      value: "",
      expires: new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookies = headers.getSetCookie();
    if (!cookies) {
      return [];
    }
    return cookies.map((pair) => parseSetCookie(pair));
  }
  function setCookie(headers, cookie) {
    webidl.argumentLengthCheck(arguments, 2, "setCookie");
    webidl.brandCheck(headers, Headers, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers.append("Set-Cookie", str);
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: () => new Array(0)
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/undici/lib/web/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { kConstruct } = require_symbols();
  var { MessagePort } = __require("node:worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      if (type === kConstruct) {
        super(arguments[1], arguments[2]);
        webidl.util.markAsUncloneable(this);
        return;
      }
      const prefix = "MessageEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
    static createFastMessageEvent(type, init) {
      const messageEvent = new MessageEvent(kConstruct, type, init);
      messageEvent.#eventInit = init;
      messageEvent.#eventInit.data ??= null;
      messageEvent.#eventInit.origin ??= "";
      messageEvent.#eventInit.lastEventId ??= "";
      messageEvent.#eventInit.source ??= null;
      messageEvent.#eventInit.ports ??= [];
      return messageEvent;
    }
  }
  var { createFastMessageEvent } = MessageEvent;
  delete MessageEvent.createFastMessageEvent;

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      const prefix = "CloseEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      const prefix = "ErrorEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      super(type, eventInitDict);
      webidl.util.markAsUncloneable(this);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      defaultValue: () => new Array(0)
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent,
    createFastMessageEvent
  };
});

// node_modules/undici/lib/web/websocket/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  var states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  var sentCloseFrameState = {
    NOT_SENT: 0,
    PROCESSING: 1,
    SENT: 2
  };
  var opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var maxUnsigned16Bit = 2 ** 16 - 1;
  var parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  var emptyBuffer = Buffer.allocUnsafe(0);
  var sendHints = {
    string: 1,
    typedArray: 2,
    arrayBuffer: 3,
    blob: 4
  };
  module.exports = {
    uid,
    sentCloseFrameState,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer,
    sendHints
  };
});

// node_modules/undici/lib/web/websocket/symbols.js
var require_symbols5 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/undici/lib/web/websocket/util.js
var require_util7 = __commonJS((exports, module) => {
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
  var { states, opcodes } = require_constants5();
  var { ErrorEvent, createFastMessageEvent } = require_events();
  var { isUtf8 } = __require("node:buffer");
  var { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require_data_url();
  function isConnecting(ws) {
    return ws[kReadyState] === states.CONNECTING;
  }
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    const event = eventFactory(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = utf8Decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = toArrayBuffer(data);
      }
    }
    fireEvent("message", ws, createFastMessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function toArrayBuffer(buffer) {
    if (buffer.byteLength === buffer.buffer.byteLength) {
      return buffer.buffer;
    }
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (let i = 0;i < protocol.length; ++i) {
      const code = protocol.charCodeAt(i);
      if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code === 58 || code === 59 || code === 60 || code === 61 || code === 62 || code === 63 || code === 64 || code === 91 || code === 92 || code === 93 || code === 123 || code === 125) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1000 && code < 1015) {
      return code !== 1004 && code !== 1005 && code !== 1006;
    }
    return code >= 3000 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    const { [kController]: controller, [kResponse]: response } = ws;
    controller.abort();
    if (response?.socket && !response.socket.destroyed) {
      response.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, (type, init) => new ErrorEvent(type, init), {
        error: new Error(reason),
        message: reason
      });
    }
  }
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  function parseExtensions(extensions) {
    const position = { position: 0 };
    const extensionList = new Map;
    while (position.position < extensions.length) {
      const pair = collectASequenceOfCodePointsFast(";", extensions, position);
      const [name, value = ""] = pair.split("=");
      extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));
      position.position++;
    }
    return extensionList;
  }
  function isValidClientWindowBits(value) {
    for (let i = 0;i < value.length; i++) {
      const byte = value.charCodeAt(i);
      if (byte < 48 || byte > 57) {
        return false;
      }
    }
    return true;
  }
  var hasIntl = typeof process.versions.icu === "string";
  var fatalDecoder = hasIntl ? new TextDecoder("utf-8", { fatal: true }) : undefined;
  var utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {
    if (isUtf8(buffer)) {
      return buffer.toString("utf-8");
    }
    throw new TypeError("Invalid utf-8 received.");
  };
  module.exports = {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isContinuationFrame,
    isTextBinaryFrame,
    isValidOpcode,
    parseExtensions,
    isValidClientWindowBits
  };
});

// node_modules/undici/lib/web/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { maxUnsigned16Bit } = require_constants5();
  var BUFFER_SIZE = 16386;
  var crypto2;
  var buffer = null;
  var bufIdx = BUFFER_SIZE;
  try {
    crypto2 = __require("node:crypto");
  } catch {
    crypto2 = {
      randomFillSync: function randomFillSync(buffer2, _offset, _size) {
        for (let i = 0;i < buffer2.length; ++i) {
          buffer2[i] = Math.random() * 255 | 0;
        }
        return buffer2;
      }
    };
  }
  function generateMask() {
    if (bufIdx === BUFFER_SIZE) {
      bufIdx = 0;
      crypto2.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);
    }
    return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
  }

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data;
    }
    createFrame(opcode) {
      const frameData = this.frameData;
      const maskKey = generateMask();
      const bodyLength = frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
      buffer2[0] = buffer2[1] = 0;
      buffer2[0] |= 128;
      buffer2[0] = (buffer2[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer2[offset - 4] = maskKey[0];
      buffer2[offset - 3] = maskKey[1];
      buffer2[offset - 2] = maskKey[2];
      buffer2[offset - 1] = maskKey[3];
      buffer2[1] = payloadLength;
      if (payloadLength === 126) {
        buffer2.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer2[2] = buffer2[3] = 0;
        buffer2.writeUIntBE(bodyLength, 4, 6);
      }
      buffer2[1] |= 128;
      for (let i = 0;i < bodyLength; ++i) {
        buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
      }
      return buffer2;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/undici/lib/web/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  var { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require_constants5();
  var {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose,
    kResponse
  } = require_symbols5();
  var { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = require_util7();
  var { channels } = require_diagnostics();
  var { CloseEvent } = require_events();
  var { makeRequest } = require_request2();
  var { fetching } = require_fetch();
  var { Headers, getHeadersList } = require_headers();
  var { getDecodeSplit } = require_util2();
  var { WebsocketFrameSend } = require_frame();
  var crypto2;
  try {
    crypto2 = __require("node:crypto");
  } catch {}
  function establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request = makeRequest({
      urlList: [requestURL],
      client,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = getHeadersList(new Headers(options.headers));
      request.headersList = headersList;
    }
    const keyValue = crypto2.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue);
    request.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate = "permessage-deflate; client_max_window_bits";
    request.headersList.append("sec-websocket-extensions", permessageDeflate);
    const controller = fetching({
      request,
      useParallelQueue: true,
      dispatcher: options.dispatcher,
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        let extensions;
        if (secExtension !== null) {
          extensions = parseExtensions(secExtension);
          if (!extensions.has("permessage-deflate")) {
            failWebsocketConnection(ws, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
        }
        const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null) {
          const requestProtocols = getDecodeSplit("sec-websocket-protocol", request.headersList);
          if (!requestProtocols.includes(secProtocol)) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
        }
        response.socket.on("data", onSocketData);
        response.socket.on("close", onSocketClose);
        response.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response, extensions);
      }
    });
    return controller;
  }
  function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
    if (isClosing(ws) || isClosed(ws)) {} else if (!isEstablished(ws)) {
      failWebsocketConnection(ws, "Connection was closed before it was established.");
      ws[kReadyState] = states.CLOSING;
    } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
      ws[kSentClose] = sentCloseFrameState.PROCESSING;
      const frame = new WebsocketFrameSend;
      if (code !== undefined && reason === undefined) {
        frame.frameData = Buffer.allocUnsafe(2);
        frame.frameData.writeUInt16BE(code, 0);
      } else if (code !== undefined && reason !== undefined) {
        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
        frame.frameData.writeUInt16BE(code, 0);
        frame.frameData.write(reason, 2, "utf-8");
      } else {
        frame.frameData = emptyBuffer;
      }
      const socket = ws[kResponse].socket;
      socket.write(frame.createFrame(opcodes.CLOSE));
      ws[kSentClose] = sentCloseFrameState.SENT;
      ws[kReadyState] = states.CLOSING;
    } else {
      ws[kReadyState] = states.CLOSING;
    }
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  }
  function onSocketClose() {
    const { ws } = this;
    const { [kResponse]: response } = ws;
    response.socket.off("data", onSocketData);
    response.socket.off("close", onSocketClose);
    response.socket.off("error", onSocketError);
    const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result && !result.error) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kReceivedClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, (type, init) => new CloseEvent(type, init), {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  }
  function onSocketError(error) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error);
    }
    this.destroy();
  }
  module.exports = {
    establishWebSocketConnection,
    closeWebSocketConnection
  };
});

// node_modules/undici/lib/web/websocket/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __require("node:zlib");
  var { isValidClientWindowBits } = require_util7();
  var tail = Buffer.from([0, 0, 255, 255]);
  var kBuffer = Symbol("kBuffer");
  var kLength = Symbol("kLength");

  class PerMessageDeflate {
    #inflate;
    #options = {};
    constructor(extensions) {
      this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
      this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
    }
    decompress(chunk, fin, callback) {
      if (!this.#inflate) {
        let windowBits = Z_DEFAULT_WINDOWBITS;
        if (this.#options.serverMaxWindowBits) {
          if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
            callback(new Error("Invalid server_max_window_bits"));
            return;
          }
          windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
        }
        this.#inflate = createInflateRaw({ windowBits });
        this.#inflate[kBuffer] = [];
        this.#inflate[kLength] = 0;
        this.#inflate.on("data", (data) => {
          this.#inflate[kBuffer].push(data);
          this.#inflate[kLength] += data.length;
        });
        this.#inflate.on("error", (err) => {
          this.#inflate = null;
          callback(err);
        });
      }
      this.#inflate.write(chunk);
      if (fin) {
        this.#inflate.write(tail);
      }
      this.#inflate.flush(() => {
        const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
        this.#inflate[kBuffer].length = 0;
        this.#inflate[kLength] = 0;
        callback(null, full);
      });
    }
  }
  module.exports = { PerMessageDeflate };
});

// node_modules/undici/lib/web/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("node:stream");
  var assert = __require("node:assert");
  var { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require_constants5();
  var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
  var { channels } = require_diagnostics();
  var {
    isValidStatusCode,
    isValidOpcode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isTextBinaryFrame,
    isContinuationFrame
  } = require_util7();
  var { WebsocketFrameSend } = require_frame();
  var { closeWebSocketConnection } = require_connection();
  var { PerMessageDeflate } = require_permessage_deflate();

  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #loop = false;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    #extensions;
    constructor(ws, extensions) {
      super();
      this.ws = ws;
      this.#extensions = extensions == null ? new Map : extensions;
      if (this.#extensions.has("permessage-deflate")) {
        this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
      }
    }
    _write(chunk, _2, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.#loop = true;
      this.run(callback);
    }
    run(callback) {
      while (this.#loop) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          const fin = (buffer[0] & 128) !== 0;
          const opcode = buffer[0] & 15;
          const masked = (buffer[1] & 128) === 128;
          const fragmented = !fin && opcode !== opcodes.CONTINUATION;
          const payloadLength = buffer[1] & 127;
          const rsv1 = buffer[0] & 64;
          const rsv2 = buffer[0] & 32;
          const rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) {
            failWebsocketConnection(this.ws, "Invalid opcode received");
            return callback();
          }
          if (masked) {
            failWebsocketConnection(this.ws, "Frame cannot be masked");
            return callback();
          }
          if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
            failWebsocketConnection(this.ws, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(this.ws, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
            failWebsocketConnection(this.ws, "Expected continuation frame");
            return;
          }
          if (this.#info.fragmented && fragmented) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(this.ws, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
            failWebsocketConnection(this.ws, "Unexpected continuation frame");
            return;
          }
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (isTextBinaryFrame(opcode)) {
            this.#info.binaryType = opcode;
            this.#info.compressed = rsv1 !== 0;
          }
          this.#info.opcode = opcode;
          this.#info.masked = masked;
          this.#info.fin = fin;
          this.#info.fragmented = fragmented;
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          }
          const body = this.consume(this.#info.payloadLength);
          if (isControlFrame(this.#info.opcode)) {
            this.#loop = this.parseControlFrame(body);
            this.#state = parserStates.INFO;
          } else {
            if (!this.#info.compressed) {
              this.#fragments.push(body);
              if (!this.#info.fragmented && this.#info.fin) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            } else {
              this.#extensions.get("permessage-deflate").decompress(body, this.#info.fin, (error, data) => {
                if (error) {
                  closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);
                  return;
                }
                this.#fragments.push(data);
                if (!this.#info.fin) {
                  this.#state = parserStates.INFO;
                  this.#loop = true;
                  this.run(callback);
                  return;
                }
                websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));
                this.#loop = true;
                this.#state = parserStates.INFO;
                this.#fragments.length = 0;
                this.run(callback);
              });
              this.#loop = false;
              break;
            }
          }
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset) {
        throw new Error("Called consume() before buffers satiated.");
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          this.#buffers[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n;
      return buffer;
    }
    parseCloseBody(data) {
      assert(data.length !== 1);
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (code !== undefined && !isValidStatusCode(code)) {
        return { code: 1002, reason: "Invalid status code", error: true };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      try {
        reason = utf8Decode(reason);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: true };
      }
      return { code, reason, error: false };
    }
    parseControlFrame(body) {
      const { opcode, payloadLength } = this.#info;
      if (opcode === opcodes.CLOSE) {
        if (payloadLength === 1) {
          failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
          return false;
        }
        this.#info.closeInfo = this.parseCloseBody(body);
        if (this.#info.closeInfo.error) {
          const { code, reason } = this.#info.closeInfo;
          closeWebSocketConnection(this.ws, code, reason, reason.length);
          failWebsocketConnection(this.ws, reason);
          return false;
        }
        if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
          let body2 = emptyBuffer;
          if (this.#info.closeInfo.code) {
            body2 = Buffer.allocUnsafe(2);
            body2.writeUInt16BE(this.#info.closeInfo.code, 0);
          }
          const closeFrame = new WebsocketFrameSend(body2);
          this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this.ws[kSentClose] = sentCloseFrameState.SENT;
            }
          });
        }
        this.ws[kReadyState] = states.CLOSING;
        this.ws[kReceivedClose] = true;
        return false;
      } else if (opcode === opcodes.PING) {
        if (!this.ws[kReceivedClose]) {
          const frame = new WebsocketFrameSend(body);
          this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
          if (channels.ping.hasSubscribers) {
            channels.ping.publish({
              payload: body
            });
          }
        }
      } else if (opcode === opcodes.PONG) {
        if (channels.pong.hasSubscribers) {
          channels.pong.publish({
            payload: body
          });
        }
      }
      return true;
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/web/websocket/sender.js
var require_sender = __commonJS((exports, module) => {
  var { WebsocketFrameSend } = require_frame();
  var { opcodes, sendHints } = require_constants5();
  var FixedQueue = require_fixed_queue();
  var FastBuffer = Buffer[Symbol.species];

  class SendQueue {
    #queue = new FixedQueue;
    #running = false;
    #socket;
    constructor(socket) {
      this.#socket = socket;
    }
    add(item, cb, hint) {
      if (hint !== sendHints.blob) {
        const frame = createFrame(item, hint);
        if (!this.#running) {
          this.#socket.write(frame, cb);
        } else {
          const node2 = {
            promise: null,
            callback: cb,
            frame
          };
          this.#queue.push(node2);
        }
        return;
      }
      const node = {
        promise: item.arrayBuffer().then((ab) => {
          node.promise = null;
          node.frame = createFrame(ab, hint);
        }),
        callback: cb,
        frame: null
      };
      this.#queue.push(node);
      if (!this.#running) {
        this.#run();
      }
    }
    async#run() {
      this.#running = true;
      const queue = this.#queue;
      while (!queue.isEmpty()) {
        const node = queue.shift();
        if (node.promise !== null) {
          await node.promise;
        }
        this.#socket.write(node.frame, node.callback);
        node.callback = node.frame = null;
      }
      this.#running = false;
    }
  }
  function createFrame(data, hint) {
    return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);
  }
  function toBuffer(data, hint) {
    switch (hint) {
      case sendHints.string:
        return Buffer.from(data);
      case sendHints.arrayBuffer:
      case sendHints.blob:
        return new FastBuffer(data);
      case sendHints.typedArray:
        return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    }
  }
  module.exports = { SendQueue };
});

// node_modules/undici/lib/web/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { URLSerializer } = require_data_url();
  var { environmentSettingsObject } = require_util2();
  var { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = require_constants5();
  var {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols5();
  var {
    isConnecting,
    isEstablished,
    isClosing,
    isValidSubprotocol,
    fireEvent
  } = require_util7();
  var { establishWebSocketConnection, closeWebSocketConnection } = require_connection();
  var { ByteParser } = require_receiver();
  var { kEnumerableProperty, isBlobLike } = require_util();
  var { getGlobalDispatcher } = require_global2();
  var { types } = __require("node:util");
  var { ErrorEvent, CloseEvent } = require_events();
  var { SendQueue } = require_sender();

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    #sendQueue;
    constructor(url, protocols = []) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "WebSocket constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
      url = webidl.converters.USVString(url, prefix, "url");
      protocols = options.protocols;
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      const client = environmentSettingsObject.settingsObject;
      this[kController] = establishWebSocketConnection(urlRecord, protocols, client, this, (response, extensions) => this.#onConnectionEstablished(response, extensions), options);
      this[kReadyState] = WebSocket.CONNECTING;
      this[kSentClose] = sentCloseFrameState.NOT_SENT;
      this[kBinaryType] = "blob";
    }
    close(code = undefined, reason = undefined) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.close";
      if (code !== undefined) {
        code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
      }
      if (reason !== undefined) {
        reason = webidl.converters.USVString(reason, prefix, "reason");
      }
      if (code !== undefined) {
        if (code !== 1000 && (code < 3000 || code > 4999)) {
          throw new DOMException("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== undefined) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
        }
      }
      closeWebSocketConnection(this, code, reason, reasonByteLength);
    }
    send(data) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.send";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      data = webidl.converters.WebSocketSendData(data, prefix, "data");
      if (isConnecting(this)) {
        throw new DOMException("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      if (typeof data === "string") {
        const length = Buffer.byteLength(data);
        this.#bufferedAmount += length;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= length;
        }, sendHints.string);
      } else if (types.isArrayBuffer(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.arrayBuffer);
      } else if (ArrayBuffer.isView(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.typedArray);
      } else if (isBlobLike(data)) {
        this.#bufferedAmount += data.size;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.size;
        }, sendHints.blob);
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
    #onConnectionEstablished(response, parsedExtensions) {
      this[kResponse] = response;
      const parser = new ByteParser(this, parsedExtensions);
      parser.on("drain", onParserDrain);
      parser.on("error", onParserError.bind(this));
      response.socket.ws = this;
      this[kByteParser] = parser;
      this.#sendQueue = new SendQueue(response.socket);
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => new Array(0)
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any,
      defaultValue: () => getGlobalDispatcher()
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  function onParserDrain() {
    this.ws[kResponse].socket.resume();
  }
  function onParserError(err) {
    let message;
    let code;
    if (err instanceof CloseEvent) {
      message = err.reason;
      code = err.code;
    } else {
      message = err.message;
    }
    fireEvent("error", this, () => new ErrorEvent("error", { error: err, message }));
    closeWebSocketConnection(this, code);
  }
  module.exports = {
    WebSocket
  };
});

// node_modules/undici/lib/web/eventsource/util.js
var require_util8 = __commonJS((exports, module) => {
  function isValidLastEventId(value) {
    return value.indexOf("\x00") === -1;
  }
  function isASCIINumber(value) {
    if (value.length === 0)
      return false;
    for (let i = 0;i < value.length; i++) {
      if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57)
        return false;
    }
    return true;
  }
  function delay(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms).unref();
    });
  }
  module.exports = {
    isValidLastEventId,
    isASCIINumber,
    delay
  };
});

// node_modules/undici/lib/web/eventsource/eventsource-stream.js
var require_eventsource_stream = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var { isASCIINumber, isValidLastEventId } = require_util8();
  var BOM = [239, 187, 191];
  var LF = 10;
  var CR = 13;
  var COLON = 58;
  var SPACE = 32;

  class EventSourceStream extends Transform {
    state = null;
    checkBOM = true;
    crlfCheck = false;
    eventEndCheck = false;
    buffer = null;
    pos = 0;
    event = {
      data: undefined,
      event: undefined,
      id: undefined,
      retry: undefined
    };
    constructor(options = {}) {
      options.readableObjectMode = true;
      super(options);
      this.state = options.eventSourceSettings || {};
      if (options.push) {
        this.push = options.push;
      }
    }
    _transform(chunk, _encoding, callback) {
      if (chunk.length === 0) {
        callback();
        return;
      }
      if (this.buffer) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
      } else {
        this.buffer = chunk;
      }
      if (this.checkBOM) {
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = false;
            callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0);
              this.checkBOM = false;
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          default:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = this.buffer.subarray(3);
            }
            this.checkBOM = false;
            break;
        }
      }
      while (this.pos < this.buffer.length) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === LF) {
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              this.crlfCheck = false;
              continue;
            }
            this.crlfCheck = false;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            if (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {
              this.processEvent(this.event);
            }
            this.clearEvent();
            continue;
          }
          this.eventEndCheck = false;
          continue;
        }
        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true;
          }
          this.parseLine(this.buffer.subarray(0, this.pos), this.event);
          this.buffer = this.buffer.subarray(this.pos + 1);
          this.pos = 0;
          this.eventEndCheck = true;
          continue;
        }
        this.pos++;
      }
      callback();
    }
    parseLine(line, event) {
      if (line.length === 0) {
        return;
      }
      const colonPosition = line.indexOf(COLON);
      if (colonPosition === 0) {
        return;
      }
      let field = "";
      let value = "";
      if (colonPosition !== -1) {
        field = line.subarray(0, colonPosition).toString("utf8");
        let valueStart = colonPosition + 1;
        if (line[valueStart] === SPACE) {
          ++valueStart;
        }
        value = line.subarray(valueStart).toString("utf8");
      } else {
        field = line.toString("utf8");
        value = "";
      }
      switch (field) {
        case "data":
          if (event[field] === undefined) {
            event[field] = value;
          } else {
            event[field] += `
${value}`;
          }
          break;
        case "retry":
          if (isASCIINumber(value)) {
            event[field] = value;
          }
          break;
        case "id":
          if (isValidLastEventId(value)) {
            event[field] = value;
          }
          break;
        case "event":
          if (value.length > 0) {
            event[field] = value;
          }
          break;
      }
    }
    processEvent(event) {
      if (event.retry && isASCIINumber(event.retry)) {
        this.state.reconnectionTime = parseInt(event.retry, 10);
      }
      if (event.id && isValidLastEventId(event.id)) {
        this.state.lastEventId = event.id;
      }
      if (event.data !== undefined) {
        this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
    }
    clearEvent() {
      this.event = {
        data: undefined,
        event: undefined,
        id: undefined,
        retry: undefined
      };
    }
  }
  module.exports = {
    EventSourceStream
  };
});

// node_modules/undici/lib/web/eventsource/eventsource.js
var require_eventsource = __commonJS((exports, module) => {
  var { pipeline } = __require("node:stream");
  var { fetching } = require_fetch();
  var { makeRequest } = require_request2();
  var { webidl } = require_webidl();
  var { EventSourceStream } = require_eventsource_stream();
  var { parseMIMEType } = require_data_url();
  var { createFastMessageEvent } = require_events();
  var { isNetworkError } = require_response();
  var { delay } = require_util8();
  var { kEnumerableProperty } = require_util();
  var { environmentSettingsObject } = require_util2();
  var experimentalWarned = false;
  var defaultReconnectionTime = 3000;
  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSED = 2;
  var ANONYMOUS = "anonymous";
  var USE_CREDENTIALS = "use-credentials";

  class EventSource extends EventTarget {
    #events = {
      open: null,
      error: null,
      message: null
    };
    #url = null;
    #withCredentials = false;
    #readyState = CONNECTING;
    #request = null;
    #controller = null;
    #dispatcher;
    #state;
    constructor(url, eventSourceInitDict = {}) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "EventSource constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        });
      }
      url = webidl.converters.USVString(url, prefix, "url");
      eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
      this.#dispatcher = eventSourceInitDict.dispatcher;
      this.#state = {
        lastEventId: "",
        reconnectionTime: defaultReconnectionTime
      };
      const settings = environmentSettingsObject;
      let urlRecord;
      try {
        urlRecord = new URL(url, settings.settingsObject.baseUrl);
        this.#state.origin = urlRecord.origin;
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      this.#url = urlRecord.href;
      let corsAttributeState = ANONYMOUS;
      if (eventSourceInitDict.withCredentials) {
        corsAttributeState = USE_CREDENTIALS;
        this.#withCredentials = true;
      }
      const initRequest = {
        redirect: "follow",
        keepalive: true,
        mode: "cors",
        credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      initRequest.client = environmentSettingsObject.settingsObject;
      initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
      initRequest.cache = "no-store";
      initRequest.initiator = "other";
      initRequest.urlList = [new URL(this.#url)];
      this.#request = makeRequest(initRequest);
      this.#connect();
    }
    get readyState() {
      return this.#readyState;
    }
    get url() {
      return this.#url;
    }
    get withCredentials() {
      return this.#withCredentials;
    }
    #connect() {
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CONNECTING;
      const fetchParams = {
        request: this.#request,
        dispatcher: this.#dispatcher
      };
      const processEventSourceEndOfBody = (response) => {
        if (isNetworkError(response)) {
          this.dispatchEvent(new Event("error"));
          this.close();
        }
        this.#reconnect();
      };
      fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
      fetchParams.processResponse = (response) => {
        if (isNetworkError(response)) {
          if (response.aborted) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          } else {
            this.#reconnect();
            return;
          }
        }
        const contentType = response.headersList.get("content-type", true);
        const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
        const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
        if (response.status !== 200 || contentTypeValid === false) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        }
        this.#readyState = OPEN;
        this.dispatchEvent(new Event("open"));
        this.#state.origin = response.urlList[response.urlList.length - 1].origin;
        const eventSourceStream = new EventSourceStream({
          eventSourceSettings: this.#state,
          push: (event) => {
            this.dispatchEvent(createFastMessageEvent(event.type, event.options));
          }
        });
        pipeline(response.body.stream, eventSourceStream, (error) => {
          if (error?.aborted === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
          }
        });
      };
      this.#controller = fetching(fetchParams);
    }
    async#reconnect() {
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CONNECTING;
      this.dispatchEvent(new Event("error"));
      await delay(this.#state.reconnectionTime);
      if (this.#readyState !== CONNECTING)
        return;
      if (this.#state.lastEventId.length) {
        this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
      }
      this.#connect();
    }
    close() {
      webidl.brandCheck(this, EventSource);
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CLOSED;
      this.#controller.abort();
      this.#request = null;
    }
    get onopen() {
      return this.#events.open;
    }
    set onopen(fn) {
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onmessage() {
      return this.#events.message;
    }
    set onmessage(fn) {
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get onerror() {
      return this.#events.error;
    }
    set onerror(fn) {
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
  }
  var constantsPropertyDescriptors = {
    CONNECTING: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CONNECTING,
      writable: false
    },
    OPEN: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: OPEN,
      writable: false
    },
    CLOSED: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CLOSED,
      writable: false
    }
  };
  Object.defineProperties(EventSource, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, {
    close: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    onopen: kEnumerableProperty,
    readyState: kEnumerableProperty,
    url: kEnumerableProperty,
    withCredentials: kEnumerableProperty
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
    {
      key: "withCredentials",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    EventSource,
    defaultReconnectionTime
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  var Client = require_client();
  var Dispatcher = require_dispatcher();
  var Pool = require_pool();
  var BalancedPool = require_balanced_pool();
  var Agent = require_agent();
  var ProxyAgent = require_proxy_agent();
  var EnvHttpProxyAgent = require_env_http_proxy_agent();
  var RetryAgent = require_retry_agent();
  var errors = require_errors();
  var util = require_util();
  var { InvalidArgumentError } = errors;
  var api = require_api();
  var buildConnector = require_connect();
  var MockClient = require_mock_client();
  var MockAgent = require_mock_agent();
  var MockPool = require_mock_pool();
  var mockErrors = require_mock_errors();
  var RetryHandler = require_retry_handler();
  var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
  var DecoratorHandler = require_decorator_handler();
  var RedirectHandler = require_redirect_handler();
  var createRedirectInterceptor = require_redirect_interceptor();
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
  exports.RetryAgent = RetryAgent;
  exports.RetryHandler = RetryHandler;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.interceptors = {
    redirect: require_redirect(),
    retry: require_retry(),
    dump: require_dump(),
    dns: require_dns()
  };
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  exports.util = {
    parseHeaders: util.parseHeaders,
    headerNameToString: util.headerNameToString
  };
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path = opts.path;
        if (!opts.path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util.parseURL(url);
      }
      const { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  var fetchImpl = require_fetch().fetch;
  exports.fetch = async function fetch(init, options = undefined) {
    try {
      return await fetchImpl(init, options);
    } catch (err) {
      if (err && typeof err === "object") {
        Error.captureStackTrace(err);
      }
      throw err;
    }
  };
  exports.Headers = require_headers().Headers;
  exports.Response = require_response().Response;
  exports.Request = require_request2().Request;
  exports.FormData = require_formdata().FormData;
  exports.File = globalThis.File ?? __require("node:buffer").File;
  exports.FileReader = require_filereader().FileReader;
  var { setGlobalOrigin, getGlobalOrigin } = require_global();
  exports.setGlobalOrigin = setGlobalOrigin;
  exports.getGlobalOrigin = getGlobalOrigin;
  var { CacheStorage } = require_cachestorage();
  var { kConstruct } = require_symbols4();
  exports.caches = new CacheStorage(kConstruct);
  var { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
  exports.deleteCookie = deleteCookie;
  exports.getCookies = getCookies;
  exports.getSetCookies = getSetCookies;
  exports.setCookie = setCookie;
  var { parseMIMEType, serializeAMimeType } = require_data_url();
  exports.parseMIMEType = parseMIMEType;
  exports.serializeAMimeType = serializeAMimeType;
  var { CloseEvent, ErrorEvent, MessageEvent } = require_events();
  exports.WebSocket = require_websocket().WebSocket;
  exports.CloseEvent = CloseEvent;
  exports.ErrorEvent = ErrorEvent;
  exports.MessageEvent = MessageEvent;
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
  var { EventSource } = require_eventsource();
  exports.EventSource = EventSource;
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpClient = exports.HttpClientResponse = exports.HttpClientError = exports.MediaTypes = exports.Headers = exports.HttpCodes = undefined;
  exports.getProxyUrl = getProxyUrl;
  exports.isHttps = isHttps;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var pm = __importStar(require_proxy());
  var tunnel = __importStar(require_tunnel());
  var undici_1 = require_undici();
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  var HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  var ExponentialBackoffCeiling = 10;
  var ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          });
          this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          const chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          });
          this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = this._getUserAgentWithOrchestrationId(userAgent);
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    getJson(requestUrl_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        const res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        const parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response;
        do {
          response = yield this.requestRaw(info, data);
          if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (const handler of this.handlers) {
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info, data);
            } else {
              return response;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            const parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (const header in headers) {
                if (header.toLowerCase() === "authorization") {
                  delete headers[header];
                }
              }
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers);
            response = yield this.requestRaw(info, data);
            redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
            return response;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    requestRaw(info, data) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err) {
              reject(err);
            } else if (!res) {
              reject(new Error("Unknown error"));
            } else {
              resolve(res);
            }
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers) {
          info.options.headers = {};
        }
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      function handleResult(err, res) {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      }
      const req = info.httpModule.request(info.options, (msg) => {
        const res = new HttpClientResponse(msg);
        handleResult(undefined, res);
      });
      let socket;
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 60000, () => {
        if (socket) {
          socket.end();
        }
        handleResult(new Error(`Request timeout: ${info.options.path}`));
      });
      req.on("error", function(err) {
        handleResult(err);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    getAgent(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (!useProxy) {
        return;
      }
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      const info = {};
      info.parsedUrl = requestUrl;
      const usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info.options = {};
      info.options.host = info.parsedUrl.hostname;
      info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
      info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
      info.options.method = method;
      info.options.headers = this._mergeHeaders(headers);
      if (this.userAgent != null) {
        info.options.headers["user-agent"] = this.userAgent;
      }
      info.options.agent = this._getAgent(info.parsedUrl);
      if (this.handlers) {
        for (const handler of this.handlers) {
          handler.prepareRequest(info.options);
        }
      }
      return info;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      }
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        const headerValue = lowercaseKeys(this.requestOptions.headers)[header];
        if (headerValue) {
          clientHeader = typeof headerValue === "number" ? headerValue.toString() : headerValue;
        }
      }
      const additionalValue = additionalHeaders[header];
      if (additionalValue !== undefined) {
        return typeof additionalValue === "number" ? additionalValue.toString() : additionalValue;
      }
      if (clientHeader !== undefined) {
        return clientHeader;
      }
      return _default;
    }
    _getExistingOrDefaultContentTypeHeader(additionalHeaders, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        const headerValue = lowercaseKeys(this.requestOptions.headers)[Headers.ContentType];
        if (headerValue) {
          if (typeof headerValue === "number") {
            clientHeader = String(headerValue);
          } else if (Array.isArray(headerValue)) {
            clientHeader = headerValue.join(", ");
          } else {
            clientHeader = headerValue;
          }
        }
      }
      const additionalValue = additionalHeaders[Headers.ContentType];
      if (additionalValue !== undefined) {
        if (typeof additionalValue === "number") {
          return String(additionalValue);
        } else if (Array.isArray(additionalValue)) {
          return additionalValue.join(", ");
        } else {
          return additionalValue;
        }
      }
      if (clientHeader !== undefined) {
        return clientHeader;
      }
      return _default;
    }
    _getAgent(parsedUrl) {
      let agent;
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent = this._proxyAgent;
      }
      if (!useProxy) {
        agent = this._agent;
      }
      if (agent) {
        return agent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (proxyUrl && proxyUrl.hostname) {
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        }
        agent = tunnelAgent(agentOptions);
        this._proxyAgent = agent;
      }
      if (!agent) {
        const options = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
        this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError) {
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive) {
        proxyAgent = this._proxyAgentDispatcher;
      }
      if (proxyAgent) {
        return proxyAgent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      }));
      this._proxyAgentDispatcher = proxyAgent;
      if (usingSsl && this._ignoreSslError) {
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: false
        });
      }
      return proxyAgent;
    }
    _getUserAgentWithOrchestrationId(userAgent) {
      const baseUserAgent = userAgent || "actions/http-client";
      const orchId = process.env["ACTIONS_ORCHESTRATION_ID"];
      if (orchId) {
        const sanitizedId = orchId.replace(/[^a-z0-9_.-]/gi, "_");
        return `${baseUserAgent} actions_orchestration_id/${sanitizedId}`;
      }
      return baseUserAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, undefined, undefined, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
          const statusCode = res.message.statusCode || 0;
          const response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound) {
            resolve(response);
          }
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              const a = new Date(value);
              if (!isNaN(a.valueOf())) {
                return a;
              }
            }
            return value;
          }
          let obj;
          let contents;
          try {
            contents = yield res.readBody();
            if (contents && contents.length > 0) {
              if (options && options.deserializeDates) {
                obj = JSON.parse(contents, dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {}
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = `Failed request: (${statusCode})`;
            }
            const err = new HttpClientError(msg, statusCode);
            err.result = response.result;
            reject(err);
          } else {
            resolve(response);
          }
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = undefined;

  class BasicCredentialHandler {
    constructor(username, password) {
      this.username = username;
      this.password = password;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BasicCredentialHandler = BasicCredentialHandler;

  class BearerCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Bearer ${this.token}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BearerCredentialHandler = BearerCredentialHandler;

  class PersonalAccessTokenCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OidcClient = undefined;
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var core_1 = require_core();

  class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
      const requestOptions = {
        allowRetries: allowRetry,
        maxRetries: maxRetry
      };
      return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
      const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
      if (!token) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      }
      return token;
    }
    static getIDTokenUrl() {
      const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
      if (!runtimeUrl) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      }
      return runtimeUrl;
    }
    static getCall(id_token_url) {
      return __awaiter(this, undefined, undefined, function* () {
        var _a;
        const httpclient = OidcClient.createHttpClient();
        const res = yield httpclient.getJson(id_token_url).catch((error) => {
          throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
        });
        const id_token = (_a = res.result) === null || _a === undefined ? undefined : _a.value;
        if (!id_token) {
          throw new Error("Response json body do not have ID Token field");
        }
        return id_token;
      });
    }
    static getIDToken(audience) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          let id_token_url = OidcClient.getIDTokenUrl();
          if (audience) {
            const encodedAudience = encodeURIComponent(audience);
            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
          }
          (0, core_1.debug)(`ID token url is ${id_token_url}`);
          const id_token = yield OidcClient.getCall(id_token_url);
          (0, core_1.setSecret)(id_token);
          return id_token;
        } catch (error) {
          throw new Error(`Error message: ${error.message}`);
        }
      });
    }
  }
  exports.OidcClient = OidcClient;
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = undefined;
  var os_1 = __require("os");
  var fs_1 = __require("fs");
  var { access, appendFile, writeFile } = fs_1.promises;
  exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
  exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";

  class Summary {
    constructor() {
      this._buffer = "";
    }
    filePath() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._filePath) {
          return this._filePath;
        }
        const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
        if (!pathFromEnv) {
          throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
        }
        try {
          yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
        } catch (_a) {
          throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
        }
        this._filePath = pathFromEnv;
        return this._filePath;
      });
    }
    wrap(tag, content, attrs = {}) {
      const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
      if (!content) {
        return `<${tag}${htmlAttrs}>`;
      }
      return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    write(options) {
      return __awaiter(this, undefined, undefined, function* () {
        const overwrite = !!(options === null || options === undefined ? undefined : options.overwrite);
        const filePath = yield this.filePath();
        const writeFunc = overwrite ? writeFile : appendFile;
        yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
        return this.emptyBuffer();
      });
    }
    clear() {
      return __awaiter(this, undefined, undefined, function* () {
        return this.emptyBuffer().write({ overwrite: true });
      });
    }
    stringify() {
      return this._buffer;
    }
    isEmptyBuffer() {
      return this._buffer.length === 0;
    }
    emptyBuffer() {
      this._buffer = "";
      return this;
    }
    addRaw(text, addEOL = false) {
      this._buffer += text;
      return addEOL ? this.addEOL() : this;
    }
    addEOL() {
      return this.addRaw(os_1.EOL);
    }
    addCodeBlock(code, lang) {
      const attrs = Object.assign({}, lang && { lang });
      const element = this.wrap("pre", this.wrap("code", code), attrs);
      return this.addRaw(element).addEOL();
    }
    addList(items, ordered = false) {
      const tag = ordered ? "ol" : "ul";
      const listItems = items.map((item) => this.wrap("li", item)).join("");
      const element = this.wrap(tag, listItems);
      return this.addRaw(element).addEOL();
    }
    addTable(rows) {
      const tableBody = rows.map((row) => {
        const cells = row.map((cell) => {
          if (typeof cell === "string") {
            return this.wrap("td", cell);
          }
          const { header, data, colspan, rowspan } = cell;
          const tag = header ? "th" : "td";
          const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
          return this.wrap(tag, data, attrs);
        }).join("");
        return this.wrap("tr", cells);
      }).join("");
      const element = this.wrap("table", tableBody);
      return this.addRaw(element).addEOL();
    }
    addDetails(label, content) {
      const element = this.wrap("details", this.wrap("summary", label) + content);
      return this.addRaw(element).addEOL();
    }
    addImage(src, alt, options) {
      const { width, height } = options || {};
      const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
      const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
      return this.addRaw(element).addEOL();
    }
    addHeading(text, level) {
      const tag = `h${level}`;
      const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
      const element = this.wrap(allowedTag, text);
      return this.addRaw(element).addEOL();
    }
    addSeparator() {
      const element = this.wrap("hr", null);
      return this.addRaw(element).addEOL();
    }
    addBreak() {
      const element = this.wrap("br", null);
      return this.addRaw(element).addEOL();
    }
    addQuote(text, cite) {
      const attrs = Object.assign({}, cite && { cite });
      const element = this.wrap("blockquote", text, attrs);
      return this.addRaw(element).addEOL();
    }
    addLink(text, href) {
      const element = this.wrap("a", text, { href });
      return this.addRaw(element).addEOL();
    }
  }
  var _summary = new Summary;
  exports.markdownSummary = _summary;
  exports.summary = _summary;
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toPosixPath = toPosixPath;
  exports.toWin32Path = toWin32Path;
  exports.toPlatformPath = toPlatformPath;
  var path = __importStar(__require("path"));
  function toPosixPath(pth) {
    return pth.replace(/[\\]/g, "/");
  }
  function toWin32Path(pth) {
    return pth.replace(/[/]/g, "\\");
  }
  function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
  }
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = undefined;
  exports.readlink = readlink;
  exports.exists = exists;
  exports.isDirectory = isDirectory;
  exports.isRooted = isRooted;
  exports.tryGetExecutablePath = tryGetExecutablePath;
  exports.getCmdPath = getCmdPath;
  var fs = __importStar(__require("fs"));
  var path = __importStar(__require("path"));
  _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
  exports.IS_WINDOWS = process.platform === "win32";
  function readlink(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      const result = yield fs.promises.readlink(fsPath);
      if (exports.IS_WINDOWS && !result.endsWith("\\")) {
        return `${result}\\`;
      }
      return result;
    });
  }
  exports.UV_FS_O_EXLOCK = 268435456;
  exports.READONLY = fs.constants.O_RDONLY;
  function exists(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      try {
        yield (0, exports.stat)(fsPath);
      } catch (err) {
        if (err.code === "ENOENT") {
          return false;
        }
        throw err;
      }
      return true;
    });
  }
  function isDirectory(fsPath_1) {
    return __awaiter(this, arguments, undefined, function* (fsPath, useStat = false) {
      const stats = useStat ? yield (0, exports.stat)(fsPath) : yield (0, exports.lstat)(fsPath);
      return stats.isDirectory();
    });
  }
  function isRooted(p) {
    p = normalizeSeparators(p);
    if (!p) {
      throw new Error('isRooted() parameter "p" cannot be empty');
    }
    if (exports.IS_WINDOWS) {
      return p.startsWith("\\") || /^[A-Z]:/i.test(p);
    }
    return p.startsWith("/");
  }
  function tryGetExecutablePath(filePath, extensions) {
    return __awaiter(this, undefined, undefined, function* () {
      let stats = undefined;
      try {
        stats = yield (0, exports.stat)(filePath);
      } catch (err) {
        if (err.code !== "ENOENT") {
          console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
      }
      if (stats && stats.isFile()) {
        if (exports.IS_WINDOWS) {
          const upperExt = path.extname(filePath).toUpperCase();
          if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
            return filePath;
          }
        } else {
          if (isUnixExecutable(stats)) {
            return filePath;
          }
        }
      }
      const originalFilePath = filePath;
      for (const extension of extensions) {
        filePath = originalFilePath + extension;
        stats = undefined;
        try {
          stats = yield (0, exports.stat)(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            try {
              const directory = path.dirname(filePath);
              const upperName = path.basename(filePath).toUpperCase();
              for (const actualName of yield (0, exports.readdir)(directory)) {
                if (upperName === actualName.toUpperCase()) {
                  filePath = path.join(directory, actualName);
                  break;
                }
              }
            } catch (err) {
              console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
            }
            return filePath;
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
      }
      return "";
    });
  }
  function normalizeSeparators(p) {
    p = p || "";
    if (exports.IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      return p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  function isUnixExecutable(stats) {
    return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && process.getgid !== undefined && stats.gid === process.getgid() || (stats.mode & 64) > 0 && process.getuid !== undefined && stats.uid === process.getuid();
  }
  function getCmdPath() {
    var _a2;
    return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== undefined ? _a2 : `cmd.exe`;
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cp = cp;
  exports.mv = mv;
  exports.rmRF = rmRF;
  exports.mkdirP = mkdirP;
  exports.which = which;
  exports.findInPath = findInPath;
  var assert_1 = __require("assert");
  var path = __importStar(__require("path"));
  var ioUtil = __importStar(require_io_util());
  function cp(source_1, dest_1) {
    return __awaiter(this, arguments, undefined, function* (source, dest, options = {}) {
      const { force, recursive, copySourceDirectory } = readCopyOptions(options);
      const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
      if (destStat && destStat.isFile() && !force) {
        return;
      }
      const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
      if (!(yield ioUtil.exists(source))) {
        throw new Error(`no such file or directory: ${source}`);
      }
      const sourceStat = yield ioUtil.stat(source);
      if (sourceStat.isDirectory()) {
        if (!recursive) {
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        } else {
          yield cpDirRecursive(source, newDest, 0, force);
        }
      } else {
        if (path.relative(source, newDest) === "") {
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        }
        yield copyFile(source, newDest, force);
      }
    });
  }
  function mv(source_1, dest_1) {
    return __awaiter(this, arguments, undefined, function* (source, dest, options = {}) {
      if (yield ioUtil.exists(dest)) {
        let destExists = true;
        if (yield ioUtil.isDirectory(dest)) {
          dest = path.join(dest, path.basename(source));
          destExists = yield ioUtil.exists(dest);
        }
        if (destExists) {
          if (options.force == null || options.force) {
            yield rmRF(dest);
          } else {
            throw new Error("Destination already exists");
          }
        }
      }
      yield mkdirP(path.dirname(dest));
      yield ioUtil.rename(source, dest);
    });
  }
  function rmRF(inputPath) {
    return __awaiter(this, undefined, undefined, function* () {
      if (ioUtil.IS_WINDOWS) {
        if (/[*"<>|]/.test(inputPath)) {
          throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
        }
      }
      try {
        yield ioUtil.rm(inputPath, {
          force: true,
          maxRetries: 3,
          recursive: true,
          retryDelay: 300
        });
      } catch (err) {
        throw new Error(`File was unable to be removed ${err}`);
      }
    });
  }
  function mkdirP(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      (0, assert_1.ok)(fsPath, "a path argument must be provided");
      yield ioUtil.mkdir(fsPath, { recursive: true });
    });
  }
  function which(tool, check) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      if (check) {
        const result = yield which(tool, false);
        if (!result) {
          if (ioUtil.IS_WINDOWS) {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          } else {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          }
        }
        return result;
      }
      const matches = yield findInPath(tool);
      if (matches && matches.length > 0) {
        return matches[0];
      }
      return "";
    });
  }
  function findInPath(tool) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      const extensions = [];
      if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
        for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
          if (extension) {
            extensions.push(extension);
          }
        }
      }
      if (ioUtil.isRooted(tool)) {
        const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
        if (filePath) {
          return [filePath];
        }
        return [];
      }
      if (tool.includes(path.sep)) {
        return [];
      }
      const directories = [];
      if (process.env.PATH) {
        for (const p of process.env.PATH.split(path.delimiter)) {
          if (p) {
            directories.push(p);
          }
        }
      }
      const matches = [];
      for (const directory of directories) {
        const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
        if (filePath) {
          matches.push(filePath);
        }
      }
      return matches;
    });
  }
  function readCopyOptions(options) {
    const force = options.force == null ? true : options.force;
    const recursive = Boolean(options.recursive);
    const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++;
      yield mkdirP(destDir);
      const files = yield ioUtil.readdir(sourceDir);
      for (const fileName of files) {
        const srcFile = `${sourceDir}/${fileName}`;
        const destFile = `${destDir}/${fileName}`;
        const srcFileStat = yield ioUtil.lstat(srcFile);
        if (srcFileStat.isDirectory()) {
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        } else {
          yield copyFile(srcFile, destFile, force);
        }
      }
      yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil.lstat(destFile);
          yield ioUtil.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM") {
            yield ioUtil.chmod(destFile, "0666");
            yield ioUtil.unlink(destFile);
          }
        }
        const symlinkFull = yield ioUtil.readlink(srcFile);
        yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil.exists(destFile)) || force) {
        yield ioUtil.copyFile(srcFile, destFile);
      }
    });
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ToolRunner = undefined;
  exports.argStringToArray = argStringToArray;
  var os = __importStar(__require("os"));
  var events = __importStar(__require("events"));
  var child = __importStar(__require("child_process"));
  var path = __importStar(__require("path"));
  var io = __importStar(require_io());
  var ioUtil = __importStar(require_io_util());
  var timers_1 = __require("timers");
  var IS_WINDOWS = process.platform === "win32";

  class ToolRunner extends events.EventEmitter {
    constructor(toolPath, args, options) {
      super();
      if (!toolPath) {
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      }
      this.toolPath = toolPath;
      this.args = args || [];
      this.options = options || {};
    }
    _debug(message) {
      if (this.options.listeners && this.options.listeners.debug) {
        this.options.listeners.debug(message);
      }
    }
    _getCommandString(options, noPrefix) {
      const toolPath = this._getSpawnFileName();
      const args = this._getSpawnArgs(options);
      let cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else if (options.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (const a of args) {
            cmd += ` ${this._windowsQuoteCmdArg(a)}`;
          }
        }
      } else {
        cmd += toolPath;
        for (const a of args) {
          cmd += ` ${a}`;
        }
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString();
        let n = s.indexOf(os.EOL);
        while (n > -1) {
          const line = s.substring(0, n);
          onLine(line);
          s = s.substring(n + os.EOL.length);
          n = s.indexOf(os.EOL);
        }
        return s;
      } catch (err) {
        this._debug(`error processing line. Failed with error ${err}`);
        return "";
      }
    }
    _getSpawnFileName() {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          return process.env["COMSPEC"] || "cmd.exe";
        }
      }
      return this.toolPath;
    }
    _getSpawnArgs(options) {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (const a of this.args) {
            argline += " ";
            argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
          }
          argline += '"';
          return [argline];
        }
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      const upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile()) {
        return this._uvQuoteCmdArg(arg);
      }
      if (!arg) {
        return '""';
      }
      const cmdSpecialChars = [
        " ",
        "\t",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ];
      let needsQuotes = false;
      for (const char of arg) {
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = true;
          break;
        }
      }
      if (!needsQuotes) {
        return arg;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length;i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += '"';
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg) {
        return '""';
      }
      if (!arg.includes(" ") && !arg.includes("\t") && !arg.includes('"')) {
        return arg;
      }
      if (!arg.includes('"') && !arg.includes("\\")) {
        return `"${arg}"`;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length;i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += "\\";
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options) {
      options = options || {};
      const result = {
        cwd: options.cwd || process.cwd(),
        env: options.env || process.env,
        silent: options.silent || false,
        windowsVerbatimArguments: options.windowsVerbatimArguments || false,
        failOnStdErr: options.failOnStdErr || false,
        ignoreReturnCode: options.ignoreReturnCode || false,
        delay: options.delay || 1e4
      };
      result.outStream = options.outStream || process.stdout;
      result.errStream = options.errStream || process.stderr;
      return result;
    }
    _getSpawnOptions(options, toolPath) {
      options = options || {};
      const result = {};
      result.cwd = options.cwd;
      result.env = options.env;
      result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
      if (options.windowsVerbatimArguments) {
        result.argv0 = `"${toolPath}"`;
      }
      return result;
    }
    exec() {
      return __awaiter(this, undefined, undefined, function* () {
        if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
          this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
        }
        this.toolPath = yield io.which(this.toolPath, true);
        return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
          this._debug(`exec tool: ${this.toolPath}`);
          this._debug("arguments:");
          for (const arg of this.args) {
            this._debug(`   ${arg}`);
          }
          const optionsNonNull = this._cloneExecOptions(this.options);
          if (!optionsNonNull.silent && optionsNonNull.outStream) {
            optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
          }
          const state = new ExecState(optionsNonNull, this.toolPath);
          state.on("debug", (message) => {
            this._debug(message);
          });
          if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
            return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
          }
          const fileName = this._getSpawnFileName();
          const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
          let stdbuffer = "";
          if (cp.stdout) {
            cp.stdout.on("data", (data) => {
              if (this.options.listeners && this.options.listeners.stdout) {
                this.options.listeners.stdout(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.outStream) {
                optionsNonNull.outStream.write(data);
              }
              stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.stdline) {
                  this.options.listeners.stdline(line);
                }
              });
            });
          }
          let errbuffer = "";
          if (cp.stderr) {
            cp.stderr.on("data", (data) => {
              state.processStderr = true;
              if (this.options.listeners && this.options.listeners.stderr) {
                this.options.listeners.stderr(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                s.write(data);
              }
              errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.errline) {
                  this.options.listeners.errline(line);
                }
              });
            });
          }
          cp.on("error", (err) => {
            state.processError = err.message;
            state.processExited = true;
            state.processClosed = true;
            state.CheckComplete();
          });
          cp.on("exit", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          cp.on("close", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            state.processClosed = true;
            this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          state.on("done", (error, exitCode) => {
            if (stdbuffer.length > 0) {
              this.emit("stdline", stdbuffer);
            }
            if (errbuffer.length > 0) {
              this.emit("errline", errbuffer);
            }
            cp.removeAllListeners();
            if (error) {
              reject(error);
            } else {
              resolve(exitCode);
            }
          });
          if (this.options.input) {
            if (!cp.stdin) {
              throw new Error("child process missing stdin");
            }
            cp.stdin.end(this.options.input);
          }
        }));
      });
    }
  }
  exports.ToolRunner = ToolRunner;
  function argStringToArray(argString) {
    const args = [];
    let inQuotes = false;
    let escaped = false;
    let arg = "";
    function append(c) {
      if (escaped && c !== '"') {
        arg += "\\";
      }
      arg += c;
      escaped = false;
    }
    for (let i = 0;i < argString.length; i++) {
      const c = argString.charAt(i);
      if (c === '"') {
        if (!escaped) {
          inQuotes = !inQuotes;
        } else {
          append(c);
        }
        continue;
      }
      if (c === "\\" && escaped) {
        append(c);
        continue;
      }
      if (c === "\\" && inQuotes) {
        escaped = true;
        continue;
      }
      if (c === " " && !inQuotes) {
        if (arg.length > 0) {
          args.push(arg);
          arg = "";
        }
        continue;
      }
      append(c);
    }
    if (arg.length > 0) {
      args.push(arg.trim());
    }
    return args;
  }

  class ExecState extends events.EventEmitter {
    constructor(options, toolPath) {
      super();
      this.processClosed = false;
      this.processError = "";
      this.processExitCode = 0;
      this.processExited = false;
      this.processStderr = false;
      this.delay = 1e4;
      this.done = false;
      this.timeout = null;
      if (!toolPath) {
        throw new Error("toolPath must not be empty");
      }
      this.options = options;
      this.toolPath = toolPath;
      if (options.delay) {
        this.delay = options.delay;
      }
    }
    CheckComplete() {
      if (this.done) {
        return;
      }
      if (this.processClosed) {
        this._setResult();
      } else if (this.processExited) {
        this.timeout = (0, timers_1.setTimeout)(ExecState.HandleTimeout, this.delay, this);
      }
    }
    _debug(message) {
      this.emit("debug", message);
    }
    _setResult() {
      let error;
      if (this.processExited) {
        if (this.processError) {
          error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
        } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
          error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
        } else if (this.processStderr && this.options.failOnStdErr) {
          error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
        }
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      this.done = true;
      this.emit("done", error, this.processExitCode);
    }
    static HandleTimeout(state) {
      if (state.done) {
        return;
      }
      if (!state.processClosed && state.processExited) {
        const message = `The STDIO streams did not close within ${state.delay / 1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        state._debug(message);
      }
      state._setResult();
    }
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exec = exec;
  exports.getExecOutput = getExecOutput;
  var string_decoder_1 = __require("string_decoder");
  var tr = __importStar(require_toolrunner());
  function exec(commandLine, args, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0) {
        throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
      }
      const toolPath = commandArgs[0];
      args = commandArgs.slice(1).concat(args || []);
      const runner = new tr.ToolRunner(toolPath, args, options);
      return runner.exec();
    });
  }
  function getExecOutput(commandLine, args, options) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a, _b;
      let stdout = "";
      let stderr = "";
      const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
      const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
      const originalStdoutListener = (_a = options === null || options === undefined ? undefined : options.listeners) === null || _a === undefined ? undefined : _a.stdout;
      const originalStdErrListener = (_b = options === null || options === undefined ? undefined : options.listeners) === null || _b === undefined ? undefined : _b.stderr;
      const stdErrListener = (data) => {
        stderr += stderrDecoder.write(data);
        if (originalStdErrListener) {
          originalStdErrListener(data);
        }
      };
      const stdOutListener = (data) => {
        stdout += stdoutDecoder.write(data);
        if (originalStdoutListener) {
          originalStdoutListener(data);
        }
      };
      const listeners = Object.assign(Object.assign({}, options === null || options === undefined ? undefined : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
      const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
      stdout += stdoutDecoder.end();
      stderr += stderrDecoder.end();
      return {
        exitCode,
        stdout,
        stderr
      };
    });
  }
});

// node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = undefined;
  exports.getDetails = getDetails;
  var os_1 = __importDefault(__require("os"));
  var exec = __importStar(require_exec());
  var getWindowsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', undefined, {
      silent: true
    });
    const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', undefined, {
      silent: true
    });
    return {
      name: name.trim(),
      version: version.trim()
    };
  });
  var getMacOsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    var _a, _b, _c, _d;
    const { stdout } = yield exec.getExecOutput("sw_vers", undefined, {
      silent: true
    });
    const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === undefined ? undefined : _a[1]) !== null && _b !== undefined ? _b : "";
    const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === undefined ? undefined : _c[1]) !== null && _d !== undefined ? _d : "";
    return {
      name,
      version
    };
  });
  var getLinuxInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    const { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
      silent: true
    });
    const [name, version] = stdout.trim().split(`
`);
    return {
      name,
      version
    };
  });
  exports.platform = os_1.default.platform();
  exports.arch = os_1.default.arch();
  exports.isWindows = exports.platform === "win32";
  exports.isMacOS = exports.platform === "darwin";
  exports.isLinux = exports.platform === "linux";
  function getDetails() {
    return __awaiter(this, undefined, undefined, function* () {
      return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
        platform: exports.platform,
        arch: exports.arch,
        isWindows: exports.isWindows,
        isMacOS: exports.isMacOS,
        isLinux: exports.isLinux
      });
    });
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.ExitCode = undefined;
  exports.exportVariable = exportVariable;
  exports.setSecret = setSecret;
  exports.addPath = addPath;
  exports.getInput = getInput;
  exports.getMultilineInput = getMultilineInput;
  exports.getBooleanInput = getBooleanInput;
  exports.setOutput = setOutput;
  exports.setCommandEcho = setCommandEcho;
  exports.setFailed = setFailed;
  exports.isDebug = isDebug;
  exports.debug = debug;
  exports.error = error;
  exports.warning = warning;
  exports.notice = notice;
  exports.info = info;
  exports.startGroup = startGroup;
  exports.endGroup = endGroup;
  exports.group = group;
  exports.saveState = saveState;
  exports.getState = getState;
  exports.getIDToken = getIDToken;
  var command_1 = require_command();
  var file_command_1 = require_file_command();
  var utils_1 = require_utils();
  var os = __importStar(__require("os"));
  var path = __importStar(__require("path"));
  var oidc_utils_1 = require_oidc_utils();
  var ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2["Success"] = 0] = "Success";
    ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
  })(ExitCode || (exports.ExitCode = ExitCode = {}));
  function exportVariable(name, val) {
    const convertedVal = (0, utils_1.toCommandValue)(val);
    process.env[name] = convertedVal;
    const filePath = process.env["GITHUB_ENV"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
    }
    (0, command_1.issueCommand)("set-env", { name }, convertedVal);
  }
  function setSecret(secret) {
    (0, command_1.issueCommand)("add-mask", {}, secret);
  }
  function addPath(inputPath) {
    const filePath = process.env["GITHUB_PATH"] || "";
    if (filePath) {
      (0, file_command_1.issueFileCommand)("PATH", inputPath);
    } else {
      (0, command_1.issueCommand)("add-path", {}, inputPath);
    }
    process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
  }
  function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options && options.required && !val) {
      throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
      return val;
    }
    return val.trim();
  }
  function getMultilineInput(name, options) {
    const inputs = getInput(name, options).split(`
`).filter((x) => x !== "");
    if (options && options.trimWhitespace === false) {
      return inputs;
    }
    return inputs.map((input) => input.trim());
  }
  function getBooleanInput(name, options) {
    const trueValue = ["true", "True", "TRUE"];
    const falseValue = ["false", "False", "FALSE"];
    const val = getInput(name, options);
    if (trueValue.includes(val))
      return true;
    if (falseValue.includes(val))
      return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
` + `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
  }
  function setOutput(name, value) {
    const filePath = process.env["GITHUB_OUTPUT"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
    }
    process.stdout.write(os.EOL);
    (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
  }
  function setCommandEcho(enabled) {
    (0, command_1.issue)("echo", enabled ? "on" : "off");
  }
  function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
  }
  function isDebug() {
    return process.env["RUNNER_DEBUG"] === "1";
  }
  function debug(message) {
    (0, command_1.issueCommand)("debug", {}, message);
  }
  function error(message, properties = {}) {
    (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function warning(message, properties = {}) {
    (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function notice(message, properties = {}) {
    (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function info(message) {
    process.stdout.write(message + os.EOL);
  }
  function startGroup(name) {
    (0, command_1.issue)("group", name);
  }
  function endGroup() {
    (0, command_1.issue)("endgroup");
  }
  function group(name, fn) {
    return __awaiter(this, undefined, undefined, function* () {
      startGroup(name);
      let result;
      try {
        result = yield fn();
      } finally {
        endGroup();
      }
      return result;
    });
  }
  function saveState(name, value) {
    const filePath = process.env["GITHUB_STATE"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
    }
    (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
  }
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  function getIDToken(aud) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
  }
  var summary_1 = require_summary();
  Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
    return summary_1.summary;
  } });
  var summary_2 = require_summary();
  Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
    return summary_2.markdownSummary;
  } });
  var path_utils_1 = require_path_utils();
  Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
    return path_utils_1.toPosixPath;
  } });
  Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
    return path_utils_1.toWin32Path;
  } });
  Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
    return path_utils_1.toPlatformPath;
  } });
  exports.platform = __importStar(require_platform());
});

// node_modules/@actions/artifact/lib/internal/shared/config.js
var require_config = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUploadChunkSize = getUploadChunkSize;
  exports.getRuntimeToken = getRuntimeToken;
  exports.getResultsServiceUrl = getResultsServiceUrl;
  exports.isGhes = isGhes;
  exports.getGitHubWorkspaceDir = getGitHubWorkspaceDir;
  exports.getConcurrency = getConcurrency;
  exports.getUploadChunkTimeout = getUploadChunkTimeout;
  exports.getMaxArtifactListCount = getMaxArtifactListCount;
  var os_1 = __importDefault(__require("os"));
  var core_1 = require_core();
  function getUploadChunkSize() {
    return 8 * 1024 * 1024;
  }
  function getRuntimeToken() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"];
    if (!token) {
      throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
    }
    return token;
  }
  function getResultsServiceUrl() {
    const resultsUrl = process.env["ACTIONS_RESULTS_URL"];
    if (!resultsUrl) {
      throw new Error("Unable to get the ACTIONS_RESULTS_URL env variable");
    }
    return new URL(resultsUrl).origin;
  }
  function isGhes() {
    const ghUrl = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com");
    const hostname = ghUrl.hostname.trimEnd().toUpperCase();
    const isGitHubHost = hostname === "GITHUB.COM";
    const isGheHost = hostname.endsWith(".GHE.COM");
    const isLocalHost = hostname.endsWith(".LOCALHOST");
    return !isGitHubHost && !isGheHost && !isLocalHost;
  }
  function getGitHubWorkspaceDir() {
    const ghWorkspaceDir = process.env["GITHUB_WORKSPACE"];
    if (!ghWorkspaceDir) {
      throw new Error("Unable to get the GITHUB_WORKSPACE env variable");
    }
    return ghWorkspaceDir;
  }
  function getConcurrency() {
    const numCPUs = os_1.default.cpus().length;
    let concurrencyCap = 32;
    if (numCPUs > 4) {
      const concurrency = 16 * numCPUs;
      concurrencyCap = concurrency > 300 ? 300 : concurrency;
    }
    const concurrencyOverride = process.env["ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY"];
    if (concurrencyOverride) {
      const concurrency = parseInt(concurrencyOverride);
      if (isNaN(concurrency) || concurrency < 1) {
        throw new Error("Invalid value set for ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY env variable");
      }
      if (concurrency < concurrencyCap) {
        (0, core_1.info)(`Set concurrency based on the value set in ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY.`);
        return concurrency;
      }
      (0, core_1.info)(`ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY is higher than the cap of ${concurrencyCap} based on the number of cpus. Set it to the maximum value allowed.`);
      return concurrencyCap;
    }
    return 5;
  }
  function getUploadChunkTimeout() {
    const timeoutVar = process.env["ACTIONS_ARTIFACT_UPLOAD_TIMEOUT_MS"];
    if (!timeoutVar) {
      return 300000;
    }
    const timeout = parseInt(timeoutVar);
    if (isNaN(timeout)) {
      throw new Error("Invalid value set for ACTIONS_ARTIFACT_UPLOAD_TIMEOUT_MS env variable");
    }
    return timeout;
  }
  function getMaxArtifactListCount() {
    const maxCountVar = process.env["ACTIONS_ARTIFACT_MAX_ARTIFACT_COUNT"] || "1000";
    const maxCount = parseInt(maxCountVar);
    if (isNaN(maxCount) || maxCount < 1) {
      throw new Error("Invalid value set for ACTIONS_ARTIFACT_MAX_ARTIFACT_COUNT env variable");
    }
    return maxCount;
  }
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-typings.js
var require_json_typings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isJsonObject = exports.typeofJsonValue = undefined;
  function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
      if (Array.isArray(value))
        return "array";
      if (value === null)
        return "null";
    }
    return t;
  }
  exports.typeofJsonValue = typeofJsonValue;
  function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
  }
  exports.isJsonObject = isJsonObject;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/base64.js
var require_base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.base64encode = exports.base64decode = undefined;
  var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  var decTable = [];
  for (let i = 0;i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
  decTable[45] = encTable.indexOf("+");
  decTable[95] = encTable.indexOf("/");
  function base64decode(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (let i = 0;i < base64Str.length; i++) {
      b = decTable[base64Str.charCodeAt(i)];
      if (b === undefined) {
        switch (base64Str[i]) {
          case "=":
            groupPos = 0;
          case `
`:
          case "\r":
          case "\t":
          case " ":
            continue;
          default:
            throw Error(`invalid base64 string.`);
        }
      }
      switch (groupPos) {
        case 0:
          p = b;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p << 2 | (b & 48) >> 4;
          p = b;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
          p = b;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
  }
  exports.base64decode = base64decode;
  function base64encode(bytes) {
    let base64 = "", groupPos = 0, b, p = 0;
    for (let i = 0;i < bytes.length; i++) {
      b = bytes[i];
      switch (groupPos) {
        case 0:
          base64 += encTable[b >> 2];
          p = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p | b >> 4];
          p = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p | b >> 6];
          base64 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p];
      base64 += "=";
      if (groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
  exports.base64encode = base64encode;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/protobufjs-utf8.js
var require_protobufjs_utf8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.utf8read = undefined;
  var fromCharCodes = (chunk) => String.fromCharCode.apply(String, chunk);
  function utf8read(bytes) {
    if (bytes.length < 1)
      return "";
    let pos = 0, parts = [], chunk = [], i = 0, t;
    let len = bytes.length;
    while (pos < len) {
      t = bytes[pos++];
      if (t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | bytes[pos++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else
        chunk[i++] = (t & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
      if (i > 8191) {
        parts.push(fromCharCodes(chunk));
        i = 0;
      }
    }
    if (parts.length) {
      if (i)
        parts.push(fromCharCodes(chunk.slice(0, i)));
      return parts.join("");
    }
    return fromCharCodes(chunk.slice(0, i));
  }
  exports.utf8read = utf8read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-format-contract.js
var require_binary_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WireType = exports.mergeBinaryOptions = exports.UnknownFieldHandler = undefined;
  var UnknownFieldHandler;
  (function(UnknownFieldHandler2) {
    UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
    UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
      let container = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
      container.push({ no: fieldNo, wireType, data });
    };
    UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
      for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
        writer.tag(no, wireType).raw(data);
    };
    UnknownFieldHandler2.list = (message, fieldNo) => {
      if (is(message)) {
        let all = message[UnknownFieldHandler2.symbol];
        return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
      }
      return [];
    };
    UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
  })(UnknownFieldHandler = exports.UnknownFieldHandler || (exports.UnknownFieldHandler = {}));
  function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
  }
  exports.mergeBinaryOptions = mergeBinaryOptions;
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType = exports.WireType || (exports.WireType = {}));
});

// node_modules/@protobuf-ts/runtime/build/commonjs/goog-varint.js
var require_goog_varint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.varint32read = exports.varint32write = exports.int64toString = exports.int64fromString = exports.varint64write = exports.varint64read = undefined;
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0;shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3;shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  exports.varint64read = varint64read;
  function varint64write(lo, hi, bytes) {
    for (let i = 0;i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3;i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  exports.varint64write = varint64write;
  var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
  function int64fromString(dec) {
    let minus = dec[0] == "-";
    if (minus)
      dec = dec.slice(1);
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
  }
  exports.int64fromString = int64fromString;
  function int64toString(bitsLow, bitsHigh) {
    if (bitsHigh >>> 0 <= 2097151) {
      return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    let low = bitsLow & 16777215;
    let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
    let high = bitsHigh >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    let base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
      let partial = digit1e7 ? String(digit1e7) : "";
      if (needLeadingZeros) {
        return "0000000".slice(partial.length) + partial;
      }
      return partial;
    }
    return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
  }
  exports.int64toString = int64toString;
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0;i < 9; i++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  exports.varint32write = varint32write;
  function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 127;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 7;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 14;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 21;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 15) << 28;
    for (let readBytes = 5;(b & 128) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  exports.varint32read = varint32read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/pb-long.js
var require_pb_long = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PbLong = exports.PbULong = exports.detectBi = undefined;
  var goog_varint_1 = require_goog_varint();
  var BI;
  function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
    BI = ok ? {
      MIN: BigInt("-9223372036854775808"),
      MAX: BigInt("9223372036854775807"),
      UMIN: BigInt("0"),
      UMAX: BigInt("18446744073709551615"),
      C: BigInt,
      V: dv
    } : undefined;
  }
  exports.detectBi = detectBi;
  detectBi();
  function assertBi(bi) {
    if (!bi)
      throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
  }
  var RE_DECIMAL_STR = /^-?[0-9]+$/;
  var TWO_PWR_32_DBL = 4294967296;
  var HALF_2_PWR_32 = 2147483648;

  class SharedPbLong {
    constructor(lo, hi) {
      this.lo = lo | 0;
      this.hi = hi | 0;
    }
    isZero() {
      return this.lo == 0 && this.hi == 0;
    }
    toNumber() {
      let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
      if (!Number.isSafeInteger(result))
        throw new Error("cannot convert to safe number");
      return result;
    }
  }

  class PbULong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw new Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.UMIN)
              throw new Error("signed value for ulong");
            if (value > BI.UMAX)
              throw new Error("ulong too large");
            BI.V.setBigUint64(0, value, true);
            return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            value = value.trim();
            if (!RE_DECIMAL_STR.test(value))
              throw new Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus)
              throw new Error("signed value for ulong");
            return new PbULong(lo, hi);
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw new Error("number is no integer");
            if (value < 0)
              throw new Error("signed value for ulong");
            return new PbULong(value, value / TWO_PWR_32_DBL);
        }
      throw new Error("unknown value " + typeof value);
    }
    toString() {
      return BI ? this.toBigInt().toString() : goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      assertBi(BI);
      BI.V.setInt32(0, this.lo, true);
      BI.V.setInt32(4, this.hi, true);
      return BI.V.getBigUint64(0, true);
    }
  }
  exports.PbULong = PbULong;
  PbULong.ZERO = new PbULong(0, 0);

  class PbLong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw new Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.MIN)
              throw new Error("signed long too small");
            if (value > BI.MAX)
              throw new Error("signed long too large");
            BI.V.setBigInt64(0, value, true);
            return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            value = value.trim();
            if (!RE_DECIMAL_STR.test(value))
              throw new Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus) {
              if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
                throw new Error("signed long too small");
            } else if (hi >= HALF_2_PWR_32)
              throw new Error("signed long too large");
            let pbl = new PbLong(lo, hi);
            return minus ? pbl.negate() : pbl;
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw new Error("number is no integer");
            return value > 0 ? new PbLong(value, value / TWO_PWR_32_DBL) : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
        }
      throw new Error("unknown value " + typeof value);
    }
    isNegative() {
      return (this.hi & HALF_2_PWR_32) !== 0;
    }
    negate() {
      let hi = ~this.hi, lo = this.lo;
      if (lo)
        lo = ~lo + 1;
      else
        hi += 1;
      return new PbLong(lo, hi);
    }
    toString() {
      if (BI)
        return this.toBigInt().toString();
      if (this.isNegative()) {
        let n = this.negate();
        return "-" + goog_varint_1.int64toString(n.lo, n.hi);
      }
      return goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      assertBi(BI);
      BI.V.setInt32(0, this.lo, true);
      BI.V.setInt32(4, this.hi, true);
      return BI.V.getBigInt64(0, true);
    }
  }
  exports.PbLong = PbLong;
  PbLong.ZERO = new PbLong(0, 0);
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-reader.js
var require_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinaryReader = exports.binaryReadOptions = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var pb_long_1 = require_pb_long();
  var goog_varint_1 = require_goog_varint();
  var defaultsRead = {
    readUnknownField: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.binaryReadOptions = binaryReadOptions;

  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = goog_varint_1.varint64read;
      this.uint32 = goog_varint_1.varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== undefined ? textDecoder : new TextDecoder("utf-8", {
        fatal: true,
        ignoreBOM: true
      });
    }
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    skip(wireType) {
      let start = this.pos;
      switch (wireType) {
        case binary_format_contract_1.WireType.Varint:
          while (this.buf[this.pos++] & 128) {}
          break;
        case binary_format_contract_1.WireType.Bit64:
          this.pos += 4;
        case binary_format_contract_1.WireType.Bit32:
          this.pos += 4;
          break;
        case binary_format_contract_1.WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case binary_format_contract_1.WireType.StartGroup:
          let t;
          while ((t = this.tag()[1]) !== binary_format_contract_1.WireType.EndGroup) {
            this.skip(t);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    int32() {
      return this.uint32() | 0;
    }
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    int64() {
      return new pb_long_1.PbLong(...this.varint64());
    }
    uint64() {
      return new pb_long_1.PbULong(...this.varint64());
    }
    sint64() {
      let [lo, hi] = this.varint64();
      let s = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
      hi = hi >>> 1 ^ s;
      return new pb_long_1.PbLong(lo, hi);
    }
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    fixed64() {
      return new pb_long_1.PbULong(this.sfixed32(), this.sfixed32());
    }
    sfixed64() {
      return new pb_long_1.PbLong(this.sfixed32(), this.sfixed32());
    }
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    bytes() {
      let len = this.uint32();
      let start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  exports.BinaryReader = BinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/assert.js
var require_assert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertFloat32 = exports.assertUInt32 = exports.assertInt32 = exports.assertNever = exports.assert = undefined;
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  exports.assert = assert;
  function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== undefined ? msg : "Unexpected object: " + value);
  }
  exports.assertNever = assertNever;
  var FLOAT32_MAX = 340282346638528860000000000000000000000;
  var FLOAT32_MIN = -340282346638528860000000000000000000000;
  var UINT32_MAX = 4294967295;
  var INT32_MAX = 2147483647;
  var INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  exports.assertInt32 = assertInt32;
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  exports.assertUInt32 = assertUInt32;
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  exports.assertFloat32 = assertFloat32;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-writer.js
var require_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinaryWriter = exports.binaryWriteOptions = undefined;
  var pb_long_1 = require_pb_long();
  var goog_varint_1 = require_goog_varint();
  var assert_1 = require_assert();
  var defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter
  };
  function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.binaryWriteOptions = binaryWriteOptions;

  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== undefined ? textEncoder : new TextEncoder;
      this.chunks = [];
      this.buf = [];
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i = 0;i < this.chunks.length; i++)
        len += this.chunks[i].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i = 0;i < this.chunks.length; i++) {
        bytes.set(this.chunks[i], offset);
        offset += this.chunks[i].length;
      }
      this.chunks = [];
      return bytes;
    }
    fork() {
      this.stack.push({ chunks: this.chunks, buf: this.buf });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    uint32(value) {
      assert_1.assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    int32(value) {
      assert_1.assertInt32(value);
      goog_varint_1.varint32write(value, this.buf);
      return this;
    }
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    float(value) {
      assert_1.assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    fixed32(value) {
      assert_1.assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    sfixed32(value) {
      assert_1.assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    sint32(value) {
      assert_1.assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      goog_varint_1.varint32write(value, this.buf);
      return this;
    }
    sfixed64(value) {
      let chunk = new Uint8Array(8);
      let view = new DataView(chunk.buffer);
      let long = pb_long_1.PbLong.from(value);
      view.setInt32(0, long.lo, true);
      view.setInt32(4, long.hi, true);
      return this.raw(chunk);
    }
    fixed64(value) {
      let chunk = new Uint8Array(8);
      let view = new DataView(chunk.buffer);
      let long = pb_long_1.PbULong.from(value);
      view.setInt32(0, long.lo, true);
      view.setInt32(4, long.hi, true);
      return this.raw(chunk);
    }
    int64(value) {
      let long = pb_long_1.PbLong.from(value);
      goog_varint_1.varint64write(long.lo, long.hi, this.buf);
      return this;
    }
    sint64(value) {
      let long = pb_long_1.PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
      goog_varint_1.varint64write(lo, hi, this.buf);
      return this;
    }
    uint64(value) {
      let long = pb_long_1.PbULong.from(value);
      goog_varint_1.varint64write(long.lo, long.hi, this.buf);
      return this;
    }
  }
  exports.BinaryWriter = BinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-format-contract.js
var require_json_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeJsonOptions = exports.jsonWriteOptions = exports.jsonReadOptions = undefined;
  var defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  var defaultsRead = {
    ignoreUnknownFields: false
  };
  function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.jsonReadOptions = jsonReadOptions;
  function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.jsonWriteOptions = jsonWriteOptions;
  function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    c.typeRegistry = [...(_a = a === null || a === undefined ? undefined : a.typeRegistry) !== null && _a !== undefined ? _a : [], ...(_b = b === null || b === undefined ? undefined : b.typeRegistry) !== null && _b !== undefined ? _b : []];
    return c;
  }
  exports.mergeJsonOptions = mergeJsonOptions;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type-contract.js
var require_message_type_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MESSAGE_TYPE = undefined;
  exports.MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
});

// node_modules/@protobuf-ts/runtime/build/commonjs/lower-camel-case.js
var require_lower_camel_case = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lowerCamelCase = undefined;
  function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0;i < snakeCase.length; i++) {
      let next = snakeCase.charAt(i);
      if (next == "_") {
        capNext = true;
      } else if (/\d/.test(next)) {
        sb.push(next);
        capNext = true;
      } else if (capNext) {
        sb.push(next.toUpperCase());
        capNext = false;
      } else if (i == 0) {
        sb.push(next.toLowerCase());
      } else {
        sb.push(next);
      }
    }
    return sb.join("");
  }
  exports.lowerCamelCase = lowerCamelCase;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-info.js
var require_reflection_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readMessageOption = exports.readFieldOption = exports.readFieldOptions = exports.normalizeFieldInfo = exports.RepeatType = exports.LongType = exports.ScalarType = undefined;
  var lower_camel_case_1 = require_lower_camel_case();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType = exports.ScalarType || (exports.ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
    LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
  })(LongType = exports.LongType || (exports.LongType = {}));
  var RepeatType;
  (function(RepeatType2) {
    RepeatType2[RepeatType2["NO"] = 0] = "NO";
    RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
    RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
  })(RepeatType = exports.RepeatType || (exports.RepeatType = {}));
  function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== undefined ? _a : lower_camel_case_1.lowerCamelCase(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== undefined ? _b : lower_camel_case_1.lowerCamelCase(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== undefined ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== undefined ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
    return field;
  }
  exports.normalizeFieldInfo = normalizeFieldInfo;
  function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === undefined ? undefined : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
  }
  exports.readFieldOptions = readFieldOptions;
  function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === undefined ? undefined : _a.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readFieldOption = readFieldOption;
  function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMessageOption = readMessageOption;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/oneof.js
var require_oneof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSelectedOneofValue = exports.clearOneofValue = exports.setUnknownOneofValue = exports.setOneofValue = exports.getOneofValue = exports.isOneofGroup = undefined;
  function isOneofGroup(any) {
    if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
      return false;
    }
    switch (typeof any.oneofKind) {
      case "string":
        if (any[any.oneofKind] === undefined)
          return false;
        return Object.keys(any).length == 2;
      case "undefined":
        return Object.keys(any).length == 1;
      default:
        return false;
    }
  }
  exports.isOneofGroup = isOneofGroup;
  function getOneofValue(oneof, kind) {
    return oneof[kind];
  }
  exports.getOneofValue = getOneofValue;
  function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
      oneof[kind] = value;
    }
  }
  exports.setOneofValue = setOneofValue;
  function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
      oneof[kind] = value;
    }
  }
  exports.setUnknownOneofValue = setUnknownOneofValue;
  function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
  }
  exports.clearOneofValue = clearOneofValue;
  function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
      return;
    }
    return oneof[oneof.oneofKind];
  }
  exports.getSelectedOneofValue = getSelectedOneofValue;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-type-check.js
var require_reflection_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionTypeCheck = undefined;
  var reflection_info_1 = require_reflection_info();
  var oneof_1 = require_oneof();

  class ReflectionTypeCheck {
    constructor(info) {
      var _a;
      this.fields = (_a = info.fields) !== null && _a !== undefined ? _a : [];
    }
    prepare() {
      if (this.data)
        return;
      const req = [], known = [], oneofs = [];
      for (let field of this.fields) {
        if (field.oneof) {
          if (!oneofs.includes(field.oneof)) {
            oneofs.push(field.oneof);
            req.push(field.oneof);
            known.push(field.oneof);
          }
        } else {
          known.push(field.localName);
          switch (field.kind) {
            case "scalar":
            case "enum":
              if (!field.opt || field.repeat)
                req.push(field.localName);
              break;
            case "message":
              if (field.repeat)
                req.push(field.localName);
              break;
            case "map":
              req.push(field.localName);
              break;
          }
        }
      }
      this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    is(message, depth, allowExcessProperties = false) {
      if (depth < 0)
        return true;
      if (message === null || message === undefined || typeof message != "object")
        return false;
      this.prepare();
      let keys = Object.keys(message), data = this.data;
      if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
        return false;
      if (!allowExcessProperties) {
        if (keys.some((k) => !data.known.includes(k)))
          return false;
      }
      if (depth < 1) {
        return true;
      }
      for (const name of data.oneofs) {
        const group = message[name];
        if (!oneof_1.isOneofGroup(group))
          return false;
        if (group.oneofKind === undefined)
          continue;
        const field = this.fields.find((f) => f.localName === group.oneofKind);
        if (!field)
          return false;
        if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
          return false;
      }
      for (const field of this.fields) {
        if (field.oneof !== undefined)
          continue;
        if (!this.field(message[field.localName], field, allowExcessProperties, depth))
          return false;
      }
      return true;
    }
    field(arg, field, allowExcessProperties, depth) {
      let repeated = field.repeat;
      switch (field.kind) {
        case "scalar":
          if (arg === undefined)
            return field.opt;
          if (repeated)
            return this.scalars(arg, field.T, depth, field.L);
          return this.scalar(arg, field.T, field.L);
        case "enum":
          if (arg === undefined)
            return field.opt;
          if (repeated)
            return this.scalars(arg, reflection_info_1.ScalarType.INT32, depth);
          return this.scalar(arg, reflection_info_1.ScalarType.INT32);
        case "message":
          if (arg === undefined)
            return true;
          if (repeated)
            return this.messages(arg, field.T(), allowExcessProperties, depth);
          return this.message(arg, field.T(), allowExcessProperties, depth);
        case "map":
          if (typeof arg != "object" || arg === null)
            return false;
          if (depth < 2)
            return true;
          if (!this.mapKeys(arg, field.K, depth))
            return false;
          switch (field.V.kind) {
            case "scalar":
              return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
            case "enum":
              return this.scalars(Object.values(arg), reflection_info_1.ScalarType.INT32, depth);
            case "message":
              return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
          }
          break;
      }
      return true;
    }
    message(arg, type, allowExcessProperties, depth) {
      if (allowExcessProperties) {
        return type.isAssignable(arg, depth);
      }
      return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
      if (!Array.isArray(arg))
        return false;
      if (depth < 2)
        return true;
      if (allowExcessProperties) {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!type.isAssignable(arg[i], depth - 1))
            return false;
      } else {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!type.is(arg[i], depth - 1))
            return false;
      }
      return true;
    }
    scalar(arg, type, longType) {
      let argType = typeof arg;
      switch (type) {
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          switch (longType) {
            case reflection_info_1.LongType.BIGINT:
              return argType == "bigint";
            case reflection_info_1.LongType.NUMBER:
              return argType == "number" && !isNaN(arg);
            default:
              return argType == "string";
          }
        case reflection_info_1.ScalarType.BOOL:
          return argType == "boolean";
        case reflection_info_1.ScalarType.STRING:
          return argType == "string";
        case reflection_info_1.ScalarType.BYTES:
          return arg instanceof Uint8Array;
        case reflection_info_1.ScalarType.DOUBLE:
        case reflection_info_1.ScalarType.FLOAT:
          return argType == "number" && !isNaN(arg);
        default:
          return argType == "number" && Number.isInteger(arg);
      }
    }
    scalars(arg, type, depth, longType) {
      if (!Array.isArray(arg))
        return false;
      if (depth < 2)
        return true;
      if (Array.isArray(arg)) {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!this.scalar(arg[i], type, longType))
            return false;
      }
      return true;
    }
    mapKeys(map, type, depth) {
      let keys = Object.keys(map);
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
        case reflection_info_1.ScalarType.UINT32:
          return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
        case reflection_info_1.ScalarType.BOOL:
          return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type, depth);
        default:
          return this.scalars(keys, type, depth, reflection_info_1.LongType.STRING);
      }
    }
  }
  exports.ReflectionTypeCheck = ReflectionTypeCheck;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-long-convert.js
var require_reflection_long_convert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionLongConvert = undefined;
  var reflection_info_1 = require_reflection_info();
  function reflectionLongConvert(long, type) {
    switch (type) {
      case reflection_info_1.LongType.BIGINT:
        return long.toBigInt();
      case reflection_info_1.LongType.NUMBER:
        return long.toNumber();
      default:
        return long.toString();
    }
  }
  exports.reflectionLongConvert = reflectionLongConvert;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-reader.js
var require_reflection_json_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionJsonReader = undefined;
  var json_typings_1 = require_json_typings();
  var base64_1 = require_base64();
  var reflection_info_1 = require_reflection_info();
  var pb_long_1 = require_pb_long();
  var assert_1 = require_assert();
  var reflection_long_convert_1 = require_reflection_long_convert();

  class ReflectionJsonReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a;
      if (this.fMap === undefined) {
        this.fMap = {};
        const fieldsInput = (_a = this.info.fields) !== null && _a !== undefined ? _a : [];
        for (const field of fieldsInput) {
          this.fMap[field.name] = field;
          this.fMap[field.jsonName] = field;
          this.fMap[field.localName] = field;
        }
      }
    }
    assert(condition, fieldName, jsonValue) {
      if (!condition) {
        let what = json_typings_1.typeofJsonValue(jsonValue);
        if (what == "number" || what == "boolean")
          what = jsonValue.toString();
        throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
      }
    }
    read(input, message, options) {
      this.prepare();
      const oneofsHandled = [];
      for (const [jsonKey, jsonValue] of Object.entries(input)) {
        const field = this.fMap[jsonKey];
        if (!field) {
          if (!options.ignoreUnknownFields)
            throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
          continue;
        }
        const localName = field.localName;
        let target;
        if (field.oneof) {
          if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
            continue;
          }
          if (oneofsHandled.includes(field.oneof))
            throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
          oneofsHandled.push(field.oneof);
          target = message[field.oneof] = {
            oneofKind: localName
          };
        } else {
          target = message;
        }
        if (field.kind == "map") {
          if (jsonValue === null) {
            continue;
          }
          this.assert(json_typings_1.isJsonObject(jsonValue), field.name, jsonValue);
          const fieldObj = target[localName];
          for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
            this.assert(jsonObjValue !== null, field.name + " map value", null);
            let val;
            switch (field.V.kind) {
              case "message":
                val = field.V.T().internalJsonRead(jsonObjValue, options);
                break;
              case "enum":
                val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                break;
            }
            this.assert(val !== undefined, field.name + " map value", jsonObjValue);
            let key = jsonObjKey;
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = key == "true" ? true : key == "false" ? false : key;
            key = this.scalar(key, field.K, reflection_info_1.LongType.STRING, field.name).toString();
            fieldObj[key] = val;
          }
        } else if (field.repeat) {
          if (jsonValue === null)
            continue;
          this.assert(Array.isArray(jsonValue), field.name, jsonValue);
          const fieldArr = target[localName];
          for (const jsonItem of jsonValue) {
            this.assert(jsonItem !== null, field.name, null);
            let val;
            switch (field.kind) {
              case "message":
                val = field.T().internalJsonRead(jsonItem, options);
                break;
              case "enum":
                val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonItem, field.T, field.L, field.name);
                break;
            }
            this.assert(val !== undefined, field.name, jsonValue);
            fieldArr.push(val);
          }
        } else {
          switch (field.kind) {
            case "message":
              if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
                this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                continue;
              }
              target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
              break;
            case "enum":
              if (jsonValue === null)
                continue;
              let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              target[localName] = val;
              break;
            case "scalar":
              if (jsonValue === null)
                continue;
              target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
              break;
          }
        }
      }
    }
    enum(type, json, fieldName, ignoreUnknownFields) {
      if (type[0] == "google.protobuf.NullValue")
        assert_1.assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
      if (json === null)
        return 0;
      switch (typeof json) {
        case "number":
          assert_1.assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
          return json;
        case "string":
          let localEnumName = json;
          if (type[2] && json.substring(0, type[2].length) === type[2])
            localEnumName = json.substring(type[2].length);
          let enumNumber = type[1][localEnumName];
          if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
            return false;
          }
          assert_1.assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
          return enumNumber;
      }
      assert_1.assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
      let e;
      try {
        switch (type) {
          case reflection_info_1.ScalarType.DOUBLE:
          case reflection_info_1.ScalarType.FLOAT:
            if (json === null)
              return 0;
            if (json === "NaN")
              return Number.NaN;
            if (json === "Infinity")
              return Number.POSITIVE_INFINITY;
            if (json === "-Infinity")
              return Number.NEGATIVE_INFINITY;
            if (json === "") {
              e = "empty string";
              break;
            }
            if (typeof json == "string" && json.trim().length !== json.length) {
              e = "extra whitespace";
              break;
            }
            if (typeof json != "string" && typeof json != "number") {
              break;
            }
            let float = Number(json);
            if (Number.isNaN(float)) {
              e = "not a number";
              break;
            }
            if (!Number.isFinite(float)) {
              e = "too large or small";
              break;
            }
            if (type == reflection_info_1.ScalarType.FLOAT)
              assert_1.assertFloat32(float);
            return float;
          case reflection_info_1.ScalarType.INT32:
          case reflection_info_1.ScalarType.FIXED32:
          case reflection_info_1.ScalarType.SFIXED32:
          case reflection_info_1.ScalarType.SINT32:
          case reflection_info_1.ScalarType.UINT32:
            if (json === null)
              return 0;
            let int32;
            if (typeof json == "number")
              int32 = json;
            else if (json === "")
              e = "empty string";
            else if (typeof json == "string") {
              if (json.trim().length !== json.length)
                e = "extra whitespace";
              else
                int32 = Number(json);
            }
            if (int32 === undefined)
              break;
            if (type == reflection_info_1.ScalarType.UINT32)
              assert_1.assertUInt32(int32);
            else
              assert_1.assertInt32(int32);
            return int32;
          case reflection_info_1.ScalarType.INT64:
          case reflection_info_1.ScalarType.SFIXED64:
          case reflection_info_1.ScalarType.SINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.from(json), longType);
          case reflection_info_1.ScalarType.FIXED64:
          case reflection_info_1.ScalarType.UINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.from(json), longType);
          case reflection_info_1.ScalarType.BOOL:
            if (json === null)
              return false;
            if (typeof json !== "boolean")
              break;
            return json;
          case reflection_info_1.ScalarType.STRING:
            if (json === null)
              return "";
            if (typeof json !== "string") {
              e = "extra whitespace";
              break;
            }
            try {
              encodeURIComponent(json);
            } catch (e2) {
              e2 = "invalid UTF8";
              break;
            }
            return json;
          case reflection_info_1.ScalarType.BYTES:
            if (json === null || json === "")
              return new Uint8Array(0);
            if (typeof json !== "string")
              break;
            return base64_1.base64decode(json);
        }
      } catch (error) {
        e = error.message;
      }
      this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
  }
  exports.ReflectionJsonReader = ReflectionJsonReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-writer.js
var require_reflection_json_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionJsonWriter = undefined;
  var base64_1 = require_base64();
  var pb_long_1 = require_pb_long();
  var reflection_info_1 = require_reflection_info();
  var assert_1 = require_assert();

  class ReflectionJsonWriter {
    constructor(info) {
      var _a;
      this.fields = (_a = info.fields) !== null && _a !== undefined ? _a : [];
    }
    write(message, options) {
      const json = {}, source = message;
      for (const field of this.fields) {
        if (!field.oneof) {
          let jsonValue2 = this.field(field, source[field.localName], options);
          if (jsonValue2 !== undefined)
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
          continue;
        }
        const group = source[field.oneof];
        if (group.oneofKind !== field.localName)
          continue;
        const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
        let jsonValue = this.field(field, group[field.localName], opt);
        assert_1.assert(jsonValue !== undefined);
        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
      }
      return json;
    }
    field(field, value, options) {
      let jsonValue = undefined;
      if (field.kind == "map") {
        assert_1.assert(typeof value == "object" && value !== null);
        const jsonObj = {};
        switch (field.V.kind) {
          case "scalar":
            for (const [entryKey, entryValue] of Object.entries(value)) {
              const val = this.scalar(field.V.T, entryValue, field.name, false, true);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
          case "message":
            const messageType = field.V.T();
            for (const [entryKey, entryValue] of Object.entries(value)) {
              const val = this.message(messageType, entryValue, field.name, options);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
          case "enum":
            const enumInfo = field.V.T();
            for (const [entryKey, entryValue] of Object.entries(value)) {
              assert_1.assert(entryValue === undefined || typeof entryValue == "number");
              const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
        }
        if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
          jsonValue = jsonObj;
      } else if (field.repeat) {
        assert_1.assert(Array.isArray(value));
        const jsonArr = [];
        switch (field.kind) {
          case "scalar":
            for (let i = 0;i < value.length; i++) {
              const val = this.scalar(field.T, value[i], field.name, field.opt, true);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
          case "enum":
            const enumInfo = field.T();
            for (let i = 0;i < value.length; i++) {
              assert_1.assert(value[i] === undefined || typeof value[i] == "number");
              const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
          case "message":
            const messageType = field.T();
            for (let i = 0;i < value.length; i++) {
              const val = this.message(messageType, value[i], field.name, options);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
        }
        if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
          jsonValue = jsonArr;
      } else {
        switch (field.kind) {
          case "scalar":
            jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
            break;
          case "enum":
            jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
            break;
          case "message":
            jsonValue = this.message(field.T(), value, field.name, options);
            break;
        }
      }
      return jsonValue;
    }
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
      if (type[0] == "google.protobuf.NullValue")
        return !emitDefaultValues && !optional ? undefined : null;
      if (value === undefined) {
        assert_1.assert(optional);
        return;
      }
      if (value === 0 && !emitDefaultValues && !optional)
        return;
      assert_1.assert(typeof value == "number");
      assert_1.assert(Number.isInteger(value));
      if (enumAsInteger || !type[1].hasOwnProperty(value))
        return value;
      if (type[2])
        return type[2] + type[1][value];
      return type[1][value];
    }
    message(type, value, fieldName, options) {
      if (value === undefined)
        return options.emitDefaultValues ? null : undefined;
      return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
      if (value === undefined) {
        assert_1.assert(optional);
        return;
      }
      const ed = emitDefaultValues || optional;
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assertInt32(value);
          return value;
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assertUInt32(value);
          return value;
        case reflection_info_1.ScalarType.FLOAT:
          assert_1.assertFloat32(value);
        case reflection_info_1.ScalarType.DOUBLE:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assert(typeof value == "number");
          if (Number.isNaN(value))
            return "NaN";
          if (value === Number.POSITIVE_INFINITY)
            return "Infinity";
          if (value === Number.NEGATIVE_INFINITY)
            return "-Infinity";
          return value;
        case reflection_info_1.ScalarType.STRING:
          if (value === "")
            return ed ? "" : undefined;
          assert_1.assert(typeof value == "string");
          return value;
        case reflection_info_1.ScalarType.BOOL:
          if (value === false)
            return ed ? false : undefined;
          assert_1.assert(typeof value == "boolean");
          return value;
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let ulong = pb_long_1.PbULong.from(value);
          if (ulong.isZero() && !ed)
            return;
          return ulong.toString();
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let long = pb_long_1.PbLong.from(value);
          if (long.isZero() && !ed)
            return;
          return long.toString();
        case reflection_info_1.ScalarType.BYTES:
          assert_1.assert(value instanceof Uint8Array);
          if (!value.byteLength)
            return ed ? "" : undefined;
          return base64_1.base64encode(value);
      }
    }
  }
  exports.ReflectionJsonWriter = ReflectionJsonWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-scalar-default.js
var require_reflection_scalar_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionScalarDefault = undefined;
  var reflection_info_1 = require_reflection_info();
  var reflection_long_convert_1 = require_reflection_long_convert();
  var pb_long_1 = require_pb_long();
  function reflectionScalarDefault(type, longType = reflection_info_1.LongType.STRING) {
    switch (type) {
      case reflection_info_1.ScalarType.BOOL:
        return false;
      case reflection_info_1.ScalarType.UINT64:
      case reflection_info_1.ScalarType.FIXED64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
      case reflection_info_1.ScalarType.INT64:
      case reflection_info_1.ScalarType.SFIXED64:
      case reflection_info_1.ScalarType.SINT64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
      case reflection_info_1.ScalarType.DOUBLE:
      case reflection_info_1.ScalarType.FLOAT:
        return 0;
      case reflection_info_1.ScalarType.BYTES:
        return new Uint8Array(0);
      case reflection_info_1.ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  exports.reflectionScalarDefault = reflectionScalarDefault;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-reader.js
var require_reflection_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionBinaryReader = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var reflection_info_1 = require_reflection_info();
  var reflection_long_convert_1 = require_reflection_long_convert();
  var reflection_scalar_default_1 = require_reflection_scalar_default();

  class ReflectionBinaryReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a;
      if (!this.fieldNoToField) {
        const fieldsInput = (_a = this.info.fields) !== null && _a !== undefined ? _a : [];
        this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
      }
    }
    read(reader, message, options, length) {
      this.prepare();
      const end = length === undefined ? reader.len : reader.pos + length;
      while (reader.pos < end) {
        const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
        if (!field) {
          let u = options.readUnknownField;
          if (u == "throw")
            throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? binary_format_contract_1.UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
          continue;
        }
        let target = message, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          target = target[field.oneof];
          if (target.oneofKind !== localName)
            target = message[field.oneof] = {
              oneofKind: localName
            };
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
            let L = field.kind == "scalar" ? field.L : undefined;
            if (repeated) {
              let arr = target[localName];
              if (wireType == binary_format_contract_1.WireType.LengthDelimited && T != reflection_info_1.ScalarType.STRING && T != reflection_info_1.ScalarType.BYTES) {
                let e = reader.uint32() + reader.pos;
                while (reader.pos < e)
                  arr.push(this.scalar(reader, T, L));
              } else
                arr.push(this.scalar(reader, T, L));
            } else
              target[localName] = this.scalar(reader, T, L);
            break;
          case "message":
            if (repeated) {
              let arr = target[localName];
              let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
              arr.push(msg);
            } else
              target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
            break;
          case "map":
            let [mapKey, mapVal] = this.mapEntry(field, reader, options);
            target[localName][mapKey] = mapVal;
            break;
        }
      }
    }
    mapEntry(field, reader, options) {
      let length = reader.uint32();
      let end = reader.pos + length;
      let key = undefined;
      let val = undefined;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = reader.bool().toString();
            else
              key = this.scalar(reader, field.K, reflection_info_1.LongType.STRING);
            break;
          case 2:
            switch (field.V.kind) {
              case "scalar":
                val = this.scalar(reader, field.V.T, field.V.L);
                break;
              case "enum":
                val = reader.int32();
                break;
              case "message":
                val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                break;
            }
            break;
          default:
            throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
        }
      }
      if (key === undefined) {
        let keyRaw = reflection_scalar_default_1.reflectionScalarDefault(field.K);
        key = field.K == reflection_info_1.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
      }
      if (val === undefined)
        switch (field.V.kind) {
          case "scalar":
            val = reflection_scalar_default_1.reflectionScalarDefault(field.V.T, field.V.L);
            break;
          case "enum":
            val = 0;
            break;
          case "message":
            val = field.V.T().create();
            break;
        }
      return [key, val];
    }
    scalar(reader, type, longType) {
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
          return reader.int32();
        case reflection_info_1.ScalarType.STRING:
          return reader.string();
        case reflection_info_1.ScalarType.BOOL:
          return reader.bool();
        case reflection_info_1.ScalarType.DOUBLE:
          return reader.double();
        case reflection_info_1.ScalarType.FLOAT:
          return reader.float();
        case reflection_info_1.ScalarType.INT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.int64(), longType);
        case reflection_info_1.ScalarType.UINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.uint64(), longType);
        case reflection_info_1.ScalarType.FIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.fixed64(), longType);
        case reflection_info_1.ScalarType.FIXED32:
          return reader.fixed32();
        case reflection_info_1.ScalarType.BYTES:
          return reader.bytes();
        case reflection_info_1.ScalarType.UINT32:
          return reader.uint32();
        case reflection_info_1.ScalarType.SFIXED32:
          return reader.sfixed32();
        case reflection_info_1.ScalarType.SFIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sfixed64(), longType);
        case reflection_info_1.ScalarType.SINT32:
          return reader.sint32();
        case reflection_info_1.ScalarType.SINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sint64(), longType);
      }
    }
  }
  exports.ReflectionBinaryReader = ReflectionBinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-writer.js
var require_reflection_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionBinaryWriter = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var reflection_info_1 = require_reflection_info();
  var assert_1 = require_assert();
  var pb_long_1 = require_pb_long();

  class ReflectionBinaryWriter {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      if (!this.fields) {
        const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
        this.fields = fieldsInput.sort((a, b) => a.no - b.no);
      }
    }
    write(message, writer, options) {
      this.prepare();
      for (const field of this.fields) {
        let value, emitDefault, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          const group = message[field.oneof];
          if (group.oneofKind !== localName)
            continue;
          value = group[localName];
          emitDefault = true;
        } else {
          value = message[localName];
          emitDefault = false;
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
            if (repeated) {
              assert_1.assert(Array.isArray(value));
              if (repeated == reflection_info_1.RepeatType.PACKED)
                this.packed(writer, T, field.no, value);
              else
                for (const item of value)
                  this.scalar(writer, T, field.no, item, true);
            } else if (value === undefined)
              assert_1.assert(field.opt);
            else
              this.scalar(writer, T, field.no, value, emitDefault || field.opt);
            break;
          case "message":
            if (repeated) {
              assert_1.assert(Array.isArray(value));
              for (const item of value)
                this.message(writer, options, field.T(), field.no, item);
            } else {
              this.message(writer, options, field.T(), field.no, value);
            }
            break;
          case "map":
            assert_1.assert(typeof value == "object" && value !== null);
            for (const [key, val] of Object.entries(value))
              this.mapEntry(writer, options, field, key, val);
            break;
        }
      }
      let u = options.writeUnknownFields;
      if (u !== false)
        (u === true ? binary_format_contract_1.UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
      writer.tag(field.no, binary_format_contract_1.WireType.LengthDelimited);
      writer.fork();
      let keyValue = key;
      switch (field.K) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          keyValue = Number.parseInt(key);
          break;
        case reflection_info_1.ScalarType.BOOL:
          assert_1.assert(key == "true" || key == "false");
          keyValue = key == "true";
          break;
      }
      this.scalar(writer, field.K, 1, keyValue, true);
      switch (field.V.kind) {
        case "scalar":
          this.scalar(writer, field.V.T, 2, value, true);
          break;
        case "enum":
          this.scalar(writer, reflection_info_1.ScalarType.INT32, 2, value, true);
          break;
        case "message":
          this.message(writer, options, field.V.T(), 2, value);
          break;
      }
      writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
      if (value === undefined)
        return;
      handler.internalBinaryWrite(value, writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited).fork(), options);
      writer.join();
    }
    scalar(writer, type, fieldNo, value, emitDefault) {
      let [wireType, method, isDefault] = this.scalarInfo(type, value);
      if (!isDefault || emitDefault) {
        writer.tag(fieldNo, wireType);
        writer[method](value);
      }
    }
    packed(writer, type, fieldNo, value) {
      if (!value.length)
        return;
      assert_1.assert(type !== reflection_info_1.ScalarType.BYTES && type !== reflection_info_1.ScalarType.STRING);
      writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited);
      writer.fork();
      let [, method] = this.scalarInfo(type);
      for (let i = 0;i < value.length; i++)
        writer[method](value[i]);
      writer.join();
    }
    scalarInfo(type, value) {
      let t = binary_format_contract_1.WireType.Varint;
      let m;
      let i = value === undefined;
      let d = value === 0;
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
          m = "int32";
          break;
        case reflection_info_1.ScalarType.STRING:
          d = i || !value.length;
          t = binary_format_contract_1.WireType.LengthDelimited;
          m = "string";
          break;
        case reflection_info_1.ScalarType.BOOL:
          d = value === false;
          m = "bool";
          break;
        case reflection_info_1.ScalarType.UINT32:
          m = "uint32";
          break;
        case reflection_info_1.ScalarType.DOUBLE:
          t = binary_format_contract_1.WireType.Bit64;
          m = "double";
          break;
        case reflection_info_1.ScalarType.FLOAT:
          t = binary_format_contract_1.WireType.Bit32;
          m = "float";
          break;
        case reflection_info_1.ScalarType.INT64:
          d = i || pb_long_1.PbLong.from(value).isZero();
          m = "int64";
          break;
        case reflection_info_1.ScalarType.UINT64:
          d = i || pb_long_1.PbULong.from(value).isZero();
          m = "uint64";
          break;
        case reflection_info_1.ScalarType.FIXED64:
          d = i || pb_long_1.PbULong.from(value).isZero();
          t = binary_format_contract_1.WireType.Bit64;
          m = "fixed64";
          break;
        case reflection_info_1.ScalarType.BYTES:
          d = i || !value.byteLength;
          t = binary_format_contract_1.WireType.LengthDelimited;
          m = "bytes";
          break;
        case reflection_info_1.ScalarType.FIXED32:
          t = binary_format_contract_1.WireType.Bit32;
          m = "fixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED32:
          t = binary_format_contract_1.WireType.Bit32;
          m = "sfixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED64:
          d = i || pb_long_1.PbLong.from(value).isZero();
          t = binary_format_contract_1.WireType.Bit64;
          m = "sfixed64";
          break;
        case reflection_info_1.ScalarType.SINT32:
          m = "sint32";
          break;
        case reflection_info_1.ScalarType.SINT64:
          d = i || pb_long_1.PbLong.from(value).isZero();
          m = "sint64";
          break;
      }
      return [t, m, i || d];
    }
  }
  exports.ReflectionBinaryWriter = ReflectionBinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-create.js
var require_reflection_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionCreate = undefined;
  var reflection_scalar_default_1 = require_reflection_scalar_default();
  var message_type_contract_1 = require_message_type_contract();
  function reflectionCreate(type) {
    const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, message_type_contract_1.MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
      let name = field.localName;
      if (field.opt)
        continue;
      if (field.oneof)
        msg[field.oneof] = { oneofKind: undefined };
      else if (field.repeat)
        msg[name] = [];
      else
        switch (field.kind) {
          case "scalar":
            msg[name] = reflection_scalar_default_1.reflectionScalarDefault(field.T, field.L);
            break;
          case "enum":
            msg[name] = 0;
            break;
          case "map":
            msg[name] = {};
            break;
        }
    }
    return msg;
  }
  exports.reflectionCreate = reflectionCreate;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-merge-partial.js
var require_reflection_merge_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionMergePartial = undefined;
  function reflectionMergePartial(info, target, source) {
    let fieldValue, input = source, output;
    for (let field of info.fields) {
      let name = field.localName;
      if (field.oneof) {
        const group = input[field.oneof];
        if ((group === null || group === undefined ? undefined : group.oneofKind) == undefined) {
          continue;
        }
        fieldValue = group[name];
        output = target[field.oneof];
        output.oneofKind = group.oneofKind;
        if (fieldValue == undefined) {
          delete output[name];
          continue;
        }
      } else {
        fieldValue = input[name];
        output = target;
        if (fieldValue == undefined) {
          continue;
        }
      }
      if (field.repeat)
        output[name].length = fieldValue.length;
      switch (field.kind) {
        case "scalar":
        case "enum":
          if (field.repeat)
            for (let i = 0;i < fieldValue.length; i++)
              output[name][i] = fieldValue[i];
          else
            output[name] = fieldValue;
          break;
        case "message":
          let T = field.T();
          if (field.repeat)
            for (let i = 0;i < fieldValue.length; i++)
              output[name][i] = T.create(fieldValue[i]);
          else if (output[name] === undefined)
            output[name] = T.create(fieldValue);
          else
            T.mergePartial(output[name], fieldValue);
          break;
        case "map":
          switch (field.V.kind) {
            case "scalar":
            case "enum":
              Object.assign(output[name], fieldValue);
              break;
            case "message":
              let T2 = field.V.T();
              for (let k of Object.keys(fieldValue))
                output[name][k] = T2.create(fieldValue[k]);
              break;
          }
          break;
      }
    }
  }
  exports.reflectionMergePartial = reflectionMergePartial;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-equals.js
var require_reflection_equals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionEquals = undefined;
  var reflection_info_1 = require_reflection_info();
  function reflectionEquals(info, a, b) {
    if (a === b)
      return true;
    if (!a || !b)
      return false;
    for (let field of info.fields) {
      let localName = field.localName;
      let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
      let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
      switch (field.kind) {
        case "enum":
        case "scalar":
          let t = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
          if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
            return false;
          break;
        case "map":
          if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
            return false;
          break;
        case "message":
          let T = field.T();
          if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
            return false;
          break;
      }
    }
    return true;
  }
  exports.reflectionEquals = reflectionEquals;
  var objectValues = Object.values;
  function primitiveEq(type, a, b) {
    if (a === b)
      return true;
    if (type !== reflection_info_1.ScalarType.BYTES)
      return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
      return false;
    for (let i = 0;i < ba.length; i++)
      if (ba[i] != bb[i])
        return false;
    return true;
  }
  function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0;i < a.length; i++)
      if (!primitiveEq(type, a[i], b[i]))
        return false;
    return true;
  }
  function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0;i < a.length; i++)
      if (!type.equals(a[i], b[i]))
        return false;
    return true;
  }
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type.js
var require_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageType = undefined;
  var message_type_contract_1 = require_message_type_contract();
  var reflection_info_1 = require_reflection_info();
  var reflection_type_check_1 = require_reflection_type_check();
  var reflection_json_reader_1 = require_reflection_json_reader();
  var reflection_json_writer_1 = require_reflection_json_writer();
  var reflection_binary_reader_1 = require_reflection_binary_reader();
  var reflection_binary_writer_1 = require_reflection_binary_writer();
  var reflection_create_1 = require_reflection_create();
  var reflection_merge_partial_1 = require_reflection_merge_partial();
  var json_typings_1 = require_json_typings();
  var json_format_contract_1 = require_json_format_contract();
  var reflection_equals_1 = require_reflection_equals();
  var binary_writer_1 = require_binary_writer();
  var binary_reader_1 = require_binary_reader();
  var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
  var messageTypeDescriptor = baseDescriptors[message_type_contract_1.MESSAGE_TYPE] = {};

  class MessageType {
    constructor(name, fields, options) {
      this.defaultCheckDepth = 16;
      this.typeName = name;
      this.fields = fields.map(reflection_info_1.normalizeFieldInfo);
      this.options = options !== null && options !== undefined ? options : {};
      messageTypeDescriptor.value = this;
      this.messagePrototype = Object.create(null, baseDescriptors);
      this.refTypeCheck = new reflection_type_check_1.ReflectionTypeCheck(this);
      this.refJsonReader = new reflection_json_reader_1.ReflectionJsonReader(this);
      this.refJsonWriter = new reflection_json_writer_1.ReflectionJsonWriter(this);
      this.refBinReader = new reflection_binary_reader_1.ReflectionBinaryReader(this);
      this.refBinWriter = new reflection_binary_writer_1.ReflectionBinaryWriter(this);
    }
    create(value) {
      let message = reflection_create_1.reflectionCreate(this);
      if (value !== undefined) {
        reflection_merge_partial_1.reflectionMergePartial(this, message, value);
      }
      return message;
    }
    clone(message) {
      let copy = this.create();
      reflection_merge_partial_1.reflectionMergePartial(this, copy, message);
      return copy;
    }
    equals(a, b) {
      return reflection_equals_1.reflectionEquals(this, a, b);
    }
    is(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, false);
    }
    isAssignable(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, true);
    }
    mergePartial(target, source) {
      reflection_merge_partial_1.reflectionMergePartial(this, target, source);
    }
    fromBinary(data, options) {
      let opt = binary_reader_1.binaryReadOptions(options);
      return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    fromJson(json, options) {
      return this.internalJsonRead(json, json_format_contract_1.jsonReadOptions(options));
    }
    fromJsonString(json, options) {
      let value = JSON.parse(json);
      return this.fromJson(value, options);
    }
    toJson(message, options) {
      return this.internalJsonWrite(message, json_format_contract_1.jsonWriteOptions(options));
    }
    toJsonString(message, options) {
      var _a;
      let value = this.toJson(message, options);
      return JSON.stringify(value, null, (_a = options === null || options === undefined ? undefined : options.prettySpaces) !== null && _a !== undefined ? _a : 0);
    }
    toBinary(message, options) {
      let opt = binary_writer_1.binaryWriteOptions(options);
      return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    internalJsonRead(json, options, target) {
      if (json !== null && typeof json == "object" && !Array.isArray(json)) {
        let message = target !== null && target !== undefined ? target : this.create();
        this.refJsonReader.read(json, message, options);
        return message;
      }
      throw new Error(`Unable to parse message ${this.typeName} from JSON ${json_typings_1.typeofJsonValue(json)}.`);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.write(message, options);
    }
    internalBinaryWrite(message, writer, options) {
      this.refBinWriter.write(message, writer, options);
      return writer;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create();
      this.refBinReader.read(reader, message, options, length);
      return message;
    }
  }
  exports.MessageType = MessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-contains-message-type.js
var require_reflection_contains_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.containsMessageType = undefined;
  var message_type_contract_1 = require_message_type_contract();
  function containsMessageType(msg) {
    return msg[message_type_contract_1.MESSAGE_TYPE] != null;
  }
  exports.containsMessageType = containsMessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/enum-object.js
var require_enum_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listEnumNumbers = exports.listEnumNames = exports.listEnumValues = exports.isEnumObject = undefined;
  function isEnumObject(arg) {
    if (typeof arg != "object" || arg === null) {
      return false;
    }
    if (!arg.hasOwnProperty(0)) {
      return false;
    }
    for (let k of Object.keys(arg)) {
      let num = parseInt(k);
      if (!Number.isNaN(num)) {
        let nam = arg[num];
        if (nam === undefined)
          return false;
        if (arg[nam] !== num)
          return false;
      } else {
        let num2 = arg[k];
        if (num2 === undefined)
          return false;
        if (typeof num2 !== "number")
          return false;
        if (arg[num2] === undefined)
          return false;
      }
    }
    return true;
  }
  exports.isEnumObject = isEnumObject;
  function listEnumValues(enumObject) {
    if (!isEnumObject(enumObject))
      throw new Error("not a typescript enum object");
    let values = [];
    for (let [name, number] of Object.entries(enumObject))
      if (typeof number == "number")
        values.push({ name, number });
    return values;
  }
  exports.listEnumValues = listEnumValues;
  function listEnumNames(enumObject) {
    return listEnumValues(enumObject).map((val) => val.name);
  }
  exports.listEnumNames = listEnumNames;
  function listEnumNumbers(enumObject) {
    return listEnumValues(enumObject).map((val) => val.number).filter((num, index, arr) => arr.indexOf(num) == index);
  }
  exports.listEnumNumbers = listEnumNumbers;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var json_typings_1 = require_json_typings();
  Object.defineProperty(exports, "typeofJsonValue", { enumerable: true, get: function() {
    return json_typings_1.typeofJsonValue;
  } });
  Object.defineProperty(exports, "isJsonObject", { enumerable: true, get: function() {
    return json_typings_1.isJsonObject;
  } });
  var base64_1 = require_base64();
  Object.defineProperty(exports, "base64decode", { enumerable: true, get: function() {
    return base64_1.base64decode;
  } });
  Object.defineProperty(exports, "base64encode", { enumerable: true, get: function() {
    return base64_1.base64encode;
  } });
  var protobufjs_utf8_1 = require_protobufjs_utf8();
  Object.defineProperty(exports, "utf8read", { enumerable: true, get: function() {
    return protobufjs_utf8_1.utf8read;
  } });
  var binary_format_contract_1 = require_binary_format_contract();
  Object.defineProperty(exports, "WireType", { enumerable: true, get: function() {
    return binary_format_contract_1.WireType;
  } });
  Object.defineProperty(exports, "mergeBinaryOptions", { enumerable: true, get: function() {
    return binary_format_contract_1.mergeBinaryOptions;
  } });
  Object.defineProperty(exports, "UnknownFieldHandler", { enumerable: true, get: function() {
    return binary_format_contract_1.UnknownFieldHandler;
  } });
  var binary_reader_1 = require_binary_reader();
  Object.defineProperty(exports, "BinaryReader", { enumerable: true, get: function() {
    return binary_reader_1.BinaryReader;
  } });
  Object.defineProperty(exports, "binaryReadOptions", { enumerable: true, get: function() {
    return binary_reader_1.binaryReadOptions;
  } });
  var binary_writer_1 = require_binary_writer();
  Object.defineProperty(exports, "BinaryWriter", { enumerable: true, get: function() {
    return binary_writer_1.BinaryWriter;
  } });
  Object.defineProperty(exports, "binaryWriteOptions", { enumerable: true, get: function() {
    return binary_writer_1.binaryWriteOptions;
  } });
  var pb_long_1 = require_pb_long();
  Object.defineProperty(exports, "PbLong", { enumerable: true, get: function() {
    return pb_long_1.PbLong;
  } });
  Object.defineProperty(exports, "PbULong", { enumerable: true, get: function() {
    return pb_long_1.PbULong;
  } });
  var json_format_contract_1 = require_json_format_contract();
  Object.defineProperty(exports, "jsonReadOptions", { enumerable: true, get: function() {
    return json_format_contract_1.jsonReadOptions;
  } });
  Object.defineProperty(exports, "jsonWriteOptions", { enumerable: true, get: function() {
    return json_format_contract_1.jsonWriteOptions;
  } });
  Object.defineProperty(exports, "mergeJsonOptions", { enumerable: true, get: function() {
    return json_format_contract_1.mergeJsonOptions;
  } });
  var message_type_contract_1 = require_message_type_contract();
  Object.defineProperty(exports, "MESSAGE_TYPE", { enumerable: true, get: function() {
    return message_type_contract_1.MESSAGE_TYPE;
  } });
  var message_type_1 = require_message_type();
  Object.defineProperty(exports, "MessageType", { enumerable: true, get: function() {
    return message_type_1.MessageType;
  } });
  var reflection_info_1 = require_reflection_info();
  Object.defineProperty(exports, "ScalarType", { enumerable: true, get: function() {
    return reflection_info_1.ScalarType;
  } });
  Object.defineProperty(exports, "LongType", { enumerable: true, get: function() {
    return reflection_info_1.LongType;
  } });
  Object.defineProperty(exports, "RepeatType", { enumerable: true, get: function() {
    return reflection_info_1.RepeatType;
  } });
  Object.defineProperty(exports, "normalizeFieldInfo", { enumerable: true, get: function() {
    return reflection_info_1.normalizeFieldInfo;
  } });
  Object.defineProperty(exports, "readFieldOptions", { enumerable: true, get: function() {
    return reflection_info_1.readFieldOptions;
  } });
  Object.defineProperty(exports, "readFieldOption", { enumerable: true, get: function() {
    return reflection_info_1.readFieldOption;
  } });
  Object.defineProperty(exports, "readMessageOption", { enumerable: true, get: function() {
    return reflection_info_1.readMessageOption;
  } });
  var reflection_type_check_1 = require_reflection_type_check();
  Object.defineProperty(exports, "ReflectionTypeCheck", { enumerable: true, get: function() {
    return reflection_type_check_1.ReflectionTypeCheck;
  } });
  var reflection_create_1 = require_reflection_create();
  Object.defineProperty(exports, "reflectionCreate", { enumerable: true, get: function() {
    return reflection_create_1.reflectionCreate;
  } });
  var reflection_scalar_default_1 = require_reflection_scalar_default();
  Object.defineProperty(exports, "reflectionScalarDefault", { enumerable: true, get: function() {
    return reflection_scalar_default_1.reflectionScalarDefault;
  } });
  var reflection_merge_partial_1 = require_reflection_merge_partial();
  Object.defineProperty(exports, "reflectionMergePartial", { enumerable: true, get: function() {
    return reflection_merge_partial_1.reflectionMergePartial;
  } });
  var reflection_equals_1 = require_reflection_equals();
  Object.defineProperty(exports, "reflectionEquals", { enumerable: true, get: function() {
    return reflection_equals_1.reflectionEquals;
  } });
  var reflection_binary_reader_1 = require_reflection_binary_reader();
  Object.defineProperty(exports, "ReflectionBinaryReader", { enumerable: true, get: function() {
    return reflection_binary_reader_1.ReflectionBinaryReader;
  } });
  var reflection_binary_writer_1 = require_reflection_binary_writer();
  Object.defineProperty(exports, "ReflectionBinaryWriter", { enumerable: true, get: function() {
    return reflection_binary_writer_1.ReflectionBinaryWriter;
  } });
  var reflection_json_reader_1 = require_reflection_json_reader();
  Object.defineProperty(exports, "ReflectionJsonReader", { enumerable: true, get: function() {
    return reflection_json_reader_1.ReflectionJsonReader;
  } });
  var reflection_json_writer_1 = require_reflection_json_writer();
  Object.defineProperty(exports, "ReflectionJsonWriter", { enumerable: true, get: function() {
    return reflection_json_writer_1.ReflectionJsonWriter;
  } });
  var reflection_contains_message_type_1 = require_reflection_contains_message_type();
  Object.defineProperty(exports, "containsMessageType", { enumerable: true, get: function() {
    return reflection_contains_message_type_1.containsMessageType;
  } });
  var oneof_1 = require_oneof();
  Object.defineProperty(exports, "isOneofGroup", { enumerable: true, get: function() {
    return oneof_1.isOneofGroup;
  } });
  Object.defineProperty(exports, "setOneofValue", { enumerable: true, get: function() {
    return oneof_1.setOneofValue;
  } });
  Object.defineProperty(exports, "getOneofValue", { enumerable: true, get: function() {
    return oneof_1.getOneofValue;
  } });
  Object.defineProperty(exports, "clearOneofValue", { enumerable: true, get: function() {
    return oneof_1.clearOneofValue;
  } });
  Object.defineProperty(exports, "getSelectedOneofValue", { enumerable: true, get: function() {
    return oneof_1.getSelectedOneofValue;
  } });
  var enum_object_1 = require_enum_object();
  Object.defineProperty(exports, "listEnumValues", { enumerable: true, get: function() {
    return enum_object_1.listEnumValues;
  } });
  Object.defineProperty(exports, "listEnumNames", { enumerable: true, get: function() {
    return enum_object_1.listEnumNames;
  } });
  Object.defineProperty(exports, "listEnumNumbers", { enumerable: true, get: function() {
    return enum_object_1.listEnumNumbers;
  } });
  Object.defineProperty(exports, "isEnumObject", { enumerable: true, get: function() {
    return enum_object_1.isEnumObject;
  } });
  var lower_camel_case_1 = require_lower_camel_case();
  Object.defineProperty(exports, "lowerCamelCase", { enumerable: true, get: function() {
    return lower_camel_case_1.lowerCamelCase;
  } });
  var assert_1 = require_assert();
  Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
    return assert_1.assert;
  } });
  Object.defineProperty(exports, "assertNever", { enumerable: true, get: function() {
    return assert_1.assertNever;
  } });
  Object.defineProperty(exports, "assertInt32", { enumerable: true, get: function() {
    return assert_1.assertInt32;
  } });
  Object.defineProperty(exports, "assertUInt32", { enumerable: true, get: function() {
    return assert_1.assertUInt32;
  } });
  Object.defineProperty(exports, "assertFloat32", { enumerable: true, get: function() {
    return assert_1.assertFloat32;
  } });
});

// node_modules/@actions/artifact/lib/generated/google/protobuf/timestamp.js
var require_timestamp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Timestamp = undefined;
  var runtime_1 = require_commonjs();
  var runtime_2 = require_commonjs();
  var runtime_3 = require_commonjs();
  var runtime_4 = require_commonjs();
  var runtime_5 = require_commonjs();
  var runtime_6 = require_commonjs();
  var runtime_7 = require_commonjs();

  class Timestamp$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.Timestamp", [
        { no: 1, name: "seconds", kind: "scalar", T: 3 },
        { no: 2, name: "nanos", kind: "scalar", T: 5 }
      ]);
    }
    now() {
      const msg = this.create();
      const ms = Date.now();
      msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1000)).toString();
      msg.nanos = ms % 1000 * 1e6;
      return msg;
    }
    toDate(message) {
      return new Date(runtime_6.PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1e6));
    }
    fromDate(date) {
      const msg = this.create();
      const ms = date.getTime();
      msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1000)).toString();
      msg.nanos = ms % 1000 * 1e6;
      return msg;
    }
    internalJsonWrite(message, options) {
      let ms = runtime_6.PbLong.from(message.seconds).toNumber() * 1000;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
        throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (message.nanos < 0)
        throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
      let z = "Z";
      if (message.nanos > 0) {
        let nanosStr = (message.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000")
          z = "." + nanosStr.substring(0, 3) + "Z";
        else if (nanosStr.substring(6) === "000")
          z = "." + nanosStr.substring(0, 6) + "Z";
        else
          z = "." + nanosStr + "Z";
      }
      return new Date(ms).toISOString().replace(".000Z", z);
    }
    internalJsonRead(json, options, target) {
      if (typeof json !== "string")
        throw new Error("Unable to parse Timestamp from JSON " + (0, runtime_5.typeofJsonValue)(json) + ".");
      let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches)
        throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
      let ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
      if (Number.isNaN(ms))
        throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
        throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (!target)
        target = this.create();
      target.seconds = runtime_6.PbLong.from(ms / 1000).toString();
      target.nanos = 0;
      if (matches[7])
        target.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      return target;
    }
    create(value) {
      const message = { seconds: "0", nanos: 0 };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.seconds = reader.int64().toString();
            break;
          case 2:
            message.nanos = reader.int32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.seconds !== "0")
        writer.tag(1, runtime_1.WireType.Varint).int64(message.seconds);
      if (message.nanos !== 0)
        writer.tag(2, runtime_1.WireType.Varint).int32(message.nanos);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.Timestamp = new Timestamp$Type;
});

// node_modules/@actions/artifact/lib/generated/google/protobuf/wrappers.js
var require_wrappers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BytesValue = exports.StringValue = exports.BoolValue = exports.UInt32Value = exports.Int32Value = exports.UInt64Value = exports.Int64Value = exports.FloatValue = exports.DoubleValue = undefined;
  var runtime_1 = require_commonjs();
  var runtime_2 = require_commonjs();
  var runtime_3 = require_commonjs();
  var runtime_4 = require_commonjs();
  var runtime_5 = require_commonjs();
  var runtime_6 = require_commonjs();
  var runtime_7 = require_commonjs();

  class DoubleValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.DoubleValue", [
        { no: 1, name: "value", kind: "scalar", T: 1 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(2, message.value, "value", false, true);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, 1, undefined, "value");
      return target;
    }
    create(value) {
      const message = { value: 0 };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.double();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Bit64).double(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DoubleValue = new DoubleValue$Type;

  class FloatValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.FloatValue", [
        { no: 1, name: "value", kind: "scalar", T: 2 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(1, message.value, "value", false, true);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, 1, undefined, "value");
      return target;
    }
    create(value) {
      const message = { value: 0 };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.float();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Bit32).float(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FloatValue = new FloatValue$Type;

  class Int64Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.Int64Value", [
        { no: 1, name: "value", kind: "scalar", T: 3 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(runtime_1.ScalarType.INT64, message.value, "value", false, true);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, runtime_1.ScalarType.INT64, runtime_2.LongType.STRING, "value");
      return target;
    }
    create(value) {
      const message = { value: "0" };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== "0")
        writer.tag(1, runtime_3.WireType.Varint).int64(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.Int64Value = new Int64Value$Type;

  class UInt64Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.UInt64Value", [
        { no: 1, name: "value", kind: "scalar", T: 4 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(runtime_1.ScalarType.UINT64, message.value, "value", false, true);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, runtime_1.ScalarType.UINT64, runtime_2.LongType.STRING, "value");
      return target;
    }
    create(value) {
      const message = { value: "0" };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.uint64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== "0")
        writer.tag(1, runtime_3.WireType.Varint).uint64(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.UInt64Value = new UInt64Value$Type;

  class Int32Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.Int32Value", [
        { no: 1, name: "value", kind: "scalar", T: 5 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(5, message.value, "value", false, true);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, 5, undefined, "value");
      return target;
    }
    create(value) {
      const message = { value: 0 };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.int32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Varint).int32(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.Int32Value = new Int32Value$Type;

  class UInt32Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.UInt32Value", [
        { no: 1, name: "value", kind: "scalar", T: 13 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(13, message.value, "value", false, true);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, 13, undefined, "value");
      return target;
    }
    create(value) {
      const message = { value: 0 };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.uint32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Varint).uint32(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.UInt32Value = new UInt32Value$Type;

  class BoolValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.BoolValue", [
        { no: 1, name: "value", kind: "scalar", T: 8 }
      ]);
    }
    internalJsonWrite(message, options) {
      return message.value;
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, 8, undefined, "value");
      return target;
    }
    create(value) {
      const message = { value: false };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.bool();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== false)
        writer.tag(1, runtime_3.WireType.Varint).bool(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.BoolValue = new BoolValue$Type;

  class StringValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.StringValue", [
        { no: 1, name: "value", kind: "scalar", T: 9 }
      ]);
    }
    internalJsonWrite(message, options) {
      return message.value;
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, 9, undefined, "value");
      return target;
    }
    create(value) {
      const message = { value: "" };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== "")
        writer.tag(1, runtime_3.WireType.LengthDelimited).string(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.StringValue = new StringValue$Type;

  class BytesValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.BytesValue", [
        { no: 1, name: "value", kind: "scalar", T: 12 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(12, message.value, "value", false, true);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      target.value = this.refJsonReader.scalar(json, 12, undefined, "value");
      return target;
    }
    create(value) {
      const message = { value: new Uint8Array(0) };
      globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.bytes();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value.length)
        writer.tag(1, runtime_3.WireType.LengthDelimited).bytes(message.value);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.BytesValue = new BytesValue$Type;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/reflection-info.js
var require_reflection_info2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readServiceOption = exports.readMethodOption = exports.readMethodOptions = exports.normalizeMethodInfo = undefined;
  var runtime_1 = require_commonjs();
  function normalizeMethodInfo(method, service) {
    var _a, _b, _c;
    let m = method;
    m.service = service;
    m.localName = (_a = m.localName) !== null && _a !== undefined ? _a : runtime_1.lowerCamelCase(m.name);
    m.serverStreaming = !!m.serverStreaming;
    m.clientStreaming = !!m.clientStreaming;
    m.options = (_b = m.options) !== null && _b !== undefined ? _b : {};
    m.idempotency = (_c = m.idempotency) !== null && _c !== undefined ? _c : undefined;
    return m;
  }
  exports.normalizeMethodInfo = normalizeMethodInfo;
  function readMethodOptions(service, methodName, extensionName, extensionType) {
    var _a;
    const options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === undefined ? undefined : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
  }
  exports.readMethodOptions = readMethodOptions;
  function readMethodOption(service, methodName, extensionName, extensionType) {
    var _a;
    const options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === undefined ? undefined : _a.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMethodOption = readMethodOption;
  function readServiceOption(service, extensionName, extensionType) {
    const options = service.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readServiceOption = readServiceOption;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/service-type.js
var require_service_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceType = undefined;
  var reflection_info_1 = require_reflection_info2();

  class ServiceType {
    constructor(typeName, methods, options) {
      this.typeName = typeName;
      this.methods = methods.map((i) => reflection_info_1.normalizeMethodInfo(i, this));
      this.options = options !== null && options !== undefined ? options : {};
    }
  }
  exports.ServiceType = ServiceType;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-error.js
var require_rpc_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RpcError = undefined;

  class RpcError extends Error {
    constructor(message, code = "UNKNOWN", meta) {
      super(message);
      this.name = "RpcError";
      Object.setPrototypeOf(this, new.target.prototype);
      this.code = code;
      this.meta = meta !== null && meta !== undefined ? meta : {};
    }
    toString() {
      const l = [this.name + ": " + this.message];
      if (this.code) {
        l.push("");
        l.push("Code: " + this.code);
      }
      if (this.serviceName && this.methodName) {
        l.push("Method: " + this.serviceName + "/" + this.methodName);
      }
      let m = Object.entries(this.meta);
      if (m.length) {
        l.push("");
        l.push("Meta:");
        for (let [k, v] of m) {
          l.push(`  ${k}: ${v}`);
        }
      }
      return l.join(`
`);
    }
  }
  exports.RpcError = RpcError;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-options.js
var require_rpc_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeRpcOptions = undefined;
  var runtime_1 = require_commonjs();
  function mergeRpcOptions(defaults, options) {
    if (!options)
      return defaults;
    let o = {};
    copy(defaults, o);
    copy(options, o);
    for (let key of Object.keys(options)) {
      let val = options[key];
      switch (key) {
        case "jsonOptions":
          o.jsonOptions = runtime_1.mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);
          break;
        case "binaryOptions":
          o.binaryOptions = runtime_1.mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);
          break;
        case "meta":
          o.meta = {};
          copy(defaults.meta, o.meta);
          copy(options.meta, o.meta);
          break;
        case "interceptors":
          o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
          break;
      }
    }
    return o;
  }
  exports.mergeRpcOptions = mergeRpcOptions;
  function copy(a, into) {
    if (!a)
      return;
    let c = into;
    for (let [k, v] of Object.entries(a)) {
      if (v instanceof Date)
        c[k] = new Date(v.getTime());
      else if (Array.isArray(v))
        c[k] = v.concat();
      else
        c[k] = v;
    }
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/deferred.js
var require_deferred = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = exports.DeferredState = undefined;
  var DeferredState;
  (function(DeferredState2) {
    DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
    DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
    DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
  })(DeferredState = exports.DeferredState || (exports.DeferredState = {}));

  class Deferred {
    constructor(preventUnhandledRejectionWarning = true) {
      this._state = DeferredState.PENDING;
      this._promise = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
      if (preventUnhandledRejectionWarning) {
        this._promise.catch((_2) => {});
      }
    }
    get state() {
      return this._state;
    }
    get promise() {
      return this._promise;
    }
    resolve(value) {
      if (this.state !== DeferredState.PENDING)
        throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
      this._resolve(value);
      this._state = DeferredState.RESOLVED;
    }
    reject(reason) {
      if (this.state !== DeferredState.PENDING)
        throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
      this._reject(reason);
      this._state = DeferredState.REJECTED;
    }
    resolvePending(val) {
      if (this._state === DeferredState.PENDING)
        this.resolve(val);
    }
    rejectPending(reason) {
      if (this._state === DeferredState.PENDING)
        this.reject(reason);
    }
  }
  exports.Deferred = Deferred;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-output-stream.js
var require_rpc_output_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RpcOutputStreamController = undefined;
  var deferred_1 = require_deferred();
  var runtime_1 = require_commonjs();

  class RpcOutputStreamController {
    constructor() {
      this._lis = {
        nxt: [],
        msg: [],
        err: [],
        cmp: []
      };
      this._closed = false;
      this._itState = { q: [] };
    }
    onNext(callback) {
      return this.addLis(callback, this._lis.nxt);
    }
    onMessage(callback) {
      return this.addLis(callback, this._lis.msg);
    }
    onError(callback) {
      return this.addLis(callback, this._lis.err);
    }
    onComplete(callback) {
      return this.addLis(callback, this._lis.cmp);
    }
    addLis(callback, list) {
      list.push(callback);
      return () => {
        let i = list.indexOf(callback);
        if (i >= 0)
          list.splice(i, 1);
      };
    }
    clearLis() {
      for (let l of Object.values(this._lis))
        l.splice(0, l.length);
    }
    get closed() {
      return this._closed !== false;
    }
    notifyNext(message, error, complete) {
      runtime_1.assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
      if (message)
        this.notifyMessage(message);
      if (error)
        this.notifyError(error);
      if (complete)
        this.notifyComplete();
    }
    notifyMessage(message) {
      runtime_1.assert(!this.closed, "stream is closed");
      this.pushIt({ value: message, done: false });
      this._lis.msg.forEach((l) => l(message));
      this._lis.nxt.forEach((l) => l(message, undefined, false));
    }
    notifyError(error) {
      runtime_1.assert(!this.closed, "stream is closed");
      this._closed = error;
      this.pushIt(error);
      this._lis.err.forEach((l) => l(error));
      this._lis.nxt.forEach((l) => l(undefined, error, false));
      this.clearLis();
    }
    notifyComplete() {
      runtime_1.assert(!this.closed, "stream is closed");
      this._closed = true;
      this.pushIt({ value: null, done: true });
      this._lis.cmp.forEach((l) => l());
      this._lis.nxt.forEach((l) => l(undefined, undefined, true));
      this.clearLis();
    }
    [Symbol.asyncIterator]() {
      if (this._closed === true)
        this.pushIt({ value: null, done: true });
      else if (this._closed !== false)
        this.pushIt(this._closed);
      return {
        next: () => {
          let state = this._itState;
          runtime_1.assert(state, "bad state");
          runtime_1.assert(!state.p, "iterator contract broken");
          let first = state.q.shift();
          if (first)
            return "value" in first ? Promise.resolve(first) : Promise.reject(first);
          state.p = new deferred_1.Deferred;
          return state.p.promise;
        }
      };
    }
    pushIt(result) {
      let state = this._itState;
      if (state.p) {
        const p = state.p;
        runtime_1.assert(p.state == deferred_1.DeferredState.PENDING, "iterator contract broken");
        "value" in result ? p.resolve(result) : p.reject(result);
        delete state.p;
      } else {
        state.q.push(result);
      }
    }
  }
  exports.RpcOutputStreamController = RpcOutputStreamController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/unary-call.js
var require_unary_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnaryCall = undefined;

  class UnaryCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.request = request;
      this.headers = headers;
      this.response = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.UnaryCall = UnaryCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-streaming-call.js
var require_server_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerStreamingCall = undefined;

  class ServerStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.request = request;
      this.headers = headers;
      this.responses = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.ServerStreamingCall = ServerStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/client-streaming-call.js
var require_client_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientStreamingCall = undefined;

  class ClientStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.requests = request;
      this.headers = headers;
      this.response = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.ClientStreamingCall = ClientStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/duplex-streaming-call.js
var require_duplex_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DuplexStreamingCall = undefined;

  class DuplexStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.requests = request;
      this.headers = headers;
      this.responses = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.DuplexStreamingCall = DuplexStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/test-transport.js
var require_test_transport = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTransport = undefined;
  var rpc_error_1 = require_rpc_error();
  var runtime_1 = require_commonjs();
  var rpc_output_stream_1 = require_rpc_output_stream();
  var rpc_options_1 = require_rpc_options();
  var unary_call_1 = require_unary_call();
  var server_streaming_call_1 = require_server_streaming_call();
  var client_streaming_call_1 = require_client_streaming_call();
  var duplex_streaming_call_1 = require_duplex_streaming_call();

  class TestTransport {
    constructor(data) {
      this.suppressUncaughtRejections = true;
      this.headerDelay = 10;
      this.responseDelay = 50;
      this.betweenResponseDelay = 10;
      this.afterResponseDelay = 10;
      this.data = data !== null && data !== undefined ? data : {};
    }
    get sentMessages() {
      if (this.lastInput instanceof TestInputStream) {
        return this.lastInput.sent;
      } else if (typeof this.lastInput == "object") {
        return [this.lastInput.single];
      }
      return [];
    }
    get sendComplete() {
      if (this.lastInput instanceof TestInputStream) {
        return this.lastInput.completed;
      } else if (typeof this.lastInput == "object") {
        return true;
      }
      return false;
    }
    promiseHeaders() {
      var _a;
      const headers = (_a = this.data.headers) !== null && _a !== undefined ? _a : TestTransport.defaultHeaders;
      return headers instanceof rpc_error_1.RpcError ? Promise.reject(headers) : Promise.resolve(headers);
    }
    promiseSingleResponse(method) {
      if (this.data.response instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.response);
      }
      let r;
      if (Array.isArray(this.data.response)) {
        runtime_1.assert(this.data.response.length > 0);
        r = this.data.response[0];
      } else if (this.data.response !== undefined) {
        r = this.data.response;
      } else {
        r = method.O.create();
      }
      runtime_1.assert(method.O.is(r));
      return Promise.resolve(r);
    }
    streamResponses(method, stream, abort) {
      return __awaiter(this, undefined, undefined, function* () {
        const messages = [];
        if (this.data.response === undefined) {
          messages.push(method.O.create());
        } else if (Array.isArray(this.data.response)) {
          for (let msg of this.data.response) {
            runtime_1.assert(method.O.is(msg));
            messages.push(msg);
          }
        } else if (!(this.data.response instanceof rpc_error_1.RpcError)) {
          runtime_1.assert(method.O.is(this.data.response));
          messages.push(this.data.response);
        }
        try {
          yield delay(this.responseDelay, abort)(undefined);
        } catch (error) {
          stream.notifyError(error);
          return;
        }
        if (this.data.response instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.response);
          return;
        }
        for (let msg of messages) {
          stream.notifyMessage(msg);
          try {
            yield delay(this.betweenResponseDelay, abort)(undefined);
          } catch (error) {
            stream.notifyError(error);
            return;
          }
        }
        if (this.data.status instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.status);
          return;
        }
        if (this.data.trailers instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.trailers);
          return;
        }
        stream.notifyComplete();
      });
    }
    promiseStatus() {
      var _a;
      const status = (_a = this.data.status) !== null && _a !== undefined ? _a : TestTransport.defaultStatus;
      return status instanceof rpc_error_1.RpcError ? Promise.reject(status) : Promise.resolve(status);
    }
    promiseTrailers() {
      var _a;
      const trailers = (_a = this.data.trailers) !== null && _a !== undefined ? _a : TestTransport.defaultTrailers;
      return trailers instanceof rpc_error_1.RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
    }
    maybeSuppressUncaught(...promise) {
      if (this.suppressUncaughtRejections) {
        for (let p of promise) {
          p.catch(() => {});
        }
      }
    }
    mergeOptions(options) {
      return rpc_options_1.mergeRpcOptions({}, options);
    }
    unary(method, input, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {}).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = { single: input };
      return new unary_call_1.UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    serverStreaming(method, input, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {}).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = { single: input };
      return new server_streaming_call_1.ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
    }
    clientStreaming(method, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {}).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = new TestInputStream(this.data, options.abort);
      return new client_streaming_call_1.ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    duplex(method, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {}).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = new TestInputStream(this.data, options.abort);
      return new duplex_streaming_call_1.DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
    }
  }
  exports.TestTransport = TestTransport;
  TestTransport.defaultHeaders = {
    responseHeader: "test"
  };
  TestTransport.defaultStatus = {
    code: "OK",
    detail: "all good"
  };
  TestTransport.defaultTrailers = {
    responseTrailer: "test"
  };
  function delay(ms, abort) {
    return (v) => new Promise((resolve, reject) => {
      if (abort === null || abort === undefined ? undefined : abort.aborted) {
        reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
      } else {
        const id = setTimeout(() => resolve(v), ms);
        if (abort) {
          abort.addEventListener("abort", (ev) => {
            clearTimeout(id);
            reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
          });
        }
      }
    });
  }

  class TestInputStream {
    constructor(data, abort) {
      this._completed = false;
      this._sent = [];
      this.data = data;
      this.abort = abort;
    }
    get sent() {
      return this._sent;
    }
    get completed() {
      return this._completed;
    }
    send(message) {
      if (this.data.inputMessage instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.inputMessage);
      }
      const delayMs = this.data.inputMessage === undefined ? 10 : this.data.inputMessage;
      return Promise.resolve(undefined).then(() => {
        this._sent.push(message);
      }).then(delay(delayMs, this.abort));
    }
    complete() {
      if (this.data.inputComplete instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.inputComplete);
      }
      const delayMs = this.data.inputComplete === undefined ? 10 : this.data.inputComplete;
      return Promise.resolve(undefined).then(() => {
        this._completed = true;
      }).then(delay(delayMs, this.abort));
    }
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-interceptor.js
var require_rpc_interceptor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stackDuplexStreamingInterceptors = exports.stackClientStreamingInterceptors = exports.stackServerStreamingInterceptors = exports.stackUnaryInterceptors = exports.stackIntercept = undefined;
  var runtime_1 = require_commonjs();
  function stackIntercept(kind, transport, method, options, input) {
    var _a, _b, _c, _d;
    if (kind == "unary") {
      let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
      for (const curr of ((_a = options.interceptors) !== null && _a !== undefined ? _a : []).filter((i) => i.interceptUnary).reverse()) {
        const next = tail;
        tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "serverStreaming") {
      let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
      for (const curr of ((_b = options.interceptors) !== null && _b !== undefined ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
        const next = tail;
        tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "clientStreaming") {
      let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
      for (const curr of ((_c = options.interceptors) !== null && _c !== undefined ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
        const next = tail;
        tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
      }
      return tail(method, options);
    }
    if (kind == "duplex") {
      let tail = (mtd, opt) => transport.duplex(mtd, opt);
      for (const curr of ((_d = options.interceptors) !== null && _d !== undefined ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
        const next = tail;
        tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
      }
      return tail(method, options);
    }
    runtime_1.assertNever(kind);
  }
  exports.stackIntercept = stackIntercept;
  function stackUnaryInterceptors(transport, method, input, options) {
    return stackIntercept("unary", transport, method, options, input);
  }
  exports.stackUnaryInterceptors = stackUnaryInterceptors;
  function stackServerStreamingInterceptors(transport, method, input, options) {
    return stackIntercept("serverStreaming", transport, method, options, input);
  }
  exports.stackServerStreamingInterceptors = stackServerStreamingInterceptors;
  function stackClientStreamingInterceptors(transport, method, options) {
    return stackIntercept("clientStreaming", transport, method, options);
  }
  exports.stackClientStreamingInterceptors = stackClientStreamingInterceptors;
  function stackDuplexStreamingInterceptors(transport, method, options) {
    return stackIntercept("duplex", transport, method, options);
  }
  exports.stackDuplexStreamingInterceptors = stackDuplexStreamingInterceptors;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-call-context.js
var require_server_call_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCallContextController = undefined;

  class ServerCallContextController {
    constructor(method, headers, deadline, sendResponseHeadersFn, defaultStatus = { code: "OK", detail: "" }) {
      this._cancelled = false;
      this._listeners = [];
      this.method = method;
      this.headers = headers;
      this.deadline = deadline;
      this.trailers = {};
      this._sendRH = sendResponseHeadersFn;
      this.status = defaultStatus;
    }
    notifyCancelled() {
      if (!this._cancelled) {
        this._cancelled = true;
        for (let l of this._listeners) {
          l();
        }
      }
    }
    sendResponseHeaders(data) {
      this._sendRH(data);
    }
    get cancelled() {
      return this._cancelled;
    }
    onCancel(callback) {
      const l = this._listeners;
      l.push(callback);
      return () => {
        let i = l.indexOf(callback);
        if (i >= 0)
          l.splice(i, 1);
      };
    }
  }
  exports.ServerCallContextController = ServerCallContextController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/index.js
var require_commonjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var service_type_1 = require_service_type();
  Object.defineProperty(exports, "ServiceType", { enumerable: true, get: function() {
    return service_type_1.ServiceType;
  } });
  var reflection_info_1 = require_reflection_info2();
  Object.defineProperty(exports, "readMethodOptions", { enumerable: true, get: function() {
    return reflection_info_1.readMethodOptions;
  } });
  Object.defineProperty(exports, "readMethodOption", { enumerable: true, get: function() {
    return reflection_info_1.readMethodOption;
  } });
  Object.defineProperty(exports, "readServiceOption", { enumerable: true, get: function() {
    return reflection_info_1.readServiceOption;
  } });
  var rpc_error_1 = require_rpc_error();
  Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
    return rpc_error_1.RpcError;
  } });
  var rpc_options_1 = require_rpc_options();
  Object.defineProperty(exports, "mergeRpcOptions", { enumerable: true, get: function() {
    return rpc_options_1.mergeRpcOptions;
  } });
  var rpc_output_stream_1 = require_rpc_output_stream();
  Object.defineProperty(exports, "RpcOutputStreamController", { enumerable: true, get: function() {
    return rpc_output_stream_1.RpcOutputStreamController;
  } });
  var test_transport_1 = require_test_transport();
  Object.defineProperty(exports, "TestTransport", { enumerable: true, get: function() {
    return test_transport_1.TestTransport;
  } });
  var deferred_1 = require_deferred();
  Object.defineProperty(exports, "Deferred", { enumerable: true, get: function() {
    return deferred_1.Deferred;
  } });
  Object.defineProperty(exports, "DeferredState", { enumerable: true, get: function() {
    return deferred_1.DeferredState;
  } });
  var duplex_streaming_call_1 = require_duplex_streaming_call();
  Object.defineProperty(exports, "DuplexStreamingCall", { enumerable: true, get: function() {
    return duplex_streaming_call_1.DuplexStreamingCall;
  } });
  var client_streaming_call_1 = require_client_streaming_call();
  Object.defineProperty(exports, "ClientStreamingCall", { enumerable: true, get: function() {
    return client_streaming_call_1.ClientStreamingCall;
  } });
  var server_streaming_call_1 = require_server_streaming_call();
  Object.defineProperty(exports, "ServerStreamingCall", { enumerable: true, get: function() {
    return server_streaming_call_1.ServerStreamingCall;
  } });
  var unary_call_1 = require_unary_call();
  Object.defineProperty(exports, "UnaryCall", { enumerable: true, get: function() {
    return unary_call_1.UnaryCall;
  } });
  var rpc_interceptor_1 = require_rpc_interceptor();
  Object.defineProperty(exports, "stackIntercept", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackIntercept;
  } });
  Object.defineProperty(exports, "stackDuplexStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackDuplexStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackClientStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackClientStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackServerStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackServerStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackUnaryInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackUnaryInterceptors;
  } });
  var server_call_context_1 = require_server_call_context();
  Object.defineProperty(exports, "ServerCallContextController", { enumerable: true, get: function() {
    return server_call_context_1.ServerCallContextController;
  } });
});

// node_modules/@actions/artifact/lib/generated/results/api/v1/artifact.js
var require_artifact = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArtifactService = exports.DeleteArtifactResponse = exports.DeleteArtifactRequest = exports.GetSignedArtifactURLResponse = exports.GetSignedArtifactURLRequest = exports.ListArtifactsResponse_MonolithArtifact = exports.ListArtifactsResponse = exports.ListArtifactsRequest = exports.FinalizeArtifactResponse = exports.FinalizeArtifactRequest = exports.CreateArtifactResponse = exports.CreateArtifactRequest = exports.FinalizeMigratedArtifactResponse = exports.FinalizeMigratedArtifactRequest = exports.MigrateArtifactResponse = exports.MigrateArtifactRequest = undefined;
  var runtime_rpc_1 = require_commonjs2();
  var runtime_1 = require_commonjs();
  var runtime_2 = require_commonjs();
  var runtime_3 = require_commonjs();
  var runtime_4 = require_commonjs();
  var runtime_5 = require_commonjs();
  var wrappers_1 = require_wrappers();
  var wrappers_2 = require_wrappers();
  var timestamp_1 = require_timestamp();

  class MigrateArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.MigrateArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        { no: 3, name: "expires_at", kind: "message", T: () => timestamp_1.Timestamp }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", name: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.name = reader.string();
            break;
          case 3:
            message.expiresAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.name !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.expiresAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.MigrateArtifactRequest = new MigrateArtifactRequest$Type;

  class MigrateArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.MigrateArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_upload_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { ok: false, signedUploadUrl: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedUploadUrl = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedUploadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.MigrateArtifactResponse = new MigrateArtifactResponse$Type;

  class FinalizeMigratedArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeMigratedArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        { no: 3, name: "size", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", name: "", size: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.name = reader.string();
            break;
          case 3:
            message.size = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.name !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.size !== "0")
        writer.tag(3, runtime_1.WireType.Varint).int64(message.size);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeMigratedArtifactRequest = new FinalizeMigratedArtifactRequest$Type;

  class FinalizeMigratedArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeMigratedArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "artifact_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { ok: false, artifactId: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.artifactId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.artifactId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeMigratedArtifactResponse = new FinalizeMigratedArtifactResponse$Type;

  class CreateArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 },
        { no: 4, name: "expires_at", kind: "message", T: () => timestamp_1.Timestamp },
        { no: 5, name: "version", kind: "scalar", T: 5 }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "", version: 0 };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.expiresAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
            break;
          case 5:
            message.version = reader.int32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.expiresAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.version !== 0)
        writer.tag(5, runtime_1.WireType.Varint).int32(message.version);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateArtifactRequest = new CreateArtifactRequest$Type;

  class CreateArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_upload_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { ok: false, signedUploadUrl: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedUploadUrl = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedUploadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateArtifactResponse = new CreateArtifactResponse$Type;

  class FinalizeArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 },
        { no: 4, name: "size", kind: "scalar", T: 3 },
        { no: 5, name: "hash", kind: "message", T: () => wrappers_2.StringValue }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "", size: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.size = reader.int64().toString();
            break;
          case 5:
            message.hash = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.hash);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.size !== "0")
        writer.tag(4, runtime_1.WireType.Varint).int64(message.size);
      if (message.hash)
        wrappers_2.StringValue.internalBinaryWrite(message.hash, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeArtifactRequest = new FinalizeArtifactRequest$Type;

  class FinalizeArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "artifact_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { ok: false, artifactId: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.artifactId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.artifactId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeArtifactResponse = new FinalizeArtifactResponse$Type;

  class ListArtifactsRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListArtifactsRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name_filter", kind: "message", T: () => wrappers_2.StringValue },
        { no: 4, name: "id_filter", kind: "message", T: () => wrappers_1.Int64Value }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", workflowJobRunBackendId: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.nameFilter = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.nameFilter);
            break;
          case 4:
            message.idFilter = wrappers_1.Int64Value.internalBinaryRead(reader, reader.uint32(), options, message.idFilter);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.nameFilter)
        wrappers_2.StringValue.internalBinaryWrite(message.nameFilter, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.idFilter)
        wrappers_1.Int64Value.internalBinaryWrite(message.idFilter, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListArtifactsRequest = new ListArtifactsRequest$Type;

  class ListArtifactsResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListArtifactsResponse", [
        { no: 1, name: "artifacts", kind: "message", repeat: 1, T: () => exports.ListArtifactsResponse_MonolithArtifact }
      ]);
    }
    create(value) {
      const message = { artifacts: [] };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.artifacts.push(exports.ListArtifactsResponse_MonolithArtifact.internalBinaryRead(reader, reader.uint32(), options));
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      for (let i = 0;i < message.artifacts.length; i++)
        exports.ListArtifactsResponse_MonolithArtifact.internalBinaryWrite(message.artifacts[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListArtifactsResponse = new ListArtifactsResponse$Type;

  class ListArtifactsResponse_MonolithArtifact$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListArtifactsResponse.MonolithArtifact", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "database_id", kind: "scalar", T: 3 },
        { no: 4, name: "name", kind: "scalar", T: 9 },
        { no: 5, name: "size", kind: "scalar", T: 3 },
        { no: 6, name: "created_at", kind: "message", T: () => timestamp_1.Timestamp },
        { no: 7, name: "digest", kind: "message", T: () => wrappers_2.StringValue }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", workflowJobRunBackendId: "", databaseId: "0", name: "", size: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.databaseId = reader.int64().toString();
            break;
          case 4:
            message.name = reader.string();
            break;
          case 5:
            message.size = reader.int64().toString();
            break;
          case 6:
            message.createdAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
            break;
          case 7:
            message.digest = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.digest);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.databaseId !== "0")
        writer.tag(3, runtime_1.WireType.Varint).int64(message.databaseId);
      if (message.name !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.size !== "0")
        writer.tag(5, runtime_1.WireType.Varint).int64(message.size);
      if (message.createdAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.digest)
        wrappers_2.StringValue.internalBinaryWrite(message.digest, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListArtifactsResponse_MonolithArtifact = new ListArtifactsResponse_MonolithArtifact$Type;

  class GetSignedArtifactURLRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetSignedArtifactURLRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetSignedArtifactURLRequest = new GetSignedArtifactURLRequest$Type;

  class GetSignedArtifactURLResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetSignedArtifactURLResponse", [
        { no: 1, name: "signed_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { signedUrl: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.signedUrl = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.signedUrl !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.signedUrl);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetSignedArtifactURLResponse = new GetSignedArtifactURLResponse$Type;

  class DeleteArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.DeleteArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DeleteArtifactRequest = new DeleteArtifactRequest$Type;

  class DeleteArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.DeleteArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "artifact_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { ok: false, artifactId: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.artifactId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.artifactId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DeleteArtifactResponse = new DeleteArtifactResponse$Type;
  exports.ArtifactService = new runtime_rpc_1.ServiceType("github.actions.results.api.v1.ArtifactService", [
    { name: "CreateArtifact", options: {}, I: exports.CreateArtifactRequest, O: exports.CreateArtifactResponse },
    { name: "FinalizeArtifact", options: {}, I: exports.FinalizeArtifactRequest, O: exports.FinalizeArtifactResponse },
    { name: "ListArtifacts", options: {}, I: exports.ListArtifactsRequest, O: exports.ListArtifactsResponse },
    { name: "GetSignedArtifactURL", options: {}, I: exports.GetSignedArtifactURLRequest, O: exports.GetSignedArtifactURLResponse },
    { name: "DeleteArtifact", options: {}, I: exports.DeleteArtifactRequest, O: exports.DeleteArtifactResponse },
    { name: "MigrateArtifact", options: {}, I: exports.MigrateArtifactRequest, O: exports.MigrateArtifactResponse },
    { name: "FinalizeMigratedArtifact", options: {}, I: exports.FinalizeMigratedArtifactRequest, O: exports.FinalizeMigratedArtifactResponse }
  ]);
});

// node_modules/@actions/artifact/lib/generated/results/api/v1/artifact.twirp-client.js
var require_artifact_twirp_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArtifactServiceClientProtobuf = exports.ArtifactServiceClientJSON = undefined;
  var artifact_1 = require_artifact();

  class ArtifactServiceClientJSON {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateArtifact.bind(this);
      this.FinalizeArtifact.bind(this);
      this.ListArtifacts.bind(this);
      this.GetSignedArtifactURL.bind(this);
      this.DeleteArtifact.bind(this);
    }
    CreateArtifact(request) {
      const data = artifact_1.CreateArtifactRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "CreateArtifact", "application/json", data);
      return promise.then((data2) => artifact_1.CreateArtifactResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    FinalizeArtifact(request) {
      const data = artifact_1.FinalizeArtifactRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "FinalizeArtifact", "application/json", data);
      return promise.then((data2) => artifact_1.FinalizeArtifactResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    ListArtifacts(request) {
      const data = artifact_1.ListArtifactsRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "ListArtifacts", "application/json", data);
      return promise.then((data2) => artifact_1.ListArtifactsResponse.fromJson(data2, { ignoreUnknownFields: true }));
    }
    GetSignedArtifactURL(request) {
      const data = artifact_1.GetSignedArtifactURLRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "GetSignedArtifactURL", "application/json", data);
      return promise.then((data2) => artifact_1.GetSignedArtifactURLResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    DeleteArtifact(request) {
      const data = artifact_1.DeleteArtifactRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "DeleteArtifact", "application/json", data);
      return promise.then((data2) => artifact_1.DeleteArtifactResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
  }
  exports.ArtifactServiceClientJSON = ArtifactServiceClientJSON;

  class ArtifactServiceClientProtobuf {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateArtifact.bind(this);
      this.FinalizeArtifact.bind(this);
      this.ListArtifacts.bind(this);
      this.GetSignedArtifactURL.bind(this);
      this.DeleteArtifact.bind(this);
    }
    CreateArtifact(request) {
      const data = artifact_1.CreateArtifactRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "CreateArtifact", "application/protobuf", data);
      return promise.then((data2) => artifact_1.CreateArtifactResponse.fromBinary(data2));
    }
    FinalizeArtifact(request) {
      const data = artifact_1.FinalizeArtifactRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "FinalizeArtifact", "application/protobuf", data);
      return promise.then((data2) => artifact_1.FinalizeArtifactResponse.fromBinary(data2));
    }
    ListArtifacts(request) {
      const data = artifact_1.ListArtifactsRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "ListArtifacts", "application/protobuf", data);
      return promise.then((data2) => artifact_1.ListArtifactsResponse.fromBinary(data2));
    }
    GetSignedArtifactURL(request) {
      const data = artifact_1.GetSignedArtifactURLRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "GetSignedArtifactURL", "application/protobuf", data);
      return promise.then((data2) => artifact_1.GetSignedArtifactURLResponse.fromBinary(data2));
    }
    DeleteArtifact(request) {
      const data = artifact_1.DeleteArtifactRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.ArtifactService", "DeleteArtifact", "application/protobuf", data);
      return promise.then((data2) => artifact_1.DeleteArtifactResponse.fromBinary(data2));
    }
  }
  exports.ArtifactServiceClientProtobuf = ArtifactServiceClientProtobuf;
});

// node_modules/@actions/artifact/lib/generated/index.js
var require_generated = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_timestamp(), exports);
  __exportStar(require_wrappers(), exports);
  __exportStar(require_artifact(), exports);
  __exportStar(require_artifact_twirp_client(), exports);
});

// node_modules/@actions/artifact/lib/internal/upload/retention.js
var require_retention = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getExpiration = getExpiration;
  var generated_1 = require_generated();
  var core = __importStar(require_core());
  function getExpiration(retentionDays) {
    if (!retentionDays) {
      return;
    }
    const maxRetentionDays = getRetentionDays();
    if (maxRetentionDays && maxRetentionDays < retentionDays) {
      core.warning(`Retention days cannot be greater than the maximum allowed retention set within the repository. Using ${maxRetentionDays} instead.`);
      retentionDays = maxRetentionDays;
    }
    const expirationDate = new Date;
    expirationDate.setDate(expirationDate.getDate() + retentionDays);
    return generated_1.Timestamp.fromDate(expirationDate);
  }
  function getRetentionDays() {
    const retentionDays = process.env["GITHUB_RETENTION_DAYS"];
    if (!retentionDays) {
      return;
    }
    const days = parseInt(retentionDays);
    if (isNaN(days)) {
      return;
    }
    return days;
  }
});

// node_modules/@actions/artifact/lib/internal/upload/path-and-artifact-name-validation.js
var require_path_and_artifact_name_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateArtifactName = validateArtifactName;
  exports.validateFilePath = validateFilePath;
  var core_1 = require_core();
  var invalidArtifactFilePathCharacters = new Map([
    ['"', ' Double quote "'],
    [":", " Colon :"],
    ["<", " Less than <"],
    [">", " Greater than >"],
    ["|", " Vertical bar |"],
    ["*", " Asterisk *"],
    ["?", " Question mark ?"],
    ["\r", " Carriage return \\r"],
    [`
`, " Line feed \\n"]
  ]);
  var invalidArtifactNameCharacters = new Map([
    ...invalidArtifactFilePathCharacters,
    ["\\", " Backslash \\"],
    ["/", " Forward slash /"]
  ]);
  function validateArtifactName(name) {
    if (!name) {
      throw new Error(`Provided artifact name input during validation is empty`);
    }
    for (const [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactNameCharacters) {
      if (name.includes(invalidCharacterKey)) {
        throw new Error(`The artifact name is not valid: ${name}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactNameCharacters.values()).toString()}
          
These characters are not allowed in the artifact name due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.`);
      }
    }
    (0, core_1.info)(`Artifact name is valid!`);
  }
  function validateFilePath(path) {
    if (!path) {
      throw new Error(`Provided file path input during validation is empty`);
    }
    for (const [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactFilePathCharacters) {
      if (path.includes(invalidCharacterKey)) {
        throw new Error(`The path for one of the files in artifact is not valid: ${path}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactFilePathCharacters.values()).toString()}
          
The following characters are not allowed in files that are uploaded due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.
          `);
      }
    }
  }
});

// node_modules/@actions/artifact/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "@actions/artifact",
    version: "5.0.2",
    preview: true,
    description: "Actions artifact lib",
    keywords: [
      "github",
      "actions",
      "artifact"
    ],
    homepage: "https://github.com/actions/toolkit/tree/main/packages/artifact",
    license: "MIT",
    main: "lib/artifact.js",
    types: "lib/artifact.d.ts",
    directories: {
      lib: "lib",
      test: "__tests__"
    },
    files: [
      "lib",
      "!.DS_Store"
    ],
    publishConfig: {
      access: "public"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/actions/toolkit.git",
      directory: "packages/artifact"
    },
    scripts: {
      "audit-moderate": "npm install && npm audit --json --audit-level=moderate > audit.json",
      test: "cd ../../ && npm run test ./packages/artifact",
      bootstrap: "cd ../../ && npm run bootstrap",
      "tsc-run": "tsc",
      tsc: "npm run bootstrap && npm run tsc-run",
      "gen:docs": "typedoc --plugin typedoc-plugin-markdown --out docs/generated src/artifact.ts --githubPages false --readme none"
    },
    bugs: {
      url: "https://github.com/actions/toolkit/issues"
    },
    dependencies: {
      "@actions/core": "^2.0.0",
      "@actions/github": "^6.0.1",
      "@actions/http-client": "^3.0.1",
      "@azure/storage-blob": "^12.29.1",
      "@octokit/core": "^5.2.1",
      "@octokit/plugin-request-log": "^1.0.4",
      "@octokit/plugin-retry": "^3.0.9",
      "@octokit/request": "^8.4.1",
      "@octokit/request-error": "^5.1.1",
      "@protobuf-ts/plugin": "^2.2.3-alpha.1",
      archiver: "^7.0.1",
      "jwt-decode": "^3.1.2",
      "unzip-stream": "^0.3.1"
    },
    devDependencies: {
      "@types/archiver": "^5.3.2",
      "@types/unzip-stream": "^0.3.4",
      typedoc: "^0.28.13",
      "typedoc-plugin-markdown": "^3.17.1",
      typescript: "^5.2.2"
    },
    overrides: {
      "uri-js": "npm:uri-js-replace@^1.0.1",
      "node-fetch": "^3.3.2"
    }
  };
});

// node_modules/@actions/artifact/lib/internal/shared/user-agent.js
var require_user_agent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentString = getUserAgentString;
  var packageJson = require_package();
  function getUserAgentString() {
    return `@actions/artifact-${packageJson.version}`;
  }
});

// node_modules/@actions/artifact/lib/internal/shared/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UsageError = exports.NetworkError = exports.GHESNotSupportedError = exports.ArtifactNotFoundError = exports.InvalidResponseError = exports.FilesNotFoundError = undefined;

  class FilesNotFoundError extends Error {
    constructor(files = []) {
      let message = "No files were found to upload";
      if (files.length > 0) {
        message += `: ${files.join(", ")}`;
      }
      super(message);
      this.files = files;
      this.name = "FilesNotFoundError";
    }
  }
  exports.FilesNotFoundError = FilesNotFoundError;

  class InvalidResponseError extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidResponseError";
    }
  }
  exports.InvalidResponseError = InvalidResponseError;

  class ArtifactNotFoundError extends Error {
    constructor(message = "Artifact not found") {
      super(message);
      this.name = "ArtifactNotFoundError";
    }
  }
  exports.ArtifactNotFoundError = ArtifactNotFoundError;

  class GHESNotSupportedError extends Error {
    constructor(message = "@actions/artifact v2.0.0+, upload-artifact@v4+ and download-artifact@v4+ are not currently supported on GHES.") {
      super(message);
      this.name = "GHESNotSupportedError";
    }
  }
  exports.GHESNotSupportedError = GHESNotSupportedError;

  class NetworkError extends Error {
    constructor(code) {
      const message = `Unable to make request: ${code}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
      super(message);
      this.code = code;
      this.name = "NetworkError";
    }
  }
  exports.NetworkError = NetworkError;
  NetworkError.isNetworkErrorCode = (code) => {
    if (!code)
      return false;
    return [
      "ECONNRESET",
      "ENOTFOUND",
      "ETIMEDOUT",
      "ECONNREFUSED",
      "EHOSTUNREACH"
    ].includes(code);
  };

  class UsageError extends Error {
    constructor() {
      const message = `Artifact storage quota has been hit. Unable to upload any new artifacts. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`;
      super(message);
      this.name = "UsageError";
    }
  }
  exports.UsageError = UsageError;
  UsageError.isUsageErrorMessage = (msg) => {
    if (!msg)
      return false;
    return msg.includes("insufficient usage");
  };
});

// node_modules/jwt-decode/build/jwt-decode.cjs.js
var require_jwt_decode_cjs = __commonJS((exports, module) => {
  function e(e2) {
    this.message = e2;
  }
  e.prototype = new Error, e.prototype.name = "InvalidCharacterError";
  var r = typeof window != "undefined" && window.atob && window.atob.bind(window) || function(r2) {
    var t2 = String(r2).replace(/=+$/, "");
    if (t2.length % 4 == 1)
      throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var n2, o2, a2 = 0, i = 0, c = "";o2 = t2.charAt(i++); ~o2 && (n2 = a2 % 4 ? 64 * n2 + o2 : o2, a2++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a2 & 6)) : 0)
      o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
    return c;
  };
  function t(e2) {
    var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
    switch (t2.length % 4) {
      case 0:
        break;
      case 2:
        t2 += "==";
        break;
      case 3:
        t2 += "=";
        break;
      default:
        throw "Illegal base64url string!";
    }
    try {
      return function(e3) {
        return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
          var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
          return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
        }));
      }(t2);
    } catch (e3) {
      return r(t2);
    }
  }
  function n(e2) {
    this.message = e2;
  }
  function o(e2, r2) {
    if (typeof e2 != "string")
      throw new n("Invalid token specified");
    var o2 = (r2 = r2 || {}).header === true ? 0 : 1;
    try {
      return JSON.parse(t(e2.split(".")[o2]));
    } catch (e3) {
      throw new n("Invalid token specified: " + e3.message);
    }
  }
  n.prototype = new Error, n.prototype.name = "InvalidTokenError";
  var a = o;
  a.default = o, a.InvalidTokenError = n, module.exports = a;
});

// node_modules/@actions/artifact/lib/internal/shared/util.js
var require_util9 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBackendIdsFromToken = getBackendIdsFromToken;
  exports.maskSigUrl = maskSigUrl;
  exports.maskSecretUrls = maskSecretUrls;
  var core = __importStar(require_core());
  var config_1 = require_config();
  var jwt_decode_1 = __importDefault(require_jwt_decode_cjs());
  var core_1 = require_core();
  var InvalidJwtError = new Error("Failed to get backend IDs: The provided JWT token is invalid and/or missing claims");
  function getBackendIdsFromToken() {
    const token = (0, config_1.getRuntimeToken)();
    const decoded = (0, jwt_decode_1.default)(token);
    if (!decoded.scp) {
      throw InvalidJwtError;
    }
    const scpParts = decoded.scp.split(" ");
    if (scpParts.length === 0) {
      throw InvalidJwtError;
    }
    for (const scopes of scpParts) {
      const scopeParts = scopes.split(":");
      if ((scopeParts === null || scopeParts === undefined ? undefined : scopeParts[0]) !== "Actions.Results") {
        continue;
      }
      if (scopeParts.length !== 3) {
        throw InvalidJwtError;
      }
      const ids = {
        workflowRunBackendId: scopeParts[1],
        workflowJobRunBackendId: scopeParts[2]
      };
      core.debug(`Workflow Run Backend ID: ${ids.workflowRunBackendId}`);
      core.debug(`Workflow Job Run Backend ID: ${ids.workflowJobRunBackendId}`);
      return ids;
    }
    throw InvalidJwtError;
  }
  function maskSigUrl(url) {
    if (!url)
      return;
    try {
      const parsedUrl = new URL(url);
      const signature = parsedUrl.searchParams.get("sig");
      if (signature) {
        (0, core_1.setSecret)(signature);
        (0, core_1.setSecret)(encodeURIComponent(signature));
      }
    } catch (error) {
      (0, core_1.debug)(`Failed to parse URL: ${url} ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  function maskSecretUrls(body) {
    if (typeof body !== "object" || body === null) {
      (0, core_1.debug)("body is not an object or is null");
      return;
    }
    if ("signed_upload_url" in body && typeof body.signed_upload_url === "string") {
      maskSigUrl(body.signed_upload_url);
    }
    if ("signed_url" in body && typeof body.signed_url === "string") {
      maskSigUrl(body.signed_url);
    }
  }
});

// node_modules/@actions/artifact/lib/internal/shared/artifact-twirp-client.js
var require_artifact_twirp_client2 = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.internalArtifactTwirpClient = internalArtifactTwirpClient;
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var core_1 = require_core();
  var generated_1 = require_generated();
  var config_1 = require_config();
  var user_agent_1 = require_user_agent();
  var errors_1 = require_errors2();
  var util_1 = require_util9();

  class ArtifactHttpClient {
    constructor(userAgent, maxAttempts, baseRetryIntervalMilliseconds, retryMultiplier) {
      this.maxAttempts = 5;
      this.baseRetryIntervalMilliseconds = 3000;
      this.retryMultiplier = 1.5;
      const token = (0, config_1.getRuntimeToken)();
      this.baseUrl = (0, config_1.getResultsServiceUrl)();
      if (maxAttempts) {
        this.maxAttempts = maxAttempts;
      }
      if (baseRetryIntervalMilliseconds) {
        this.baseRetryIntervalMilliseconds = baseRetryIntervalMilliseconds;
      }
      if (retryMultiplier) {
        this.retryMultiplier = retryMultiplier;
      }
      this.httpClient = new http_client_1.HttpClient(userAgent, [
        new auth_1.BearerCredentialHandler(token)
      ]);
    }
    request(service, method, contentType, data) {
      return __awaiter(this, undefined, undefined, function* () {
        const url = new URL(`/twirp/${service}/${method}`, this.baseUrl).href;
        (0, core_1.debug)(`[Request] ${method} ${url}`);
        const headers = {
          "Content-Type": contentType
        };
        try {
          const { body } = yield this.retryableRequest(() => __awaiter(this, undefined, undefined, function* () {
            return this.httpClient.post(url, JSON.stringify(data), headers);
          }));
          return body;
        } catch (error) {
          throw new Error(`Failed to ${method}: ${error.message}`);
        }
      });
    }
    retryableRequest(operation) {
      return __awaiter(this, undefined, undefined, function* () {
        let attempt = 0;
        let errorMessage = "";
        let rawBody = "";
        while (attempt < this.maxAttempts) {
          let isRetryable = false;
          try {
            const response = yield operation();
            const statusCode = response.message.statusCode;
            rawBody = yield response.readBody();
            (0, core_1.debug)(`[Response] - ${response.message.statusCode}`);
            (0, core_1.debug)(`Headers: ${JSON.stringify(response.message.headers, null, 2)}`);
            const body = JSON.parse(rawBody);
            (0, util_1.maskSecretUrls)(body);
            (0, core_1.debug)(`Body: ${JSON.stringify(body, null, 2)}`);
            if (this.isSuccessStatusCode(statusCode)) {
              return { response, body };
            }
            isRetryable = this.isRetryableHttpStatusCode(statusCode);
            errorMessage = `Failed request: (${statusCode}) ${response.message.statusMessage}`;
            if (body.msg) {
              if (errors_1.UsageError.isUsageErrorMessage(body.msg)) {
                throw new errors_1.UsageError;
              }
              errorMessage = `${errorMessage}: ${body.msg}`;
            }
          } catch (error) {
            if (error instanceof SyntaxError) {
              (0, core_1.debug)(`Raw Body: ${rawBody}`);
            }
            if (error instanceof errors_1.UsageError) {
              throw error;
            }
            if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === undefined ? undefined : error.code)) {
              throw new errors_1.NetworkError(error === null || error === undefined ? undefined : error.code);
            }
            isRetryable = true;
            errorMessage = error.message;
          }
          if (!isRetryable) {
            throw new Error(`Received non-retryable error: ${errorMessage}`);
          }
          if (attempt + 1 === this.maxAttempts) {
            throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${errorMessage}`);
          }
          const retryTimeMilliseconds = this.getExponentialRetryTimeMilliseconds(attempt);
          (0, core_1.info)(`Attempt ${attempt + 1} of ${this.maxAttempts} failed with error: ${errorMessage}. Retrying request in ${retryTimeMilliseconds} ms...`);
          yield this.sleep(retryTimeMilliseconds);
          attempt++;
        }
        throw new Error(`Request failed`);
      });
    }
    isSuccessStatusCode(statusCode) {
      if (!statusCode)
        return false;
      return statusCode >= 200 && statusCode < 300;
    }
    isRetryableHttpStatusCode(statusCode) {
      if (!statusCode)
        return false;
      const retryableStatusCodes = [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.GatewayTimeout,
        http_client_1.HttpCodes.InternalServerError,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.TooManyRequests
      ];
      return retryableStatusCodes.includes(statusCode);
    }
    sleep(milliseconds) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => setTimeout(resolve, milliseconds));
      });
    }
    getExponentialRetryTimeMilliseconds(attempt) {
      if (attempt < 0) {
        throw new Error("attempt should be a positive integer");
      }
      if (attempt === 0) {
        return this.baseRetryIntervalMilliseconds;
      }
      const minTime = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, attempt);
      const maxTime = minTime * this.retryMultiplier;
      return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
    }
  }
  function internalArtifactTwirpClient(options) {
    const client = new ArtifactHttpClient((0, user_agent_1.getUserAgentString)(), options === null || options === undefined ? undefined : options.maxAttempts, options === null || options === undefined ? undefined : options.retryIntervalMs, options === null || options === undefined ? undefined : options.retryMultiplier);
    return new generated_1.ArtifactServiceClientJSON(client);
  }
});

// node_modules/@actions/artifact/lib/internal/upload/upload-zip-specification.js
var require_upload_zip_specification = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateRootDirectory = validateRootDirectory;
  exports.getUploadZipSpecification = getUploadZipSpecification;
  var fs = __importStar(__require("fs"));
  var core_1 = require_core();
  var path_1 = __require("path");
  var path_and_artifact_name_validation_1 = require_path_and_artifact_name_validation();
  function validateRootDirectory(rootDirectory) {
    if (!fs.existsSync(rootDirectory)) {
      throw new Error(`The provided rootDirectory ${rootDirectory} does not exist`);
    }
    if (!fs.statSync(rootDirectory).isDirectory()) {
      throw new Error(`The provided rootDirectory ${rootDirectory} is not a valid directory`);
    }
    (0, core_1.info)(`Root directory input is valid!`);
  }
  function getUploadZipSpecification(filesToZip, rootDirectory) {
    const specification = [];
    rootDirectory = (0, path_1.normalize)(rootDirectory);
    rootDirectory = (0, path_1.resolve)(rootDirectory);
    for (let file of filesToZip) {
      const stats = fs.lstatSync(file, { throwIfNoEntry: false });
      if (!stats) {
        throw new Error(`File ${file} does not exist`);
      }
      if (!stats.isDirectory()) {
        file = (0, path_1.normalize)(file);
        file = (0, path_1.resolve)(file);
        if (!file.startsWith(rootDirectory)) {
          throw new Error(`The rootDirectory: ${rootDirectory} is not a parent directory of the file: ${file}`);
        }
        const uploadPath = file.replace(rootDirectory, "");
        (0, path_and_artifact_name_validation_1.validateFilePath)(uploadPath);
        specification.push({
          sourcePath: file,
          destinationPath: uploadPath,
          stats
        });
      } else {
        const directoryPath = file.replace(rootDirectory, "");
        (0, path_and_artifact_name_validation_1.validateFilePath)(directoryPath);
        specification.push({
          sourcePath: null,
          destinationPath: directoryPath,
          stats
        });
      }
    }
    return specification;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _2, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_2 = accept(result.get))
            descriptor.get = _2;
          if (_2 = accept(result.set))
            descriptor.set = _2;
          if (_2 = accept(result.init))
            initializers.unshift(_2);
        } else if (_2 = accept(result)) {
          if (kind === "field")
            initializers.unshift(_2);
          else
            descriptor[key] = _2;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/abort-controller/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/log.js
var require_log = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.log = log;
  var tslib_1 = require_tslib();
  var node_os_1 = __require("node:os");
  var node_util_1 = tslib_1.__importDefault(__require("node:util"));
  var node_process_1 = tslib_1.__importDefault(__require("node:process"));
  function log(message, ...args) {
    node_process_1.default.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/debug.js
var require_debug = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var log_js_1 = require_log();
  var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || undefined;
  var enabledString;
  var enabledNamespaces = [];
  var skippedNamespaces = [];
  var debuggers = [];
  if (debugEnvVariable) {
    enable(debugEnvVariable);
  }
  var debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
  }, {
    enable,
    enabled,
    disable,
    log: log_js_1.log
  });
  function enable(namespaces) {
    enabledString = namespaces;
    enabledNamespaces = [];
    skippedNamespaces = [];
    const namespaceList = namespaces.split(",").map((ns) => ns.trim());
    for (const ns of namespaceList) {
      if (ns.startsWith("-")) {
        skippedNamespaces.push(ns.substring(1));
      } else {
        enabledNamespaces.push(ns);
      }
    }
    for (const instance of debuggers) {
      instance.enabled = enabled(instance.namespace);
    }
  }
  function enabled(namespace) {
    if (namespace.endsWith("*")) {
      return true;
    }
    for (const skipped of skippedNamespaces) {
      if (namespaceMatches(namespace, skipped)) {
        return false;
      }
    }
    for (const enabledNamespace of enabledNamespaces) {
      if (namespaceMatches(namespace, enabledNamespace)) {
        return true;
      }
    }
    return false;
  }
  function namespaceMatches(namespace, patternToMatch) {
    if (patternToMatch.indexOf("*") === -1) {
      return namespace === patternToMatch;
    }
    let pattern = patternToMatch;
    if (patternToMatch.indexOf("**") !== -1) {
      const patternParts = [];
      let lastCharacter = "";
      for (const character of patternToMatch) {
        if (character === "*" && lastCharacter === "*") {
          continue;
        } else {
          lastCharacter = character;
          patternParts.push(character);
        }
      }
      pattern = patternParts.join("");
    }
    let namespaceIndex = 0;
    let patternIndex = 0;
    const patternLength = pattern.length;
    const namespaceLength = namespace.length;
    let lastWildcard = -1;
    let lastWildcardNamespace = -1;
    while (namespaceIndex < namespaceLength && patternIndex < patternLength) {
      if (pattern[patternIndex] === "*") {
        lastWildcard = patternIndex;
        patternIndex++;
        if (patternIndex === patternLength) {
          return true;
        }
        while (namespace[namespaceIndex] !== pattern[patternIndex]) {
          namespaceIndex++;
          if (namespaceIndex === namespaceLength) {
            return false;
          }
        }
        lastWildcardNamespace = namespaceIndex;
        namespaceIndex++;
        patternIndex++;
        continue;
      } else if (pattern[patternIndex] === namespace[namespaceIndex]) {
        patternIndex++;
        namespaceIndex++;
      } else if (lastWildcard >= 0) {
        patternIndex = lastWildcard + 1;
        namespaceIndex = lastWildcardNamespace + 1;
        if (namespaceIndex === namespaceLength) {
          return false;
        }
        while (namespace[namespaceIndex] !== pattern[patternIndex]) {
          namespaceIndex++;
          if (namespaceIndex === namespaceLength) {
            return false;
          }
        }
        lastWildcardNamespace = namespaceIndex;
        namespaceIndex++;
        patternIndex++;
        continue;
      } else {
        return false;
      }
    }
    const namespaceDone = namespaceIndex === namespace.length;
    const patternDone = patternIndex === pattern.length;
    const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === "*";
    return namespaceDone && (patternDone || trailingWildCard);
  }
  function disable() {
    const result = enabledString || "";
    enable("");
    return result;
  }
  function createDebugger(namespace) {
    const newDebugger = Object.assign(debug, {
      enabled: enabled(namespace),
      destroy,
      log: debugObj.log,
      namespace,
      extend
    });
    function debug(...args) {
      if (!newDebugger.enabled) {
        return;
      }
      if (args.length > 0) {
        args[0] = `${namespace} ${args[0]}`;
      }
      newDebugger.log(...args);
    }
    debuggers.push(newDebugger);
    return newDebugger;
  }
  function destroy() {
    const index = debuggers.indexOf(this);
    if (index >= 0) {
      debuggers.splice(index, 1);
      return true;
    }
    return false;
  }
  function extend(namespace) {
    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
  }
  exports.default = debugObj;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/logger.js
var require_logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSpecRuntimeLogger = undefined;
  exports.createLoggerContext = createLoggerContext;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var tslib_1 = require_tslib();
  var debug_js_1 = tslib_1.__importDefault(require_debug());
  var TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
  var levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
  function patchLogMethod(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  function isTypeSpecRuntimeLogLevel(level) {
    return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
  }
  function createLoggerContext(options) {
    const registeredLoggers = new Set;
    const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || undefined;
    let logLevel;
    const clientLogger = (0, debug_js_1.default)(options.namespace);
    clientLogger.log = (...args) => {
      debug_js_1.default.log(...args);
    };
    function contextSetLogLevel(level) {
      if (level && !isTypeSpecRuntimeLogLevel(level)) {
        throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
      }
      logLevel = level;
      const enabledNamespaces = [];
      for (const logger of registeredLoggers) {
        if (shouldEnable(logger)) {
          enabledNamespaces.push(logger.namespace);
        }
      }
      debug_js_1.default.enable(enabledNamespaces.join(","));
    }
    if (logLevelFromEnv) {
      if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
        contextSetLogLevel(logLevelFromEnv);
      } else {
        console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
      }
    }
    function shouldEnable(logger) {
      return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
    }
    function createLogger(parent, level) {
      const logger = Object.assign(parent.extend(level), {
        level
      });
      patchLogMethod(parent, logger);
      if (shouldEnable(logger)) {
        const enabledNamespaces = debug_js_1.default.disable();
        debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
      }
      registeredLoggers.add(logger);
      return logger;
    }
    function contextGetLogLevel() {
      return logLevel;
    }
    function contextCreateClientLogger(namespace) {
      const clientRootLogger = clientLogger.extend(namespace);
      patchLogMethod(clientLogger, clientRootLogger);
      return {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
      };
    }
    return {
      setLogLevel: contextSetLogLevel,
      getLogLevel: contextGetLogLevel,
      createClientLogger: contextCreateClientLogger,
      logger: clientLogger
    };
  }
  var context = createLoggerContext({
    logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
    namespace: "typeSpecRuntime"
  });
  exports.TypeSpecRuntimeLogger = context.logger;
  function setLogLevel(logLevel) {
    context.setLogLevel(logLevel);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/httpHeaders.js
var require_httpHeaders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpHeaders = createHttpHeaders;
  function normalizeName(name) {
    return name.toLowerCase();
  }
  function* headerIterator(map) {
    for (const entry of map.values()) {
      yield [entry.name, entry.value];
    }
  }

  class HttpHeadersImpl {
    _headersMap;
    constructor(rawHeaders) {
      this._headersMap = new Map;
      if (rawHeaders) {
        for (const headerName of Object.keys(rawHeaders)) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(name, value) {
      this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
    }
    get(name) {
      return this._headersMap.get(normalizeName(name))?.value;
    }
    has(name) {
      return this._headersMap.has(normalizeName(name));
    }
    delete(name) {
      this._headersMap.delete(normalizeName(name));
    }
    toJSON(options = {}) {
      const result = {};
      if (options.preserveCase) {
        for (const entry of this._headersMap.values()) {
          result[entry.name] = entry.value;
        }
      } else {
        for (const [normalizedName, entry] of this._headersMap) {
          result[normalizedName] = entry.value;
        }
      }
      return result;
    }
    toString() {
      return JSON.stringify(this.toJSON({ preserveCase: true }));
    }
    [Symbol.iterator]() {
      return headerIterator(this._headersMap);
    }
  }
  function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/schemes.js
var require_schemes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/oauth2Flows.js
var require_oauth2Flows = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/uuidUtils.js
var require_uuidUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomUUID = randomUUID;
  function randomUUID() {
    return crypto.randomUUID();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipelineRequest.js
var require_pipelineRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineRequest = createPipelineRequest;
  var httpHeaders_js_1 = require_httpHeaders();
  var uuidUtils_js_1 = require_uuidUtils();

  class PipelineRequestImpl {
    url;
    method;
    headers;
    timeout;
    withCredentials;
    body;
    multipartBody;
    formData;
    streamResponseStatusCodes;
    enableBrowserStreams;
    proxySettings;
    disableKeepAlive;
    abortSignal;
    requestId;
    allowInsecureConnection;
    onUploadProgress;
    onDownloadProgress;
    requestOverrides;
    authSchemes;
    constructor(options) {
      this.url = options.url;
      this.body = options.body;
      this.headers = options.headers ?? (0, httpHeaders_js_1.createHttpHeaders)();
      this.method = options.method ?? "GET";
      this.timeout = options.timeout ?? 0;
      this.multipartBody = options.multipartBody;
      this.formData = options.formData;
      this.disableKeepAlive = options.disableKeepAlive ?? false;
      this.proxySettings = options.proxySettings;
      this.streamResponseStatusCodes = options.streamResponseStatusCodes;
      this.withCredentials = options.withCredentials ?? false;
      this.abortSignal = options.abortSignal;
      this.onUploadProgress = options.onUploadProgress;
      this.onDownloadProgress = options.onDownloadProgress;
      this.requestId = options.requestId || (0, uuidUtils_js_1.randomUUID)();
      this.allowInsecureConnection = options.allowInsecureConnection ?? false;
      this.enableBrowserStreams = options.enableBrowserStreams ?? false;
      this.requestOverrides = options.requestOverrides;
      this.authSchemes = options.authSchemes;
    }
  }
  function createPipelineRequest(options) {
    return new PipelineRequestImpl(options);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipeline.js
var require_pipeline = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createEmptyPipeline = createEmptyPipeline;
  var ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);

  class HttpPipeline {
    _policies = [];
    _orderedPolicies;
    constructor(policies) {
      this._policies = policies?.slice(0) ?? [];
      this._orderedPolicies = undefined;
    }
    addPolicy(policy, options = {}) {
      if (options.phase && options.afterPhase) {
        throw new Error("Policies inside a phase cannot specify afterPhase.");
      }
      if (options.phase && !ValidPhaseNames.has(options.phase)) {
        throw new Error(`Invalid phase name: ${options.phase}`);
      }
      if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
        throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
      }
      this._policies.push({
        policy,
        options
      });
      this._orderedPolicies = undefined;
    }
    removePolicy(options) {
      const removedPolicies = [];
      this._policies = this._policies.filter((policyDescriptor) => {
        if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
          removedPolicies.push(policyDescriptor.policy);
          return false;
        } else {
          return true;
        }
      });
      this._orderedPolicies = undefined;
      return removedPolicies;
    }
    sendRequest(httpClient, request) {
      const policies = this.getOrderedPolicies();
      const pipeline = policies.reduceRight((next, policy) => {
        return (req) => {
          return policy.sendRequest(req, next);
        };
      }, (req) => httpClient.sendRequest(req));
      return pipeline(request);
    }
    getOrderedPolicies() {
      if (!this._orderedPolicies) {
        this._orderedPolicies = this.orderPolicies();
      }
      return this._orderedPolicies;
    }
    clone() {
      return new HttpPipeline(this._policies);
    }
    static create() {
      return new HttpPipeline;
    }
    orderPolicies() {
      const result = [];
      const policyMap = new Map;
      function createPhase(name) {
        return {
          name,
          policies: new Set,
          hasRun: false,
          hasAfterPolicies: false
        };
      }
      const serializePhase = createPhase("Serialize");
      const noPhase = createPhase("None");
      const deserializePhase = createPhase("Deserialize");
      const retryPhase = createPhase("Retry");
      const signPhase = createPhase("Sign");
      const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
      function getPhase(phase) {
        if (phase === "Retry") {
          return retryPhase;
        } else if (phase === "Serialize") {
          return serializePhase;
        } else if (phase === "Deserialize") {
          return deserializePhase;
        } else if (phase === "Sign") {
          return signPhase;
        } else {
          return noPhase;
        }
      }
      for (const descriptor of this._policies) {
        const policy = descriptor.policy;
        const options = descriptor.options;
        const policyName = policy.name;
        if (policyMap.has(policyName)) {
          throw new Error("Duplicate policy names not allowed in pipeline");
        }
        const node = {
          policy,
          dependsOn: new Set,
          dependants: new Set
        };
        if (options.afterPhase) {
          node.afterPhase = getPhase(options.afterPhase);
          node.afterPhase.hasAfterPolicies = true;
        }
        policyMap.set(policyName, node);
        const phase = getPhase(options.phase);
        phase.policies.add(node);
      }
      for (const descriptor of this._policies) {
        const { policy, options } = descriptor;
        const policyName = policy.name;
        const node = policyMap.get(policyName);
        if (!node) {
          throw new Error(`Missing node for policy ${policyName}`);
        }
        if (options.afterPolicies) {
          for (const afterPolicyName of options.afterPolicies) {
            const afterNode = policyMap.get(afterPolicyName);
            if (afterNode) {
              node.dependsOn.add(afterNode);
              afterNode.dependants.add(node);
            }
          }
        }
        if (options.beforePolicies) {
          for (const beforePolicyName of options.beforePolicies) {
            const beforeNode = policyMap.get(beforePolicyName);
            if (beforeNode) {
              beforeNode.dependsOn.add(node);
              node.dependants.add(beforeNode);
            }
          }
        }
      }
      function walkPhase(phase) {
        phase.hasRun = true;
        for (const node of phase.policies) {
          if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
            continue;
          }
          if (node.dependsOn.size === 0) {
            result.push(node.policy);
            for (const dependant of node.dependants) {
              dependant.dependsOn.delete(node);
            }
            policyMap.delete(node.policy.name);
            phase.policies.delete(node);
          }
        }
      }
      function walkPhases() {
        for (const phase of orderedPhases) {
          walkPhase(phase);
          if (phase.policies.size > 0 && phase !== noPhase) {
            if (!noPhase.hasRun) {
              walkPhase(noPhase);
            }
            return;
          }
          if (phase.hasAfterPolicies) {
            walkPhase(noPhase);
          }
        }
      }
      let iteration = 0;
      while (policyMap.size > 0) {
        iteration++;
        const initialResultLength = result.length;
        walkPhases();
        if (result.length <= initialResultLength && iteration > 1) {
          throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
      }
      return result;
    }
  }
  function createEmptyPipeline() {
    return HttpPipeline.create();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/object.js
var require_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObject = isObject;
  function isObject(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isError = isError;
  var object_js_1 = require_object();
  function isError(e) {
    if ((0, object_js_1.isObject)(e)) {
      const hasName = typeof e.name === "string";
      const hasMessage = typeof e.message === "string";
      return hasName && hasMessage;
    }
    return false;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/inspect.js
var require_inspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.custom = undefined;
  var node_util_1 = __require("node:util");
  exports.custom = node_util_1.inspect.custom;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sanitizer.js
var require_sanitizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Sanitizer = undefined;
  var object_js_1 = require_object();
  var RedactedString = "REDACTED";
  var defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate"
  ];
  var defaultAllowedQueryParameters = ["api-version"];

  class Sanitizer {
    allowedHeaderNames;
    allowedQueryParameters;
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
      allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
      allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
      this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
      this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
    }
    sanitize(obj) {
      const seen = new Set;
      return JSON.stringify(obj, (key, value) => {
        if (value instanceof Error) {
          return {
            ...value,
            name: value.name,
            message: value.message
          };
        }
        if (key === "headers") {
          return this.sanitizeHeaders(value);
        } else if (key === "url") {
          return this.sanitizeUrl(value);
        } else if (key === "query") {
          return this.sanitizeQuery(value);
        } else if (key === "body") {
          return;
        } else if (key === "response") {
          return;
        } else if (key === "operationSpec") {
          return;
        } else if (Array.isArray(value) || (0, object_js_1.isObject)(value)) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      }, 2);
    }
    sanitizeUrl(value) {
      if (typeof value !== "string" || value === null || value === "") {
        return value;
      }
      const url = new URL(value);
      if (!url.search) {
        return value;
      }
      for (const [key] of url.searchParams) {
        if (!this.allowedQueryParameters.has(key.toLowerCase())) {
          url.searchParams.set(key, RedactedString);
        }
      }
      return url.toString();
    }
    sanitizeHeaders(obj) {
      const sanitized = {};
      for (const key of Object.keys(obj)) {
        if (this.allowedHeaderNames.has(key.toLowerCase())) {
          sanitized[key] = obj[key];
        } else {
          sanitized[key] = RedactedString;
        }
      }
      return sanitized;
    }
    sanitizeQuery(value) {
      if (typeof value !== "object" || value === null) {
        return value;
      }
      const sanitized = {};
      for (const k of Object.keys(value)) {
        if (this.allowedQueryParameters.has(k.toLowerCase())) {
          sanitized[k] = value[k];
        } else {
          sanitized[k] = RedactedString;
        }
      }
      return sanitized;
    }
  }
  exports.Sanitizer = Sanitizer;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/restError.js
var require_restError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestError = undefined;
  exports.isRestError = isRestError;
  var error_js_1 = require_error();
  var inspect_js_1 = require_inspect();
  var sanitizer_js_1 = require_sanitizer();
  var errorSanitizer = new sanitizer_js_1.Sanitizer;

  class RestError extends Error {
    static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    static PARSE_ERROR = "PARSE_ERROR";
    code;
    statusCode;
    request;
    response;
    details;
    constructor(message, options = {}) {
      super(message);
      this.name = "RestError";
      this.code = options.code;
      this.statusCode = options.statusCode;
      Object.defineProperty(this, "request", { value: options.request, enumerable: false });
      Object.defineProperty(this, "response", { value: options.response, enumerable: false });
      const agent = this.request?.agent ? {
        maxFreeSockets: this.request.agent.maxFreeSockets,
        maxSockets: this.request.agent.maxSockets
      } : undefined;
      Object.defineProperty(this, inspect_js_1.custom, {
        value: () => {
          return `RestError: ${this.message} 
 ${errorSanitizer.sanitize({
            ...this,
            request: { ...this.request, agent },
            response: this.response
          })}`;
        },
        enumerable: false
      });
      Object.setPrototypeOf(this, RestError.prototype);
    }
  }
  exports.RestError = RestError;
  function isRestError(e) {
    if (e instanceof RestError) {
      return true;
    }
    return (0, error_js_1.isError)(e) && e.name === "RestError";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/bytesEncoding.js
var require_bytesEncoding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint8ArrayToString = uint8ArrayToString;
  exports.stringToUint8Array = stringToUint8Array;
  function uint8ArrayToString(bytes, format) {
    return Buffer.from(bytes).toString(format);
  }
  function stringToUint8Array(value, format) {
    return Buffer.from(value, format);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/log.js
var require_log2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_js_1 = require_logger();
  exports.logger = (0, logger_js_1.createClientLogger)("ts-http-runtime");
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/nodeHttpClient.js
var require_nodeHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBodyLength = getBodyLength;
  exports.createNodeHttpClient = createNodeHttpClient;
  var tslib_1 = require_tslib();
  var node_http_1 = tslib_1.__importDefault(__require("node:http"));
  var node_https_1 = tslib_1.__importDefault(__require("node:https"));
  var node_zlib_1 = tslib_1.__importDefault(__require("node:zlib"));
  var node_stream_1 = __require("node:stream");
  var AbortError_js_1 = require_AbortError();
  var httpHeaders_js_1 = require_httpHeaders();
  var restError_js_1 = require_restError();
  var log_js_1 = require_log2();
  var sanitizer_js_1 = require_sanitizer();
  var DEFAULT_TLS_SETTINGS = {};
  function isReadableStream(body) {
    return body && typeof body.pipe === "function";
  }
  function isStreamComplete(stream) {
    if (stream.readable === false) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const handler = () => {
        resolve();
        stream.removeListener("close", handler);
        stream.removeListener("end", handler);
        stream.removeListener("error", handler);
      };
      stream.on("close", handler);
      stream.on("end", handler);
      stream.on("error", handler);
    });
  }
  function isArrayBuffer(body) {
    return body && typeof body.byteLength === "number";
  }

  class ReportTransform extends node_stream_1.Transform {
    loadedBytes = 0;
    progressCallback;
    _transform(chunk, _encoding, callback) {
      this.push(chunk);
      this.loadedBytes += chunk.length;
      try {
        this.progressCallback({ loadedBytes: this.loadedBytes });
        callback();
      } catch (e) {
        callback(e);
      }
    }
    constructor(progressCallback) {
      super();
      this.progressCallback = progressCallback;
    }
  }

  class NodeHttpClient {
    cachedHttpAgent;
    cachedHttpsAgents = new WeakMap;
    async sendRequest(request) {
      const abortController = new AbortController;
      let abortListener;
      if (request.abortSignal) {
        if (request.abortSignal.aborted) {
          throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
        }
        abortListener = (event) => {
          if (event.type === "abort") {
            abortController.abort();
          }
        };
        request.abortSignal.addEventListener("abort", abortListener);
      }
      let timeoutId;
      if (request.timeout > 0) {
        timeoutId = setTimeout(() => {
          const sanitizer = new sanitizer_js_1.Sanitizer;
          log_js_1.logger.info(`request to '${sanitizer.sanitizeUrl(request.url)}' timed out. canceling...`);
          abortController.abort();
        }, request.timeout);
      }
      const acceptEncoding = request.headers.get("Accept-Encoding");
      const shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate");
      let body = typeof request.body === "function" ? request.body() : request.body;
      if (body && !request.headers.has("Content-Length")) {
        const bodyLength = getBodyLength(body);
        if (bodyLength !== null) {
          request.headers.set("Content-Length", bodyLength);
        }
      }
      let responseStream;
      try {
        if (body && request.onUploadProgress) {
          const onUploadProgress = request.onUploadProgress;
          const uploadReportStream = new ReportTransform(onUploadProgress);
          uploadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in upload progress", e);
          });
          if (isReadableStream(body)) {
            body.pipe(uploadReportStream);
          } else {
            uploadReportStream.end(body);
          }
          body = uploadReportStream;
        }
        const res = await this.makeRequest(request, abortController, body);
        if (timeoutId !== undefined) {
          clearTimeout(timeoutId);
        }
        const headers = getResponseHeaders(res);
        const status = res.statusCode ?? 0;
        const response = {
          status,
          headers,
          request
        };
        if (request.method === "HEAD") {
          res.resume();
          return response;
        }
        responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
        const onDownloadProgress = request.onDownloadProgress;
        if (onDownloadProgress) {
          const downloadReportStream = new ReportTransform(onDownloadProgress);
          downloadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in download progress", e);
          });
          responseStream.pipe(downloadReportStream);
          responseStream = downloadReportStream;
        }
        if (request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || request.streamResponseStatusCodes?.has(response.status)) {
          response.readableStreamBody = responseStream;
        } else {
          response.bodyAsText = await streamToText(responseStream);
        }
        return response;
      } finally {
        if (request.abortSignal && abortListener) {
          let uploadStreamDone = Promise.resolve();
          if (isReadableStream(body)) {
            uploadStreamDone = isStreamComplete(body);
          }
          let downloadStreamDone = Promise.resolve();
          if (isReadableStream(responseStream)) {
            downloadStreamDone = isStreamComplete(responseStream);
          }
          Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
            if (abortListener) {
              request.abortSignal?.removeEventListener("abort", abortListener);
            }
          }).catch((e) => {
            log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
          });
        }
      }
    }
    makeRequest(request, abortController, body) {
      const url = new URL(request.url);
      const isInsecure = url.protocol !== "https:";
      if (isInsecure && !request.allowInsecureConnection) {
        throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
      }
      const agent = request.agent ?? this.getOrCreateAgent(request, isInsecure);
      const options = {
        agent,
        hostname: url.hostname,
        path: `${url.pathname}${url.search}`,
        port: url.port,
        method: request.method,
        headers: request.headers.toJSON({ preserveCase: true }),
        ...request.requestOverrides
      };
      return new Promise((resolve, reject) => {
        const req = isInsecure ? node_http_1.default.request(options, resolve) : node_https_1.default.request(options, resolve);
        req.once("error", (err) => {
          reject(new restError_js_1.RestError(err.message, { code: err.code ?? restError_js_1.RestError.REQUEST_SEND_ERROR, request }));
        });
        abortController.signal.addEventListener("abort", () => {
          const abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
          req.destroy(abortError);
          reject(abortError);
        });
        if (body && isReadableStream(body)) {
          body.pipe(req);
        } else if (body) {
          if (typeof body === "string" || Buffer.isBuffer(body)) {
            req.end(body);
          } else if (isArrayBuffer(body)) {
            req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
          } else {
            log_js_1.logger.error("Unrecognized body type", body);
            reject(new restError_js_1.RestError("Unrecognized body type"));
          }
        } else {
          req.end();
        }
      });
    }
    getOrCreateAgent(request, isInsecure) {
      const disableKeepAlive = request.disableKeepAlive;
      if (isInsecure) {
        if (disableKeepAlive) {
          return node_http_1.default.globalAgent;
        }
        if (!this.cachedHttpAgent) {
          this.cachedHttpAgent = new node_http_1.default.Agent({ keepAlive: true });
        }
        return this.cachedHttpAgent;
      } else {
        if (disableKeepAlive && !request.tlsSettings) {
          return node_https_1.default.globalAgent;
        }
        const tlsSettings = request.tlsSettings ?? DEFAULT_TLS_SETTINGS;
        let agent = this.cachedHttpsAgents.get(tlsSettings);
        if (agent && agent.options.keepAlive === !disableKeepAlive) {
          return agent;
        }
        log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
        agent = new node_https_1.default.Agent({
          keepAlive: !disableKeepAlive,
          ...tlsSettings
        });
        this.cachedHttpsAgents.set(tlsSettings, agent);
        return agent;
      }
    }
  }
  function getResponseHeaders(res) {
    const headers = (0, httpHeaders_js_1.createHttpHeaders)();
    for (const header of Object.keys(res.headers)) {
      const value = res.headers[header];
      if (Array.isArray(value)) {
        if (value.length > 0) {
          headers.set(header, value[0]);
        }
      } else if (value) {
        headers.set(header, value);
      }
    }
    return headers;
  }
  function getDecodedResponseStream(stream, headers) {
    const contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
      const unzip = node_zlib_1.default.createGunzip();
      stream.pipe(unzip);
      return unzip;
    } else if (contentEncoding === "deflate") {
      const inflate = node_zlib_1.default.createInflate();
      stream.pipe(inflate);
      return inflate;
    }
    return stream;
  }
  function streamToText(stream) {
    return new Promise((resolve, reject) => {
      const buffer = [];
      stream.on("data", (chunk) => {
        if (Buffer.isBuffer(chunk)) {
          buffer.push(chunk);
        } else {
          buffer.push(Buffer.from(chunk));
        }
      });
      stream.on("end", () => {
        resolve(Buffer.concat(buffer).toString("utf8"));
      });
      stream.on("error", (e) => {
        if (e && e?.name === "AbortError") {
          reject(e);
        } else {
          reject(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
            code: restError_js_1.RestError.PARSE_ERROR
          }));
        }
      });
    });
  }
  function getBodyLength(body) {
    if (!body) {
      return 0;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (isReadableStream(body)) {
      return null;
    } else if (isArrayBuffer(body)) {
      return body.byteLength;
    } else if (typeof body === "string") {
      return Buffer.from(body).length;
    } else {
      return null;
    }
  }
  function createNodeHttpClient() {
    return new NodeHttpClient;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultHttpClient = createDefaultHttpClient;
  var nodeHttpClient_js_1 = require_nodeHttpClient();
  function createDefaultHttpClient() {
    return (0, nodeHttpClient_js_1.createNodeHttpClient)();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/logPolicy.js
var require_logPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logPolicyName = undefined;
  exports.logPolicy = logPolicy;
  var log_js_1 = require_log2();
  var sanitizer_js_1 = require_sanitizer();
  exports.logPolicyName = "logPolicy";
  function logPolicy(options = {}) {
    const logger = options.logger ?? log_js_1.logger.info;
    const sanitizer = new sanitizer_js_1.Sanitizer({
      additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    return {
      name: exports.logPolicyName,
      async sendRequest(request, next) {
        if (!logger.enabled) {
          return next(request);
        }
        logger(`Request: ${sanitizer.sanitize(request)}`);
        const response = await next(request);
        logger(`Response status code: ${response.status}`);
        logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
        return response;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redirectPolicyName = undefined;
  exports.redirectPolicy = redirectPolicy;
  exports.redirectPolicyName = "redirectPolicy";
  var allowedRedirect = ["GET", "HEAD"];
  function redirectPolicy(options = {}) {
    const { maxRetries = 20 } = options;
    return {
      name: exports.redirectPolicyName,
      async sendRequest(request, next) {
        const response = await next(request);
        return handleRedirect(next, response, maxRetries);
      }
    };
  }
  async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    const { request, status, headers } = response;
    const locationHeader = headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
      const url = new URL(locationHeader, request.url);
      request.url = url.toString();
      if (status === 303) {
        request.method = "GET";
        request.headers.delete("Content-Length");
        delete request.body;
      }
      request.headers.delete("Authorization");
      const res = await next(request);
      return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeaderName = getHeaderName;
  exports.setPlatformSpecificData = setPlatformSpecificData;
  var tslib_1 = require_tslib();
  var node_os_1 = tslib_1.__importDefault(__require("node:os"));
  var node_process_1 = tslib_1.__importDefault(__require("node:process"));
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (node_process_1.default && node_process_1.default.versions) {
      const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
      const versions = node_process_1.default.versions;
      if (versions.bun) {
        map.set("Bun", `${versions.bun} (${osInfo})`);
      } else if (versions.deno) {
        map.set("Deno", `${versions.deno} (${osInfo})`);
      } else if (versions.node) {
        map.set("Node", `${versions.node} (${osInfo})`);
      }
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/constants.js
var require_constants6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "0.3.2";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgent.js
var require_userAgent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentHeaderName = getUserAgentHeaderName;
  exports.getUserAgentValue = getUserAgentValue;
  var userAgentPlatform_js_1 = require_userAgentPlatform();
  var constants_js_1 = require_constants6();
  function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    const runtimeInfo = new Map;
    runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = undefined;
  exports.userAgentPolicy = userAgentPolicy;
  var userAgent_js_1 = require_userAgent();
  var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy(options = {}) {
    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(UserAgentHeaderName)) {
          request.headers.set(UserAgentHeaderName, await userAgentValue);
        }
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompressResponsePolicyName = undefined;
  exports.decompressResponsePolicy = decompressResponsePolicy;
  exports.decompressResponsePolicyName = "decompressResponsePolicy";
  function decompressResponsePolicy() {
    return {
      name: exports.decompressResponsePolicyName,
      async sendRequest(request, next) {
        if (request.method !== "HEAD") {
          request.headers.set("Accept-Encoding", "gzip,deflate");
        }
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/random.js
var require_random = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
  function getRandomIntegerInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/delay.js
var require_delay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.calculateRetryDelay = calculateRetryDelay;
  var random_js_1 = require_random();
  function calculateRetryDelay(retryAttempt, config) {
    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return { retryAfterInMs };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay;
  exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
  var AbortError_js_1 = require_AbortError();
  var StandardAbortMessage = "The operation was aborted.";
  function delay(delayInMs, value, options) {
    return new Promise((resolve, reject) => {
      let timer = undefined;
      let onAborted = undefined;
      const rejectOnAbort = () => {
        return reject(new AbortError_js_1.AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage));
      };
      const removeListeners = () => {
        if (options?.abortSignal && onAborted) {
          options.abortSignal.removeEventListener("abort", onAborted);
        }
      };
      onAborted = () => {
        if (timer) {
          clearTimeout(timer);
        }
        removeListeners();
        return rejectOnAbort();
      };
      if (options?.abortSignal && options.abortSignal.aborted) {
        return rejectOnAbort();
      }
      timer = setTimeout(() => {
        removeListeners();
        resolve(value);
      }, delayInMs);
      if (options?.abortSignal) {
        options.abortSignal.addEventListener("abort", onAborted);
      }
    });
  }
  function parseHeaderValueAsNumber(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value)
      return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
      return;
    return valueAsNum;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/throttlingRetryStrategy.js
var require_throttlingRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isThrottlingRetryResponse = isThrottlingRetryResponse;
  exports.throttlingRetryStrategy = throttlingRetryStrategy;
  var helpers_js_1 = require_helpers();
  var RetryAfterHeader = "Retry-After";
  var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  function getRetryAfterInMs(response) {
    if (!(response && [429, 503].includes(response.status)))
      return;
    try {
      for (const header of AllRetryAfterHeaders) {
        const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
        if (retryAfterValue === 0 || retryAfterValue) {
          const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
          return retryAfterValue * multiplyingFactor;
        }
      }
      const retryAfterHeader = response.headers.get(RetryAfterHeader);
      if (!retryAfterHeader)
        return;
      const date = Date.parse(retryAfterHeader);
      const diff = date - Date.now();
      return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
    } catch {
      return;
    }
  }
  function isThrottlingRetryResponse(response) {
    return Number.isFinite(getRetryAfterInMs(response));
  }
  function throttlingRetryStrategy() {
    return {
      name: "throttlingRetryStrategy",
      retry({ response }) {
        const retryAfterInMs = getRetryAfterInMs(response);
        if (!Number.isFinite(retryAfterInMs)) {
          return { skipStrategy: true };
        }
        return {
          retryAfterInMs
        };
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/exponentialRetryStrategy.js
var require_exponentialRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryStrategy = exponentialRetryStrategy;
  exports.isExponentialRetryResponse = isExponentialRetryResponse;
  exports.isSystemError = isSystemError;
  var delay_js_1 = require_delay();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
  var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
  function exponentialRetryStrategy(options = {}) {
    const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
    const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    return {
      name: "exponentialRetryStrategy",
      retry({ retryCount, response, responseError }) {
        const matchedSystemError = isSystemError(responseError);
        const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
        const isExponential = isExponentialRetryResponse(response);
        const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
        const unknownResponse = response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential);
        if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
          return { skipStrategy: true };
        }
        if (responseError && !matchedSystemError && !isExponential) {
          return { errorToThrow: responseError };
        }
        return (0, delay_js_1.calculateRetryDelay)(retryCount, {
          retryDelayInMs: retryInterval,
          maxRetryDelayInMs: maxRetryInterval
        });
      }
    };
  }
  function isExponentialRetryResponse(response) {
    return Boolean(response && response.status !== undefined && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
  }
  function isSystemError(err) {
    if (!err) {
      return false;
    }
    return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryPolicy = retryPolicy;
  var helpers_js_1 = require_helpers();
  var AbortError_js_1 = require_AbortError();
  var logger_js_1 = require_logger();
  var constants_js_1 = require_constants6();
  var retryPolicyLogger = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy");
  var retryPolicyName = "retryPolicy";
  function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    const logger = options.logger || retryPolicyLogger;
    return {
      name: retryPolicyName,
      async sendRequest(request, next) {
        let response;
        let responseError;
        let retryCount = -1;
        retryRequest:
          while (true) {
            retryCount += 1;
            response = undefined;
            responseError = undefined;
            try {
              logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
              response = await next(request);
              logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
            } catch (e) {
              logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
              responseError = e;
              if (!e || responseError.name !== "RestError") {
                throw e;
              }
              response = responseError.response;
            }
            if (request.abortSignal?.aborted) {
              logger.error(`Retry ${retryCount}: Request aborted.`);
              const abortError = new AbortError_js_1.AbortError;
              throw abortError;
            }
            if (retryCount >= (options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
              logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
              if (responseError) {
                throw responseError;
              } else if (response) {
                return response;
              } else {
                throw new Error("Maximum retries reached with no response or error to throw");
              }
            }
            logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
            strategiesLoop:
              for (const strategy of strategies) {
                const strategyLogger = strategy.logger || logger;
                strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                const modifiers = strategy.retry({
                  retryCount,
                  response,
                  responseError
                });
                if (modifiers.skipStrategy) {
                  strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                  continue strategiesLoop;
                }
                const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                if (errorToThrow) {
                  strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                  throw errorToThrow;
                }
                if (retryAfterInMs || retryAfterInMs === 0) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                  await (0, helpers_js_1.delay)(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
                  continue retryRequest;
                }
                if (redirectTo) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                  request.url = redirectTo;
                  continue retryRequest;
                }
              }
            if (responseError) {
              logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
              throw responseError;
            }
            if (response) {
              logger.info(`None of the retry strategies could work with the received response. Returning it.`);
              return response;
            }
          }
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultRetryPolicyName = undefined;
  exports.defaultRetryPolicy = defaultRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants6();
  exports.defaultRetryPolicyName = "defaultRetryPolicy";
  function defaultRetryPolicy(options = {}) {
    return {
      name: exports.defaultRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/checkEnvironment.js
var require_checkEnvironment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = undefined;
  exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  exports.isWebWorker = typeof self === "object" && typeof self?.importScripts === "function" && (self.constructor?.name === "DedicatedWorkerGlobalScope" || self.constructor?.name === "ServiceWorkerGlobalScope" || self.constructor?.name === "SharedWorkerGlobalScope");
  exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
  exports.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean(globalThis.process.versions?.node);
  exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
  exports.isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formDataPolicyName = undefined;
  exports.formDataPolicy = formDataPolicy;
  var bytesEncoding_js_1 = require_bytesEncoding();
  var checkEnvironment_js_1 = require_checkEnvironment();
  var httpHeaders_js_1 = require_httpHeaders();
  exports.formDataPolicyName = "formDataPolicy";
  function formDataToFormDataMap(formData) {
    const formDataMap = {};
    for (const [key, value] of formData.entries()) {
      formDataMap[key] ??= [];
      formDataMap[key].push(value);
    }
    return formDataMap;
  }
  function formDataPolicy() {
    return {
      name: exports.formDataPolicyName,
      async sendRequest(request, next) {
        if (checkEnvironment_js_1.isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
          request.formData = formDataToFormDataMap(request.body);
          request.body = undefined;
        }
        if (request.formData) {
          const contentType = request.headers.get("Content-Type");
          if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
            request.body = wwwFormUrlEncode(request.formData);
          } else {
            await prepareFormData(request.formData, request);
          }
          request.formData = undefined;
        }
        return next(request);
      }
    };
  }
  function wwwFormUrlEncode(formData) {
    const urlSearchParams = new URLSearchParams;
    for (const [key, value] of Object.entries(formData)) {
      if (Array.isArray(value)) {
        for (const subValue of value) {
          urlSearchParams.append(key, subValue.toString());
        }
      } else {
        urlSearchParams.append(key, value.toString());
      }
    }
    return urlSearchParams.toString();
  }
  async function prepareFormData(formData, request) {
    const contentType = request.headers.get("Content-Type");
    if (contentType && !contentType.startsWith("multipart/form-data")) {
      return;
    }
    request.headers.set("Content-Type", contentType ?? "multipart/form-data");
    const parts = [];
    for (const [fieldName, values] of Object.entries(formData)) {
      for (const value of Array.isArray(values) ? values : [values]) {
        if (typeof value === "string") {
          parts.push({
            headers: (0, httpHeaders_js_1.createHttpHeaders)({
              "Content-Disposition": `form-data; name="${fieldName}"`
            }),
            body: (0, bytesEncoding_js_1.stringToUint8Array)(value, "utf-8")
          });
        } else if (value === undefined || value === null || typeof value !== "object") {
          throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
        } else {
          const fileName = value.name || "blob";
          const headers = (0, httpHeaders_js_1.createHttpHeaders)();
          headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
          headers.set("Content-Type", value.type || "application/octet-stream");
          parts.push({
            headers,
            body: value
          });
        }
      }
    }
    request.multipartBody = { parts };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.req = exports.json = exports.toBuffer = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  async function toBuffer(stream) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  exports.toBuffer = toBuffer;
  async function json(stream) {
    const buf = await toBuffer(stream);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  exports.json = json;
  function req(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
    const promise = new Promise((resolve, reject) => {
      req2.once("response", resolve).once("error", reject).end();
    });
    req2.then = promise.then.bind(promise);
    return req2;
  }
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = undefined;
  var net = __importStar(__require("net"));
  var http = __importStar(__require("http"));
  var https_1 = __require("https");
  __exportStar(require_helpers2(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split(`
`).some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    incrementSockets(name) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const fakeSocket = new net.Socket({ writable: false });
      this.sockets[name].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null) {
        return;
      }
      const sockets = this.sockets[name];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name];
        }
      }
    }
    getName(options) {
      const secureEndpoint = this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_1.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        this.decrementSockets(name, fakeSocket);
        if (socket instanceof http.Agent) {
          try {
            return socket.addRequest(req, connectOpts);
          } catch (err) {
            return cb(err);
          }
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseProxyResponse = undefined;
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf(`\r
\r
`);
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split(`\r
`);
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug("got proxy server response: %o %o", firstLine, headers);
        cleanup();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  }
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpsProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var assert_1 = __importDefault(__require("assert"));
  var debug_1 = __importDefault(require_src());
  var agent_base_1 = require_dist();
  var url_1 = __require("url");
  var parse_proxy_response_1 = require_parse_proxy_response();
  var debug = (0, debug_1.default)("https-proxy-agent");
  var setServernameFromNonIpHost = (options) => {
    if (options.servername === undefined && options.host && !net.isIP(options.host)) {
      return {
        ...options,
        servername: options.host
      };
    }
    return options;
  };

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: undefined };
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r
`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r
`);
      const { connect, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect);
      this.emit("proxyConnect", connect, req);
      if (connect.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          return tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var debug_1 = __importDefault(require_src());
  var events_1 = __require("events");
  var agent_base_1 = require_dist();
  var url_1 = __require("url");
  var debug = (0, debug_1.default)("http-proxy-agent");

  class HttpProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    addRequest(req, opts) {
      req._header = null;
      this.setRequestProps(req, opts);
      super.addRequest(req, opts);
    }
    setRequestProps(req, opts) {
      const { proxy } = this;
      const protocol = opts.secureEndpoint ? "https:" : "http:";
      const hostname = req.getHeader("host") || "localhost";
      const base = `${protocol}//${hostname}`;
      const url = new url_1.URL(req.path, base);
      if (opts.port !== 80) {
        url.port = String(opts.port);
      }
      req.path = String(url);
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        const value = headers[name];
        if (value) {
          req.setHeader(name, value);
        }
      }
    }
    async connect(req, opts) {
      req._header = null;
      if (!req.path.includes("://")) {
        this.setRequestProps(req, opts);
      }
      let first;
      let endOfHeaders;
      debug("Regenerating stored HTTP header string for request");
      req._implicitHeader();
      if (req.outputData && req.outputData.length > 0) {
        debug("Patching connection write() output buffer with updated header");
        first = req.outputData[0].data;
        endOfHeaders = first.indexOf(`\r
\r
`) + 4;
        req.outputData[0].data = req._header + first.substring(endOfHeaders);
        debug("Output buffer: %o", req.outputData[0].data);
      }
      let socket;
      if (this.proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(this.connectOpts);
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      await (0, events_1.once)(socket, "connect");
      return socket;
    }
  }
  HttpProxyAgent.protocols = ["http", "https"];
  exports.HttpProxyAgent = HttpProxyAgent;
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalNoProxyList = exports.proxyPolicyName = undefined;
  exports.loadNoProxy = loadNoProxy;
  exports.getDefaultProxySettings = getDefaultProxySettings;
  exports.proxyPolicy = proxyPolicy;
  var https_proxy_agent_1 = require_dist2();
  var http_proxy_agent_1 = require_dist3();
  var log_js_1 = require_log2();
  var HTTPS_PROXY = "HTTPS_PROXY";
  var HTTP_PROXY = "HTTP_PROXY";
  var ALL_PROXY = "ALL_PROXY";
  var NO_PROXY = "NO_PROXY";
  exports.proxyPolicyName = "proxyPolicy";
  exports.globalNoProxyList = [];
  var noProxyListLoaded = false;
  var globalBypassedMap = new Map;
  function getEnvironmentValue(name) {
    if (process.env[name]) {
      return process.env[name];
    } else if (process.env[name.toLowerCase()]) {
      return process.env[name.toLowerCase()];
    }
    return;
  }
  function loadEnvironmentProxyValue() {
    if (!process) {
      return;
    }
    const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
    const allProxy = getEnvironmentValue(ALL_PROXY);
    const httpProxy = getEnvironmentValue(HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
  }
  function isBypassed(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0) {
      return false;
    }
    const host = new URL(uri).hostname;
    if (bypassedMap?.has(host)) {
      return bypassedMap.get(host);
    }
    let isBypassedFlag = false;
    for (const pattern of noProxyList) {
      if (pattern[0] === ".") {
        if (host.endsWith(pattern)) {
          isBypassedFlag = true;
        } else {
          if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
            isBypassedFlag = true;
          }
        }
      } else {
        if (host === pattern) {
          isBypassedFlag = true;
        }
      }
    }
    bypassedMap?.set(host, isBypassedFlag);
    return isBypassedFlag;
  }
  function loadNoProxy() {
    const noProxy = getEnvironmentValue(NO_PROXY);
    noProxyListLoaded = true;
    if (noProxy) {
      return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
    }
    return [];
  }
  function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl) {
      proxyUrl = loadEnvironmentProxyValue();
      if (!proxyUrl) {
        return;
      }
    }
    const parsedUrl = new URL(proxyUrl);
    const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
    return {
      host: schema + parsedUrl.hostname,
      port: Number.parseInt(parsedUrl.port || "80"),
      username: parsedUrl.username,
      password: parsedUrl.password
    };
  }
  function getDefaultProxySettingsInternal() {
    const envProxy = loadEnvironmentProxyValue();
    return envProxy ? new URL(envProxy) : undefined;
  }
  function getUrlFromProxySettings(settings) {
    let parsedProxyUrl;
    try {
      parsedProxyUrl = new URL(settings.host);
    } catch {
      throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
    }
    parsedProxyUrl.port = String(settings.port);
    if (settings.username) {
      parsedProxyUrl.username = settings.username;
    }
    if (settings.password) {
      parsedProxyUrl.password = settings.password;
    }
    return parsedProxyUrl;
  }
  function setProxyAgentOnRequest(request, cachedAgents, proxyUrl) {
    if (request.agent) {
      return;
    }
    const url = new URL(request.url);
    const isInsecure = url.protocol !== "https:";
    if (request.tlsSettings) {
      log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    }
    const headers = request.headers.toJSON();
    if (isInsecure) {
      if (!cachedAgents.httpProxyAgent) {
        cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
      }
      request.agent = cachedAgents.httpProxyAgent;
    } else {
      if (!cachedAgents.httpsProxyAgent) {
        cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
      }
      request.agent = cachedAgents.httpsProxyAgent;
    }
  }
  function proxyPolicy(proxySettings, options) {
    if (!noProxyListLoaded) {
      exports.globalNoProxyList.push(...loadNoProxy());
    }
    const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
    const cachedAgents = {};
    return {
      name: exports.proxyPolicyName,
      async sendRequest(request, next) {
        if (!request.proxySettings && defaultProxy && !isBypassed(request.url, options?.customNoProxyList ?? exports.globalNoProxyList, options?.customNoProxyList ? undefined : globalBypassedMap)) {
          setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
        } else if (request.proxySettings) {
          setProxyAgentOnRequest(request, cachedAgents, getUrlFromProxySettings(request.proxySettings));
        }
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.agentPolicyName = undefined;
  exports.agentPolicy = agentPolicy;
  exports.agentPolicyName = "agentPolicy";
  function agentPolicy(agent) {
    return {
      name: exports.agentPolicyName,
      sendRequest: async (req, next) => {
        if (!req.agent) {
          req.agent = agent;
        }
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tlsPolicyName = undefined;
  exports.tlsPolicy = tlsPolicy;
  exports.tlsPolicyName = "tlsPolicy";
  function tlsPolicy(tlsSettings) {
    return {
      name: exports.tlsPolicyName,
      sendRequest: async (req, next) => {
        if (!req.tlsSettings) {
          req.tlsSettings = tlsSettings;
        }
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/typeGuards.js
var require_typeGuards = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadableStream = isNodeReadableStream;
  exports.isWebReadableStream = isWebReadableStream;
  exports.isBinaryBody = isBinaryBody;
  exports.isReadableStream = isReadableStream;
  exports.isBlob = isBlob;
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x["pipe"] === "function");
  }
  function isWebReadableStream(x) {
    return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
  }
  function isBinaryBody(body) {
    return body !== undefined && (body instanceof Uint8Array || isReadableStream(body) || typeof body === "function" || body instanceof Blob);
  }
  function isReadableStream(x) {
    return isNodeReadableStream(x) || isWebReadableStream(x);
  }
  function isBlob(x) {
    return typeof x.stream === "function";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/concat.js
var require_concat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = concat;
  var stream_1 = __require("stream");
  var typeGuards_js_1 = require_typeGuards();
  async function* streamAsyncIterator() {
    const reader = this.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          return;
        }
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
  function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
      webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
    }
    if (!webStream.values) {
      webStream.values = streamAsyncIterator.bind(webStream);
    }
  }
  function ensureNodeStream(stream) {
    if (stream instanceof ReadableStream) {
      makeAsyncIterable(stream);
      return stream_1.Readable.fromWeb(stream);
    } else {
      return stream;
    }
  }
  function toStream(source) {
    if (source instanceof Uint8Array) {
      return stream_1.Readable.from(Buffer.from(source));
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return ensureNodeStream(source.stream());
    } else {
      return ensureNodeStream(source);
    }
  }
  async function concat(sources) {
    return function() {
      const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
      return stream_1.Readable.from(async function* () {
        for (const stream of streams) {
          for await (const chunk of stream) {
            yield chunk;
          }
        }
      }());
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multipartPolicyName = undefined;
  exports.multipartPolicy = multipartPolicy;
  var bytesEncoding_js_1 = require_bytesEncoding();
  var typeGuards_js_1 = require_typeGuards();
  var uuidUtils_js_1 = require_uuidUtils();
  var concat_js_1 = require_concat();
  function generateBoundary() {
    return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
  }
  function encodeHeaders(headers) {
    let result = "";
    for (const [key, value] of headers) {
      result += `${key}: ${value}\r
`;
    }
    return result;
  }
  function getLength(source) {
    if (source instanceof Uint8Array) {
      return source.byteLength;
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return source.size === -1 ? undefined : source.size;
    } else {
      return;
    }
  }
  function getTotalLength(sources) {
    let total = 0;
    for (const source of sources) {
      const partLength = getLength(source);
      if (partLength === undefined) {
        return;
      } else {
        total += partLength;
      }
    }
    return total;
  }
  async function buildRequestBody(request, parts, boundary) {
    const sources = [
      (0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
      ...parts.flatMap((part) => [
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
`, "utf-8"),
        (0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
`, "utf-8"),
        part.body,
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
--${boundary}`, "utf-8")
      ]),
      (0, bytesEncoding_js_1.stringToUint8Array)(`--\r
\r
`, "utf-8")
    ];
    const contentLength = getTotalLength(sources);
    if (contentLength) {
      request.headers.set("Content-Length", contentLength);
    }
    request.body = await (0, concat_js_1.concat)(sources);
  }
  exports.multipartPolicyName = "multipartPolicy";
  var maxBoundaryLength = 70;
  var validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
  function assertValidBoundary(boundary) {
    if (boundary.length > maxBoundaryLength) {
      throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
    }
    if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
      throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
    }
  }
  function multipartPolicy() {
    return {
      name: exports.multipartPolicyName,
      async sendRequest(request, next) {
        if (!request.multipartBody) {
          return next(request);
        }
        if (request.body) {
          throw new Error("multipartBody and regular body cannot be set at the same time");
        }
        let boundary = request.multipartBody.boundary;
        const contentTypeHeader = request.headers.get("Content-Type") ?? "multipart/mixed";
        const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
        if (!parsedHeader) {
          throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
        }
        const [, contentType, parsedBoundary] = parsedHeader;
        if (parsedBoundary && boundary && parsedBoundary !== boundary) {
          throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
        }
        boundary ??= parsedBoundary;
        if (boundary) {
          assertValidBoundary(boundary);
        } else {
          boundary = generateBoundary();
        }
        request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
        await buildRequestBody(request, request.multipartBody.parts, boundary);
        request.multipartBody = undefined;
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineFromOptions = createPipelineFromOptions;
  var logPolicy_js_1 = require_logPolicy();
  var pipeline_js_1 = require_pipeline();
  var redirectPolicy_js_1 = require_redirectPolicy();
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  var formDataPolicy_js_1 = require_formDataPolicy();
  var checkEnvironment_js_1 = require_checkEnvironment();
  var proxyPolicy_js_1 = require_proxyPolicy();
  var agentPolicy_js_1 = require_agentPolicy();
  var tlsPolicy_js_1 = require_tlsPolicy();
  var multipartPolicy_js_1 = require_multipartPolicy();
  function createPipelineFromOptions(options) {
    const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
    if (checkEnvironment_js_1.isNodeLike) {
      if (options.agent) {
        pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
      }
      if (options.tlsOptions) {
        pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
      }
      pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
      pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
    pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
    if (checkEnvironment_js_1.isNodeLike) {
      pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
    return pipeline;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/apiVersionPolicy.js
var require_apiVersionPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.apiVersionPolicyName = undefined;
  exports.apiVersionPolicy = apiVersionPolicy;
  exports.apiVersionPolicyName = "ApiVersionPolicy";
  function apiVersionPolicy(options) {
    return {
      name: exports.apiVersionPolicyName,
      sendRequest: (req, next) => {
        const url = new URL(req.url);
        if (!url.searchParams.get("api-version") && options.apiVersion) {
          req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
        }
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/credentials.js
var require_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isOAuth2TokenCredential = isOAuth2TokenCredential;
  exports.isBearerTokenCredential = isBearerTokenCredential;
  exports.isBasicCredential = isBasicCredential;
  exports.isApiKeyCredential = isApiKeyCredential;
  function isOAuth2TokenCredential(credential) {
    return "getOAuth2Token" in credential;
  }
  function isBearerTokenCredential(credential) {
    return "getBearerToken" in credential;
  }
  function isBasicCredential(credential) {
    return "username" in credential && "password" in credential;
  }
  function isApiKeyCredential(credential) {
    return "key" in credential;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/checkInsecureConnection.js
var require_checkInsecureConnection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ensureSecureConnection = ensureSecureConnection;
  var log_js_1 = require_log2();
  var insecureConnectionWarningEmmitted = false;
  function allowInsecureConnection(request, options) {
    if (options.allowInsecureConnection && request.allowInsecureConnection) {
      const url = new URL(request.url);
      if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
        return true;
      }
    }
    return false;
  }
  function emitInsecureConnectionWarning() {
    const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
    log_js_1.logger.warning(warning);
    if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
      insecureConnectionWarningEmmitted = true;
      process.emitWarning(warning);
    }
  }
  function ensureSecureConnection(request, options) {
    if (!request.url.toLowerCase().startsWith("https://")) {
      if (allowInsecureConnection(request, options)) {
        emitInsecureConnectionWarning();
      } else {
        throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
      }
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/apiKeyAuthenticationPolicy.js
var require_apiKeyAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.apiKeyAuthenticationPolicyName = undefined;
  exports.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
  function apiKeyAuthenticationPolicy(options) {
    return {
      name: exports.apiKeyAuthenticationPolicyName,
      async sendRequest(request, next) {
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
        const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
        if (!scheme) {
          return next(request);
        }
        if (scheme.apiKeyLocation !== "header") {
          throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
        }
        request.headers.set(scheme.name, options.credential.key);
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/basicAuthenticationPolicy.js
var require_basicAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.basicAuthenticationPolicyName = undefined;
  exports.basicAuthenticationPolicy = basicAuthenticationPolicy;
  var bytesEncoding_js_1 = require_bytesEncoding();
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function basicAuthenticationPolicy(options) {
    return {
      name: exports.basicAuthenticationPolicyName,
      async sendRequest(request, next) {
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
        const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "basic");
        if (!scheme) {
          return next(request);
        }
        const { username, password } = options.credential;
        const headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
        request.headers.set("Authorization", `Basic ${headerValue}`);
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/bearerAuthenticationPolicy.js
var require_bearerAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearerAuthenticationPolicyName = undefined;
  exports.bearerAuthenticationPolicy = bearerAuthenticationPolicy;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function bearerAuthenticationPolicy(options) {
    return {
      name: exports.bearerAuthenticationPolicyName,
      async sendRequest(request, next) {
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
        const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "bearer");
        if (!scheme) {
          return next(request);
        }
        const token = await options.credential.getBearerToken({
          abortSignal: request.abortSignal
        });
        request.headers.set("Authorization", `Bearer ${token}`);
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/oauth2AuthenticationPolicy.js
var require_oauth2AuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.oauth2AuthenticationPolicyName = undefined;
  exports.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
  function oauth2AuthenticationPolicy(options) {
    return {
      name: exports.oauth2AuthenticationPolicyName,
      async sendRequest(request, next) {
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
        const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
        if (!scheme) {
          return next(request);
        }
        const token = await options.credential.getOAuth2Token(scheme.flows, {
          abortSignal: request.abortSignal
        });
        request.headers.set("Authorization", `Bearer ${token}`);
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/clientHelpers.js
var require_clientHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultPipeline = createDefaultPipeline;
  exports.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient;
  var defaultHttpClient_js_1 = require_defaultHttpClient();
  var createPipelineFromOptions_js_1 = require_createPipelineFromOptions();
  var apiVersionPolicy_js_1 = require_apiVersionPolicy();
  var credentials_js_1 = require_credentials();
  var apiKeyAuthenticationPolicy_js_1 = require_apiKeyAuthenticationPolicy();
  var basicAuthenticationPolicy_js_1 = require_basicAuthenticationPolicy();
  var bearerAuthenticationPolicy_js_1 = require_bearerAuthenticationPolicy();
  var oauth2AuthenticationPolicy_js_1 = require_oauth2AuthenticationPolicy();
  var cachedHttpClient;
  function createDefaultPipeline(options = {}) {
    const pipeline = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options);
    pipeline.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options));
    const { credential, authSchemes, allowInsecureConnection } = options;
    if (credential) {
      if ((0, credentials_js_1.isApiKeyCredential)(credential)) {
        pipeline.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      } else if ((0, credentials_js_1.isBasicCredential)(credential)) {
        pipeline.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      } else if ((0, credentials_js_1.isBearerTokenCredential)(credential)) {
        pipeline.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      } else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential)) {
        pipeline.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      }
    }
    return pipeline;
  }
  function getCachedDefaultHttpsClient() {
    if (!cachedHttpClient) {
      cachedHttpClient = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
    }
    return cachedHttpClient;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/multipart.js
var require_multipart = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildBodyPart = buildBodyPart;
  exports.buildMultipartBody = buildMultipartBody;
  var restError_js_1 = require_restError();
  var httpHeaders_js_1 = require_httpHeaders();
  var bytesEncoding_js_1 = require_bytesEncoding();
  var typeGuards_js_1 = require_typeGuards();
  function getHeaderValue(descriptor, headerName) {
    if (descriptor.headers) {
      const actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
      if (actualHeaderName) {
        return descriptor.headers[actualHeaderName];
      }
    }
    return;
  }
  function getPartContentType(descriptor) {
    const contentTypeHeader = getHeaderValue(descriptor, "content-type");
    if (contentTypeHeader) {
      return contentTypeHeader;
    }
    if (descriptor.contentType === null) {
      return;
    }
    if (descriptor.contentType) {
      return descriptor.contentType;
    }
    const { body } = descriptor;
    if (body === null || body === undefined) {
      return;
    }
    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
      return "text/plain; charset=UTF-8";
    }
    if (body instanceof Blob) {
      return body.type || "application/octet-stream";
    }
    if ((0, typeGuards_js_1.isBinaryBody)(body)) {
      return "application/octet-stream";
    }
    return "application/json";
  }
  function escapeDispositionField(value) {
    return JSON.stringify(value);
  }
  function getContentDisposition(descriptor) {
    const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
    if (contentDispositionHeader) {
      return contentDispositionHeader;
    }
    if (descriptor.dispositionType === undefined && descriptor.name === undefined && descriptor.filename === undefined) {
      return;
    }
    const dispositionType = descriptor.dispositionType ?? "form-data";
    let disposition = dispositionType;
    if (descriptor.name) {
      disposition += `; name=${escapeDispositionField(descriptor.name)}`;
    }
    let filename = undefined;
    if (descriptor.filename) {
      filename = descriptor.filename;
    } else if (typeof File !== "undefined" && descriptor.body instanceof File) {
      const filenameFromFile = descriptor.body.name;
      if (filenameFromFile !== "") {
        filename = filenameFromFile;
      }
    }
    if (filename) {
      disposition += `; filename=${escapeDispositionField(filename)}`;
    }
    return disposition;
  }
  function normalizeBody(body, contentType) {
    if (body === undefined) {
      return new Uint8Array([]);
    }
    if ((0, typeGuards_js_1.isBinaryBody)(body)) {
      return body;
    }
    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
      return (0, bytesEncoding_js_1.stringToUint8Array)(String(body), "utf-8");
    }
    if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
      return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body), "utf-8");
    }
    throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
  }
  function buildBodyPart(descriptor) {
    const contentType = getPartContentType(descriptor);
    const contentDisposition = getContentDisposition(descriptor);
    const headers = (0, httpHeaders_js_1.createHttpHeaders)(descriptor.headers ?? {});
    if (contentType) {
      headers.set("content-type", contentType);
    }
    if (contentDisposition) {
      headers.set("content-disposition", contentDisposition);
    }
    const body = normalizeBody(descriptor.body, contentType);
    return {
      headers,
      body
    };
  }
  function buildMultipartBody(parts) {
    return { parts: parts.map(buildBodyPart) };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/sendRequest.js
var require_sendRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sendRequest = sendRequest;
  var restError_js_1 = require_restError();
  var httpHeaders_js_1 = require_httpHeaders();
  var pipelineRequest_js_1 = require_pipelineRequest();
  var clientHelpers_js_1 = require_clientHelpers();
  var typeGuards_js_1 = require_typeGuards();
  var multipart_js_1 = require_multipart();
  async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
    const httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
    const request = buildPipelineRequest(method, url, options);
    try {
      const response = await pipeline.sendRequest(httpClient, request);
      const headers = response.headers.toJSON();
      const stream = response.readableStreamBody ?? response.browserStreamBody;
      const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);
      const body = stream ?? parsedBody;
      if (options?.onResponse) {
        options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });
      }
      return {
        request,
        headers,
        status: `${response.status}`,
        body
      };
    } catch (e) {
      if ((0, restError_js_1.isRestError)(e) && e.response && options.onResponse) {
        const { response } = e;
        const rawHeaders = response.headers.toJSON();
        options?.onResponse({ ...response, request, rawHeaders }, e);
      }
      throw e;
    }
  }
  function getRequestContentType(options = {}) {
    return options.contentType ?? options.headers?.["content-type"] ?? getContentType(options.body);
  }
  function getContentType(body) {
    if (ArrayBuffer.isView(body)) {
      return "application/octet-stream";
    }
    if (typeof body === "string") {
      try {
        JSON.parse(body);
        return "application/json";
      } catch (error) {
        return;
      }
    }
    return "application/json";
  }
  function buildPipelineRequest(method, url, options = {}) {
    const requestContentType = getRequestContentType(options);
    const { body, multipartBody } = getRequestBody(options.body, requestContentType);
    const hasContent = body !== undefined || multipartBody !== undefined;
    const headers = (0, httpHeaders_js_1.createHttpHeaders)({
      ...options.headers ? options.headers : {},
      accept: options.accept ?? options.headers?.accept ?? "application/json",
      ...hasContent && requestContentType && {
        "content-type": requestContentType
      }
    });
    return (0, pipelineRequest_js_1.createPipelineRequest)({
      url,
      method,
      body,
      multipartBody,
      headers,
      allowInsecureConnection: options.allowInsecureConnection,
      abortSignal: options.abortSignal,
      onUploadProgress: options.onUploadProgress,
      onDownloadProgress: options.onDownloadProgress,
      timeout: options.timeout,
      enableBrowserStreams: true,
      streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : undefined
    });
  }
  function getRequestBody(body, contentType = "") {
    if (body === undefined) {
      return { body: undefined };
    }
    if (typeof FormData !== "undefined" && body instanceof FormData) {
      return { body };
    }
    if ((0, typeGuards_js_1.isReadableStream)(body)) {
      return { body };
    }
    if (ArrayBuffer.isView(body)) {
      return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
    }
    const firstType = contentType.split(";")[0];
    switch (firstType) {
      case "application/json":
        return { body: JSON.stringify(body) };
      case "multipart/form-data":
        if (Array.isArray(body)) {
          return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body) };
        }
        return { body: JSON.stringify(body) };
      case "text/plain":
        return { body: String(body) };
      default:
        if (typeof body === "string") {
          return { body };
        }
        return { body: JSON.stringify(body) };
    }
  }
  function getResponseBody(response) {
    const contentType = response.headers.get("content-type") ?? "";
    const firstType = contentType.split(";")[0];
    const bodyToParse = response.bodyAsText ?? "";
    if (firstType === "text/plain") {
      return String(bodyToParse);
    }
    try {
      return bodyToParse ? JSON.parse(bodyToParse) : undefined;
    } catch (error) {
      if (firstType === "application/json") {
        throw createParseError(response, error);
      }
      return String(bodyToParse);
    }
  }
  function createParseError(response, err) {
    const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
    const errCode = err.code ?? restError_js_1.RestError.PARSE_ERROR;
    return new restError_js_1.RestError(msg, {
      code: errCode,
      statusCode: response.status,
      request: response.request,
      response
    });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/urlHelpers.js
var require_urlHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildRequestUrl = buildRequestUrl;
  exports.buildBaseUrl = buildBaseUrl;
  exports.replaceAll = replaceAll;
  function isQueryParameterWithOptions(x) {
    const value = x.value;
    return value !== undefined && value.toString !== undefined && typeof value.toString === "function";
  }
  function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {
    if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
      return routePath;
    }
    endpoint = buildBaseUrl(endpoint, options);
    routePath = buildRoutePath(routePath, pathParameters, options);
    const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
    const url = new URL(requestUrl);
    return url.toString().replace(/([^:]\/)\/+/g, "$1");
  }
  function getQueryParamValue(key, allowReserved, style, param) {
    let separator;
    if (style === "pipeDelimited") {
      separator = "|";
    } else if (style === "spaceDelimited") {
      separator = "%20";
    } else {
      separator = ",";
    }
    let paramValues;
    if (Array.isArray(param)) {
      paramValues = param;
    } else if (typeof param === "object" && param.toString === Object.prototype.toString) {
      paramValues = Object.entries(param).flat();
    } else {
      paramValues = [param];
    }
    const value = paramValues.map((p) => {
      if (p === null || p === undefined) {
        return "";
      }
      if (!p.toString || typeof p.toString !== "function") {
        throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
      }
      const rawValue = p.toISOString !== undefined ? p.toISOString() : p.toString();
      return allowReserved ? rawValue : encodeURIComponent(rawValue);
    }).join(separator);
    return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
  }
  function appendQueryParams(url, options = {}) {
    if (!options.queryParameters) {
      return url;
    }
    const parsedUrl = new URL(url);
    const queryParams = options.queryParameters;
    const paramStrings = [];
    for (const key of Object.keys(queryParams)) {
      const param = queryParams[key];
      if (param === undefined || param === null) {
        continue;
      }
      const hasMetadata = isQueryParameterWithOptions(param);
      const rawValue = hasMetadata ? param.value : param;
      const explode = hasMetadata ? param.explode ?? false : false;
      const style = hasMetadata && param.style ? param.style : "form";
      if (explode) {
        if (Array.isArray(rawValue)) {
          for (const item of rawValue) {
            paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, item));
          }
        } else if (typeof rawValue === "object") {
          for (const [actualKey, value] of Object.entries(rawValue)) {
            paramStrings.push(getQueryParamValue(actualKey, options.skipUrlEncoding ?? false, style, value));
          }
        } else {
          throw new Error("explode can only be set to true for objects and arrays");
        }
      } else {
        paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, rawValue));
      }
    }
    if (parsedUrl.search !== "") {
      parsedUrl.search += "&";
    }
    parsedUrl.search += paramStrings.join("&");
    return parsedUrl.toString();
  }
  function buildBaseUrl(endpoint, options) {
    if (!options.pathParameters) {
      return endpoint;
    }
    const pathParams = options.pathParameters;
    for (const [key, param] of Object.entries(pathParams)) {
      if (param === undefined || param === null) {
        throw new Error(`Path parameters ${key} must not be undefined or null`);
      }
      if (!param.toString || typeof param.toString !== "function") {
        throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
      }
      let value = param.toISOString !== undefined ? param.toISOString() : String(param);
      if (!options.skipUrlEncoding) {
        value = encodeURIComponent(param);
      }
      endpoint = replaceAll(endpoint, `{${key}}`, value) ?? "";
    }
    return endpoint;
  }
  function buildRoutePath(routePath, pathParameters, options = {}) {
    for (const pathParam of pathParameters) {
      const allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? false);
      let value = typeof pathParam === "object" ? pathParam.value : pathParam;
      if (!options.skipUrlEncoding && !allowReserved) {
        value = encodeURIComponent(value);
      }
      routePath = routePath.replace(/\{[\w-]+\}/, String(value));
    }
    return routePath;
  }
  function replaceAll(value, searchValue, replaceValue) {
    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/getClient.js
var require_getClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getClient = getClient;
  var clientHelpers_js_1 = require_clientHelpers();
  var sendRequest_js_1 = require_sendRequest();
  var urlHelpers_js_1 = require_urlHelpers();
  var checkEnvironment_js_1 = require_checkEnvironment();
  function getClient(endpoint, clientOptions = {}) {
    const pipeline = clientOptions.pipeline ?? (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
    if (clientOptions.additionalPolicies?.length) {
      for (const { policy, position } of clientOptions.additionalPolicies) {
        const afterPhase = position === "perRetry" ? "Sign" : undefined;
        pipeline.addPolicy(policy, {
          afterPhase
        });
      }
    }
    const { allowInsecureConnection, httpClient } = clientOptions;
    const endpointUrl = clientOptions.endpoint ?? endpoint;
    const client = (path, ...args) => {
      const getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path, args, { allowInsecureConnection, ...requestOptions });
      return {
        get: (requestOptions = {}) => {
          return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        post: (requestOptions = {}) => {
          return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        put: (requestOptions = {}) => {
          return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        patch: (requestOptions = {}) => {
          return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        delete: (requestOptions = {}) => {
          return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        head: (requestOptions = {}) => {
          return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        options: (requestOptions = {}) => {
          return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        trace: (requestOptions = {}) => {
          return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        }
      };
    };
    return {
      path: client,
      pathUnchecked: client,
      pipeline
    };
  }
  function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
    allowInsecureConnection = options.allowInsecureConnection ?? allowInsecureConnection;
    return {
      then: function(onFulfilled, onrejected) {
        return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection }, httpClient).then(onFulfilled, onrejected);
      },
      async asBrowserStream() {
        if (checkEnvironment_js_1.isNodeLike) {
          throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
        } else {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
        }
      },
      async asNodeStream() {
        if (checkEnvironment_js_1.isNodeLike) {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
        } else {
          throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
        }
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/operationOptionHelpers.js
var require_operationOptionHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
  function operationOptionsToRequestParameters(options) {
    return {
      allowInsecureConnection: options.requestOptions?.allowInsecureConnection,
      timeout: options.requestOptions?.timeout,
      skipUrlEncoding: options.requestOptions?.skipUrlEncoding,
      abortSignal: options.abortSignal,
      onUploadProgress: options.requestOptions?.onUploadProgress,
      onDownloadProgress: options.requestOptions?.onDownloadProgress,
      headers: { ...options.requestOptions?.headers },
      onResponse: options.onResponse
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/restError.js
var require_restError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRestError = createRestError;
  var restError_js_1 = require_restError();
  var httpHeaders_js_1 = require_httpHeaders();
  function createRestError(messageOrResponse, response) {
    const resp = typeof messageOrResponse === "string" ? response : messageOrResponse;
    const internalError = resp.body?.error ?? resp.body;
    const message = typeof messageOrResponse === "string" ? messageOrResponse : internalError?.message ?? `Unexpected status code: ${resp.status}`;
    return new restError_js_1.RestError(message, {
      statusCode: statusCodeToNumber(resp.status),
      code: internalError?.code,
      request: resp.request,
      response: toPipelineResponse(resp)
    });
  }
  function toPipelineResponse(response) {
    return {
      headers: (0, httpHeaders_js_1.createHttpHeaders)(response.headers),
      request: response.request,
      status: statusCodeToNumber(response.status) ?? -1
    };
  }
  function statusCodeToNumber(statusCode) {
    const status = Number.parseInt(statusCode);
    return Number.isNaN(status) ? undefined : status;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/index.js
var require_commonjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRestError = exports.operationOptionsToRequestParameters = exports.getClient = exports.createDefaultHttpClient = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isRestError = exports.RestError = exports.createEmptyPipeline = exports.createPipelineRequest = exports.createHttpHeaders = exports.TypeSpecRuntimeLogger = exports.setLogLevel = exports.getLogLevel = exports.createClientLogger = exports.AbortError = undefined;
  var tslib_1 = require_tslib();
  var AbortError_js_1 = require_AbortError();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
  var logger_js_1 = require_logger();
  Object.defineProperty(exports, "createClientLogger", { enumerable: true, get: function() {
    return logger_js_1.createClientLogger;
  } });
  Object.defineProperty(exports, "getLogLevel", { enumerable: true, get: function() {
    return logger_js_1.getLogLevel;
  } });
  Object.defineProperty(exports, "setLogLevel", { enumerable: true, get: function() {
    return logger_js_1.setLogLevel;
  } });
  Object.defineProperty(exports, "TypeSpecRuntimeLogger", { enumerable: true, get: function() {
    return logger_js_1.TypeSpecRuntimeLogger;
  } });
  var httpHeaders_js_1 = require_httpHeaders();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  tslib_1.__exportStar(require_schemes(), exports);
  tslib_1.__exportStar(require_oauth2Flows(), exports);
  var pipelineRequest_js_1 = require_pipelineRequest();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var pipeline_js_1 = require_pipeline();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var restError_js_1 = require_restError();
  Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
    return restError_js_1.isRestError;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var getClient_js_1 = require_getClient();
  Object.defineProperty(exports, "getClient", { enumerable: true, get: function() {
    return getClient_js_1.getClient;
  } });
  var operationOptionHelpers_js_1 = require_operationOptionHelpers();
  Object.defineProperty(exports, "operationOptionsToRequestParameters", { enumerable: true, get: function() {
    return operationOptionHelpers_js_1.operationOptionsToRequestParameters;
  } });
  var restError_js_2 = require_restError2();
  Object.defineProperty(exports, "createRestError", { enumerable: true, get: function() {
    return restError_js_2.createRestError;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js
var require_pipeline2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createEmptyPipeline = createEmptyPipeline;
  var ts_http_runtime_1 = require_commonjs3();
  function createEmptyPipeline() {
    return (0, ts_http_runtime_1.createEmptyPipeline)();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/internal.js
var require_internal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLoggerContext = undefined;
  var logger_js_1 = require_logger();
  Object.defineProperty(exports, "createLoggerContext", { enumerable: true, get: function() {
    return logger_js_1.createLoggerContext;
  } });
});

// node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureLogger = undefined;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var logger_1 = require_internal();
  var context = (0, logger_1.createLoggerContext)({
    logLevelEnvVarName: "AZURE_LOG_LEVEL",
    namespace: "azure"
  });
  exports.AzureLogger = context.logger;
  function setLogLevel(level) {
    context.setLogLevel(level);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js
var require_log3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs4();
  exports.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryPolicyName = undefined;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants6();
  exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
  function exponentialRetryPolicy(options = {}) {
    return (0, retryPolicy_js_1.retryPolicy)([
      (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
        ...options,
        ignoreSystemErrors: true
      })
    ], {
      maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
    });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.systemErrorRetryPolicyName = undefined;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants6();
  exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
  function systemErrorRetryPolicy(options = {}) {
    return {
      name: exports.systemErrorRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([
        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
          ...options,
          ignoreHttpStatusCodes: true
        })
      ], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttlingRetryPolicyName = undefined;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants6();
  exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
  function throttlingRetryPolicy(options = {}) {
    return {
      name: exports.throttlingRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/internal.js
var require_internal2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = exports.userAgentPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.retryPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.defaultRetryPolicyName = exports.defaultRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.agentPolicyName = exports.agentPolicy = undefined;
  var agentPolicy_js_1 = require_agentPolicy();
  Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicy;
  } });
  Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicyName;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  Object.defineProperty(exports, "defaultRetryPolicyName", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy();
  Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy();
  Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js
var require_logPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logPolicyName = undefined;
  exports.logPolicy = logPolicy;
  var log_js_1 = require_log3();
  var policies_1 = require_internal2();
  exports.logPolicyName = policies_1.logPolicyName;
  function logPolicy(options = {}) {
    return (0, policies_1.logPolicy)({
      logger: log_js_1.logger.info,
      ...options
    });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redirectPolicyName = undefined;
  exports.redirectPolicy = redirectPolicy;
  var policies_1 = require_internal2();
  exports.redirectPolicyName = policies_1.redirectPolicyName;
  function redirectPolicy(options = {}) {
    return (0, policies_1.redirectPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeaderName = getHeaderName;
  exports.setPlatformSpecificData = setPlatformSpecificData;
  var tslib_1 = require_tslib();
  var node_os_1 = tslib_1.__importDefault(__require("node:os"));
  var node_process_1 = tslib_1.__importDefault(__require("node:process"));
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (node_process_1.default && node_process_1.default.versions) {
      const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
      const versions = node_process_1.default.versions;
      if (versions.bun) {
        map.set("Bun", `${versions.bun} (${osInfo})`);
      } else if (versions.deno) {
        map.set("Deno", `${versions.deno} (${osInfo})`);
      } else if (versions.node) {
        map.set("Node", `${versions.node} (${osInfo})`);
      }
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js
var require_constants7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "1.22.2";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js
var require_userAgent2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentHeaderName = getUserAgentHeaderName;
  exports.getUserAgentValue = getUserAgentValue;
  var userAgentPlatform_js_1 = require_userAgentPlatform2();
  var constants_js_1 = require_constants7();
  function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    const runtimeInfo = new Map;
    runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = undefined;
  exports.userAgentPolicy = userAgentPolicy;
  var userAgent_js_1 = require_userAgent2();
  var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy(options = {}) {
    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(UserAgentHeaderName)) {
          request.headers.set(UserAgentHeaderName, await userAgentValue);
        }
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sha256.js
var require_sha256 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.computeSha256Hash = computeSha256Hash;
  var node_crypto_1 = __require("node:crypto");
  async function computeSha256Hmac(key, stringToSign, encoding) {
    const decodedKey = Buffer.from(key, "base64");
    return (0, node_crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
  }
  async function computeSha256Hash(content, encoding) {
    return (0, node_crypto_1.createHash)("sha256").update(content).digest(encoding);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/internal.js
var require_internal3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Sanitizer = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isBrowser = exports.randomUUID = exports.computeSha256Hmac = exports.computeSha256Hash = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.calculateRetryDelay = undefined;
  var delay_js_1 = require_delay();
  Object.defineProperty(exports, "calculateRetryDelay", { enumerable: true, get: function() {
    return delay_js_1.calculateRetryDelay;
  } });
  var random_js_1 = require_random();
  Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: true, get: function() {
    return random_js_1.getRandomIntegerInclusive;
  } });
  var object_js_1 = require_object();
  Object.defineProperty(exports, "isObject", { enumerable: true, get: function() {
    return object_js_1.isObject;
  } });
  var error_js_1 = require_error();
  Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
    return error_js_1.isError;
  } });
  var sha256_js_1 = require_sha256();
  Object.defineProperty(exports, "computeSha256Hash", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hash;
  } });
  Object.defineProperty(exports, "computeSha256Hmac", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hmac;
  } });
  var uuidUtils_js_1 = require_uuidUtils();
  Object.defineProperty(exports, "randomUUID", { enumerable: true, get: function() {
    return uuidUtils_js_1.randomUUID;
  } });
  var checkEnvironment_js_1 = require_checkEnvironment();
  Object.defineProperty(exports, "isBrowser", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBrowser;
  } });
  Object.defineProperty(exports, "isBun", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBun;
  } });
  Object.defineProperty(exports, "isNodeLike", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeLike;
  } });
  Object.defineProperty(exports, "isNodeRuntime", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeRuntime;
  } });
  Object.defineProperty(exports, "isDeno", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isDeno;
  } });
  Object.defineProperty(exports, "isReactNative", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isReactNative;
  } });
  Object.defineProperty(exports, "isWebWorker", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isWebWorker;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  var sanitizer_js_1 = require_sanitizer();
  Object.defineProperty(exports, "Sanitizer", { enumerable: true, get: function() {
    return sanitizer_js_1.Sanitizer;
  } });
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cancelablePromiseRace = cancelablePromiseRace;
  async function cancelablePromiseRace(abortablePromiseBuilders, options) {
    const aborter = new AbortController;
    function abortHandler() {
      aborter.abort();
    }
    options?.abortSignal?.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort();
      options?.abortSignal?.removeEventListener("abort", abortHandler);
    }
  }
});

// node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError2();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createAbortablePromise = createAbortablePromise;
  var abort_controller_1 = require_commonjs5();
  function createAbortablePromise(buildPromise, options) {
    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
    return new Promise((resolve, reject) => {
      function rejectOnAbort() {
        reject(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal?.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort?.();
        removeListeners();
        rejectOnAbort();
      }
      if (abortSignal?.aborted) {
        return rejectOnAbort();
      }
      try {
        buildPromise((x) => {
          removeListeners();
          resolve(x);
        }, (x) => {
          removeListeners();
          reject(x);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal?.addEventListener("abort", onAbort);
    });
  }
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay;
  exports.calculateRetryDelay = calculateRetryDelay;
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  var util_1 = require_internal3();
  var StandardAbortMessage = "The delay was aborted.";
  function delay(timeInMs, options) {
    let token;
    const { abortSignal, abortErrorMsg } = options ?? {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal,
      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
    });
  }
  function calculateRetryDelay(retryAttempt, config) {
    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    const retryAfterInMs = clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return { retryAfterInMs };
  }
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getErrorMessage = getErrorMessage;
  var util_1 = require_internal3();
  function getErrorMessage(e) {
    if ((0, util_1.isError)(e)) {
      return e.message;
    } else {
      let stringified;
      try {
        if (typeof e === "object" && e) {
          stringified = JSON.stringify(e);
        } else {
          stringified = String(e);
        }
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDefined = isDefined;
  exports.isObjectWithProperties = isObjectWithProperties;
  exports.objectHasProperty = objectHasProperty;
  function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
  }
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
      return false;
    }
    for (const property of properties) {
      if (!objectHasProperty(thing, property)) {
        return false;
      }
    }
    return true;
  }
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
  }
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWebWorker = exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.getErrorMessage = exports.delay = exports.createAbortablePromise = exports.cancelablePromiseRace = undefined;
  exports.calculateRetryDelay = calculateRetryDelay;
  exports.computeSha256Hash = computeSha256Hash;
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
  exports.isError = isError;
  exports.isObject = isObject;
  exports.randomUUID = randomUUID;
  exports.uint8ArrayToString = uint8ArrayToString;
  exports.stringToUint8Array = stringToUint8Array;
  var tslib_1 = require_tslib();
  var tspRuntime = tslib_1.__importStar(require_internal3());
  var aborterUtils_js_1 = require_aborterUtils();
  Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: true, get: function() {
    return aborterUtils_js_1.cancelablePromiseRace;
  } });
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  Object.defineProperty(exports, "createAbortablePromise", { enumerable: true, get: function() {
    return createAbortablePromise_js_1.createAbortablePromise;
  } });
  var delay_js_1 = require_delay2();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_js_1.delay;
  } });
  var error_js_1 = require_error2();
  Object.defineProperty(exports, "getErrorMessage", { enumerable: true, get: function() {
    return error_js_1.getErrorMessage;
  } });
  var typeGuards_js_1 = require_typeGuards2();
  Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
    return typeGuards_js_1.isDefined;
  } });
  Object.defineProperty(exports, "isObjectWithProperties", { enumerable: true, get: function() {
    return typeGuards_js_1.isObjectWithProperties;
  } });
  Object.defineProperty(exports, "objectHasProperty", { enumerable: true, get: function() {
    return typeGuards_js_1.objectHasProperty;
  } });
  function calculateRetryDelay(retryAttempt, config) {
    return tspRuntime.calculateRetryDelay(retryAttempt, config);
  }
  function computeSha256Hash(content, encoding) {
    return tspRuntime.computeSha256Hash(content, encoding);
  }
  function computeSha256Hmac(key, stringToSign, encoding) {
    return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
  }
  function getRandomIntegerInclusive(min, max) {
    return tspRuntime.getRandomIntegerInclusive(min, max);
  }
  function isError(e) {
    return tspRuntime.isError(e);
  }
  function isObject(input) {
    return tspRuntime.isObject(input);
  }
  function randomUUID() {
    return tspRuntime.randomUUID();
  }
  exports.isBrowser = tspRuntime.isBrowser;
  exports.isBun = tspRuntime.isBun;
  exports.isDeno = tspRuntime.isDeno;
  exports.isNode = tspRuntime.isNodeLike;
  exports.isNodeLike = tspRuntime.isNodeLike;
  exports.isNodeRuntime = tspRuntime.isNodeRuntime;
  exports.isReactNative = tspRuntime.isReactNative;
  exports.isWebWorker = tspRuntime.isWebWorker;
  function uint8ArrayToString(bytes, format) {
    return tspRuntime.uint8ArrayToString(bytes, format);
  }
  function stringToUint8Array(value, format) {
    return tspRuntime.stringToUint8Array(value, format);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js
var require_file2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasRawContent = hasRawContent;
  exports.getRawContent = getRawContent;
  exports.createFileFromStream = createFileFromStream;
  exports.createFile = createFile;
  var core_util_1 = require_commonjs6();
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x["pipe"] === "function");
  }
  var unimplementedMethods = {
    arrayBuffer: () => {
      throw new Error("Not implemented");
    },
    bytes: () => {
      throw new Error("Not implemented");
    },
    slice: () => {
      throw new Error("Not implemented");
    },
    text: () => {
      throw new Error("Not implemented");
    }
  };
  var rawContent = Symbol("rawContent");
  function hasRawContent(x) {
    return typeof x[rawContent] === "function";
  }
  function getRawContent(blob) {
    if (hasRawContent(blob)) {
      return blob[rawContent]();
    } else {
      return blob;
    }
  }
  function createFileFromStream(stream, name, options = {}) {
    return {
      ...unimplementedMethods,
      type: options.type ?? "",
      lastModified: options.lastModified ?? new Date().getTime(),
      webkitRelativePath: options.webkitRelativePath ?? "",
      size: options.size ?? -1,
      name,
      stream: () => {
        const s = stream();
        if (isNodeReadableStream(s)) {
          throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
        }
        return s;
      },
      [rawContent]: stream
    };
  }
  function createFile(content, name, options = {}) {
    if (core_util_1.isNodeLike) {
      return {
        ...unimplementedMethods,
        type: options.type ?? "",
        lastModified: options.lastModified ?? new Date().getTime(),
        webkitRelativePath: options.webkitRelativePath ?? "",
        size: content.byteLength,
        name,
        arrayBuffer: async () => content.buffer,
        stream: () => new Blob([toArrayBuffer(content)]).stream(),
        [rawContent]: () => content
      };
    } else {
      return new File([toArrayBuffer(content)], name, options);
    }
  }
  function toArrayBuffer(source) {
    if ("resize" in source.buffer) {
      return source;
    }
    return source.map((x) => x);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multipartPolicyName = undefined;
  exports.multipartPolicy = multipartPolicy;
  var policies_1 = require_internal2();
  var file_js_1 = require_file2();
  exports.multipartPolicyName = policies_1.multipartPolicyName;
  function multipartPolicy() {
    const tspPolicy = (0, policies_1.multipartPolicy)();
    return {
      name: exports.multipartPolicyName,
      sendRequest: async (request, next) => {
        if (request.multipartBody) {
          for (const part of request.multipartBody.parts) {
            if ((0, file_js_1.hasRawContent)(part.body)) {
              part.body = (0, file_js_1.getRawContent)(part.body);
            }
          }
        }
        return tspPolicy.sendRequest(request, next);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompressResponsePolicyName = undefined;
  exports.decompressResponsePolicy = decompressResponsePolicy;
  var policies_1 = require_internal2();
  exports.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
  function decompressResponsePolicy() {
    return (0, policies_1.decompressResponsePolicy)();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultRetryPolicyName = undefined;
  exports.defaultRetryPolicy = defaultRetryPolicy;
  var policies_1 = require_internal2();
  exports.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
  function defaultRetryPolicy(options = {}) {
    return (0, policies_1.defaultRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formDataPolicyName = undefined;
  exports.formDataPolicy = formDataPolicy;
  var policies_1 = require_internal2();
  exports.formDataPolicyName = policies_1.formDataPolicyName;
  function formDataPolicy() {
    return (0, policies_1.formDataPolicy)();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.proxyPolicyName = undefined;
  exports.getDefaultProxySettings = getDefaultProxySettings;
  exports.proxyPolicy = proxyPolicy;
  var policies_1 = require_internal2();
  exports.proxyPolicyName = policies_1.proxyPolicyName;
  function getDefaultProxySettings(proxyUrl) {
    return (0, policies_1.getDefaultProxySettings)(proxyUrl);
  }
  function proxyPolicy(proxySettings, options) {
    return (0, policies_1.proxyPolicy)(proxySettings, options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js
var require_setClientRequestIdPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setClientRequestIdPolicyName = undefined;
  exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
  exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
      name: exports.setClientRequestIdPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(requestIdHeaderName)) {
          request.headers.set(requestIdHeaderName, request.requestId);
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.agentPolicyName = undefined;
  exports.agentPolicy = agentPolicy;
  var policies_1 = require_internal2();
  exports.agentPolicyName = policies_1.agentPolicyName;
  function agentPolicy(agent) {
    return (0, policies_1.agentPolicy)(agent);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tlsPolicyName = undefined;
  exports.tlsPolicy = tlsPolicy;
  var policies_1 = require_internal2();
  exports.tlsPolicyName = policies_1.tlsPolicyName;
  function tlsPolicy(tlsSettings) {
    return (0, policies_1.tlsPolicy)(tlsSettings);
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TracingContextImpl = exports.knownContextKeys = undefined;
  exports.createTracingContext = createTracingContext;
  exports.knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
  };
  function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    if (options.span) {
      context = context.setValue(exports.knownContextKeys.span, options.span);
    }
    if (options.namespace) {
      context = context.setValue(exports.knownContextKeys.namespace, options.namespace);
    }
    return context;
  }

  class TracingContextImpl {
    _contextMap;
    constructor(initialContext) {
      this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : new Map;
    }
    setValue(key, value) {
      const newContext = new TracingContextImpl(this);
      newContext._contextMap.set(key, value);
      return newContext;
    }
    getValue(key) {
      return this._contextMap.get(key);
    }
    deleteValue(key) {
      const newContext = new TracingContextImpl(this);
      newContext._contextMap.delete(key);
      return newContext;
    }
  }
  exports.TracingContextImpl = TracingContextImpl;
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    instrumenterImplementation: undefined
  };
});

// node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultTracingSpan = createDefaultTracingSpan;
  exports.createDefaultInstrumenter = createDefaultInstrumenter;
  exports.useInstrumenter = useInstrumenter;
  exports.getInstrumenter = getInstrumenter;
  var tracingContext_js_1 = require_tracingContext();
  var state_js_1 = require_state();
  function createDefaultTracingSpan() {
    return {
      end: () => {},
      isRecording: () => false,
      recordException: () => {},
      setAttribute: () => {},
      setStatus: () => {},
      addEvent: () => {}
    };
  }
  function createDefaultInstrumenter() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return;
      },
      startSpan: (_name, spanOptions) => {
        return {
          span: createDefaultTracingSpan(),
          tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
        };
      },
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  function useInstrumenter(instrumenter) {
    state_js_1.state.instrumenterImplementation = instrumenter;
  }
  function getInstrumenter() {
    if (!state_js_1.state.instrumenterImplementation) {
      state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
    }
    return state_js_1.state.instrumenterImplementation;
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = createTracingClient;
  var instrumenter_js_1 = require_instrumenter();
  var tracingContext_js_1 = require_tracingContext();
  function createTracingClient(options) {
    const { namespace, packageName, packageVersion } = options;
    function startSpan(name, operationOptions, spanOptions) {
      const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, {
        ...spanOptions,
        packageName,
        packageVersion,
        tracingContext: operationOptions?.tracingOptions?.tracingContext
      });
      let tracingContext = startSpanResult.tracingContext;
      const span = startSpanResult.span;
      if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
        tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
      }
      span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
      const updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: { ...operationOptions?.tracingOptions, tracingContext }
      });
      return {
        span,
        updatedOptions
      };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
      const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
      try {
        const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        span.setStatus({ status: "success" });
        return result;
      } catch (err) {
        span.setStatus({ status: "error", error: err });
        throw err;
      } finally {
        span.end();
      }
    }
    function withContext(context, callback, ...callbackArgs) {
      return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
    }
    function parseTraceparentHeader(traceparentHeader) {
      return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    function createRequestHeaders(tracingContext) {
      return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
    }
    return {
      startSpan,
      withSpan,
      withContext,
      parseTraceparentHeader,
      createRequestHeaders
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = exports.useInstrumenter = undefined;
  var instrumenter_js_1 = require_instrumenter();
  Object.defineProperty(exports, "useInstrumenter", { enumerable: true, get: function() {
    return instrumenter_js_1.useInstrumenter;
  } });
  var tracingClient_js_1 = require_tracingClient();
  Object.defineProperty(exports, "createTracingClient", { enumerable: true, get: function() {
    return tracingClient_js_1.createTracingClient;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js
var require_restError3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestError = undefined;
  exports.isRestError = isRestError;
  var ts_http_runtime_1 = require_commonjs3();
  exports.RestError = ts_http_runtime_1.RestError;
  function isRestError(e) {
    return (0, ts_http_runtime_1.isRestError)(e);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js
var require_tracingPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tracingPolicyName = undefined;
  exports.tracingPolicy = tracingPolicy;
  var core_tracing_1 = require_commonjs7();
  var constants_js_1 = require_constants7();
  var userAgent_js_1 = require_userAgent2();
  var log_js_1 = require_log3();
  var core_util_1 = require_commonjs6();
  var restError_js_1 = require_restError3();
  var util_1 = require_internal3();
  exports.tracingPolicyName = "tracingPolicy";
  function tracingPolicy(options = {}) {
    const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    const sanitizer = new util_1.Sanitizer({
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    const tracingClient = tryCreateTracingClient();
    return {
      name: exports.tracingPolicyName,
      async sendRequest(request, next) {
        if (!tracingClient) {
          return next(request);
        }
        const userAgent = await userAgentPromise;
        const spanAttributes = {
          "http.url": sanitizer.sanitizeUrl(request.url),
          "http.method": request.method,
          "http.user_agent": userAgent,
          requestId: request.requestId
        };
        if (userAgent) {
          spanAttributes["http.user_agent"] = userAgent;
        }
        const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};
        if (!span || !tracingContext) {
          return next(request);
        }
        try {
          const response = await tracingClient.withContext(tracingContext, next, request);
          tryProcessResponse(span, response);
          return response;
        } catch (err) {
          tryProcessError(span, err);
          throw err;
        }
      }
    };
  }
  function tryCreateTracingClient() {
    try {
      return (0, core_tracing_1.createTracingClient)({
        namespace: "",
        packageName: "@azure/core-rest-pipeline",
        packageVersion: constants_js_1.SDK_VERSION
      });
    } catch (e) {
      log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryCreateSpan(tracingClient, request, spanAttributes) {
    try {
      const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
        spanKind: "client",
        spanAttributes
      });
      if (!span.isRecording()) {
        span.end();
        return;
      }
      const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
      for (const [key, value] of Object.entries(headers)) {
        request.headers.set(key, value);
      }
      return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    } catch (e) {
      log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryProcessError(span, error) {
    try {
      span.setStatus({
        status: "error",
        error: (0, core_util_1.isError)(error) ? error : undefined
      });
      if ((0, restError_js_1.isRestError)(error) && error.statusCode) {
        span.setAttribute("http.status_code", error.statusCode);
      }
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
  function tryProcessResponse(span, response) {
    try {
      span.setAttribute("http.status_code", response.status);
      const serviceRequestId = response.headers.get("x-ms-request-id");
      if (serviceRequestId) {
        span.setAttribute("serviceRequestId", serviceRequestId);
      }
      if (response.status >= 400) {
        span.setStatus({
          status: "error"
        });
      }
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/wrapAbortSignal.js
var require_wrapAbortSignal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapAbortSignalLike = wrapAbortSignalLike;
  function wrapAbortSignalLike(abortSignalLike) {
    if (abortSignalLike instanceof AbortSignal) {
      return { abortSignal: abortSignalLike };
    }
    if (abortSignalLike.aborted) {
      return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
    }
    const controller = new AbortController;
    let needsCleanup = true;
    function cleanup() {
      if (needsCleanup) {
        abortSignalLike.removeEventListener("abort", listener);
        needsCleanup = false;
      }
    }
    function listener() {
      controller.abort(abortSignalLike.reason);
      cleanup();
    }
    abortSignalLike.addEventListener("abort", listener);
    return { abortSignal: controller.signal, cleanup };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/wrapAbortSignalLikePolicy.js
var require_wrapAbortSignalLikePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapAbortSignalLikePolicyName = undefined;
  exports.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy;
  var wrapAbortSignal_js_1 = require_wrapAbortSignal();
  exports.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
  function wrapAbortSignalLikePolicy() {
    return {
      name: exports.wrapAbortSignalLikePolicyName,
      sendRequest: async (request, next) => {
        if (!request.abortSignal) {
          return next(request);
        }
        const { abortSignal, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal);
        request.abortSignal = abortSignal;
        try {
          return await next(request);
        } finally {
          cleanup?.();
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineFromOptions = createPipelineFromOptions;
  var logPolicy_js_1 = require_logPolicy2();
  var pipeline_js_1 = require_pipeline2();
  var redirectPolicy_js_1 = require_redirectPolicy2();
  var userAgentPolicy_js_1 = require_userAgentPolicy2();
  var multipartPolicy_js_1 = require_multipartPolicy2();
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
  var formDataPolicy_js_1 = require_formDataPolicy2();
  var core_util_1 = require_commonjs6();
  var proxyPolicy_js_1 = require_proxyPolicy2();
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  var agentPolicy_js_1 = require_agentPolicy2();
  var tlsPolicy_js_1 = require_tlsPolicy2();
  var tracingPolicy_js_1 = require_tracingPolicy();
  var wrapAbortSignalLikePolicy_js_1 = require_wrapAbortSignalLikePolicy();
  function createPipelineFromOptions(options) {
    const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
    if (core_util_1.isNodeLike) {
      if (options.agent) {
        pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
      }
      if (options.tlsOptions) {
        pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
      }
      pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
      pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)());
    pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
    pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)(options.telemetryOptions?.clientRequestIdHeaderName));
    pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
    pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)({ ...options.userAgentOptions, ...options.loggingOptions }), {
      afterPhase: "Retry"
    });
    if (core_util_1.isNodeLike) {
      pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
    return pipeline;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultHttpClient = createDefaultHttpClient;
  var ts_http_runtime_1 = require_commonjs3();
  var wrapAbortSignal_js_1 = require_wrapAbortSignal();
  function createDefaultHttpClient() {
    const client = (0, ts_http_runtime_1.createDefaultHttpClient)();
    return {
      async sendRequest(request) {
        const { abortSignal, cleanup } = request.abortSignal ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal) : {};
        try {
          request.abortSignal = abortSignal;
          return await client.sendRequest(request);
        } finally {
          cleanup?.();
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js
var require_httpHeaders2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpHeaders = createHttpHeaders;
  var ts_http_runtime_1 = require_commonjs3();
  function createHttpHeaders(rawHeaders) {
    return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js
var require_pipelineRequest2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineRequest = createPipelineRequest;
  var ts_http_runtime_1 = require_commonjs3();
  function createPipelineRequest(options) {
    return (0, ts_http_runtime_1.createPipelineRequest)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryPolicyName = undefined;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var policies_1 = require_internal2();
  exports.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
  function exponentialRetryPolicy(options = {}) {
    return (0, policies_1.exponentialRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.systemErrorRetryPolicyName = undefined;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var policies_1 = require_internal2();
  exports.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
  function systemErrorRetryPolicy(options = {}) {
    return (0, policies_1.systemErrorRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttlingRetryPolicyName = undefined;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var policies_1 = require_internal2();
  exports.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
  function throttlingRetryPolicy(options = {}) {
    return (0, policies_1.throttlingRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryPolicy = retryPolicy;
  var logger_1 = require_commonjs4();
  var constants_js_1 = require_constants7();
  var policies_1 = require_internal2();
  var retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
  function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    return (0, policies_1.retryPolicy)(strategies, {
      logger: retryPolicyLogger,
      ...options
    });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js
var require_tokenCycler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CYCLER_OPTIONS = undefined;
  exports.createTokenCycler = createTokenCycler;
  var core_util_1 = require_commonjs6();
  exports.DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2
  };
  async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    async function tryGetAccessToken() {
      if (Date.now() < refreshTimeout) {
        try {
          return await getAccessToken();
        } catch {
          return null;
        }
      } else {
        const finalToken = await getAccessToken();
        if (finalToken === null) {
          throw new Error("Failed to refresh access token.");
        }
        return finalToken;
      }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
      await (0, core_util_1.delay)(retryIntervalInMs);
      token = await tryGetAccessToken();
    }
    return token;
  }
  function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    let tenantId;
    const options = {
      ...exports.DEFAULT_CYCLER_OPTIONS,
      ...tokenCyclerOptions
    };
    const cycler = {
      get isRefreshing() {
        return refreshWorker !== null;
      },
      get shouldRefresh() {
        if (cycler.isRefreshing) {
          return false;
        }
        if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {
          return true;
        }
        return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
      },
      get mustRefresh() {
        return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
      }
    };
    function refresh(scopes, getTokenOptions) {
      if (!cycler.isRefreshing) {
        const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
        refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, token?.expiresOnTimestamp ?? Date.now()).then((_token) => {
          refreshWorker = null;
          token = _token;
          tenantId = getTokenOptions.tenantId;
          return token;
        }).catch((reason) => {
          refreshWorker = null;
          token = null;
          tenantId = undefined;
          throw reason;
        });
      }
      return refreshWorker;
    }
    return async (scopes, tokenOptions) => {
      const hasClaimChallenge = Boolean(tokenOptions.claims);
      const tenantIdChanged = tenantId !== tokenOptions.tenantId;
      if (hasClaimChallenge) {
        token = null;
      }
      const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
      if (mustRefresh) {
        return refresh(scopes, tokenOptions);
      }
      if (cycler.shouldRefresh) {
        refresh(scopes, tokenOptions);
      }
      return token;
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js
var require_bearerTokenAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearerTokenAuthenticationPolicyName = undefined;
  exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
  exports.parseChallenges = parseChallenges;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log3();
  var restError_js_1 = require_restError3();
  exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  async function trySendRequest(request, next) {
    try {
      return [await next(request), undefined];
    } catch (e) {
      if ((0, restError_js_1.isRestError)(e) && e.response) {
        return [e.response, e];
      } else {
        throw e;
      }
    }
  }
  async function defaultAuthorizeRequest(options) {
    const { scopes, getAccessToken, request } = options;
    const getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions,
      enableCae: true
    };
    const accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken) {
      options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    }
  }
  function isChallengeResponse(response) {
    return response.status === 401 && response.headers.has("WWW-Authenticate");
  }
  async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
    const { scopes } = onChallengeOptions;
    const accessToken = await onChallengeOptions.getAccessToken(scopes, {
      enableCae: true,
      claims: caeClaims
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
    return true;
  }
  function bearerTokenAuthenticationPolicy(options) {
    const { credential, scopes, challengeCallbacks } = options;
    const logger = options.logger || log_js_1.logger;
    const callbacks = {
      authorizeRequest: challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
      authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks)
    };
    const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(credential) : () => Promise.resolve(null);
    return {
      name: exports.bearerTokenAuthenticationPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
        }
        await callbacks.authorizeRequest({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          getAccessToken,
          logger
        });
        let response;
        let error;
        let shouldSendRequest;
        [response, error] = await trySendRequest(request, next);
        if (isChallengeResponse(response)) {
          let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
          if (claims) {
            let parsedClaim;
            try {
              parsedClaim = atob(claims);
            } catch (e) {
              logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
              return response;
            }
            shouldSendRequest = await authorizeRequestOnCaeChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              response,
              request,
              getAccessToken,
              logger
            }, parsedClaim);
            if (shouldSendRequest) {
              [response, error] = await trySendRequest(request, next);
            }
          } else if (callbacks.authorizeRequestOnChallenge) {
            shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request,
              response,
              getAccessToken,
              logger
            });
            if (shouldSendRequest) {
              [response, error] = await trySendRequest(request, next);
            }
            if (isChallengeResponse(response)) {
              claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
              if (claims) {
                let parsedClaim;
                try {
                  parsedClaim = atob(claims);
                } catch (e) {
                  logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                  return response;
                }
                shouldSendRequest = await authorizeRequestOnCaeChallenge({
                  scopes: Array.isArray(scopes) ? scopes : [scopes],
                  response,
                  request,
                  getAccessToken,
                  logger
                }, parsedClaim);
                if (shouldSendRequest) {
                  [response, error] = await trySendRequest(request, next);
                }
              }
            }
          }
        }
        if (error) {
          throw error;
        } else {
          return response;
        }
      }
    };
  }
  function parseChallenges(challenges) {
    const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
    const paramRegex = /(\w+)="([^"]*)"/g;
    const parsedChallenges = [];
    let match;
    while ((match = challengeRegex.exec(challenges)) !== null) {
      const scheme = match[1];
      const paramsString = match[2];
      const params = {};
      let paramMatch;
      while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
        params[paramMatch[1]] = paramMatch[2];
      }
      parsedChallenges.push({ scheme, params });
    }
    return parsedChallenges;
  }
  function getCaeChallengeClaims(challenges) {
    if (!challenges) {
      return;
    }
    const parsedChallenges = parseChallenges(challenges);
    return parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")?.params.claims;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js
var require_ndJsonPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ndJsonPolicyName = undefined;
  exports.ndJsonPolicy = ndJsonPolicy;
  exports.ndJsonPolicyName = "ndJsonPolicy";
  function ndJsonPolicy() {
    return {
      name: exports.ndJsonPolicyName,
      async sendRequest(request, next) {
        if (typeof request.body === "string" && request.body.startsWith("[")) {
          const body = JSON.parse(request.body);
          if (Array.isArray(body)) {
            request.body = body.map((item) => JSON.stringify(item) + `
`).join("");
          }
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js
var require_auxiliaryAuthenticationHeaderPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auxiliaryAuthenticationHeaderPolicyName = undefined;
  exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log3();
  exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
  var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
  async function sendAuthorizeRequest(options) {
    const { scopes, getAccessToken, request } = options;
    const getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions
    };
    return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
  }
  function auxiliaryAuthenticationHeaderPolicy(options) {
    const { credentials, scopes } = options;
    const logger = options.logger || log_js_1.logger;
    const tokenCyclerMap = new WeakMap;
    return {
      name: exports.auxiliaryAuthenticationHeaderPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
        }
        if (!credentials || credentials.length === 0) {
          logger.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
          return next(request);
        }
        const tokenPromises = [];
        for (const credential of credentials) {
          let getAccessToken = tokenCyclerMap.get(credential);
          if (!getAccessToken) {
            getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
            tokenCyclerMap.set(credential, getAccessToken);
          }
          tokenPromises.push(sendAuthorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            getAccessToken,
            logger
          }));
        }
        const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
        if (auxiliaryTokens.length === 0) {
          logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
          return next(request);
        }
        request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js
var require_commonjs8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileFromStream = exports.createFile = exports.agentPolicyName = exports.agentPolicy = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = undefined;
  var pipeline_js_1 = require_pipeline2();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var createPipelineFromOptions_js_1 = require_createPipelineFromOptions2();
  Object.defineProperty(exports, "createPipelineFromOptions", { enumerable: true, get: function() {
    return createPipelineFromOptions_js_1.createPipelineFromOptions;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient2();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var httpHeaders_js_1 = require_httpHeaders2();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  var pipelineRequest_js_1 = require_pipelineRequest2();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var restError_js_1 = require_restError3();
  Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
    return restError_js_1.isRestError;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy2();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  Object.defineProperty(exports, "setClientRequestIdPolicy", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
  } });
  Object.defineProperty(exports, "setClientRequestIdPolicyName", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy2();
  Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy2();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy2();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy2();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy2();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy2();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy2();
  Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var tracingPolicy_js_1 = require_tracingPolicy();
  Object.defineProperty(exports, "tracingPolicy", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicy;
  } });
  Object.defineProperty(exports, "tracingPolicyName", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy2();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy2();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy2();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
  } });
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
  } });
  var ndJsonPolicy_js_1 = require_ndJsonPolicy();
  Object.defineProperty(exports, "ndJsonPolicy", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicy;
  } });
  Object.defineProperty(exports, "ndJsonPolicyName", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicyName;
  } });
  var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
  } });
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
  } });
  var agentPolicy_js_1 = require_agentPolicy2();
  Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicy;
  } });
  Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicyName;
  } });
  var file_js_1 = require_file2();
  Object.defineProperty(exports, "createFile", { enumerable: true, get: function() {
    return file_js_1.createFile;
  } });
  Object.defineProperty(exports, "createFileFromStream", { enumerable: true, get: function() {
    return file_js_1.createFileFromStream;
  } });
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureKeyCredential = undefined;

  class AzureKeyCredential {
    _key;
    get key() {
      return this._key;
    }
    constructor(key) {
      if (!key) {
        throw new Error("key must be a non-empty string");
      }
      this._key = key;
    }
    update(newKey) {
      this._key = newKey;
    }
  }
  exports.AzureKeyCredential = AzureKeyCredential;
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isKeyCredential = isKeyCredential;
  var core_util_1 = require_commonjs6();
  function isKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureNamedKeyCredential = undefined;
  exports.isNamedKeyCredential = isNamedKeyCredential;
  var core_util_1 = require_commonjs6();

  class AzureNamedKeyCredential {
    _key;
    _name;
    get key() {
      return this._key;
    }
    get name() {
      return this._name;
    }
    constructor(name, key) {
      if (!name || !key) {
        throw new TypeError("name and key must be non-empty strings");
      }
      this._name = name;
      this._key = key;
    }
    update(newName, newKey) {
      if (!newName || !newKey) {
        throw new TypeError("newName and newKey must be non-empty strings");
      }
      this._name = newName;
      this._key = newKey;
    }
  }
  exports.AzureNamedKeyCredential = AzureNamedKeyCredential;
  function isNamedKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureSASCredential = undefined;
  exports.isSASCredential = isSASCredential;
  var core_util_1 = require_commonjs6();

  class AzureSASCredential {
    _signature;
    get signature() {
      return this._signature;
    }
    constructor(signature) {
      if (!signature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = signature;
    }
    update(newSignature) {
      if (!newSignature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = newSignature;
    }
  }
  exports.AzureSASCredential = AzureSASCredential;
  function isSASCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBearerToken = isBearerToken;
  exports.isPopToken = isPopToken;
  exports.isTokenCredential = isTokenCredential;
  function isBearerToken(accessToken) {
    return !accessToken.tokenType || accessToken.tokenType === "Bearer";
  }
  function isPopToken(accessToken) {
    return accessToken.tokenType === "pop";
  }
  function isTokenCredential(credential) {
    const castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
  }
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = undefined;
  var azureKeyCredential_js_1 = require_azureKeyCredential();
  Object.defineProperty(exports, "AzureKeyCredential", { enumerable: true, get: function() {
    return azureKeyCredential_js_1.AzureKeyCredential;
  } });
  var keyCredential_js_1 = require_keyCredential();
  Object.defineProperty(exports, "isKeyCredential", { enumerable: true, get: function() {
    return keyCredential_js_1.isKeyCredential;
  } });
  var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
  Object.defineProperty(exports, "AzureNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
  } });
  Object.defineProperty(exports, "isNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.isNamedKeyCredential;
  } });
  var azureSASCredential_js_1 = require_azureSASCredential();
  Object.defineProperty(exports, "AzureSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.AzureSASCredential;
  } });
  Object.defineProperty(exports, "isSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.isSASCredential;
  } });
  var tokenCredential_js_1 = require_tokenCredential();
  Object.defineProperty(exports, "isTokenCredential", { enumerable: true, get: function() {
    return tokenCredential_js_1.isTokenCredential;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/disableKeepAlivePolicy.js
var require_disableKeepAlivePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableKeepAlivePolicyName = undefined;
  exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
  exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
  exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
  function createDisableKeepAlivePolicy() {
    return {
      name: exports.disableKeepAlivePolicyName,
      async sendRequest(request, next) {
        request.disableKeepAlive = true;
        return next(request);
      }
    };
  }
  function pipelineContainsDisableKeepAlivePolicy(pipeline) {
    return pipeline.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
  }
});

// node_modules/@azure/core-client/dist/commonjs/base64.js
var require_base642 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeString = encodeString;
  exports.encodeByteArray = encodeByteArray;
  exports.decodeString = decodeString;
  exports.decodeStringToString = decodeStringToString;
  function encodeString(value) {
    return Buffer.from(value).toString("base64");
  }
  function encodeByteArray(value) {
    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
    return bufferValue.toString("base64");
  }
  function decodeString(value) {
    return Buffer.from(value, "base64");
  }
  function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-client/dist/commonjs/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPrimitiveBody = isPrimitiveBody;
  exports.isDuration = isDuration;
  exports.isValidUuid = isValidUuid;
  exports.flattenResponse = flattenResponse;
  function isPrimitiveBody(value, mapperTypeName) {
    return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || value === undefined || value === null);
  }
  var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function isDuration(value) {
    return validateISODuration.test(value);
  }
  var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
  }
  function handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = {
      ...responseObject.headers,
      ...responseObject.body
    };
    if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
      return responseObject.shouldWrapBody ? { body: null } : null;
    } else {
      return responseObject.shouldWrapBody ? {
        ...responseObject.headers,
        body: responseObject.body
      } : combinedHeadersAndBody;
    }
  }
  function flattenResponse(fullResponse, responseSpec) {
    const parsedHeaders = fullResponse.parsedHeaders;
    if (fullResponse.request.method === "HEAD") {
      return {
        ...parsedHeaders,
        body: fullResponse.parsedBody
      };
    }
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper?.nullable);
    const expectedBodyTypeName = bodyMapper?.type.name;
    if (expectedBodyTypeName === "Stream") {
      return {
        ...parsedHeaders,
        blobBody: fullResponse.blobBody,
        readableStreamBody: fullResponse.readableStreamBody
      };
    }
    const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
      const arrayResponse = fullResponse.parsedBody ?? [];
      for (const key of Object.keys(modelProperties)) {
        if (modelProperties[key].serializedName) {
          arrayResponse[key] = fullResponse.parsedBody?.[key];
        }
      }
      if (parsedHeaders) {
        for (const key of Object.keys(parsedHeaders)) {
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
      body: fullResponse.parsedBody,
      headers: parsedHeaders,
      hasNullableType: isNullable,
      shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
    });
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MapperTypeNames = undefined;
  exports.createSerializer = createSerializer;
  var tslib_1 = require_tslib();
  var base64 = tslib_1.__importStar(require_base642());
  var interfaces_js_1 = require_interfaces();
  var utils_js_1 = require_utils3();

  class SerializerImpl {
    modelMappers;
    isXML;
    constructor(modelMappers = {}, isXML = false) {
      this.modelMappers = modelMappers;
      this.isXML = isXML;
    }
    validateConstraints(mapper, value, objectName) {
      const failValidation = (constraintName, constraintValue) => {
        throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
      };
      if (mapper.constraints && value !== undefined && value !== null) {
        const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
        if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
          failValidation("ExclusiveMaximum", ExclusiveMaximum);
        }
        if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
          failValidation("ExclusiveMinimum", ExclusiveMinimum);
        }
        if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
          failValidation("InclusiveMaximum", InclusiveMaximum);
        }
        if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
          failValidation("InclusiveMinimum", InclusiveMinimum);
        }
        if (MaxItems !== undefined && value.length > MaxItems) {
          failValidation("MaxItems", MaxItems);
        }
        if (MaxLength !== undefined && value.length > MaxLength) {
          failValidation("MaxLength", MaxLength);
        }
        if (MinItems !== undefined && value.length < MinItems) {
          failValidation("MinItems", MinItems);
        }
        if (MinLength !== undefined && value.length < MinLength) {
          failValidation("MinLength", MinLength);
        }
        if (MultipleOf !== undefined && value % MultipleOf !== 0) {
          failValidation("MultipleOf", MultipleOf);
        }
        if (Pattern) {
          const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
          if (typeof value !== "string" || value.match(pattern) === null) {
            failValidation("Pattern", Pattern);
          }
        }
        if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {
          failValidation("UniqueItems", UniqueItems);
        }
      }
    }
    serialize(mapper, object, objectName, options = { xml: {} }) {
      const updatedOptions = {
        xml: {
          rootName: options.xml.rootName ?? "",
          includeRoot: options.xml.includeRoot ?? false,
          xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      let payload = {};
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Sequence$/i) !== null) {
        payload = [];
      }
      if (mapper.isConstant) {
        object = mapper.defaultValue;
      }
      const { required, nullable } = mapper;
      if (required && nullable && object === undefined) {
        throw new Error(`${objectName} cannot be undefined.`);
      }
      if (required && !nullable && (object === undefined || object === null)) {
        throw new Error(`${objectName} cannot be null or undefined.`);
      }
      if (!required && nullable === false && object === null) {
        throw new Error(`${objectName} cannot be null.`);
      }
      if (object === undefined || object === null) {
        payload = object;
      } else {
        if (mapperType.match(/^any$/i) !== null) {
          payload = object;
        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
          payload = serializeBasicTypes(mapperType, objectName, object);
        } else if (mapperType.match(/^Enum$/i) !== null) {
          const enumMapper = mapper;
          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
          payload = serializeDateTypes(mapperType, object, objectName);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = serializeByteArrayType(objectName, object);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = serializeBase64UrlType(objectName, object);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Composite$/i) !== null) {
          payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        }
      }
      return payload;
    }
    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
      const updatedOptions = {
        xml: {
          rootName: options.xml.rootName ?? "",
          includeRoot: options.xml.includeRoot ?? false,
          xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        },
        ignoreUnknownProperties: options.ignoreUnknownProperties ?? false
      };
      if (responseBody === undefined || responseBody === null) {
        if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
          responseBody = [];
        }
        if (mapper.defaultValue !== undefined) {
          responseBody = mapper.defaultValue;
        }
        return responseBody;
      }
      let payload;
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Composite$/i) !== null) {
        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
      } else {
        if (this.isXML) {
          const xmlCharKey = updatedOptions.xml.xmlCharKey;
          if (responseBody[interfaces_js_1.XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
            responseBody = responseBody[xmlCharKey];
          }
        }
        if (mapperType.match(/^Number$/i) !== null) {
          payload = parseFloat(responseBody);
          if (isNaN(payload)) {
            payload = responseBody;
          }
        } else if (mapperType.match(/^Boolean$/i) !== null) {
          if (responseBody === "true") {
            payload = true;
          } else if (responseBody === "false") {
            payload = false;
          } else {
            payload = responseBody;
          }
        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
          payload = responseBody;
        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
          payload = new Date(responseBody);
        } else if (mapperType.match(/^UnixTime$/i) !== null) {
          payload = unixTimeToDate(responseBody);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = base64.decodeString(responseBody);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = base64UrlToByteArray(responseBody);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
      }
      if (mapper.isConstant) {
        payload = mapper.defaultValue;
      }
      return payload;
    }
  }
  function createSerializer(modelMappers = {}, isXML = false) {
    return new SerializerImpl(modelMappers, isXML);
  }
  function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch) {
      --len;
    }
    return str.substr(0, len);
  }
  function bufferToBase64Url(buffer) {
    if (!buffer) {
      return;
    }
    if (!(buffer instanceof Uint8Array)) {
      throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    }
    const str = base64.encodeByteArray(buffer);
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function base64UrlToByteArray(str) {
    if (!str) {
      return;
    }
    if (str && typeof str.valueOf() !== "string") {
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    }
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    return base64.decodeString(str);
  }
  function splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
      const subwords = prop.split(".");
      for (const item of subwords) {
        if (item.charAt(item.length - 1) === "\\") {
          partialclass += item.substr(0, item.length - 1) + ".";
        } else {
          partialclass += item;
          classes.push(partialclass);
          partialclass = "";
        }
      }
    }
    return classes;
  }
  function dateToUnixTime(d) {
    if (!d) {
      return;
    }
    if (typeof d.valueOf() === "string") {
      d = new Date(d);
    }
    return Math.floor(d.getTime() / 1000);
  }
  function unixTimeToDate(n) {
    if (!n) {
      return;
    }
    return new Date(n * 1000);
  }
  function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
      if (typeName.match(/^Number$/i) !== null) {
        if (typeof value !== "number") {
          throw new Error(`${objectName} with value ${value} must be of type number.`);
        }
      } else if (typeName.match(/^String$/i) !== null) {
        if (typeof value.valueOf() !== "string") {
          throw new Error(`${objectName} with value "${value}" must be of type string.`);
        }
      } else if (typeName.match(/^Uuid$/i) !== null) {
        if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
          throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
        }
      } else if (typeName.match(/^Boolean$/i) !== null) {
        if (typeof value !== "boolean") {
          throw new Error(`${objectName} with value ${value} must be of type boolean.`);
        }
      } else if (typeName.match(/^Stream$/i) !== null) {
        const objectType = typeof value;
        if (objectType !== "string" && typeof value.pipe !== "function" && typeof value.tee !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
          throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
        }
      }
    }
    return value;
  }
  function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) {
      throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    }
    const isPresent = allowedValues.some((item) => {
      if (typeof item.valueOf() === "string") {
        return item.toLowerCase() === value.toLowerCase();
      }
      return item === value;
    });
    if (!isPresent) {
      throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    }
    return value;
  }
  function serializeByteArrayType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = base64.encodeByteArray(value);
    }
    return value;
  }
  function serializeBase64UrlType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = bufferToBase64Url(value);
    }
    return value;
  }
  function serializeDateTypes(typeName, value, objectName) {
    if (value !== undefined && value !== null) {
      if (typeName.match(/^Date$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
      } else if (typeName.match(/^DateTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
      } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
        }
        value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
      } else if (typeName.match(/^UnixTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);
        }
        value = dateToUnixTime(value);
      } else if (typeName.match(/^TimeSpan$/i) !== null) {
        if (!(0, utils_js_1.isDuration)(value)) {
          throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
        }
      }
    }
    return value;
  }
  function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    if (!Array.isArray(object)) {
      throw new Error(`${objectName} must be of type Array.`);
    }
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    if (elementType.type.name === "Composite" && elementType.type.className) {
      elementType = serializer.modelMappers[elementType.type.className] ?? elementType;
    }
    const tempArray = [];
    for (let i = 0;i < object.length; i++) {
      const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
      if (isXml && elementType.xmlNamespace) {
        const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
        if (elementType.type.name === "Composite") {
          tempArray[i] = { ...serializedValue };
          tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        } else {
          tempArray[i] = {};
          tempArray[i][options.xml.xmlCharKey] = serializedValue;
          tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        }
      } else {
        tempArray[i] = serializedValue;
      }
    }
    return tempArray;
  }
  function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    if (typeof object !== "object") {
      throw new Error(`${objectName} must be of type object.`);
    }
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    const tempDictionary = {};
    for (const key of Object.keys(object)) {
      const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
      tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    if (isXml && mapper.xmlNamespace) {
      const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
      const result = tempDictionary;
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
      return result;
    }
    return tempDictionary;
  }
  function resolveAdditionalProperties(serializer, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      return modelMapper?.type.additionalProperties;
    }
    return additionalProperties;
  }
  function resolveReferencedMapper(serializer, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) {
      throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
    }
    return serializer.modelMappers[className];
  }
  function resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      if (!modelMapper) {
        throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
      }
      modelProps = modelMapper?.type.modelProperties;
      if (!modelProps) {
        throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
      }
    }
    return modelProps;
  }
  function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    }
    if (object !== undefined && object !== null) {
      const payload = {};
      const modelProps = resolveModelProperties(serializer, mapper, objectName);
      for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        if (propertyMapper.readOnly) {
          continue;
        }
        let propName;
        let parentObject = payload;
        if (serializer.isXML) {
          if (propertyMapper.xmlIsWrapped) {
            propName = propertyMapper.xmlName;
          } else {
            propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
          }
        } else {
          const paths = splitSerializeName(propertyMapper.serializedName);
          propName = paths.pop();
          for (const pathName of paths) {
            const childObject = parentObject[pathName];
            if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {
              parentObject[pathName] = {};
            }
            parentObject = parentObject[pathName];
          }
        }
        if (parentObject !== undefined && parentObject !== null) {
          if (isXml && mapper.xmlNamespace) {
            const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
            parentObject[interfaces_js_1.XML_ATTRKEY] = {
              ...parentObject[interfaces_js_1.XML_ATTRKEY],
              [xmlnsKey]: mapper.xmlNamespace
            };
          }
          const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
          let toSerialize = object[key];
          const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
          if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {
            toSerialize = mapper.serializedName;
          }
          const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
          if (serializedValue !== undefined && propName !== undefined && propName !== null) {
            const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
            if (isXml && propertyMapper.xmlIsAttribute) {
              parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
              parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
            } else if (isXml && propertyMapper.xmlIsWrapped) {
              parentObject[propName] = { [propertyMapper.xmlElementName]: value };
            } else {
              parentObject[propName] = value;
            }
          }
        }
      }
      const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
      if (additionalPropertiesMapper) {
        const propNames = Object.keys(modelProps);
        for (const clientPropName in object) {
          const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
          if (isAdditionalProperty) {
            payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
          }
        }
      }
      return payload;
    }
    return object;
  }
  function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    if (!isXml || !propertyMapper.xmlNamespace) {
      return serializedValue;
    }
    const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name)) {
      if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
        return serializedValue;
      } else {
        const result2 = { ...serializedValue };
        result2[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
        return result2;
      }
    }
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
    return result;
  }
  function isSpecialXmlProperty(propertyName, options) {
    return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
  }
  function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    const xmlCharKey = options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    }
    const modelProps = resolveModelProperties(serializer, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      const paths = splitSerializeName(modelProps[key].serializedName);
      handledPropertyNames.push(paths[0]);
      const { serializedName, xmlName, xmlElementName } = propertyMapper;
      let propertyObjectName = objectName;
      if (serializedName !== "" && serializedName !== undefined) {
        propertyObjectName = objectName + "." + serializedName;
      }
      const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
      if (headerCollectionPrefix) {
        const dictionary = {};
        for (const headerKey of Object.keys(responseBody)) {
          if (headerKey.startsWith(headerCollectionPrefix)) {
            dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
          }
          handledPropertyNames.push(headerKey);
        }
        instance[key] = dictionary;
      } else if (serializer.isXML) {
        if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
          instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
        } else if (propertyMapper.xmlIsMsText) {
          if (responseBody[xmlCharKey] !== undefined) {
            instance[key] = responseBody[xmlCharKey];
          } else if (typeof responseBody === "string") {
            instance[key] = responseBody;
          }
        } else {
          const propertyName = xmlElementName || xmlName || serializedName;
          if (propertyMapper.xmlIsWrapped) {
            const wrapped = responseBody[xmlName];
            const elementList = wrapped?.[xmlElementName] ?? [];
            instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
            handledPropertyNames.push(xmlName);
          } else {
            const property = responseBody[propertyName];
            instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
            handledPropertyNames.push(propertyName);
          }
        }
      } else {
        let propertyInstance;
        let res = responseBody;
        let steps = 0;
        for (const item of paths) {
          if (!res)
            break;
          steps++;
          res = res[item];
        }
        if (res === null && steps < paths.length) {
          res = undefined;
        }
        propertyInstance = res;
        const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
        if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {
          propertyInstance = mapper.serializedName;
        }
        let serializedValue;
        if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
          propertyInstance = responseBody[key];
          const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
          for (const [k, v] of Object.entries(instance)) {
            if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
              arrayInstance[k] = v;
            }
          }
          instance = arrayInstance;
        } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
          serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
          instance[key] = serializedValue;
        }
      }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
      const isAdditionalProperty = (responsePropName) => {
        for (const clientPropName in modelProps) {
          const paths = splitSerializeName(modelProps[clientPropName].serializedName);
          if (paths[0] === responsePropName) {
            return false;
          }
        }
        return true;
      };
      for (const responsePropName in responseBody) {
        if (isAdditionalProperty(responsePropName)) {
          instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
        }
      }
    } else if (responseBody && !options.ignoreUnknownProperties) {
      for (const key of Object.keys(responseBody)) {
        if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
          instance[key] = responseBody[key];
        }
      }
    }
    return instance;
  }
  function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    const value = mapper.type.value;
    if (!value || typeof value !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      const tempDictionary = {};
      for (const key of Object.keys(responseBody)) {
        tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
      }
      return tempDictionary;
    }
    return responseBody;
  }
  function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    let element = mapper.type.element;
    if (!element || typeof element !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      if (!Array.isArray(responseBody)) {
        responseBody = [responseBody];
      }
      if (element.type.name === "Composite" && element.type.className) {
        element = serializer.modelMappers[element.type.className] ?? element;
      }
      const tempArray = [];
      for (let i = 0;i < responseBody.length; i++) {
        tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
      }
      return tempArray;
    }
    return responseBody;
  }
  function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
      const currentName = typeNamesToCheck.shift();
      const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
      if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
        return discriminators[indexDiscriminator];
      } else {
        for (const [name, mapper] of Object.entries(discriminators)) {
          if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
            typeNamesToCheck.push(mapper.type.className);
          }
        }
      }
    }
    return;
  }
  function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
      let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
      if (discriminatorName) {
        if (polymorphicPropertyName === "serializedName") {
          discriminatorName = discriminatorName.replace(/\\/gi, "");
        }
        const discriminatorValue = object[discriminatorName];
        const typeName = mapper.type.uberParent ?? mapper.type.className;
        if (typeof discriminatorValue === "string" && typeName) {
          const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
          if (polymorphicMapper) {
            mapper = polymorphicMapper;
          }
        }
      }
    }
    return mapper;
  }
  function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
  }
  function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
  }
  exports.MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime"
  };
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    operationRequestMap: new WeakMap
  };
});

// node_modules/@azure/core-client/dist/commonjs/operationHelpers.js
var require_operationHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
  exports.getOperationRequestInfo = getOperationRequestInfo;
  var state_js_1 = require_state2();
  function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") {
      parameterPath = [parameterPath];
    }
    if (Array.isArray(parameterPath)) {
      if (parameterPath.length > 0) {
        if (parameterMapper.isConstant) {
          value = parameterMapper.defaultValue;
        } else {
          let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
          if (!propertySearchResult.propertyFound && fallbackObject) {
            propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
          }
          let useDefaultValue = false;
          if (!propertySearchResult.propertyFound) {
            useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
          }
          value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
        }
      }
    } else {
      if (parameterMapper.required) {
        value = {};
      }
      for (const propertyName in parameterPath) {
        const propertyMapper = parameterMapper.type.modelProperties[propertyName];
        const propertyPath = parameterPath[propertyName];
        const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
          parameterPath: propertyPath,
          mapper: propertyMapper
        }, fallbackObject);
        if (propertyValue !== undefined) {
          if (!value) {
            value = {};
          }
          value[propertyName] = propertyValue;
        }
      }
    }
    return value;
  }
  function getPropertyFromParameterPath(parent, parameterPath) {
    const result = { propertyFound: false };
    let i = 0;
    for (;i < parameterPath.length; ++i) {
      const parameterPathPart = parameterPath[i];
      if (parent && parameterPathPart in parent) {
        parent = parent[parameterPathPart];
      } else {
        break;
      }
    }
    if (i === parameterPath.length) {
      result.propertyValue = parent;
      result.propertyFound = true;
    }
    return result;
  }
  var originalRequestSymbol = Symbol.for("@azure/core-client original request");
  function hasOriginalRequest(request) {
    return originalRequestSymbol in request;
  }
  function getOperationRequestInfo(request) {
    if (hasOriginalRequest(request)) {
      return getOperationRequestInfo(request[originalRequestSymbol]);
    }
    let info = state_js_1.state.operationRequestMap.get(request);
    if (!info) {
      info = {};
      state_js_1.state.operationRequestMap.set(request, info);
    }
    return info;
  }
});

// node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js
var require_deserializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializationPolicyName = undefined;
  exports.deserializationPolicy = deserializationPolicy;
  var interfaces_js_1 = require_interfaces();
  var core_rest_pipeline_1 = require_commonjs8();
  var serializer_js_1 = require_serializer();
  var operationHelpers_js_1 = require_operationHelpers();
  var defaultJsonContentTypes = ["application/json", "text/json"];
  var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
  exports.deserializationPolicyName = "deserializationPolicy";
  function deserializationPolicy(options = {}) {
    const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;
    const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;
    const parseXML = options.parseXML;
    const serializerOptions = options.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: serializerOptions?.xml.rootName ?? "",
        includeRoot: serializerOptions?.xml.includeRoot ?? false,
        xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
      }
    };
    return {
      name: exports.deserializationPolicyName,
      async sendRequest(request, next) {
        const response = await next(request);
        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
      }
    };
  }
  function getOperationResponseMap(parsedResponse) {
    let result;
    const request = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
    const operationSpec = operationInfo?.operationSpec;
    if (operationSpec) {
      if (!operationInfo?.operationResponseGetter) {
        result = operationSpec.responses[parsedResponse.status];
      } else {
        result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);
      }
    }
    return result;
  }
  function shouldDeserializeResponse(parsedResponse) {
    const request = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
    const shouldDeserialize = operationInfo?.shouldDeserialize;
    let result;
    if (shouldDeserialize === undefined) {
      result = true;
    } else if (typeof shouldDeserialize === "boolean") {
      result = shouldDeserialize;
    } else {
      result = shouldDeserialize(parsedResponse);
    }
    return result;
  }
  async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
    if (!shouldDeserializeResponse(parsedResponse)) {
      return parsedResponse;
    }
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
    const operationSpec = operationInfo?.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
      return parsedResponse;
    }
    const responseSpec = getOperationResponseMap(parsedResponse);
    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
    if (error) {
      throw error;
    } else if (shouldReturnResponse) {
      return parsedResponse;
    }
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        let valueToDeserialize = parsedResponse.parsedBody;
        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        }
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (deserializeError) {
          const restError = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
            statusCode: parsedResponse.status,
            request: parsedResponse.request,
            response: parsedResponse
          });
          throw restError;
        }
      } else if (operationSpec.httpMethod === "HEAD") {
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      }
      if (responseSpec.headersMapper) {
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
      }
    }
    return parsedResponse;
  }
  function isOperationSpecEmpty(operationSpec) {
    const expectedStatusCodes = Object.keys(operationSpec.responses);
    return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
  }
  function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
    if (isExpectedStatusCode) {
      if (responseSpec) {
        if (!responseSpec.isError) {
          return { error: null, shouldReturnResponse: false };
        }
      } else {
        return { error: null, shouldReturnResponse: false };
      }
    }
    const errorResponseSpec = responseSpec ?? operationSpec.responses.default;
    const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(parsedResponse.status) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
    const error = new core_rest_pipeline_1.RestError(initialErrorMessage, {
      statusCode: parsedResponse.status,
      request: parsedResponse.request,
      response: parsedResponse
    });
    if (!errorResponseSpec && !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message)) {
      throw error;
    }
    const defaultBodyMapper = errorResponseSpec?.bodyMapper;
    const defaultHeadersMapper = errorResponseSpec?.headersMapper;
    try {
      if (parsedResponse.parsedBody) {
        const parsedBody = parsedResponse.parsedBody;
        let deserializedError;
        if (defaultBodyMapper) {
          let valueToDeserialize = parsedBody;
          if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = [];
            const elementName = defaultBodyMapper.xmlElementName;
            if (typeof parsedBody === "object" && elementName) {
              valueToDeserialize = parsedBody[elementName];
            }
          }
          deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
        }
        const internalError = parsedBody.error || deserializedError || parsedBody;
        error.code = internalError.code;
        if (internalError.message) {
          error.message = internalError.message;
        }
        if (defaultBodyMapper) {
          error.response.parsedBody = deserializedError;
        }
      }
      if (parsedResponse.headers && defaultHeadersMapper) {
        error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
      }
    } catch (defaultError) {
      error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return { error, shouldReturnResponse: false };
  }
  async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    if (!operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) && operationResponse.bodyAsText) {
      const text = operationResponse.bodyAsText;
      const contentType = operationResponse.headers.get("Content-Type") || "";
      const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
      try {
        if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
          operationResponse.parsedBody = JSON.parse(text);
          return operationResponse;
        } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
          if (!parseXML) {
            throw new Error("Parsing XML not supported.");
          }
          const body = await parseXML(text, opts.xml);
          operationResponse.parsedBody = body;
          return operationResponse;
        }
      } catch (err) {
        const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
        const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
        const e = new core_rest_pipeline_1.RestError(msg, {
          code: errCode,
          statusCode: operationResponse.status,
          request: operationResponse.request,
          response: operationResponse
        });
        throw e;
      }
    }
    return operationResponse;
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js
var require_interfaceHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
  exports.getPathStringFromParameter = getPathStringFromParameter;
  var serializer_js_1 = require_serializer();
  function getStreamingResponseStatusCodes(operationSpec) {
    const result = new Set;
    for (const statusCode in operationSpec.responses) {
      const operationResponse = operationSpec.responses[statusCode];
      if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
        result.add(Number(statusCode));
      }
    }
    return result;
  }
  function getPathStringFromParameter(parameter) {
    const { parameterPath, mapper } = parameter;
    let result;
    if (typeof parameterPath === "string") {
      result = parameterPath;
    } else if (Array.isArray(parameterPath)) {
      result = parameterPath.join(".");
    } else {
      result = mapper.serializedName;
    }
    return result;
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js
var require_serializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializationPolicyName = undefined;
  exports.serializationPolicy = serializationPolicy;
  exports.serializeHeaders = serializeHeaders;
  exports.serializeRequestBody = serializeRequestBody;
  var interfaces_js_1 = require_interfaces();
  var operationHelpers_js_1 = require_operationHelpers();
  var serializer_js_1 = require_serializer();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  exports.serializationPolicyName = "serializationPolicy";
  function serializationPolicy(options = {}) {
    const stringifyXML = options.stringifyXML;
    return {
      name: exports.serializationPolicyName,
      async sendRequest(request, next) {
        const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
        const operationSpec = operationInfo?.operationSpec;
        const operationArguments = operationInfo?.operationArguments;
        if (operationSpec && operationArguments) {
          serializeHeaders(request, operationArguments, operationSpec);
          serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
        }
        return next(request);
      }
    };
  }
  function serializeHeaders(request, operationArguments, operationSpec) {
    if (operationSpec.headerParameters) {
      for (const headerParameter of operationSpec.headerParameters) {
        let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
        if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {
          headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
          const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
          if (headerCollectionPrefix) {
            for (const key of Object.keys(headerValue)) {
              request.headers.set(headerCollectionPrefix + key, headerValue[key]);
            }
          } else {
            request.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
          }
        }
      }
    }
    const customHeaders = operationArguments.options?.requestOptions?.customHeaders;
    if (customHeaders) {
      for (const customHeaderName of Object.keys(customHeaders)) {
        request.headers.set(customHeaderName, customHeaders[customHeaderName]);
      }
    }
  }
  function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
    throw new Error("XML serialization unsupported!");
  }) {
    const serializerOptions = operationArguments.options?.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: serializerOptions?.xml.rootName ?? "",
        includeRoot: serializerOptions?.xml.includeRoot ?? false,
        xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
      }
    };
    const xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
      request.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
      const bodyMapper = operationSpec.requestBody.mapper;
      const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
      const typeName = bodyMapper.type.name;
      try {
        if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {
          const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
          request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
          const isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
          if (operationSpec.isXML) {
            const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
            const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
            if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
              request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
            } else if (!isStream) {
              request.body = stringifyXML(value, {
                rootName: xmlName || serializedName,
                xmlCharKey
              });
            }
          } else if (typeName === serializer_js_1.MapperTypeNames.String && (operationSpec.contentType?.match("text/plain") || operationSpec.mediaType === "text")) {
            return;
          } else if (!isStream) {
            request.body = JSON.stringify(request.body);
          }
        }
      } catch (error) {
        throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
      }
    } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
      request.formData = {};
      for (const formDataParameter of operationSpec.formDataParameters) {
        const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
          const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
          request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
        }
      }
    }
  }
  function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
      const result = {};
      result[options.xml.xmlCharKey] = serializedValue;
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
      return result;
    }
    return serializedValue;
  }
  function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj)) {
      obj = [obj];
    }
    if (!xmlNamespaceKey || !xmlNamespace) {
      return { [elementName]: obj };
    }
    const result = { [elementName]: obj };
    result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
    return result;
  }
});

// node_modules/@azure/core-client/dist/commonjs/pipeline.js
var require_pipeline3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createClientPipeline = createClientPipeline;
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  var core_rest_pipeline_1 = require_commonjs8();
  var serializationPolicy_js_1 = require_serializationPolicy();
  function createClientPipeline(options = {}) {
    const pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options ?? {});
    if (options.credentialOptions) {
      pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
        credential: options.credentialOptions.credential,
        scopes: options.credentialOptions.credentialScopes
      }));
    }
    pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
    pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), {
      phase: "Deserialize"
    });
    return pipeline;
  }
});

// node_modules/@azure/core-client/dist/commonjs/httpClientCache.js
var require_httpClientCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
  var core_rest_pipeline_1 = require_commonjs8();
  var cachedHttpClient;
  function getCachedDefaultHttpClient() {
    if (!cachedHttpClient) {
      cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    }
    return cachedHttpClient;
  }
});

// node_modules/@azure/core-client/dist/commonjs/urlHelpers.js
var require_urlHelpers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRequestUrl = getRequestUrl;
  exports.appendQueryParams = appendQueryParams;
  var operationHelpers_js_1 = require_operationHelpers();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "\t",
    Pipes: "|"
  };
  function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
      let path = replaceAll(operationSpec.path, urlReplacements);
      if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
        path = path.substring(1);
      }
      if (isAbsoluteUrl(path)) {
        requestUrl = path;
        isAbsolutePath = true;
      } else {
        requestUrl = appendPath(requestUrl, path);
      }
    }
    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
  }
  function replaceAll(input, replacements) {
    let result = input;
    for (const [searchValue, replaceValue] of replacements) {
      result = result.split(searchValue).join(replaceValue);
    }
    return result;
  }
  function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    const result = new Map;
    if (operationSpec.urlParameters?.length) {
      for (const urlParameter of operationSpec.urlParameters) {
        let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
        const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
        if (!urlParameter.skipEncoding) {
          urlParameterValue = encodeURIComponent(urlParameterValue);
        }
        result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
      }
    }
    return result;
  }
  function isAbsoluteUrl(url) {
    return url.includes("://");
  }
  function appendPath(url, pathToAppend) {
    if (!pathToAppend) {
      return url;
    }
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) {
      newPath = `${newPath}/`;
    }
    if (pathToAppend.startsWith("/")) {
      pathToAppend = pathToAppend.substring(1);
    }
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
      const path = pathToAppend.substring(0, searchStart);
      const search = pathToAppend.substring(searchStart + 1);
      newPath = newPath + path;
      if (search) {
        parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
      }
    } else {
      newPath = newPath + pathToAppend;
    }
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
  }
  function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    const result = new Map;
    const sequenceParams = new Set;
    if (operationSpec.queryParameters?.length) {
      for (const queryParameter of operationSpec.queryParameters) {
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
          sequenceParams.add(queryParameter.mapper.serializedName);
        }
        let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {
          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
          const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              if (item === null || item === undefined) {
                return "";
              }
              return item;
            });
          }
          if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
            continue;
          } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          if (!queryParameter.skipEncoding) {
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map((item) => {
                return encodeURIComponent(item);
              });
            } else {
              queryParameterValue = encodeURIComponent(queryParameterValue);
            }
          }
          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
        }
      }
    }
    return {
      queryParams: result,
      sequenceParams
    };
  }
  function simpleParseQueryParams(queryString) {
    const result = new Map;
    if (!queryString || queryString[0] !== "?") {
      return result;
    }
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [name, value] = pair.split("=", 2);
      const existingValue = result.get(name);
      if (existingValue) {
        if (Array.isArray(existingValue)) {
          existingValue.push(value);
        } else {
          result.set(name, [existingValue, value]);
        }
      } else {
        result.set(name, value);
      }
    }
    return result;
  }
  function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) {
      return url;
    }
    const parsedUrl = new URL(url);
    const combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams) {
      const existingValue = combinedParams.get(name);
      if (Array.isArray(existingValue)) {
        if (Array.isArray(value)) {
          existingValue.push(...value);
          const valueSet = new Set(existingValue);
          combinedParams.set(name, Array.from(valueSet));
        } else {
          existingValue.push(value);
        }
      } else if (existingValue) {
        if (Array.isArray(value)) {
          value.unshift(existingValue);
        } else if (sequenceParams.has(name)) {
          combinedParams.set(name, [existingValue, value]);
        }
        if (!noOverwrite) {
          combinedParams.set(name, value);
        }
      } else {
        combinedParams.set(name, value);
      }
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams) {
      if (typeof value === "string") {
        searchPieces.push(`${name}=${value}`);
      } else if (Array.isArray(value)) {
        for (const subValue of value) {
          searchPieces.push(`${name}=${subValue}`);
        }
      } else {
        searchPieces.push(`${name}=${value}`);
      }
    }
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
  }
});

// node_modules/@azure/core-client/dist/commonjs/log.js
var require_log4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs4();
  exports.logger = (0, logger_1.createClientLogger)("core-client");
});

// node_modules/@azure/core-client/dist/commonjs/serviceClient.js
var require_serviceClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceClient = undefined;
  var core_rest_pipeline_1 = require_commonjs8();
  var pipeline_js_1 = require_pipeline3();
  var utils_js_1 = require_utils3();
  var httpClientCache_js_1 = require_httpClientCache();
  var operationHelpers_js_1 = require_operationHelpers();
  var urlHelpers_js_1 = require_urlHelpers2();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var log_js_1 = require_log4();

  class ServiceClient {
    _endpoint;
    _requestContentType;
    _allowInsecureConnection;
    _httpClient;
    pipeline;
    constructor(options = {}) {
      this._requestContentType = options.requestContentType;
      this._endpoint = options.endpoint ?? options.baseUri;
      if (options.baseUri) {
        log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
      }
      this._allowInsecureConnection = options.allowInsecureConnection;
      this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
      this.pipeline = options.pipeline || createDefaultPipeline(options);
      if (options.additionalPolicies?.length) {
        for (const { policy, position } of options.additionalPolicies) {
          const afterPhase = position === "perRetry" ? "Sign" : undefined;
          this.pipeline.addPolicy(policy, {
            afterPhase
          });
        }
      }
    }
    async sendRequest(request) {
      return this.pipeline.sendRequest(this._httpClient, request);
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      const endpoint = operationSpec.baseUrl || this._endpoint;
      if (!endpoint) {
        throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
      }
      const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
      const request = (0, core_rest_pipeline_1.createPipelineRequest)({
        url
      });
      request.method = operationSpec.httpMethod;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      operationInfo.operationSpec = operationSpec;
      operationInfo.operationArguments = operationArguments;
      const contentType = operationSpec.contentType || this._requestContentType;
      if (contentType && operationSpec.requestBody) {
        request.headers.set("Content-Type", contentType);
      }
      const options = operationArguments.options;
      if (options) {
        const requestOptions = options.requestOptions;
        if (requestOptions) {
          if (requestOptions.timeout) {
            request.timeout = requestOptions.timeout;
          }
          if (requestOptions.onUploadProgress) {
            request.onUploadProgress = requestOptions.onUploadProgress;
          }
          if (requestOptions.onDownloadProgress) {
            request.onDownloadProgress = requestOptions.onDownloadProgress;
          }
          if (requestOptions.shouldDeserialize !== undefined) {
            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
          }
          if (requestOptions.allowInsecureConnection) {
            request.allowInsecureConnection = true;
          }
        }
        if (options.abortSignal) {
          request.abortSignal = options.abortSignal;
        }
        if (options.tracingOptions) {
          request.tracingOptions = options.tracingOptions;
        }
      }
      if (this._allowInsecureConnection) {
        request.allowInsecureConnection = true;
      }
      if (request.streamResponseStatusCodes === undefined) {
        request.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
      }
      try {
        const rawResponse = await this.sendRequest(request);
        const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
        if (options?.onResponse) {
          options.onResponse(rawResponse, flatResponse);
        }
        return flatResponse;
      } catch (error) {
        if (typeof error === "object" && error?.response) {
          const rawResponse = error.response;
          const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
          error.details = flatResponse;
          if (options?.onResponse) {
            options.onResponse(rawResponse, flatResponse, error);
          }
        }
        throw error;
      }
    }
  }
  exports.ServiceClient = ServiceClient;
  function createDefaultPipeline(options) {
    const credentialScopes = getCredentialScopes(options);
    const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : undefined;
    return (0, pipeline_js_1.createClientPipeline)({
      ...options,
      credentialOptions
    });
  }
  function getCredentialScopes(options) {
    if (options.credentialScopes) {
      return options.credentialScopes;
    }
    if (options.endpoint) {
      return `${options.endpoint}/.default`;
    }
    if (options.baseUri) {
      return `${options.baseUri}/.default`;
    }
    if (options.credential && !options.credentialScopes) {
      throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    }
    return;
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js
var require_authorizeRequestOnClaimChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCAEChallenge = parseCAEChallenge;
  exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
  var log_js_1 = require_log4();
  var base64_js_1 = require_base642();
  function parseCAEChallenge(challenges) {
    const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
    return bearerChallenges.map((challenge) => {
      const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
      const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
      return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
    });
  }
  async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
    const { scopes, response } = onChallengeOptions;
    const logger = onChallengeOptions.logger || log_js_1.logger;
    const challenge = response.headers.get("WWW-Authenticate");
    if (!challenge) {
      logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const challenges = parseCAEChallenge(challenge) || [];
    const parsedChallenge = challenges.find((x) => x.claims);
    if (!parsedChallenge) {
      logger.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
      claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
    return true;
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js
var require_authorizeRequestOnTenantChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = undefined;
  var Constants = {
    DefaultScope: "/.default",
    HeaderConstants: {
      AUTHORIZATION: "authorization"
    }
  };
  function isUuid(text) {
    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
  }
  var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
    const requestOptions = requestToOptions(challengeOptions.request);
    const challenge = getChallenge(challengeOptions.response);
    if (challenge) {
      const challengeInfo = parseChallenge(challenge);
      const challengeScopes = buildScopes(challengeOptions, challengeInfo);
      const tenantId = extractTenantId(challengeInfo);
      if (!tenantId) {
        return false;
      }
      const accessToken = await challengeOptions.getAccessToken(challengeScopes, {
        ...requestOptions,
        tenantId
      });
      if (!accessToken) {
        return false;
      }
      challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
      return true;
    }
    return false;
  };
  exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
  function extractTenantId(challengeInfo) {
    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
    const pathSegments = parsedAuthUri.pathname.split("/");
    const tenantId = pathSegments[1];
    if (tenantId && isUuid(tenantId)) {
      return tenantId;
    }
    return;
  }
  function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_id) {
      return challengeOptions.scopes;
    }
    const challengeScopes = new URL(challengeInfo.resource_id);
    challengeScopes.pathname = Constants.DefaultScope;
    let scope = challengeScopes.toString();
    if (scope === "https://disk.azure.com/.default") {
      scope = "https://disk.azure.com//.default";
    }
    return [scope];
  }
  function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
      return challenge;
    }
    return;
  }
  function parseChallenge(challenge) {
    const bearerChallenge = challenge.slice("Bearer ".length);
    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
    return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
  }
  function requestToOptions(request) {
    return {
      abortSignal: request.abortSignal,
      requestOptions: {
        timeout: request.timeout
      },
      tracingOptions: request.tracingOptions
    };
  }
});

// node_modules/@azure/core-client/dist/commonjs/index.js
var require_commonjs10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = undefined;
  var serializer_js_1 = require_serializer();
  Object.defineProperty(exports, "createSerializer", { enumerable: true, get: function() {
    return serializer_js_1.createSerializer;
  } });
  Object.defineProperty(exports, "MapperTypeNames", { enumerable: true, get: function() {
    return serializer_js_1.MapperTypeNames;
  } });
  var serviceClient_js_1 = require_serviceClient();
  Object.defineProperty(exports, "ServiceClient", { enumerable: true, get: function() {
    return serviceClient_js_1.ServiceClient;
  } });
  var pipeline_js_1 = require_pipeline3();
  Object.defineProperty(exports, "createClientPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createClientPipeline;
  } });
  var interfaces_js_1 = require_interfaces();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_CHARKEY;
  } });
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  Object.defineProperty(exports, "deserializationPolicy", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicy;
  } });
  Object.defineProperty(exports, "deserializationPolicyName", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicyName;
  } });
  var serializationPolicy_js_1 = require_serializationPolicy();
  Object.defineProperty(exports, "serializationPolicy", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicy;
  } });
  Object.defineProperty(exports, "serializationPolicyName", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicyName;
  } });
  var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
  Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
  } });
  var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
  Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/util.js
var require_util10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpHeaders = undefined;
  exports.toPipelineRequest = toPipelineRequest;
  exports.toWebResourceLike = toWebResourceLike;
  exports.toHttpHeadersLike = toHttpHeadersLike;
  var core_rest_pipeline_1 = require_commonjs8();
  var originalRequestSymbol = Symbol("Original PipelineRequest");
  var originalClientRequestSymbol = Symbol.for("@azure/core-client original request");
  function toPipelineRequest(webResource, options = {}) {
    const compatWebResource = webResource;
    const request = compatWebResource[originalRequestSymbol];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: true }));
    if (request) {
      request.headers = headers;
      return request;
    } else {
      const newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
        url: webResource.url,
        method: webResource.method,
        headers,
        withCredentials: webResource.withCredentials,
        timeout: webResource.timeout,
        requestId: webResource.requestId,
        abortSignal: webResource.abortSignal,
        body: webResource.body,
        formData: webResource.formData,
        disableKeepAlive: !!webResource.keepAlive,
        onDownloadProgress: webResource.onDownloadProgress,
        onUploadProgress: webResource.onUploadProgress,
        proxySettings: webResource.proxySettings,
        streamResponseStatusCodes: webResource.streamResponseStatusCodes,
        agent: webResource.agent,
        requestOverrides: webResource.requestOverrides
      });
      if (options.originalRequest) {
        newRequest[originalClientRequestSymbol] = options.originalRequest;
      }
      return newRequest;
    }
  }
  function toWebResourceLike(request, options) {
    const originalRequest = options?.originalRequest ?? request;
    const webResource = {
      url: request.url,
      method: request.method,
      headers: toHttpHeadersLike(request.headers),
      withCredentials: request.withCredentials,
      timeout: request.timeout,
      requestId: request.headers.get("x-ms-client-request-id") || request.requestId,
      abortSignal: request.abortSignal,
      body: request.body,
      formData: request.formData,
      keepAlive: !!request.disableKeepAlive,
      onDownloadProgress: request.onDownloadProgress,
      onUploadProgress: request.onUploadProgress,
      proxySettings: request.proxySettings,
      streamResponseStatusCodes: request.streamResponseStatusCodes,
      agent: request.agent,
      requestOverrides: request.requestOverrides,
      clone() {
        throw new Error("Cannot clone a non-proxied WebResourceLike");
      },
      prepare() {
        throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
      },
      validateRequestProperties() {}
    };
    if (options?.createProxy) {
      return new Proxy(webResource, {
        get(target, prop, receiver) {
          if (prop === originalRequestSymbol) {
            return request;
          } else if (prop === "clone") {
            return () => {
              return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
                createProxy: true,
                originalRequest
              });
            };
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "keepAlive") {
            request.disableKeepAlive = !value;
          }
          const passThroughProps = [
            "url",
            "method",
            "withCredentials",
            "timeout",
            "requestId",
            "abortSignal",
            "body",
            "formData",
            "onDownloadProgress",
            "onUploadProgress",
            "proxySettings",
            "streamResponseStatusCodes",
            "agent",
            "requestOverrides"
          ];
          if (typeof prop === "string" && passThroughProps.includes(prop)) {
            request[prop] = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return webResource;
    }
  }
  function toHttpHeadersLike(headers) {
    return new HttpHeaders(headers.toJSON({ preserveCase: true }));
  }
  function getHeaderKey(headerName) {
    return headerName.toLowerCase();
  }

  class HttpHeaders {
    _headersMap;
    constructor(rawHeaders) {
      this._headersMap = {};
      if (rawHeaders) {
        for (const headerName in rawHeaders) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(headerName, headerValue) {
      this._headersMap[getHeaderKey(headerName)] = {
        name: headerName,
        value: headerValue.toString()
      };
    }
    get(headerName) {
      const header = this._headersMap[getHeaderKey(headerName)];
      return !header ? undefined : header.value;
    }
    contains(headerName) {
      return !!this._headersMap[getHeaderKey(headerName)];
    }
    remove(headerName) {
      const result = this.contains(headerName);
      delete this._headersMap[getHeaderKey(headerName)];
      return result;
    }
    rawHeaders() {
      return this.toJson({ preserveCase: true });
    }
    headersArray() {
      const headers = [];
      for (const headerKey in this._headersMap) {
        headers.push(this._headersMap[headerKey]);
      }
      return headers;
    }
    headerNames() {
      const headerNames = [];
      const headers = this.headersArray();
      for (let i = 0;i < headers.length; ++i) {
        headerNames.push(headers[i].name);
      }
      return headerNames;
    }
    headerValues() {
      const headerValues = [];
      const headers = this.headersArray();
      for (let i = 0;i < headers.length; ++i) {
        headerValues.push(headers[i].value);
      }
      return headerValues;
    }
    toJson(options = {}) {
      const result = {};
      if (options.preserveCase) {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[header.name] = header.value;
        }
      } else {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[getHeaderKey(header.name)] = header.value;
        }
      }
      return result;
    }
    toString() {
      return JSON.stringify(this.toJson({ preserveCase: true }));
    }
    clone() {
      const resultPreservingCasing = {};
      for (const headerKey in this._headersMap) {
        const header = this._headersMap[headerKey];
        resultPreservingCasing[header.name] = header.value;
      }
      return new HttpHeaders(resultPreservingCasing);
    }
  }
  exports.HttpHeaders = HttpHeaders;
});

// node_modules/@azure/core-http-compat/dist/commonjs/response.js
var require_response2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toCompatResponse = toCompatResponse;
  exports.toPipelineResponse = toPipelineResponse;
  var core_rest_pipeline_1 = require_commonjs8();
  var util_js_1 = require_util10();
  var originalResponse = Symbol("Original FullOperationResponse");
  function toCompatResponse(response, options) {
    let request = (0, util_js_1.toWebResourceLike)(response.request);
    let headers = (0, util_js_1.toHttpHeadersLike)(response.headers);
    if (options?.createProxy) {
      return new Proxy(response, {
        get(target, prop, receiver) {
          if (prop === "headers") {
            return headers;
          } else if (prop === "request") {
            return request;
          } else if (prop === originalResponse) {
            return response;
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "headers") {
            headers = value;
          } else if (prop === "request") {
            request = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return {
        ...response,
        request,
        headers
      };
    }
  }
  function toPipelineResponse(compatResponse) {
    const extendedCompatResponse = compatResponse;
    const response = extendedCompatResponse[originalResponse];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: true }));
    if (response) {
      response.headers = headers;
      return response;
    } else {
      return {
        ...compatResponse,
        headers,
        request: (0, util_js_1.toPipelineRequest)(compatResponse.request)
      };
    }
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/extendedClient.js
var require_extendedClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendedServiceClient = undefined;
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  var core_rest_pipeline_1 = require_commonjs8();
  var core_client_1 = require_commonjs10();
  var response_js_1 = require_response2();

  class ExtendedServiceClient extends core_client_1.ServiceClient {
    constructor(options) {
      super(options);
      if (options.keepAliveOptions?.enable === false && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)) {
        this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
      }
      if (options.redirectOptions?.handleRedirects === false) {
        this.pipeline.removePolicy({
          name: core_rest_pipeline_1.redirectPolicyName
        });
      }
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      const userProvidedCallBack = operationArguments?.options?.onResponse;
      let lastResponse;
      function onResponse(rawResponse, flatResponse, error) {
        lastResponse = rawResponse;
        if (userProvidedCallBack) {
          userProvidedCallBack(rawResponse, flatResponse, error);
        }
      }
      operationArguments.options = {
        ...operationArguments.options,
        onResponse
      };
      const result = await super.sendOperationRequest(operationArguments, operationSpec);
      if (lastResponse) {
        Object.defineProperty(result, "_response", {
          value: (0, response_js_1.toCompatResponse)(lastResponse)
        });
      }
      return result;
    }
  }
  exports.ExtendedServiceClient = ExtendedServiceClient;
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/requestPolicyFactoryPolicy.js
var require_requestPolicyFactoryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = undefined;
  exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
  var util_js_1 = require_util10();
  var response_js_1 = require_response2();
  var HttpPipelineLogLevel;
  (function(HttpPipelineLogLevel2) {
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
  })(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
  var mockRequestPolicyOptions = {
    log(_logLevel, _message) {},
    shouldLog(_logLevel) {
      return false;
    }
  };
  exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
  function createRequestPolicyFactoryPolicy(factories) {
    const orderedFactories = factories.slice().reverse();
    return {
      name: exports.requestPolicyFactoryPolicyName,
      async sendRequest(request, next) {
        let httpPipeline = {
          async sendRequest(httpRequest) {
            const response2 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
            return (0, response_js_1.toCompatResponse)(response2, { createProxy: true });
          }
        };
        for (const factory of orderedFactories) {
          httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
        }
        const webResourceLike = (0, util_js_1.toWebResourceLike)(request, { createProxy: true });
        const response = await httpPipeline.sendRequest(webResourceLike);
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/httpClientAdapter.js
var require_httpClientAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertHttpClient = convertHttpClient;
  var response_js_1 = require_response2();
  var util_js_1 = require_util10();
  function convertHttpClient(requestPolicyClient) {
    return {
      sendRequest: async (request) => {
        const response = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request, { createProxy: true }));
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/index.js
var require_commonjs11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = undefined;
  var extendedClient_js_1 = require_extendedClient();
  Object.defineProperty(exports, "ExtendedServiceClient", { enumerable: true, get: function() {
    return extendedClient_js_1.ExtendedServiceClient;
  } });
  var requestPolicyFactoryPolicy_js_1 = require_requestPolicyFactoryPolicy();
  Object.defineProperty(exports, "requestPolicyFactoryPolicyName", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
  } });
  Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
  } });
  Object.defineProperty(exports, "HttpPipelineLogLevel", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
  } });
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  Object.defineProperty(exports, "disableKeepAlivePolicyName", { enumerable: true, get: function() {
    return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
  } });
  var httpClientAdapter_js_1 = require_httpClientAdapter();
  Object.defineProperty(exports, "convertHttpClient", { enumerable: true, get: function() {
    return httpClientAdapter_js_1.convertHttpClient;
  } });
  var util_js_1 = require_util10();
  Object.defineProperty(exports, "toHttpHeadersLike", { enumerable: true, get: function() {
    return util_js_1.toHttpHeadersLike;
  } });
});

// node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = __commonJS((exports, module) => {
  (() => {
    var t = { d: (e2, i2) => {
      for (var n2 in i2)
        t.o(i2, n2) && !t.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: i2[n2] });
    }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    } }, e = {};
    t.r(e), t.d(e, { XMLBuilder: () => lt, XMLParser: () => tt, XMLValidator: () => pt });
    const i = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", n = new RegExp("^[" + i + "][" + i + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
    function s(t2, e2) {
      const i2 = [];
      let n2 = e2.exec(t2);
      for (;n2; ) {
        const s2 = [];
        s2.startIndex = e2.lastIndex - n2[0].length;
        const r2 = n2.length;
        for (let t3 = 0;t3 < r2; t3++)
          s2.push(n2[t3]);
        i2.push(s2), n2 = e2.exec(t2);
      }
      return i2;
    }
    const r = function(t2) {
      return !(n.exec(t2) == null);
    }, o = { allowBooleanAttributes: false, unpairedTags: [] };
    function a(t2, e2) {
      e2 = Object.assign({}, o, e2);
      const i2 = [];
      let n2 = false, s2 = false;
      t2[0] === "\uFEFF" && (t2 = t2.substr(1));
      for (let o2 = 0;o2 < t2.length; o2++)
        if (t2[o2] === "<" && t2[o2 + 1] === "?") {
          if (o2 += 2, o2 = u(t2, o2), o2.err)
            return o2;
        } else {
          if (t2[o2] !== "<") {
            if (l(t2[o2]))
              continue;
            return x("InvalidChar", "char '" + t2[o2] + "' is not expected.", b(t2, o2));
          }
          {
            let a2 = o2;
            if (o2++, t2[o2] === "!") {
              o2 = h(t2, o2);
              continue;
            }
            {
              let d2 = false;
              t2[o2] === "/" && (d2 = true, o2++);
              let p2 = "";
              for (;o2 < t2.length && t2[o2] !== ">" && t2[o2] !== " " && t2[o2] !== "\t" && t2[o2] !== `
` && t2[o2] !== "\r"; o2++)
                p2 += t2[o2];
              if (p2 = p2.trim(), p2[p2.length - 1] === "/" && (p2 = p2.substring(0, p2.length - 1), o2--), !r(p2)) {
                let e3;
                return e3 = p2.trim().length === 0 ? "Invalid space after '<'." : "Tag '" + p2 + "' is an invalid name.", x("InvalidTag", e3, b(t2, o2));
              }
              const c2 = f(t2, o2);
              if (c2 === false)
                return x("InvalidAttr", "Attributes for '" + p2 + "' have open quote.", b(t2, o2));
              let N2 = c2.value;
              if (o2 = c2.index, N2[N2.length - 1] === "/") {
                const i3 = o2 - N2.length;
                N2 = N2.substring(0, N2.length - 1);
                const s3 = g(N2, e2);
                if (s3 !== true)
                  return x(s3.err.code, s3.err.msg, b(t2, i3 + s3.err.line));
                n2 = true;
              } else if (d2) {
                if (!c2.tagClosed)
                  return x("InvalidTag", "Closing tag '" + p2 + "' doesn't have proper closing.", b(t2, o2));
                if (N2.trim().length > 0)
                  return x("InvalidTag", "Closing tag '" + p2 + "' can't have attributes or invalid starting.", b(t2, a2));
                if (i2.length === 0)
                  return x("InvalidTag", "Closing tag '" + p2 + "' has not been opened.", b(t2, a2));
                {
                  const e3 = i2.pop();
                  if (p2 !== e3.tagName) {
                    let i3 = b(t2, e3.tagStartPos);
                    return x("InvalidTag", "Expected closing tag '" + e3.tagName + "' (opened in line " + i3.line + ", col " + i3.col + ") instead of closing tag '" + p2 + "'.", b(t2, a2));
                  }
                  i2.length == 0 && (s2 = true);
                }
              } else {
                const r2 = g(N2, e2);
                if (r2 !== true)
                  return x(r2.err.code, r2.err.msg, b(t2, o2 - N2.length + r2.err.line));
                if (s2 === true)
                  return x("InvalidXml", "Multiple possible root nodes found.", b(t2, o2));
                e2.unpairedTags.indexOf(p2) !== -1 || i2.push({ tagName: p2, tagStartPos: a2 }), n2 = true;
              }
              for (o2++;o2 < t2.length; o2++)
                if (t2[o2] === "<") {
                  if (t2[o2 + 1] === "!") {
                    o2++, o2 = h(t2, o2);
                    continue;
                  }
                  if (t2[o2 + 1] !== "?")
                    break;
                  if (o2 = u(t2, ++o2), o2.err)
                    return o2;
                } else if (t2[o2] === "&") {
                  const e3 = m(t2, o2);
                  if (e3 == -1)
                    return x("InvalidChar", "char '&' is not expected.", b(t2, o2));
                  o2 = e3;
                } else if (s2 === true && !l(t2[o2]))
                  return x("InvalidXml", "Extra text at the end", b(t2, o2));
              t2[o2] === "<" && o2--;
            }
          }
        }
      return n2 ? i2.length == 1 ? x("InvalidTag", "Unclosed tag '" + i2[0].tagName + "'.", b(t2, i2[0].tagStartPos)) : !(i2.length > 0) || x("InvalidXml", "Invalid '" + JSON.stringify(i2.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : x("InvalidXml", "Start tag expected.", 1);
    }
    function l(t2) {
      return t2 === " " || t2 === "\t" || t2 === `
` || t2 === "\r";
    }
    function u(t2, e2) {
      const i2 = e2;
      for (;e2 < t2.length; e2++)
        if (t2[e2] != "?" && t2[e2] != " ")
          ;
        else {
          const n2 = t2.substr(i2, e2 - i2);
          if (e2 > 5 && n2 === "xml")
            return x("InvalidXml", "XML declaration allowed only at the start of the document.", b(t2, e2));
          if (t2[e2] == "?" && t2[e2 + 1] == ">") {
            e2++;
            break;
          }
        }
      return e2;
    }
    function h(t2, e2) {
      if (t2.length > e2 + 5 && t2[e2 + 1] === "-" && t2[e2 + 2] === "-") {
        for (e2 += 3;e2 < t2.length; e2++)
          if (t2[e2] === "-" && t2[e2 + 1] === "-" && t2[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      } else if (t2.length > e2 + 8 && t2[e2 + 1] === "D" && t2[e2 + 2] === "O" && t2[e2 + 3] === "C" && t2[e2 + 4] === "T" && t2[e2 + 5] === "Y" && t2[e2 + 6] === "P" && t2[e2 + 7] === "E") {
        let i2 = 1;
        for (e2 += 8;e2 < t2.length; e2++)
          if (t2[e2] === "<")
            i2++;
          else if (t2[e2] === ">" && (i2--, i2 === 0))
            break;
      } else if (t2.length > e2 + 9 && t2[e2 + 1] === "[" && t2[e2 + 2] === "C" && t2[e2 + 3] === "D" && t2[e2 + 4] === "A" && t2[e2 + 5] === "T" && t2[e2 + 6] === "A" && t2[e2 + 7] === "[") {
        for (e2 += 8;e2 < t2.length; e2++)
          if (t2[e2] === "]" && t2[e2 + 1] === "]" && t2[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      }
      return e2;
    }
    const d = '"', p = "'";
    function f(t2, e2) {
      let i2 = "", n2 = "", s2 = false;
      for (;e2 < t2.length; e2++) {
        if (t2[e2] === d || t2[e2] === p)
          n2 === "" ? n2 = t2[e2] : n2 !== t2[e2] || (n2 = "");
        else if (t2[e2] === ">" && n2 === "") {
          s2 = true;
          break;
        }
        i2 += t2[e2];
      }
      return n2 === "" && { value: i2, index: e2, tagClosed: s2 };
    }
    const c = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function g(t2, e2) {
      const i2 = s(t2, c), n2 = {};
      for (let t3 = 0;t3 < i2.length; t3++) {
        if (i2[t3][1].length === 0)
          return x("InvalidAttr", "Attribute '" + i2[t3][2] + "' has no space in starting.", E(i2[t3]));
        if (i2[t3][3] !== undefined && i2[t3][4] === undefined)
          return x("InvalidAttr", "Attribute '" + i2[t3][2] + "' is without value.", E(i2[t3]));
        if (i2[t3][3] === undefined && !e2.allowBooleanAttributes)
          return x("InvalidAttr", "boolean attribute '" + i2[t3][2] + "' is not allowed.", E(i2[t3]));
        const s2 = i2[t3][2];
        if (!N(s2))
          return x("InvalidAttr", "Attribute '" + s2 + "' is an invalid name.", E(i2[t3]));
        if (n2.hasOwnProperty(s2))
          return x("InvalidAttr", "Attribute '" + s2 + "' is repeated.", E(i2[t3]));
        n2[s2] = 1;
      }
      return true;
    }
    function m(t2, e2) {
      if (t2[++e2] === ";")
        return -1;
      if (t2[e2] === "#")
        return function(t3, e3) {
          let i3 = /\d/;
          for (t3[e3] === "x" && (e3++, i3 = /[\da-fA-F]/);e3 < t3.length; e3++) {
            if (t3[e3] === ";")
              return e3;
            if (!t3[e3].match(i3))
              break;
          }
          return -1;
        }(t2, ++e2);
      let i2 = 0;
      for (;e2 < t2.length; e2++, i2++)
        if (!(t2[e2].match(/\w/) && i2 < 20)) {
          if (t2[e2] === ";")
            break;
          return -1;
        }
      return e2;
    }
    function x(t2, e2, i2) {
      return { err: { code: t2, msg: e2, line: i2.line || i2, col: i2.col } };
    }
    function N(t2) {
      return r(t2);
    }
    function b(t2, e2) {
      const i2 = t2.substring(0, e2).split(/\r?\n/);
      return { line: i2.length, col: i2[i2.length - 1].length + 1 };
    }
    function E(t2) {
      return t2.startIndex + t2[1].length;
    }
    const v = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(t2, e2, i2) {
      return t2;
    }, captureMetaData: false };
    let T;
    T = typeof Symbol != "function" ? "@@xmlMetadata" : Symbol("XML Node Metadata");

    class y {
      constructor(t2) {
        this.tagname = t2, this.child = [], this[":@"] = {};
      }
      add(t2, e2) {
        t2 === "__proto__" && (t2 = "#__proto__"), this.child.push({ [t2]: e2 });
      }
      addChild(t2, e2) {
        t2.tagname === "__proto__" && (t2.tagname = "#__proto__"), t2[":@"] && Object.keys(t2[":@"]).length > 0 ? this.child.push({ [t2.tagname]: t2.child, ":@": t2[":@"] }) : this.child.push({ [t2.tagname]: t2.child }), e2 !== undefined && (this.child[this.child.length - 1][T] = { startIndex: e2 });
      }
      static getMetaDataSymbol() {
        return T;
      }
    }

    class w {
      constructor(t2) {
        this.suppressValidationErr = !t2;
      }
      readDocType(t2, e2) {
        const i2 = {};
        if (t2[e2 + 3] !== "O" || t2[e2 + 4] !== "C" || t2[e2 + 5] !== "T" || t2[e2 + 6] !== "Y" || t2[e2 + 7] !== "P" || t2[e2 + 8] !== "E")
          throw new Error("Invalid Tag instead of DOCTYPE");
        {
          e2 += 9;
          let n2 = 1, s2 = false, r2 = false, o2 = "";
          for (;e2 < t2.length; e2++)
            if (t2[e2] !== "<" || r2)
              if (t2[e2] === ">") {
                if (r2 ? t2[e2 - 1] === "-" && t2[e2 - 2] === "-" && (r2 = false, n2--) : n2--, n2 === 0)
                  break;
              } else
                t2[e2] === "[" ? s2 = true : o2 += t2[e2];
            else {
              if (s2 && P(t2, "!ENTITY", e2)) {
                let n3, s3;
                e2 += 7, [n3, s3, e2] = this.readEntityExp(t2, e2 + 1, this.suppressValidationErr), s3.indexOf("&") === -1 && (i2[n3] = { regx: RegExp(`&${n3};`, "g"), val: s3 });
              } else if (s2 && P(t2, "!ELEMENT", e2)) {
                e2 += 8;
                const { index: i3 } = this.readElementExp(t2, e2 + 1);
                e2 = i3;
              } else if (s2 && P(t2, "!ATTLIST", e2))
                e2 += 8;
              else if (s2 && P(t2, "!NOTATION", e2)) {
                e2 += 9;
                const { index: i3 } = this.readNotationExp(t2, e2 + 1, this.suppressValidationErr);
                e2 = i3;
              } else {
                if (!P(t2, "!--", e2))
                  throw new Error("Invalid DOCTYPE");
                r2 = true;
              }
              n2++, o2 = "";
            }
          if (n2 !== 0)
            throw new Error("Unclosed DOCTYPE");
        }
        return { entities: i2, i: e2 };
      }
      readEntityExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]) && t2[e2] !== '"' && t2[e2] !== "'"; )
          i2 += t2[e2], e2++;
        if (O(i2), e2 = I(t2, e2), !this.suppressValidationErr) {
          if (t2.substring(e2, e2 + 6).toUpperCase() === "SYSTEM")
            throw new Error("External entities are not supported");
          if (t2[e2] === "%")
            throw new Error("Parameter entities are not supported");
        }
        let n2 = "";
        return [e2, n2] = this.readIdentifierVal(t2, e2, "entity"), [i2, n2, --e2];
      }
      readNotationExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          i2 += t2[e2], e2++;
        !this.suppressValidationErr && O(i2), e2 = I(t2, e2);
        const n2 = t2.substring(e2, e2 + 6).toUpperCase();
        if (!this.suppressValidationErr && n2 !== "SYSTEM" && n2 !== "PUBLIC")
          throw new Error(`Expected SYSTEM or PUBLIC, found "${n2}"`);
        e2 += n2.length, e2 = I(t2, e2);
        let s2 = null, r2 = null;
        if (n2 === "PUBLIC")
          [e2, s2] = this.readIdentifierVal(t2, e2, "publicIdentifier"), t2[e2 = I(t2, e2)] !== '"' && t2[e2] !== "'" || ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"));
        else if (n2 === "SYSTEM" && ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"), !this.suppressValidationErr && !r2))
          throw new Error("Missing mandatory system identifier for SYSTEM notation");
        return { notationName: i2, publicIdentifier: s2, systemIdentifier: r2, index: --e2 };
      }
      readIdentifierVal(t2, e2, i2) {
        let n2 = "";
        const s2 = t2[e2];
        if (s2 !== '"' && s2 !== "'")
          throw new Error(`Expected quoted string, found "${s2}"`);
        for (e2++;e2 < t2.length && t2[e2] !== s2; )
          n2 += t2[e2], e2++;
        if (t2[e2] !== s2)
          throw new Error(`Unterminated ${i2} value`);
        return [++e2, n2];
      }
      readElementExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          i2 += t2[e2], e2++;
        if (!this.suppressValidationErr && !r(i2))
          throw new Error(`Invalid element name: "${i2}"`);
        let n2 = "";
        if (t2[e2 = I(t2, e2)] === "E" && P(t2, "MPTY", e2))
          e2 += 4;
        else if (t2[e2] === "A" && P(t2, "NY", e2))
          e2 += 2;
        else if (t2[e2] === "(") {
          for (e2++;e2 < t2.length && t2[e2] !== ")"; )
            n2 += t2[e2], e2++;
          if (t2[e2] !== ")")
            throw new Error("Unterminated content model");
        } else if (!this.suppressValidationErr)
          throw new Error(`Invalid Element Expression, found "${t2[e2]}"`);
        return { elementName: i2, contentModel: n2.trim(), index: e2 };
      }
      readAttlistExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          i2 += t2[e2], e2++;
        O(i2), e2 = I(t2, e2);
        let n2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          n2 += t2[e2], e2++;
        if (!O(n2))
          throw new Error(`Invalid attribute name: "${n2}"`);
        e2 = I(t2, e2);
        let s2 = "";
        if (t2.substring(e2, e2 + 8).toUpperCase() === "NOTATION") {
          if (s2 = "NOTATION", t2[e2 = I(t2, e2 += 8)] !== "(")
            throw new Error(`Expected '(', found "${t2[e2]}"`);
          e2++;
          let i3 = [];
          for (;e2 < t2.length && t2[e2] !== ")"; ) {
            let n3 = "";
            for (;e2 < t2.length && t2[e2] !== "|" && t2[e2] !== ")"; )
              n3 += t2[e2], e2++;
            if (n3 = n3.trim(), !O(n3))
              throw new Error(`Invalid notation name: "${n3}"`);
            i3.push(n3), t2[e2] === "|" && (e2++, e2 = I(t2, e2));
          }
          if (t2[e2] !== ")")
            throw new Error("Unterminated list of notations");
          e2++, s2 += " (" + i3.join("|") + ")";
        } else {
          for (;e2 < t2.length && !/\s/.test(t2[e2]); )
            s2 += t2[e2], e2++;
          const i3 = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
          if (!this.suppressValidationErr && !i3.includes(s2.toUpperCase()))
            throw new Error(`Invalid attribute type: "${s2}"`);
        }
        e2 = I(t2, e2);
        let r2 = "";
        return t2.substring(e2, e2 + 8).toUpperCase() === "#REQUIRED" ? (r2 = "#REQUIRED", e2 += 8) : t2.substring(e2, e2 + 7).toUpperCase() === "#IMPLIED" ? (r2 = "#IMPLIED", e2 += 7) : [e2, r2] = this.readIdentifierVal(t2, e2, "ATTLIST"), { elementName: i2, attributeName: n2, attributeType: s2, defaultValue: r2, index: e2 };
      }
    }
    const I = (t2, e2) => {
      for (;e2 < t2.length && /\s/.test(t2[e2]); )
        e2++;
      return e2;
    };
    function P(t2, e2, i2) {
      for (let n2 = 0;n2 < e2.length; n2++)
        if (e2[n2] !== t2[i2 + n2 + 1])
          return false;
      return true;
    }
    function O(t2) {
      if (r(t2))
        return t2;
      throw new Error(`Invalid entity name ${t2}`);
    }
    const A = /^[-+]?0x[a-fA-F0-9]+$/, S = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, C = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
    const V = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    function $(t2) {
      return typeof t2 == "function" ? t2 : Array.isArray(t2) ? (e2) => {
        for (const i2 of t2) {
          if (typeof i2 == "string" && e2 === i2)
            return true;
          if (i2 instanceof RegExp && i2.test(e2))
            return true;
        }
      } : () => false;
    }

    class D {
      constructor(t2) {
        if (this.options = t2, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "" }, pound: { regex: /&(pound|#163);/g, val: "" }, yen: { regex: /&(yen|#165);/g, val: "" }, euro: { regex: /&(euro|#8364);/g, val: "" }, copyright: { regex: /&(copy|#169);/g, val: "" }, reg: { regex: /&(reg|#174);/g, val: "" }, inr: { regex: /&(inr|#8377);/g, val: "" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 16)) } }, this.addExternalEntities = j, this.parseXml = L, this.parseTextData = M, this.resolveNameSpace = F, this.buildAttributesMap = k, this.isItStopNode = Y, this.replaceEntitiesValue = B, this.readStopNodeData = W, this.saveTextToParentTag = R, this.addChild = U, this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.options.stopNodes && this.options.stopNodes.length > 0) {
          this.stopNodesExact = new Set, this.stopNodesWildcard = new Set;
          for (let t3 = 0;t3 < this.options.stopNodes.length; t3++) {
            const e2 = this.options.stopNodes[t3];
            typeof e2 == "string" && (e2.startsWith("*.") ? this.stopNodesWildcard.add(e2.substring(2)) : this.stopNodesExact.add(e2));
          }
        }
      }
    }
    function j(t2) {
      const e2 = Object.keys(t2);
      for (let i2 = 0;i2 < e2.length; i2++) {
        const n2 = e2[i2];
        this.lastEntities[n2] = { regex: new RegExp("&" + n2 + ";", "g"), val: t2[n2] };
      }
    }
    function M(t2, e2, i2, n2, s2, r2, o2) {
      if (t2 !== undefined && (this.options.trimValues && !n2 && (t2 = t2.trim()), t2.length > 0)) {
        o2 || (t2 = this.replaceEntitiesValue(t2));
        const n3 = this.options.tagValueProcessor(e2, t2, i2, s2, r2);
        return n3 == null ? t2 : typeof n3 != typeof t2 || n3 !== t2 ? n3 : this.options.trimValues || t2.trim() === t2 ? q(t2, this.options.parseTagValue, this.options.numberParseOptions) : t2;
      }
    }
    function F(t2) {
      if (this.options.removeNSPrefix) {
        const e2 = t2.split(":"), i2 = t2.charAt(0) === "/" ? "/" : "";
        if (e2[0] === "xmlns")
          return "";
        e2.length === 2 && (t2 = i2 + e2[1]);
      }
      return t2;
    }
    const _2 = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function k(t2, e2) {
      if (this.options.ignoreAttributes !== true && typeof t2 == "string") {
        const i2 = s(t2, _2), n2 = i2.length, r2 = {};
        for (let t3 = 0;t3 < n2; t3++) {
          const n3 = this.resolveNameSpace(i2[t3][1]);
          if (this.ignoreAttributesFn(n3, e2))
            continue;
          let s2 = i2[t3][4], o2 = this.options.attributeNamePrefix + n3;
          if (n3.length)
            if (this.options.transformAttributeName && (o2 = this.options.transformAttributeName(o2)), o2 === "__proto__" && (o2 = "#__proto__"), s2 !== undefined) {
              this.options.trimValues && (s2 = s2.trim()), s2 = this.replaceEntitiesValue(s2);
              const t4 = this.options.attributeValueProcessor(n3, s2, e2);
              r2[o2] = t4 == null ? s2 : typeof t4 != typeof s2 || t4 !== s2 ? t4 : q(s2, this.options.parseAttributeValue, this.options.numberParseOptions);
            } else
              this.options.allowBooleanAttributes && (r2[o2] = true);
        }
        if (!Object.keys(r2).length)
          return;
        if (this.options.attributesGroupName) {
          const t3 = {};
          return t3[this.options.attributesGroupName] = r2, t3;
        }
        return r2;
      }
    }
    const L = function(t2) {
      t2 = t2.replace(/\r\n?/g, `
`);
      const e2 = new y("!xml");
      let i2 = e2, n2 = "", s2 = "";
      const r2 = new w(this.options.processEntities);
      for (let o2 = 0;o2 < t2.length; o2++)
        if (t2[o2] === "<")
          if (t2[o2 + 1] === "/") {
            const e3 = G(t2, ">", o2, "Closing Tag is not closed.");
            let r3 = t2.substring(o2 + 2, e3).trim();
            if (this.options.removeNSPrefix) {
              const t3 = r3.indexOf(":");
              t3 !== -1 && (r3 = r3.substr(t3 + 1));
            }
            this.options.transformTagName && (r3 = this.options.transformTagName(r3)), i2 && (n2 = this.saveTextToParentTag(n2, i2, s2));
            const a2 = s2.substring(s2.lastIndexOf(".") + 1);
            if (r3 && this.options.unpairedTags.indexOf(r3) !== -1)
              throw new Error(`Unpaired tag can not be used as closing tag: </${r3}>`);
            let l2 = 0;
            a2 && this.options.unpairedTags.indexOf(a2) !== -1 ? (l2 = s2.lastIndexOf(".", s2.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l2 = s2.lastIndexOf("."), s2 = s2.substring(0, l2), i2 = this.tagsNodeStack.pop(), n2 = "", o2 = e3;
          } else if (t2[o2 + 1] === "?") {
            let e3 = X(t2, o2, false, "?>");
            if (!e3)
              throw new Error("Pi Tag is not closed.");
            if (n2 = this.saveTextToParentTag(n2, i2, s2), this.options.ignoreDeclaration && e3.tagName === "?xml" || this.options.ignorePiTags)
              ;
            else {
              const t3 = new y(e3.tagName);
              t3.add(this.options.textNodeName, ""), e3.tagName !== e3.tagExp && e3.attrExpPresent && (t3[":@"] = this.buildAttributesMap(e3.tagExp, s2)), this.addChild(i2, t3, s2, o2);
            }
            o2 = e3.closeIndex + 1;
          } else if (t2.substr(o2 + 1, 3) === "!--") {
            const e3 = G(t2, "-->", o2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const r3 = t2.substring(o2 + 4, e3 - 2);
              n2 = this.saveTextToParentTag(n2, i2, s2), i2.add(this.options.commentPropName, [{ [this.options.textNodeName]: r3 }]);
            }
            o2 = e3;
          } else if (t2.substr(o2 + 1, 2) === "!D") {
            const e3 = r2.readDocType(t2, o2);
            this.docTypeEntities = e3.entities, o2 = e3.i;
          } else if (t2.substr(o2 + 1, 2) === "![") {
            const e3 = G(t2, "]]>", o2, "CDATA is not closed.") - 2, r3 = t2.substring(o2 + 9, e3);
            n2 = this.saveTextToParentTag(n2, i2, s2);
            let a2 = this.parseTextData(r3, i2.tagname, s2, true, false, true, true);
            a2 == null && (a2 = ""), this.options.cdataPropName ? i2.add(this.options.cdataPropName, [{ [this.options.textNodeName]: r3 }]) : i2.add(this.options.textNodeName, a2), o2 = e3 + 2;
          } else {
            let r3 = X(t2, o2, this.options.removeNSPrefix), a2 = r3.tagName;
            const l2 = r3.rawTagName;
            let { tagExp: u2, attrExpPresent: h2, closeIndex: d2 } = r3;
            if (this.options.transformTagName) {
              const t3 = this.options.transformTagName(a2);
              u2 === a2 && (u2 = t3), a2 = t3;
            }
            i2 && n2 && i2.tagname !== "!xml" && (n2 = this.saveTextToParentTag(n2, i2, s2, false));
            const p2 = i2;
            p2 && this.options.unpairedTags.indexOf(p2.tagname) !== -1 && (i2 = this.tagsNodeStack.pop(), s2 = s2.substring(0, s2.lastIndexOf("."))), a2 !== e2.tagname && (s2 += s2 ? "." + a2 : a2);
            const f2 = o2;
            if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, s2, a2)) {
              let e3 = "";
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1)
                a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), o2 = r3.closeIndex;
              else if (this.options.unpairedTags.indexOf(a2) !== -1)
                o2 = r3.closeIndex;
              else {
                const i3 = this.readStopNodeData(t2, l2, d2 + 1);
                if (!i3)
                  throw new Error(`Unexpected end of ${l2}`);
                o2 = i3.i, e3 = i3.tagContent;
              }
              const n3 = new y(a2);
              a2 !== u2 && h2 && (n3[":@"] = this.buildAttributesMap(u2, s2)), e3 && (e3 = this.parseTextData(e3, a2, s2, true, h2, true, true)), s2 = s2.substr(0, s2.lastIndexOf(".")), n3.add(this.options.textNodeName, e3), this.addChild(i2, n3, s2, f2);
            } else {
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1) {
                if (a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), this.options.transformTagName) {
                  const t4 = this.options.transformTagName(a2);
                  u2 === a2 && (u2 = t4), a2 = t4;
                }
                const t3 = new y(a2);
                a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, s2)), this.addChild(i2, t3, s2, f2), s2 = s2.substr(0, s2.lastIndexOf("."));
              } else {
                const t3 = new y(a2);
                this.tagsNodeStack.push(i2), a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, s2)), this.addChild(i2, t3, s2, f2), i2 = t3;
              }
              n2 = "", o2 = d2;
            }
          }
        else
          n2 += t2[o2];
      return e2.child;
    };
    function U(t2, e2, i2, n2) {
      this.options.captureMetaData || (n2 = undefined);
      const s2 = this.options.updateTag(e2.tagname, i2, e2[":@"]);
      s2 === false || (typeof s2 == "string" ? (e2.tagname = s2, t2.addChild(e2, n2)) : t2.addChild(e2, n2));
    }
    const B = function(t2) {
      if (this.options.processEntities) {
        for (let e2 in this.docTypeEntities) {
          const i2 = this.docTypeEntities[e2];
          t2 = t2.replace(i2.regx, i2.val);
        }
        for (let e2 in this.lastEntities) {
          const i2 = this.lastEntities[e2];
          t2 = t2.replace(i2.regex, i2.val);
        }
        if (this.options.htmlEntities)
          for (let e2 in this.htmlEntities) {
            const i2 = this.htmlEntities[e2];
            t2 = t2.replace(i2.regex, i2.val);
          }
        t2 = t2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return t2;
    };
    function R(t2, e2, i2, n2) {
      return t2 && (n2 === undefined && (n2 = e2.child.length === 0), (t2 = this.parseTextData(t2, e2.tagname, i2, false, !!e2[":@"] && Object.keys(e2[":@"]).length !== 0, n2)) !== undefined && t2 !== "" && e2.add(this.options.textNodeName, t2), t2 = ""), t2;
    }
    function Y(t2, e2, i2, n2) {
      return !(!e2 || !e2.has(n2)) || !(!t2 || !t2.has(i2));
    }
    function G(t2, e2, i2, n2) {
      const s2 = t2.indexOf(e2, i2);
      if (s2 === -1)
        throw new Error(n2);
      return s2 + e2.length - 1;
    }
    function X(t2, e2, i2, n2 = ">") {
      const s2 = function(t3, e3, i3 = ">") {
        let n3, s3 = "";
        for (let r3 = e3;r3 < t3.length; r3++) {
          let e4 = t3[r3];
          if (n3)
            e4 === n3 && (n3 = "");
          else if (e4 === '"' || e4 === "'")
            n3 = e4;
          else if (e4 === i3[0]) {
            if (!i3[1])
              return { data: s3, index: r3 };
            if (t3[r3 + 1] === i3[1])
              return { data: s3, index: r3 };
          } else
            e4 === "\t" && (e4 = " ");
          s3 += e4;
        }
      }(t2, e2 + 1, n2);
      if (!s2)
        return;
      let r2 = s2.data;
      const o2 = s2.index, a2 = r2.search(/\s/);
      let l2 = r2, u2 = true;
      a2 !== -1 && (l2 = r2.substring(0, a2), r2 = r2.substring(a2 + 1).trimStart());
      const h2 = l2;
      if (i2) {
        const t3 = l2.indexOf(":");
        t3 !== -1 && (l2 = l2.substr(t3 + 1), u2 = l2 !== s2.data.substr(t3 + 1));
      }
      return { tagName: l2, tagExp: r2, closeIndex: o2, attrExpPresent: u2, rawTagName: h2 };
    }
    function W(t2, e2, i2) {
      const n2 = i2;
      let s2 = 1;
      for (;i2 < t2.length; i2++)
        if (t2[i2] === "<")
          if (t2[i2 + 1] === "/") {
            const r2 = G(t2, ">", i2, `${e2} is not closed`);
            if (t2.substring(i2 + 2, r2).trim() === e2 && (s2--, s2 === 0))
              return { tagContent: t2.substring(n2, i2), i: r2 };
            i2 = r2;
          } else if (t2[i2 + 1] === "?")
            i2 = G(t2, "?>", i2 + 1, "StopNode is not closed.");
          else if (t2.substr(i2 + 1, 3) === "!--")
            i2 = G(t2, "-->", i2 + 3, "StopNode is not closed.");
          else if (t2.substr(i2 + 1, 2) === "![")
            i2 = G(t2, "]]>", i2, "StopNode is not closed.") - 2;
          else {
            const n3 = X(t2, i2, ">");
            n3 && ((n3 && n3.tagName) === e2 && n3.tagExp[n3.tagExp.length - 1] !== "/" && s2++, i2 = n3.closeIndex);
          }
    }
    function q(t2, e2, i2) {
      if (e2 && typeof t2 == "string") {
        const e3 = t2.trim();
        return e3 === "true" || e3 !== "false" && function(t3, e4 = {}) {
          if (e4 = Object.assign({}, C, e4), !t3 || typeof t3 != "string")
            return t3;
          let i3 = t3.trim();
          if (e4.skipLike !== undefined && e4.skipLike.test(i3))
            return t3;
          if (t3 === "0")
            return 0;
          if (e4.hex && A.test(i3))
            return function(t4) {
              if (parseInt)
                return parseInt(t4, 16);
              if (Number.parseInt)
                return Number.parseInt(t4, 16);
              if (window && window.parseInt)
                return window.parseInt(t4, 16);
              throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
            }(i3);
          if (i3.search(/.+[eE].+/) !== -1)
            return function(t4, e5, i4) {
              if (!i4.eNotation)
                return t4;
              const n3 = e5.match(V);
              if (n3) {
                let s2 = n3[1] || "";
                const r2 = n3[3].indexOf("e") === -1 ? "E" : "e", o2 = n3[2], a2 = s2 ? t4[o2.length + 1] === r2 : t4[o2.length] === r2;
                return o2.length > 1 && a2 ? t4 : o2.length !== 1 || !n3[3].startsWith(`.${r2}`) && n3[3][0] !== r2 ? i4.leadingZeros && !a2 ? (e5 = (n3[1] || "") + n3[3], Number(e5)) : t4 : Number(e5);
              }
              return t4;
            }(t3, i3, e4);
          {
            const s2 = S.exec(i3);
            if (s2) {
              const r2 = s2[1] || "", o2 = s2[2];
              let a2 = (n2 = s2[3]) && n2.indexOf(".") !== -1 ? ((n2 = n2.replace(/0+$/, "")) === "." ? n2 = "0" : n2[0] === "." ? n2 = "0" + n2 : n2[n2.length - 1] === "." && (n2 = n2.substring(0, n2.length - 1)), n2) : n2;
              const l2 = r2 ? t3[o2.length + 1] === "." : t3[o2.length] === ".";
              if (!e4.leadingZeros && (o2.length > 1 || o2.length === 1 && !l2))
                return t3;
              {
                const n3 = Number(i3), s3 = String(n3);
                if (n3 === 0 || n3 === -0)
                  return n3;
                if (s3.search(/[eE]/) !== -1)
                  return e4.eNotation ? n3 : t3;
                if (i3.indexOf(".") !== -1)
                  return s3 === "0" || s3 === a2 || s3 === `${r2}${a2}` ? n3 : t3;
                let l3 = o2 ? a2 : i3;
                return o2 ? l3 === s3 || r2 + l3 === s3 ? n3 : t3 : l3 === s3 || l3 === r2 + s3 ? n3 : t3;
              }
            }
            return t3;
          }
          var n2;
        }(t2, i2);
      }
      return t2 !== undefined ? t2 : "";
    }
    const Z = y.getMetaDataSymbol();
    function K(t2, e2) {
      return Q(t2, e2);
    }
    function Q(t2, e2, i2) {
      let n2;
      const s2 = {};
      for (let r2 = 0;r2 < t2.length; r2++) {
        const o2 = t2[r2], a2 = z(o2);
        let l2 = "";
        if (l2 = i2 === undefined ? a2 : i2 + "." + a2, a2 === e2.textNodeName)
          n2 === undefined ? n2 = o2[a2] : n2 += "" + o2[a2];
        else {
          if (a2 === undefined)
            continue;
          if (o2[a2]) {
            let t3 = Q(o2[a2], e2, l2);
            const i3 = H(t3, e2);
            o2[Z] !== undefined && (t3[Z] = o2[Z]), o2[":@"] ? J(t3, o2[":@"], l2, e2) : Object.keys(t3).length !== 1 || t3[e2.textNodeName] === undefined || e2.alwaysCreateTextNode ? Object.keys(t3).length === 0 && (e2.alwaysCreateTextNode ? t3[e2.textNodeName] = "" : t3 = "") : t3 = t3[e2.textNodeName], s2[a2] !== undefined && s2.hasOwnProperty(a2) ? (Array.isArray(s2[a2]) || (s2[a2] = [s2[a2]]), s2[a2].push(t3)) : e2.isArray(a2, l2, i3) ? s2[a2] = [t3] : s2[a2] = t3;
          }
        }
      }
      return typeof n2 == "string" ? n2.length > 0 && (s2[e2.textNodeName] = n2) : n2 !== undefined && (s2[e2.textNodeName] = n2), s2;
    }
    function z(t2) {
      const e2 = Object.keys(t2);
      for (let t3 = 0;t3 < e2.length; t3++) {
        const i2 = e2[t3];
        if (i2 !== ":@")
          return i2;
      }
    }
    function J(t2, e2, i2, n2) {
      if (e2) {
        const s2 = Object.keys(e2), r2 = s2.length;
        for (let o2 = 0;o2 < r2; o2++) {
          const r3 = s2[o2];
          n2.isArray(r3, i2 + "." + r3, true, true) ? t2[r3] = [e2[r3]] : t2[r3] = e2[r3];
        }
      }
    }
    function H(t2, e2) {
      const { textNodeName: i2 } = e2, n2 = Object.keys(t2).length;
      return n2 === 0 || !(n2 !== 1 || !t2[i2] && typeof t2[i2] != "boolean" && t2[i2] !== 0);
    }

    class tt {
      constructor(t2) {
        this.externalEntities = {}, this.options = function(t3) {
          return Object.assign({}, v, t3);
        }(t2);
      }
      parse(t2, e2) {
        if (typeof t2 != "string" && t2.toString)
          t2 = t2.toString();
        else if (typeof t2 != "string")
          throw new Error("XML data is accepted in String or Bytes[] form.");
        if (e2) {
          e2 === true && (e2 = {});
          const i3 = a(t2, e2);
          if (i3 !== true)
            throw Error(`${i3.err.msg}:${i3.err.line}:${i3.err.col}`);
        }
        const i2 = new D(this.options);
        i2.addExternalEntities(this.externalEntities);
        const n2 = i2.parseXml(t2);
        return this.options.preserveOrder || n2 === undefined ? n2 : K(n2, this.options);
      }
      addEntity(t2, e2) {
        if (e2.indexOf("&") !== -1)
          throw new Error("Entity value can't have '&'");
        if (t2.indexOf("&") !== -1 || t2.indexOf(";") !== -1)
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        if (e2 === "&")
          throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[t2] = e2;
      }
      static getMetaDataSymbol() {
        return y.getMetaDataSymbol();
      }
    }
    function et(t2, e2) {
      let i2 = "";
      return e2.format && e2.indentBy.length > 0 && (i2 = `
`), it(t2, e2, "", i2);
    }
    function it(t2, e2, i2, n2) {
      let s2 = "", r2 = false;
      for (let o2 = 0;o2 < t2.length; o2++) {
        const a2 = t2[o2], l2 = nt(a2);
        if (l2 === undefined)
          continue;
        let u2 = "";
        if (u2 = i2.length === 0 ? l2 : `${i2}.${l2}`, l2 === e2.textNodeName) {
          let t3 = a2[l2];
          rt(u2, e2) || (t3 = e2.tagValueProcessor(l2, t3), t3 = ot(t3, e2)), r2 && (s2 += n2), s2 += t3, r2 = false;
          continue;
        }
        if (l2 === e2.cdataPropName) {
          r2 && (s2 += n2), s2 += `<![CDATA[${a2[l2][0][e2.textNodeName]}]]>`, r2 = false;
          continue;
        }
        if (l2 === e2.commentPropName) {
          s2 += n2 + `<!--${a2[l2][0][e2.textNodeName]}-->`, r2 = true;
          continue;
        }
        if (l2[0] === "?") {
          const t3 = st(a2[":@"], e2), i3 = l2 === "?xml" ? "" : n2;
          let o3 = a2[l2][0][e2.textNodeName];
          o3 = o3.length !== 0 ? " " + o3 : "", s2 += i3 + `<${l2}${o3}${t3}?>`, r2 = true;
          continue;
        }
        let h2 = n2;
        h2 !== "" && (h2 += e2.indentBy);
        const d2 = n2 + `<${l2}${st(a2[":@"], e2)}`, p2 = it(a2[l2], e2, u2, h2);
        e2.unpairedTags.indexOf(l2) !== -1 ? e2.suppressUnpairedNode ? s2 += d2 + ">" : s2 += d2 + "/>" : p2 && p2.length !== 0 || !e2.suppressEmptyNode ? p2 && p2.endsWith(">") ? s2 += d2 + `>${p2}${n2}</${l2}>` : (s2 += d2 + ">", p2 && n2 !== "" && (p2.includes("/>") || p2.includes("</")) ? s2 += n2 + e2.indentBy + p2 + n2 : s2 += p2, s2 += `</${l2}>`) : s2 += d2 + "/>", r2 = true;
      }
      return s2;
    }
    function nt(t2) {
      const e2 = Object.keys(t2);
      for (let i2 = 0;i2 < e2.length; i2++) {
        const n2 = e2[i2];
        if (t2.hasOwnProperty(n2) && n2 !== ":@")
          return n2;
      }
    }
    function st(t2, e2) {
      let i2 = "";
      if (t2 && !e2.ignoreAttributes)
        for (let n2 in t2) {
          if (!t2.hasOwnProperty(n2))
            continue;
          let s2 = e2.attributeValueProcessor(n2, t2[n2]);
          s2 = ot(s2, e2), s2 === true && e2.suppressBooleanAttributes ? i2 += ` ${n2.substr(e2.attributeNamePrefix.length)}` : i2 += ` ${n2.substr(e2.attributeNamePrefix.length)}="${s2}"`;
        }
      return i2;
    }
    function rt(t2, e2) {
      let i2 = (t2 = t2.substr(0, t2.length - e2.textNodeName.length - 1)).substr(t2.lastIndexOf(".") + 1);
      for (let n2 in e2.stopNodes)
        if (e2.stopNodes[n2] === t2 || e2.stopNodes[n2] === "*." + i2)
          return true;
      return false;
    }
    function ot(t2, e2) {
      if (t2 && t2.length > 0 && e2.processEntities)
        for (let i2 = 0;i2 < e2.entities.length; i2++) {
          const n2 = e2.entities[i2];
          t2 = t2.replace(n2.regex, n2.val);
        }
      return t2;
    }
    const at = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
    function lt(t2) {
      this.options = Object.assign({}, at, t2), this.options.ignoreAttributes === true || this.options.attributesGroupName ? this.isAttribute = function() {
        return false;
      } : (this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = dt), this.processTextOrObjNode = ut, this.options.format ? (this.indentate = ht, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
        return "";
      }, this.tagEndChar = ">", this.newLine = "");
    }
    function ut(t2, e2, i2, n2) {
      const s2 = this.j2x(t2, i2 + 1, n2.concat(e2));
      return t2[this.options.textNodeName] !== undefined && Object.keys(t2).length === 1 ? this.buildTextValNode(t2[this.options.textNodeName], e2, s2.attrStr, i2) : this.buildObjectNode(s2.val, e2, s2.attrStr, i2);
    }
    function ht(t2) {
      return this.options.indentBy.repeat(t2);
    }
    function dt(t2) {
      return !(!t2.startsWith(this.options.attributeNamePrefix) || t2 === this.options.textNodeName) && t2.substr(this.attrPrefixLen);
    }
    lt.prototype.build = function(t2) {
      return this.options.preserveOrder ? et(t2, this.options) : (Array.isArray(t2) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t2 = { [this.options.arrayNodeName]: t2 }), this.j2x(t2, 0, []).val);
    }, lt.prototype.j2x = function(t2, e2, i2) {
      let n2 = "", s2 = "";
      const r2 = i2.join(".");
      for (let o2 in t2)
        if (Object.prototype.hasOwnProperty.call(t2, o2))
          if (t2[o2] === undefined)
            this.isAttribute(o2) && (s2 += "");
          else if (t2[o2] === null)
            this.isAttribute(o2) || o2 === this.options.cdataPropName ? s2 += "" : o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
          else if (t2[o2] instanceof Date)
            s2 += this.buildTextValNode(t2[o2], o2, "", e2);
          else if (typeof t2[o2] != "object") {
            const i3 = this.isAttribute(o2);
            if (i3 && !this.ignoreAttributesFn(i3, r2))
              n2 += this.buildAttrPairStr(i3, "" + t2[o2]);
            else if (!i3)
              if (o2 === this.options.textNodeName) {
                let e3 = this.options.tagValueProcessor(o2, "" + t2[o2]);
                s2 += this.replaceEntitiesValue(e3);
              } else
                s2 += this.buildTextValNode(t2[o2], o2, "", e2);
          } else if (Array.isArray(t2[o2])) {
            const n3 = t2[o2].length;
            let r3 = "", a2 = "";
            for (let l2 = 0;l2 < n3; l2++) {
              const n4 = t2[o2][l2];
              if (n4 === undefined)
                ;
              else if (n4 === null)
                o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
              else if (typeof n4 == "object")
                if (this.options.oneListGroup) {
                  const t3 = this.j2x(n4, e2 + 1, i2.concat(o2));
                  r3 += t3.val, this.options.attributesGroupName && n4.hasOwnProperty(this.options.attributesGroupName) && (a2 += t3.attrStr);
                } else
                  r3 += this.processTextOrObjNode(n4, o2, e2, i2);
              else if (this.options.oneListGroup) {
                let t3 = this.options.tagValueProcessor(o2, n4);
                t3 = this.replaceEntitiesValue(t3), r3 += t3;
              } else
                r3 += this.buildTextValNode(n4, o2, "", e2);
            }
            this.options.oneListGroup && (r3 = this.buildObjectNode(r3, o2, a2, e2)), s2 += r3;
          } else if (this.options.attributesGroupName && o2 === this.options.attributesGroupName) {
            const e3 = Object.keys(t2[o2]), i3 = e3.length;
            for (let s3 = 0;s3 < i3; s3++)
              n2 += this.buildAttrPairStr(e3[s3], "" + t2[o2][e3[s3]]);
          } else
            s2 += this.processTextOrObjNode(t2[o2], o2, e2, i2);
      return { attrStr: n2, val: s2 };
    }, lt.prototype.buildAttrPairStr = function(t2, e2) {
      return e2 = this.options.attributeValueProcessor(t2, "" + e2), e2 = this.replaceEntitiesValue(e2), this.options.suppressBooleanAttributes && e2 === "true" ? " " + t2 : " " + t2 + '="' + e2 + '"';
    }, lt.prototype.buildObjectNode = function(t2, e2, i2, n2) {
      if (t2 === "")
        return e2[0] === "?" ? this.indentate(n2) + "<" + e2 + i2 + "?" + this.tagEndChar : this.indentate(n2) + "<" + e2 + i2 + this.closeTag(e2) + this.tagEndChar;
      {
        let s2 = "</" + e2 + this.tagEndChar, r2 = "";
        return e2[0] === "?" && (r2 = "?", s2 = ""), !i2 && i2 !== "" || t2.indexOf("<") !== -1 ? this.options.commentPropName !== false && e2 === this.options.commentPropName && r2.length === 0 ? this.indentate(n2) + `<!--${t2}-->` + this.newLine : this.indentate(n2) + "<" + e2 + i2 + r2 + this.tagEndChar + t2 + this.indentate(n2) + s2 : this.indentate(n2) + "<" + e2 + i2 + r2 + ">" + t2 + s2;
      }
    }, lt.prototype.closeTag = function(t2) {
      let e2 = "";
      return this.options.unpairedTags.indexOf(t2) !== -1 ? this.options.suppressUnpairedNode || (e2 = "/") : e2 = this.options.suppressEmptyNode ? "/" : `></${t2}`, e2;
    }, lt.prototype.buildTextValNode = function(t2, e2, i2, n2) {
      if (this.options.cdataPropName !== false && e2 === this.options.cdataPropName)
        return this.indentate(n2) + `<![CDATA[${t2}]]>` + this.newLine;
      if (this.options.commentPropName !== false && e2 === this.options.commentPropName)
        return this.indentate(n2) + `<!--${t2}-->` + this.newLine;
      if (e2[0] === "?")
        return this.indentate(n2) + "<" + e2 + i2 + "?" + this.tagEndChar;
      {
        let s2 = this.options.tagValueProcessor(e2, t2);
        return s2 = this.replaceEntitiesValue(s2), s2 === "" ? this.indentate(n2) + "<" + e2 + i2 + this.closeTag(e2) + this.tagEndChar : this.indentate(n2) + "<" + e2 + i2 + ">" + s2 + "</" + e2 + this.tagEndChar;
      }
    }, lt.prototype.replaceEntitiesValue = function(t2) {
      if (t2 && t2.length > 0 && this.options.processEntities)
        for (let e2 = 0;e2 < this.options.entities.length; e2++) {
          const i2 = this.options.entities[e2];
          t2 = t2.replace(i2.regex, i2.val);
        }
      return t2;
    };
    const pt = { validate: a };
    module.exports = e;
  })();
});

// node_modules/@azure/core-xml/dist/commonjs/xml.common.js
var require_xml_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-xml/dist/commonjs/xml.js
var require_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringifyXML = stringifyXML;
  exports.parseXML = parseXML;
  var fast_xml_parser_1 = require_fxp();
  var xml_common_js_1 = require_xml_common();
  function getCommonOptions(options) {
    var _a;
    return {
      attributesGroupName: xml_common_js_1.XML_ATTRKEY,
      textNodeName: (_a = options.xmlCharKey) !== null && _a !== undefined ? _a : xml_common_js_1.XML_CHARKEY,
      ignoreAttributes: false,
      suppressBooleanAttributes: false
    };
  }
  function getSerializerOptions(options = {}) {
    var _a, _b;
    return Object.assign(Object.assign({}, getCommonOptions(options)), { attributeNamePrefix: "@_", format: true, suppressEmptyNode: true, indentBy: "", rootNodeName: (_a = options.rootName) !== null && _a !== undefined ? _a : "root", cdataPropName: (_b = options.cdataPropName) !== null && _b !== undefined ? _b : "__cdata" });
  }
  function getParserOptions(options = {}) {
    return Object.assign(Object.assign({}, getCommonOptions(options)), { parseAttributeValue: false, parseTagValue: false, attributeNamePrefix: "", stopNodes: options.stopNodes, processEntities: true, trimValues: false });
  }
  function stringifyXML(obj, opts = {}) {
    const parserOptions = getSerializerOptions(opts);
    const j2x = new fast_xml_parser_1.XMLBuilder(parserOptions);
    const node = { [parserOptions.rootNodeName]: obj };
    const xmlData = j2x.build(node);
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${xmlData}`.replace(/\n/g, "");
  }
  async function parseXML(str, opts = {}) {
    if (!str) {
      throw new Error("Document is empty");
    }
    const validation = fast_xml_parser_1.XMLValidator.validate(str);
    if (validation !== true) {
      throw validation;
    }
    const parser = new fast_xml_parser_1.XMLParser(getParserOptions(opts));
    const parsedXml = parser.parse(str);
    if (parsedXml["?xml"]) {
      delete parsedXml["?xml"];
    }
    if (!opts.includeRoot) {
      for (const key of Object.keys(parsedXml)) {
        const value = parsedXml[key];
        return typeof value === "object" ? Object.assign({}, value) : value;
      }
    }
    return parsedXml;
  }
});

// node_modules/@azure/core-xml/dist/commonjs/index.js
var require_commonjs12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = undefined;
  var xml_js_1 = require_xml();
  Object.defineProperty(exports, "stringifyXML", { enumerable: true, get: function() {
    return xml_js_1.stringifyXML;
  } });
  Object.defineProperty(exports, "parseXML", { enumerable: true, get: function() {
    return xml_js_1.parseXML;
  } });
  var xml_common_js_1 = require_xml_common();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_CHARKEY;
  } });
});

// node_modules/@azure/storage-blob/dist/commonjs/log.js
var require_log5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs4();
  exports.logger = (0, logger_1.createClientLogger)("storage-blob");
});

// node_modules/@azure/storage-common/dist/commonjs/BuffersStream.js
var require_BuffersStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BuffersStream = undefined;
  var node_stream_1 = __require("node:stream");

  class BuffersStream extends node_stream_1.Readable {
    buffers;
    byteLength;
    byteOffsetInCurrentBuffer;
    bufferIndex;
    pushedBytesLength;
    constructor(buffers, byteLength, options) {
      super(options);
      this.buffers = buffers;
      this.byteLength = byteLength;
      this.byteOffsetInCurrentBuffer = 0;
      this.bufferIndex = 0;
      this.pushedBytesLength = 0;
      let buffersLength = 0;
      for (const buf of this.buffers) {
        buffersLength += buf.byteLength;
      }
      if (buffersLength < this.byteLength) {
        throw new Error("Data size shouldn't be larger than the total length of buffers.");
      }
    }
    _read(size) {
      if (this.pushedBytesLength >= this.byteLength) {
        this.push(null);
      }
      if (!size) {
        size = this.readableHighWaterMark;
      }
      const outBuffers = [];
      let i = 0;
      while (i < size && this.pushedBytesLength < this.byteLength) {
        const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
        const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
        const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
        if (remaining > size - i) {
          const end = this.byteOffsetInCurrentBuffer + size - i;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          this.pushedBytesLength += size - i;
          this.byteOffsetInCurrentBuffer = end;
          i = size;
          break;
        } else {
          const end = this.byteOffsetInCurrentBuffer + remaining;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          if (remaining === remainingCapacityInThisBuffer) {
            this.byteOffsetInCurrentBuffer = 0;
            this.bufferIndex++;
          } else {
            this.byteOffsetInCurrentBuffer = end;
          }
          this.pushedBytesLength += remaining;
          i += remaining;
        }
      }
      if (outBuffers.length > 1) {
        this.push(Buffer.concat(outBuffers));
      } else if (outBuffers.length === 1) {
        this.push(outBuffers[0]);
      }
    }
  }
  exports.BuffersStream = BuffersStream;
});

// node_modules/@azure/storage-common/dist/commonjs/PooledBuffer.js
var require_PooledBuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PooledBuffer = undefined;
  var tslib_1 = require_tslib();
  var BuffersStream_js_1 = require_BuffersStream();
  var node_buffer_1 = tslib_1.__importDefault(__require("node:buffer"));
  var maxBufferLength = node_buffer_1.default.constants.MAX_LENGTH;

  class PooledBuffer {
    buffers = [];
    capacity;
    _size;
    get size() {
      return this._size;
    }
    constructor(capacity, buffers, totalLength) {
      this.capacity = capacity;
      this._size = 0;
      const bufferNum = Math.ceil(capacity / maxBufferLength);
      for (let i = 0;i < bufferNum; i++) {
        let len = i === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
        if (len === 0) {
          len = maxBufferLength;
        }
        this.buffers.push(Buffer.allocUnsafe(len));
      }
      if (buffers) {
        this.fill(buffers, totalLength);
      }
    }
    fill(buffers, totalLength) {
      this._size = Math.min(this.capacity, totalLength);
      let i = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
      while (totalCopiedNum < this._size) {
        const source = buffers[i];
        const target = this.buffers[j];
        const copiedNum = source.copy(target, targetOffset, sourceOffset);
        totalCopiedNum += copiedNum;
        sourceOffset += copiedNum;
        targetOffset += copiedNum;
        if (sourceOffset === source.length) {
          i++;
          sourceOffset = 0;
        }
        if (targetOffset === target.length) {
          j++;
          targetOffset = 0;
        }
      }
      buffers.splice(0, i);
      if (buffers.length > 0) {
        buffers[0] = buffers[0].slice(sourceOffset);
      }
    }
    getReadableStream() {
      return new BuffersStream_js_1.BuffersStream(this.buffers, this.size);
    }
  }
  exports.PooledBuffer = PooledBuffer;
});

// node_modules/@azure/storage-common/dist/commonjs/BufferScheduler.js
var require_BufferScheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferScheduler = undefined;
  var events_1 = __require("events");
  var PooledBuffer_js_1 = require_PooledBuffer();

  class BufferScheduler {
    bufferSize;
    maxBuffers;
    readable;
    outgoingHandler;
    emitter = new events_1.EventEmitter;
    concurrency;
    offset = 0;
    isStreamEnd = false;
    isError = false;
    executingOutgoingHandlers = 0;
    encoding;
    numBuffers = 0;
    unresolvedDataArray = [];
    unresolvedLength = 0;
    incoming = [];
    outgoing = [];
    constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
      if (bufferSize <= 0) {
        throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
      }
      if (maxBuffers <= 0) {
        throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
      }
      if (concurrency <= 0) {
        throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
      }
      this.bufferSize = bufferSize;
      this.maxBuffers = maxBuffers;
      this.readable = readable;
      this.outgoingHandler = outgoingHandler;
      this.concurrency = concurrency;
      this.encoding = encoding;
    }
    async do() {
      return new Promise((resolve, reject) => {
        this.readable.on("data", (data) => {
          data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
          this.appendUnresolvedData(data);
          if (!this.resolveData()) {
            this.readable.pause();
          }
        });
        this.readable.on("error", (err) => {
          this.emitter.emit("error", err);
        });
        this.readable.on("end", () => {
          this.isStreamEnd = true;
          this.emitter.emit("checkEnd");
        });
        this.emitter.on("error", (err) => {
          this.isError = true;
          this.readable.pause();
          reject(err);
        });
        this.emitter.on("checkEnd", () => {
          if (this.outgoing.length > 0) {
            this.triggerOutgoingHandlers();
            return;
          }
          if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {
            if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
              const buffer = this.shiftBufferFromUnresolvedDataArray();
              this.outgoingHandler(() => buffer.getReadableStream(), buffer.size, this.offset).then(resolve).catch(reject);
            } else if (this.unresolvedLength >= this.bufferSize) {
              return;
            } else {
              resolve();
            }
          }
        });
      });
    }
    appendUnresolvedData(data) {
      this.unresolvedDataArray.push(data);
      this.unresolvedLength += data.length;
    }
    shiftBufferFromUnresolvedDataArray(buffer) {
      if (!buffer) {
        buffer = new PooledBuffer_js_1.PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
      } else {
        buffer.fill(this.unresolvedDataArray, this.unresolvedLength);
      }
      this.unresolvedLength -= buffer.size;
      return buffer;
    }
    resolveData() {
      while (this.unresolvedLength >= this.bufferSize) {
        let buffer;
        if (this.incoming.length > 0) {
          buffer = this.incoming.shift();
          this.shiftBufferFromUnresolvedDataArray(buffer);
        } else {
          if (this.numBuffers < this.maxBuffers) {
            buffer = this.shiftBufferFromUnresolvedDataArray();
            this.numBuffers++;
          } else {
            return false;
          }
        }
        this.outgoing.push(buffer);
        this.triggerOutgoingHandlers();
      }
      return true;
    }
    async triggerOutgoingHandlers() {
      let buffer;
      do {
        if (this.executingOutgoingHandlers >= this.concurrency) {
          return;
        }
        buffer = this.outgoing.shift();
        if (buffer) {
          this.triggerOutgoingHandler(buffer);
        }
      } while (buffer);
    }
    async triggerOutgoingHandler(buffer) {
      const bufferLength = buffer.size;
      this.executingOutgoingHandlers++;
      this.offset += bufferLength;
      try {
        await this.outgoingHandler(() => buffer.getReadableStream(), bufferLength, this.offset - bufferLength);
      } catch (err) {
        this.emitter.emit("error", err);
        return;
      }
      this.executingOutgoingHandlers--;
      this.reuseBuffer(buffer);
      this.emitter.emit("checkEnd");
    }
    reuseBuffer(buffer) {
      this.incoming.push(buffer);
      if (!this.isError && this.resolveData() && !this.isStreamEnd) {
        this.readable.resume();
      }
    }
  }
  exports.BufferScheduler = BufferScheduler;
});

// node_modules/@azure/storage-common/dist/commonjs/cache.js
var require_cache2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
  var core_rest_pipeline_1 = require_commonjs8();
  var _defaultHttpClient;
  function getCachedDefaultHttpClient() {
    if (!_defaultHttpClient) {
      _defaultHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    }
    return _defaultHttpClient;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/RequestPolicy.js
var require_RequestPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseRequestPolicy = undefined;

  class BaseRequestPolicy {
    _nextPolicy;
    _options;
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy;
      this._options = _options;
    }
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    log(logLevel, message) {
      this._options.log(logLevel, message);
    }
  }
  exports.BaseRequestPolicy = BaseRequestPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/utils/constants.js
var require_constants8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PathStylePorts = exports.DevelopmentConnectionString = exports.HeaderConstants = exports.URLConstants = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "1.0.0";
  exports.URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  exports.HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
  };
  exports.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
  exports.PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
});

// node_modules/@azure/storage-common/dist/commonjs/utils/utils.common.js
var require_utils_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeURLPath = escapeURLPath;
  exports.getValueInConnString = getValueInConnString;
  exports.extractConnectionStringParts = extractConnectionStringParts;
  exports.appendToURLPath = appendToURLPath;
  exports.setURLParameter = setURLParameter;
  exports.getURLParameter = getURLParameter;
  exports.setURLHost = setURLHost;
  exports.getURLPath = getURLPath;
  exports.getURLScheme = getURLScheme;
  exports.getURLPathAndQuery = getURLPathAndQuery;
  exports.getURLQueries = getURLQueries;
  exports.appendToURLQuery = appendToURLQuery;
  exports.truncatedISO8061Date = truncatedISO8061Date;
  exports.base64encode = base64encode;
  exports.base64decode = base64decode;
  exports.generateBlockID = generateBlockID;
  exports.delay = delay;
  exports.padStart = padStart;
  exports.sanitizeURL = sanitizeURL;
  exports.sanitizeHeaders = sanitizeHeaders;
  exports.iEqual = iEqual;
  exports.getAccountNameFromUrl = getAccountNameFromUrl;
  exports.isIpEndpointStyle = isIpEndpointStyle;
  exports.attachCredential = attachCredential;
  exports.httpAuthorizationToString = httpAuthorizationToString;
  exports.EscapePath = EscapePath;
  exports.assertResponse = assertResponse;
  var core_rest_pipeline_1 = require_commonjs8();
  var core_util_1 = require_commonjs6();
  var constants_js_1 = require_constants8();
  function escapeURLPath(url) {
    const urlParsed = new URL(url);
    let path = urlParsed.pathname;
    path = path || "/";
    path = escape(path);
    urlParsed.pathname = path;
    return urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      const matchCredentials = connectionString.split(";");
      for (const element of matchCredentials) {
        if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
        }
      }
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
      if (element.trim().startsWith(argument)) {
        return element.trim().match(argument + "=(.*)")[1];
      }
    }
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
      proxyUri = getProxyUriFromDevConnString(connectionString);
      connectionString = constants_js_1.DevelopmentConnectionString;
    }
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "";
      let accountName = "";
      let accountKey = Buffer.from("accountKey", "base64");
      let endpointSuffix = "";
      accountName = getValueInConnString(connectionString, "AccountName");
      accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
      if (!blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
          throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
        if (!endpointSuffix) {
          throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
      } else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
      }
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
      let accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName) {
        accountName = getAccountNameFromUrl(blobEndpoint);
      }
      if (!blobEndpoint) {
        throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
      } else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      }
      if (accountSas.startsWith("?")) {
        accountSas = accountSas.substring(1);
      }
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url, name) {
    const urlParsed = new URL(url);
    let path = urlParsed.pathname;
    path = path ? path.endsWith("/") ? `${path}${name}` : `${path}/${name}` : name;
    urlParsed.pathname = path;
    return urlParsed.toString();
  }
  function setURLParameter(url, name, value) {
    const urlParsed = new URL(url);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : undefined;
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")) {
      if (pair) {
        const [key] = pair.split("=", 2);
        if (key !== encodedName) {
          searchPieces.push(pair);
        }
      }
    }
    if (encodedValue) {
      searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
  }
  function getURLParameter(url, name) {
    const urlParsed = new URL(url);
    return urlParsed.searchParams.get(name) ?? undefined;
  }
  function setURLHost(url, host) {
    const urlParsed = new URL(url);
    urlParsed.hostname = host;
    return urlParsed.toString();
  }
  function getURLPath(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.pathname;
    } catch (e) {
      return;
    }
  }
  function getURLScheme(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return;
    }
  }
  function getURLPathAndQuery(url) {
    const urlParsed = new URL(url);
    const pathString = urlParsed.pathname;
    if (!pathString) {
      throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    }
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url) {
    let queryString = new URL(url).search;
    if (!queryString) {
      return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      const indexOfEqual = value.indexOf("=");
      const lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
      const splitResults = querySubString.split("=");
      const key = splitResults[0];
      const value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url, queryParts) {
    const urlParsed = new URL(url);
    let query = urlParsed.search;
    if (query) {
      query += "&" + queryParts;
    } else {
      query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = true) {
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000" + "Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode(content) {
    return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function base64decode(encodedString) {
    return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    const maxSourceStringLength = 48;
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
      blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode(res);
  }
  async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
      let timeout;
      const abortHandler = () => {
        if (timeout !== undefined) {
          clearTimeout(timeout);
        }
        reject(abortError);
      };
      const resolveHandler = () => {
        if (aborter !== undefined) {
          aborter.removeEventListener("abort", abortHandler);
        }
        resolve();
      };
      timeout = setTimeout(resolveHandler, timeInMs);
      if (aborter !== undefined) {
        aborter.addEventListener("abort", abortHandler);
      }
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart) {
      return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
      return currentString;
    } else {
      targetLength = targetLength - currentString.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function sanitizeURL(url) {
    let safeURL = url;
    if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) {
      safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
    }
    return safeURL;
  }
  function sanitizeHeaders(originalHeader) {
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)();
    for (const [name, value] of originalHeader) {
      if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) {
        headers.set(name, "*****");
      } else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) {
        headers.set(name, sanitizeURL(value));
      } else {
        headers.set(name, value);
      }
    }
    return headers;
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url) {
    const parsedUrl = new URL(url);
    let accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob") {
        accountName = parsedUrl.hostname.split(".")[0];
      } else if (isIpEndpointStyle(parsedUrl)) {
        accountName = parsedUrl.pathname.split("/")[1];
      } else {
        accountName = "";
      }
      return accountName;
    } catch (error) {
      throw new Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
  }
  function attachCredential(thing, credential) {
    thing.credential = credential;
    return thing;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : undefined;
  }
  function EscapePath(blobName) {
    const split = blobName.split("/");
    for (let i = 0;i < split.length; i++) {
      split[i] = encodeURIComponent(split[i]);
    }
    return split.join("/");
  }
  function assertResponse(response) {
    if (`_response` in response) {
      return response;
    }
    throw new TypeError(`Unexpected response object ${response}`);
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicy.js
var require_StorageBrowserPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageBrowserPolicy = undefined;
  var RequestPolicy_js_1 = require_RequestPolicy();
  var core_util_1 = require_commonjs6();
  var constants_js_1 = require_constants8();
  var utils_common_js_1 = require_utils_common();

  class StorageBrowserPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
    async sendRequest(request) {
      if (core_util_1.isNodeLike) {
        return this._nextPolicy.sendRequest(request);
      }
      if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD") {
        request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
      }
      request.headers.remove(constants_js_1.HeaderConstants.COOKIE);
      request.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH);
      return this._nextPolicy.sendRequest(request);
    }
  }
  exports.StorageBrowserPolicy = StorageBrowserPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/StorageBrowserPolicyFactory.js
var require_StorageBrowserPolicyFactory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = undefined;
  var StorageBrowserPolicy_js_1 = require_StorageBrowserPolicy();
  Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: true, get: function() {
    return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
  } });

  class StorageBrowserPolicyFactory {
    create(nextPolicy, options) {
      return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options);
    }
  }
  exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
});

// node_modules/@azure/storage-common/dist/commonjs/policies/CredentialPolicy.js
var require_CredentialPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CredentialPolicy = undefined;
  var RequestPolicy_js_1 = require_RequestPolicy();

  class CredentialPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    sendRequest(request) {
      return this._nextPolicy.sendRequest(this.signRequest(request));
    }
    signRequest(request) {
      return request;
    }
  }
  exports.CredentialPolicy = CredentialPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/policies/AnonymousCredentialPolicy.js
var require_AnonymousCredentialPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousCredentialPolicy = undefined;
  var CredentialPolicy_js_1 = require_CredentialPolicy();

  class AnonymousCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
  }
  exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/Credential.js
var require_Credential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Credential = undefined;

  class Credential {
    create(_nextPolicy, _options) {
      throw new Error("Method should be implemented in children classes.");
    }
  }
  exports.Credential = Credential;
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/AnonymousCredential.js
var require_AnonymousCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousCredential = undefined;
  var AnonymousCredentialPolicy_js_1 = require_AnonymousCredentialPolicy();
  var Credential_js_1 = require_Credential();

  class AnonymousCredential extends Credential_js_1.Credential {
    create(nextPolicy, options) {
      return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options);
    }
  }
  exports.AnonymousCredential = AnonymousCredential;
});

// node_modules/@azure/storage-common/dist/commonjs/utils/SharedKeyComparator.js
var require_SharedKeyComparator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compareHeader = compareHeader;
  var table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]);
  var table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  var table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    const tables = [table_lv0, table_lv2, table_lv4];
    let curr_level = 0;
    let i = 0;
    let j = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i !== j) {
        return i > j;
      }
      const weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1;
      const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1) {
        i = 0;
        j = 0;
        ++curr_level;
      } else if (weight1 === weight2) {
        ++i;
        ++j;
      } else if (weight1 === 0) {
        ++i;
      } else if (weight2 === 0) {
        ++j;
      } else {
        return weight1 < weight2;
      }
    }
    return false;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicy.js
var require_StorageSharedKeyCredentialPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageSharedKeyCredentialPolicy = undefined;
  var constants_js_1 = require_constants8();
  var utils_common_js_1 = require_utils_common();
  var CredentialPolicy_js_1 = require_CredentialPolicy();
  var SharedKeyComparator_js_1 = require_SharedKeyComparator();

  class StorageSharedKeyCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    factory;
    constructor(nextPolicy, options, factory) {
      super(nextPolicy, options);
      this.factory = factory;
    }
    signRequest(request) {
      request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request.body && (typeof request.body === "string" || request.body !== undefined) && request.body.length > 0) {
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
      const stringToSign = [
        request.method.toUpperCase(),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
      ].join(`
`) + `
` + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request);
      const signature = this.factory.computeHMACSHA256(stringToSign);
      request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
      return request;
    }
    getHeaderValueToSign(request, headerName) {
      const value = request.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    getCanonicalizedHeadersString(request) {
      let headersArray = request.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    getCanonicalizedResourceString(request) {
      const path = (0, utils_common_js_1.getURLPath)(request.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path}`;
      const queries = (0, utils_common_js_1.getURLQueries)(request.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
  }
  exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/StorageSharedKeyCredential.js
var require_StorageSharedKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageSharedKeyCredential = undefined;
  var node_crypto_1 = __require("node:crypto");
  var StorageSharedKeyCredentialPolicy_js_1 = require_StorageSharedKeyCredentialPolicy();
  var Credential_js_1 = require_Credential();

  class StorageSharedKeyCredential extends Credential_js_1.Credential {
    accountName;
    accountKey;
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName;
      this.accountKey = Buffer.from(accountKey, "base64");
    }
    create(nextPolicy, options) {
      return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    }
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  }
  exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
});

// node_modules/@azure/storage-common/dist/commonjs/log.js
var require_log6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs4();
  exports.logger = (0, logger_1.createClientLogger)("storage-common");
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyType.js
var require_StorageRetryPolicyType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageRetryPolicyType = undefined;
  var StorageRetryPolicyType;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(StorageRetryPolicyType || (exports.StorageRetryPolicyType = StorageRetryPolicyType = {}));
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicy.js
var require_StorageRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageRetryPolicy = undefined;
  exports.NewRetryPolicyFactory = NewRetryPolicyFactory;
  var abort_controller_1 = require_commonjs5();
  var RequestPolicy_js_1 = require_RequestPolicy();
  var constants_js_1 = require_constants8();
  var utils_common_js_1 = require_utils_common();
  var log_js_1 = require_log6();
  var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
  function NewRetryPolicyFactory(retryOptions) {
    return {
      create: (nextPolicy, options) => {
        return new StorageRetryPolicy(nextPolicy, options, retryOptions);
      }
    };
  }
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");

  class StorageRetryPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    retryOptions;
    constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
      super(nextPolicy, options);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
      };
    }
    async sendRequest(request) {
      return this.attemptSendRequest(request, false, 1);
    }
    async attemptSendRequest(request, secondaryHas404, attempt) {
      const newRequest = request.clone();
      const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry) {
        newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
      }
      if (this.retryOptions.tryTimeoutInMs) {
        newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
      }
      let response;
      try {
        log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
        response = await this._nextPolicy.sendRequest(newRequest);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
          return response;
        }
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
      } catch (err) {
        log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
          throw err;
        }
      }
      await this.delay(isPrimaryRetry, attempt, request.abortSignal);
      return this.attemptSendRequest(request, secondaryHas404, ++attempt);
    }
    shouldRetry(isPrimaryRetry, attempt, response, err) {
      if (attempt >= this.retryOptions.maxTries) {
        log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
        return false;
      }
      const retriableErrors = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
      ];
      if (err) {
        for (const retriableError of retriableErrors) {
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
            log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
      }
      if (response || err) {
        const statusCode = response ? response.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      if (response) {
        if (response?.status >= 400) {
          const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== undefined) {
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return true;
            }
          }
        }
      }
      if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
        log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
        return true;
      }
      return false;
    }
    async delay(isPrimaryRetry, attempt, abortSignal) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (this.retryOptions.retryPolicyType) {
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR);
    }
  }
  exports.StorageRetryPolicy = StorageRetryPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/StorageRetryPolicyFactory.js
var require_StorageRetryPolicyFactory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = undefined;
  var StorageRetryPolicy_js_1 = require_StorageRetryPolicy();
  Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: true, get: function() {
    return StorageRetryPolicy_js_1.StorageRetryPolicy;
  } });
  var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
  Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: true, get: function() {
    return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
  } });

  class StorageRetryPolicyFactory {
    retryOptions;
    constructor(retryOptions) {
      this.retryOptions = retryOptions;
    }
    create(nextPolicy, options) {
      return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    }
  }
  exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicyV2.js
var require_StorageBrowserPolicyV2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.storageBrowserPolicyName = undefined;
  exports.storageBrowserPolicy = storageBrowserPolicy;
  var core_util_1 = require_commonjs6();
  var constants_js_1 = require_constants8();
  var utils_common_js_1 = require_utils_common();
  exports.storageBrowserPolicyName = "storageBrowserPolicy";
  function storageBrowserPolicy() {
    return {
      name: exports.storageBrowserPolicyName,
      async sendRequest(request, next) {
        if (core_util_1.isNodeLike) {
          return next(request);
        }
        if (request.method === "GET" || request.method === "HEAD") {
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
        }
        request.headers.delete(constants_js_1.HeaderConstants.COOKIE);
        request.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH);
        return next(request);
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageCorrectContentLengthPolicy.js
var require_StorageCorrectContentLengthPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.storageCorrectContentLengthPolicyName = undefined;
  exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
  var constants_js_1 = require_constants8();
  exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
  function storageCorrectContentLengthPolicy() {
    function correctContentLength(request) {
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
    }
    return {
      name: exports.storageCorrectContentLengthPolicyName,
      async sendRequest(request, next) {
        correctContentLength(request);
        return next(request);
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyV2.js
var require_StorageRetryPolicyV2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.storageRetryPolicyName = undefined;
  exports.storageRetryPolicy = storageRetryPolicy;
  var abort_controller_1 = require_commonjs5();
  var core_rest_pipeline_1 = require_commonjs8();
  var core_util_1 = require_commonjs6();
  var StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory();
  var constants_js_1 = require_constants8();
  var utils_common_js_1 = require_utils_common();
  var log_js_1 = require_log6();
  exports.storageRetryPolicyName = "storageRetryPolicy";
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var retriableErrors = [
    "ETIMEDOUT",
    "ESOCKETTIMEDOUT",
    "ECONNREFUSED",
    "ECONNRESET",
    "ENOENT",
    "ENOTFOUND",
    "TIMEOUT",
    "EPIPE",
    "REQUEST_SEND_ERROR"
  ];
  var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
  function storageRetryPolicy(options = {}) {
    const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
    const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
    const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
    const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
    const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
    const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
    function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
      if (attempt >= maxTries) {
        log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
        return false;
      }
      if (error) {
        for (const retriableError of retriableErrors) {
          if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {
            log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
        if (error?.code === "PARSE_ERROR" && error?.message.startsWith(`Error "Error: Unclosed root tag`)) {
          log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
          return true;
        }
      }
      if (response || error) {
        const statusCode = response?.status ?? error?.statusCode ?? 0;
        if (!isPrimaryRetry && statusCode === 404) {
          log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      if (response) {
        if (response?.status >= 400) {
          const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== undefined) {
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return true;
            }
          }
        }
      }
      return false;
    }
    function calculateDelay(isPrimaryRetry, attempt) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (retryPolicyType) {
          case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
            break;
          case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return delayTimeInMs;
    }
    return {
      name: exports.storageRetryPolicyName,
      async sendRequest(request, next) {
        if (tryTimeoutInMs) {
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));
        }
        const primaryUrl = request.url;
        const secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request.url, secondaryHost) : undefined;
        let secondaryHas404 = false;
        let attempt = 1;
        let retryAgain = true;
        let response;
        let error;
        while (retryAgain) {
          const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request.method) || attempt % 2 === 1;
          request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
          response = undefined;
          error = undefined;
          try {
            log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
            response = await next(request);
            secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
          } catch (e) {
            if ((0, core_rest_pipeline_1.isRestError)(e)) {
              log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
              error = e;
            } else {
              log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e)}`);
              throw e;
            }
          }
          retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error });
          if (retryAgain) {
            await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
          }
          attempt++;
        }
        if (response) {
          return response;
        }
        throw error ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicyV2.js
var require_StorageSharedKeyCredentialPolicyV2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.storageSharedKeyCredentialPolicyName = undefined;
  exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
  var node_crypto_1 = __require("node:crypto");
  var constants_js_1 = require_constants8();
  var utils_common_js_1 = require_utils_common();
  var SharedKeyComparator_js_1 = require_SharedKeyComparator();
  exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
  function storageSharedKeyCredentialPolicy(options) {
    function signRequest(request) {
      request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
      const stringToSign = [
        request.method.toUpperCase(),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
      ].join(`
`) + `
` + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request);
      const signature = (0, node_crypto_1.createHmac)("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
      request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
    }
    function getHeaderValueToSign(request, headerName) {
      const value = request.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    function getCanonicalizedHeadersString(request) {
      let headersArray = [];
      for (const [name, value] of request.headers) {
        if (name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE)) {
          headersArray.push({ name, value });
        }
      }
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    function getCanonicalizedResourceString(request) {
      const path = (0, utils_common_js_1.getURLPath)(request.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${options.accountName}${path}`;
      const queries = (0, utils_common_js_1.getURLQueries)(request.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
    return {
      name: exports.storageSharedKeyCredentialPolicyName,
      async sendRequest(request, next) {
        signRequest(request);
        return next(request);
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRequestFailureDetailsParserPolicy.js
var require_StorageRequestFailureDetailsParserPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.storageRequestFailureDetailsParserPolicyName = undefined;
  exports.storageRequestFailureDetailsParserPolicy = storageRequestFailureDetailsParserPolicy;
  exports.storageRequestFailureDetailsParserPolicyName = "storageRequestFailureDetailsParserPolicy";
  function storageRequestFailureDetailsParserPolicy() {
    return {
      name: exports.storageRequestFailureDetailsParserPolicyName,
      async sendRequest(request, next) {
        try {
          const response = await next(request);
          return response;
        } catch (err) {
          if (typeof err === "object" && err !== null && err.response && err.response.parsedBody) {
            if (err.response.parsedBody.code === "InvalidHeaderValue" && err.response.parsedBody.HeaderName === "x-ms-version") {
              err.message = `The provided service version is not enabled on this storage account. Please see https://learn.microsoft.com/rest/api/storageservices/versioning-for-the-azure-storage-services for additional information.
`;
            }
          }
          throw err;
        }
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/UserDelegationKeyCredential.js
var require_UserDelegationKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UserDelegationKeyCredential = undefined;
  var node_crypto_1 = __require("node:crypto");

  class UserDelegationKeyCredential {
    accountName;
    userDelegationKey;
    key;
    constructor(accountName, userDelegationKey) {
      this.accountName = accountName;
      this.userDelegationKey = userDelegationKey;
      this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.key).update(stringToSign, "utf8").digest("base64");
    }
  }
  exports.UserDelegationKeyCredential = UserDelegationKeyCredential;
});

// node_modules/@azure/storage-common/dist/commonjs/index.js
var require_commonjs13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseRequestPolicy = exports.getCachedDefaultHttpClient = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_BufferScheduler(), exports);
  var cache_js_1 = require_cache2();
  Object.defineProperty(exports, "getCachedDefaultHttpClient", { enumerable: true, get: function() {
    return cache_js_1.getCachedDefaultHttpClient;
  } });
  tslib_1.__exportStar(require_StorageBrowserPolicyFactory(), exports);
  tslib_1.__exportStar(require_AnonymousCredential(), exports);
  tslib_1.__exportStar(require_Credential(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredential(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
  var RequestPolicy_js_1 = require_RequestPolicy();
  Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: true, get: function() {
    return RequestPolicy_js_1.BaseRequestPolicy;
  } });
  tslib_1.__exportStar(require_AnonymousCredentialPolicy(), exports);
  tslib_1.__exportStar(require_CredentialPolicy(), exports);
  tslib_1.__exportStar(require_StorageBrowserPolicy(), exports);
  tslib_1.__exportStar(require_StorageBrowserPolicyV2(), exports);
  tslib_1.__exportStar(require_StorageCorrectContentLengthPolicy(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyType(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicy(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyV2(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicy(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicyV2(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
  tslib_1.__exportStar(require_StorageRequestFailureDetailsParserPolicy(), exports);
  tslib_1.__exportStar(require_UserDelegationKeyCredential(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/constants.js
var require_constants9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PathStylePorts = exports.BlobDoesNotUseCustomerSpecifiedEncryption = exports.BlobUsesCustomerSpecifiedEncryptionMsg = exports.StorageBlobLoggingAllowedQueryParameters = exports.StorageBlobLoggingAllowedHeaderNames = exports.DevelopmentConnectionString = exports.EncryptionAlgorithmAES25 = exports.HTTP_VERSION_1_1 = exports.HTTP_LINE_ENDING = exports.BATCH_MAX_PAYLOAD_IN_BYTES = exports.BATCH_MAX_REQUEST = exports.SIZE_1_MB = exports.ETagAny = exports.ETagNone = exports.HeaderConstants = exports.HTTPURLConnection = exports.URLConstants = exports.StorageOAuthScopes = exports.REQUEST_TIMEOUT = exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = exports.BLOCK_BLOB_MAX_BLOCKS = exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = exports.SERVICE_VERSION = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "12.30.0";
  exports.SERVICE_VERSION = "2026-02-06";
  exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024;
  exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4000 * 1024 * 1024;
  exports.BLOCK_BLOB_MAX_BLOCKS = 50000;
  exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024;
  exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024;
  exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
  exports.REQUEST_TIMEOUT = 100 * 1000;
  exports.StorageOAuthScopes = "https://storage.azure.com/.default";
  exports.URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  exports.HTTPURLConnection = {
    HTTP_ACCEPTED: 202,
    HTTP_CONFLICT: 409,
    HTTP_NOT_FOUND: 404,
    HTTP_PRECON_FAILED: 412,
    HTTP_RANGE_NOT_SATISFIABLE: 416
  };
  exports.HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
  };
  exports.ETagNone = "";
  exports.ETagAny = "*";
  exports.SIZE_1_MB = 1 * 1024 * 1024;
  exports.BATCH_MAX_REQUEST = 256;
  exports.BATCH_MAX_PAYLOAD_IN_BYTES = 4 * exports.SIZE_1_MB;
  exports.HTTP_LINE_ENDING = `\r
`;
  exports.HTTP_VERSION_1_1 = "HTTP/1.1";
  exports.EncryptionAlgorithmAES25 = "AES256";
  exports.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
  exports.StorageBlobLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
    "x-ms-copy-source-error-code",
    "x-ms-copy-source-status-code",
    "x-ms-if-tags",
    "x-ms-source-if-tags"
  ];
  exports.StorageBlobLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot"
  ];
  exports.BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
  exports.BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
  exports.PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
});

// node_modules/@azure/storage-blob/dist/commonjs/Pipeline.js
var require_Pipeline = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pipeline = exports.StorageOAuthScopes = undefined;
  exports.isPipelineLike = isPipelineLike;
  exports.newPipeline = newPipeline;
  exports.getCoreClientOptions = getCoreClientOptions;
  exports.getCredentialFromPipeline = getCredentialFromPipeline;
  var core_http_compat_1 = require_commonjs11();
  var core_rest_pipeline_1 = require_commonjs8();
  var core_client_1 = require_commonjs10();
  var core_xml_1 = require_commonjs12();
  var core_auth_1 = require_commonjs9();
  var log_js_1 = require_log5();
  var storage_common_1 = require_commonjs13();
  var constants_js_1 = require_constants9();
  Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: true, get: function() {
    return constants_js_1.StorageOAuthScopes;
  } });
  function isPipelineLike(pipeline) {
    if (!pipeline || typeof pipeline !== "object") {
      return false;
    }
    const castPipeline = pipeline;
    return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
  }

  class Pipeline {
    factories;
    options;
    constructor(factories, options = {}) {
      this.factories = factories;
      this.options = options;
    }
    toServiceClientOptions() {
      return {
        httpClient: this.options.httpClient,
        requestPolicyFactories: this.factories
      };
    }
  }
  exports.Pipeline = Pipeline;
  function newPipeline(credential, pipelineOptions = {}) {
    if (!credential) {
      credential = new storage_common_1.AnonymousCredential;
    }
    const pipeline = new Pipeline([], pipelineOptions);
    pipeline._credential = credential;
    return pipeline;
  }
  function processDownlevelPipeline(pipeline) {
    const knownFactoryFunctions = [
      isAnonymousCredential,
      isStorageSharedKeyCredential,
      isCoreHttpBearerTokenFactory,
      isStorageBrowserPolicyFactory,
      isStorageRetryPolicyFactory,
      isStorageTelemetryPolicyFactory,
      isCoreHttpPolicyFactory
    ];
    if (pipeline.factories.length) {
      const novelFactories = pipeline.factories.filter((factory) => {
        return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
      });
      if (novelFactories.length) {
        const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
        return {
          wrappedPolicies: (0, core_http_compat_1.createRequestPolicyFactoryPolicy)(novelFactories),
          afterRetry: hasInjector
        };
      }
    }
    return;
  }
  function getCoreClientOptions(pipeline) {
    const { httpClient: v1Client, ...restOptions } = pipeline.options;
    let httpClient = pipeline._coreHttpClient;
    if (!httpClient) {
      httpClient = v1Client ? (0, core_http_compat_1.convertHttpClient)(v1Client) : (0, storage_common_1.getCachedDefaultHttpClient)();
      pipeline._coreHttpClient = httpClient;
    }
    let corePipeline = pipeline._corePipeline;
    if (!corePipeline) {
      const packageDetails = `azsdk-js-azure-storage-blob/${constants_js_1.SDK_VERSION}`;
      const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      corePipeline = (0, core_client_1.createClientPipeline)({
        ...restOptions,
        loggingOptions: {
          additionalAllowedHeaderNames: constants_js_1.StorageBlobLoggingAllowedHeaderNames,
          additionalAllowedQueryParameters: constants_js_1.StorageBlobLoggingAllowedQueryParameters,
          logger: log_js_1.logger.info
        },
        userAgentOptions: {
          userAgentPrefix
        },
        serializationOptions: {
          stringifyXML: core_xml_1.stringifyXML,
          serializerOptions: {
            xml: {
              xmlCharKey: "#"
            }
          }
        },
        deserializationOptions: {
          parseXML: core_xml_1.parseXML,
          serializerOptions: {
            xml: {
              xmlCharKey: "#"
            }
          }
        }
      });
      corePipeline.removePolicy({ phase: "Retry" });
      corePipeline.removePolicy({ name: core_rest_pipeline_1.decompressResponsePolicyName });
      corePipeline.addPolicy((0, storage_common_1.storageCorrectContentLengthPolicy)());
      corePipeline.addPolicy((0, storage_common_1.storageRetryPolicy)(restOptions.retryOptions), { phase: "Retry" });
      corePipeline.addPolicy((0, storage_common_1.storageRequestFailureDetailsParserPolicy)());
      corePipeline.addPolicy((0, storage_common_1.storageBrowserPolicy)());
      const downlevelResults = processDownlevelPipeline(pipeline);
      if (downlevelResults) {
        corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : undefined);
      }
      const credential = getCredentialFromPipeline(pipeline);
      if ((0, core_auth_1.isTokenCredential)(credential)) {
        corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
          credential,
          scopes: restOptions.audience ?? constants_js_1.StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof storage_common_1.StorageSharedKeyCredential) {
        corePipeline.addPolicy((0, storage_common_1.storageSharedKeyCredentialPolicy)({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      pipeline._corePipeline = corePipeline;
    }
    return {
      ...restOptions,
      allowInsecureConnection: true,
      httpClient,
      pipeline: corePipeline
    };
  }
  function getCredentialFromPipeline(pipeline) {
    if (pipeline._credential) {
      return pipeline._credential;
    }
    let credential = new storage_common_1.AnonymousCredential;
    for (const factory of pipeline.factories) {
      if ((0, core_auth_1.isTokenCredential)(factory.credential)) {
        credential = factory.credential;
      } else if (isStorageSharedKeyCredential(factory)) {
        return factory;
      }
    }
    return credential;
  }
  function isStorageSharedKeyCredential(factory) {
    if (factory instanceof storage_common_1.StorageSharedKeyCredential) {
      return true;
    }
    return factory.constructor.name === "StorageSharedKeyCredential";
  }
  function isAnonymousCredential(factory) {
    if (factory instanceof storage_common_1.AnonymousCredential) {
      return true;
    }
    return factory.constructor.name === "AnonymousCredential";
  }
  function isCoreHttpBearerTokenFactory(factory) {
    return (0, core_auth_1.isTokenCredential)(factory.credential);
  }
  function isStorageBrowserPolicyFactory(factory) {
    if (factory instanceof storage_common_1.StorageBrowserPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageBrowserPolicyFactory";
  }
  function isStorageRetryPolicyFactory(factory) {
    if (factory instanceof storage_common_1.StorageRetryPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageRetryPolicyFactory";
  }
  function isStorageTelemetryPolicyFactory(factory) {
    return factory.constructor.name === "TelemetryPolicyFactory";
  }
  function isInjectorPolicyFactory(factory) {
    return factory.constructor.name === "InjectorPolicyFactory";
  }
  function isCoreHttpPolicyFactory(factory) {
    const knownPolicies = [
      "GenerateClientRequestIdPolicy",
      "TracingPolicy",
      "LogPolicy",
      "ProxyPolicy",
      "DisableResponseDecompressionPolicy",
      "KeepAlivePolicy",
      "DeserializationPolicy"
    ];
    const mockHttpClient = {
      sendRequest: async (request) => {
        return {
          request,
          headers: request.headers.clone(),
          status: 500
        };
      }
    };
    const mockRequestPolicyOptions = {
      log(_logLevel, _message) {},
      shouldLog(_logLevel) {
        return false;
      }
    };
    const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);
    const policyName = policyInstance.constructor.name;
    return knownPolicies.some((knownPolicyName) => {
      return policyName.startsWith(knownPolicyName);
    });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/index.js
var require_models = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KnownStorageErrorCode = exports.KnownBlobExpiryOptions = exports.KnownFileShareTokenIntent = exports.KnownEncryptionAlgorithmType = undefined;
  var KnownEncryptionAlgorithmType;
  (function(KnownEncryptionAlgorithmType2) {
    KnownEncryptionAlgorithmType2["AES256"] = "AES256";
  })(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
  var KnownFileShareTokenIntent;
  (function(KnownFileShareTokenIntent2) {
    KnownFileShareTokenIntent2["Backup"] = "backup";
  })(KnownFileShareTokenIntent || (exports.KnownFileShareTokenIntent = KnownFileShareTokenIntent = {}));
  var KnownBlobExpiryOptions;
  (function(KnownBlobExpiryOptions2) {
    KnownBlobExpiryOptions2["NeverExpire"] = "NeverExpire";
    KnownBlobExpiryOptions2["RelativeToCreation"] = "RelativeToCreation";
    KnownBlobExpiryOptions2["RelativeToNow"] = "RelativeToNow";
    KnownBlobExpiryOptions2["Absolute"] = "Absolute";
  })(KnownBlobExpiryOptions || (exports.KnownBlobExpiryOptions = KnownBlobExpiryOptions = {}));
  var KnownStorageErrorCode;
  (function(KnownStorageErrorCode2) {
    KnownStorageErrorCode2["AccountAlreadyExists"] = "AccountAlreadyExists";
    KnownStorageErrorCode2["AccountBeingCreated"] = "AccountBeingCreated";
    KnownStorageErrorCode2["AccountIsDisabled"] = "AccountIsDisabled";
    KnownStorageErrorCode2["AuthenticationFailed"] = "AuthenticationFailed";
    KnownStorageErrorCode2["AuthorizationFailure"] = "AuthorizationFailure";
    KnownStorageErrorCode2["ConditionHeadersNotSupported"] = "ConditionHeadersNotSupported";
    KnownStorageErrorCode2["ConditionNotMet"] = "ConditionNotMet";
    KnownStorageErrorCode2["EmptyMetadataKey"] = "EmptyMetadataKey";
    KnownStorageErrorCode2["InsufficientAccountPermissions"] = "InsufficientAccountPermissions";
    KnownStorageErrorCode2["InternalError"] = "InternalError";
    KnownStorageErrorCode2["InvalidAuthenticationInfo"] = "InvalidAuthenticationInfo";
    KnownStorageErrorCode2["InvalidHeaderValue"] = "InvalidHeaderValue";
    KnownStorageErrorCode2["InvalidHttpVerb"] = "InvalidHttpVerb";
    KnownStorageErrorCode2["InvalidInput"] = "InvalidInput";
    KnownStorageErrorCode2["InvalidMd5"] = "InvalidMd5";
    KnownStorageErrorCode2["InvalidMetadata"] = "InvalidMetadata";
    KnownStorageErrorCode2["InvalidQueryParameterValue"] = "InvalidQueryParameterValue";
    KnownStorageErrorCode2["InvalidRange"] = "InvalidRange";
    KnownStorageErrorCode2["InvalidResourceName"] = "InvalidResourceName";
    KnownStorageErrorCode2["InvalidUri"] = "InvalidUri";
    KnownStorageErrorCode2["InvalidXmlDocument"] = "InvalidXmlDocument";
    KnownStorageErrorCode2["InvalidXmlNodeValue"] = "InvalidXmlNodeValue";
    KnownStorageErrorCode2["Md5Mismatch"] = "Md5Mismatch";
    KnownStorageErrorCode2["MetadataTooLarge"] = "MetadataTooLarge";
    KnownStorageErrorCode2["MissingContentLengthHeader"] = "MissingContentLengthHeader";
    KnownStorageErrorCode2["MissingRequiredQueryParameter"] = "MissingRequiredQueryParameter";
    KnownStorageErrorCode2["MissingRequiredHeader"] = "MissingRequiredHeader";
    KnownStorageErrorCode2["MissingRequiredXmlNode"] = "MissingRequiredXmlNode";
    KnownStorageErrorCode2["MultipleConditionHeadersNotSupported"] = "MultipleConditionHeadersNotSupported";
    KnownStorageErrorCode2["OperationTimedOut"] = "OperationTimedOut";
    KnownStorageErrorCode2["OutOfRangeInput"] = "OutOfRangeInput";
    KnownStorageErrorCode2["OutOfRangeQueryParameterValue"] = "OutOfRangeQueryParameterValue";
    KnownStorageErrorCode2["RequestBodyTooLarge"] = "RequestBodyTooLarge";
    KnownStorageErrorCode2["ResourceTypeMismatch"] = "ResourceTypeMismatch";
    KnownStorageErrorCode2["RequestUrlFailedToParse"] = "RequestUrlFailedToParse";
    KnownStorageErrorCode2["ResourceAlreadyExists"] = "ResourceAlreadyExists";
    KnownStorageErrorCode2["ResourceNotFound"] = "ResourceNotFound";
    KnownStorageErrorCode2["ServerBusy"] = "ServerBusy";
    KnownStorageErrorCode2["UnsupportedHeader"] = "UnsupportedHeader";
    KnownStorageErrorCode2["UnsupportedXmlNode"] = "UnsupportedXmlNode";
    KnownStorageErrorCode2["UnsupportedQueryParameter"] = "UnsupportedQueryParameter";
    KnownStorageErrorCode2["UnsupportedHttpVerb"] = "UnsupportedHttpVerb";
    KnownStorageErrorCode2["AppendPositionConditionNotMet"] = "AppendPositionConditionNotMet";
    KnownStorageErrorCode2["BlobAlreadyExists"] = "BlobAlreadyExists";
    KnownStorageErrorCode2["BlobImmutableDueToPolicy"] = "BlobImmutableDueToPolicy";
    KnownStorageErrorCode2["BlobNotFound"] = "BlobNotFound";
    KnownStorageErrorCode2["BlobOverwritten"] = "BlobOverwritten";
    KnownStorageErrorCode2["BlobTierInadequateForContentLength"] = "BlobTierInadequateForContentLength";
    KnownStorageErrorCode2["BlobUsesCustomerSpecifiedEncryption"] = "BlobUsesCustomerSpecifiedEncryption";
    KnownStorageErrorCode2["BlockCountExceedsLimit"] = "BlockCountExceedsLimit";
    KnownStorageErrorCode2["BlockListTooLong"] = "BlockListTooLong";
    KnownStorageErrorCode2["CannotChangeToLowerTier"] = "CannotChangeToLowerTier";
    KnownStorageErrorCode2["CannotVerifyCopySource"] = "CannotVerifyCopySource";
    KnownStorageErrorCode2["ContainerAlreadyExists"] = "ContainerAlreadyExists";
    KnownStorageErrorCode2["ContainerBeingDeleted"] = "ContainerBeingDeleted";
    KnownStorageErrorCode2["ContainerDisabled"] = "ContainerDisabled";
    KnownStorageErrorCode2["ContainerNotFound"] = "ContainerNotFound";
    KnownStorageErrorCode2["ContentLengthLargerThanTierLimit"] = "ContentLengthLargerThanTierLimit";
    KnownStorageErrorCode2["CopyAcrossAccountsNotSupported"] = "CopyAcrossAccountsNotSupported";
    KnownStorageErrorCode2["CopyIdMismatch"] = "CopyIdMismatch";
    KnownStorageErrorCode2["FeatureVersionMismatch"] = "FeatureVersionMismatch";
    KnownStorageErrorCode2["IncrementalCopyBlobMismatch"] = "IncrementalCopyBlobMismatch";
    KnownStorageErrorCode2["IncrementalCopyOfEarlierVersionSnapshotNotAllowed"] = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed";
    KnownStorageErrorCode2["IncrementalCopySourceMustBeSnapshot"] = "IncrementalCopySourceMustBeSnapshot";
    KnownStorageErrorCode2["InfiniteLeaseDurationRequired"] = "InfiniteLeaseDurationRequired";
    KnownStorageErrorCode2["InvalidBlobOrBlock"] = "InvalidBlobOrBlock";
    KnownStorageErrorCode2["InvalidBlobTier"] = "InvalidBlobTier";
    KnownStorageErrorCode2["InvalidBlobType"] = "InvalidBlobType";
    KnownStorageErrorCode2["InvalidBlockId"] = "InvalidBlockId";
    KnownStorageErrorCode2["InvalidBlockList"] = "InvalidBlockList";
    KnownStorageErrorCode2["InvalidOperation"] = "InvalidOperation";
    KnownStorageErrorCode2["InvalidPageRange"] = "InvalidPageRange";
    KnownStorageErrorCode2["InvalidSourceBlobType"] = "InvalidSourceBlobType";
    KnownStorageErrorCode2["InvalidSourceBlobUrl"] = "InvalidSourceBlobUrl";
    KnownStorageErrorCode2["InvalidVersionForPageBlobOperation"] = "InvalidVersionForPageBlobOperation";
    KnownStorageErrorCode2["LeaseAlreadyPresent"] = "LeaseAlreadyPresent";
    KnownStorageErrorCode2["LeaseAlreadyBroken"] = "LeaseAlreadyBroken";
    KnownStorageErrorCode2["LeaseIdMismatchWithBlobOperation"] = "LeaseIdMismatchWithBlobOperation";
    KnownStorageErrorCode2["LeaseIdMismatchWithContainerOperation"] = "LeaseIdMismatchWithContainerOperation";
    KnownStorageErrorCode2["LeaseIdMismatchWithLeaseOperation"] = "LeaseIdMismatchWithLeaseOperation";
    KnownStorageErrorCode2["LeaseIdMissing"] = "LeaseIdMissing";
    KnownStorageErrorCode2["LeaseIsBreakingAndCannotBeAcquired"] = "LeaseIsBreakingAndCannotBeAcquired";
    KnownStorageErrorCode2["LeaseIsBreakingAndCannotBeChanged"] = "LeaseIsBreakingAndCannotBeChanged";
    KnownStorageErrorCode2["LeaseIsBrokenAndCannotBeRenewed"] = "LeaseIsBrokenAndCannotBeRenewed";
    KnownStorageErrorCode2["LeaseLost"] = "LeaseLost";
    KnownStorageErrorCode2["LeaseNotPresentWithBlobOperation"] = "LeaseNotPresentWithBlobOperation";
    KnownStorageErrorCode2["LeaseNotPresentWithContainerOperation"] = "LeaseNotPresentWithContainerOperation";
    KnownStorageErrorCode2["LeaseNotPresentWithLeaseOperation"] = "LeaseNotPresentWithLeaseOperation";
    KnownStorageErrorCode2["MaxBlobSizeConditionNotMet"] = "MaxBlobSizeConditionNotMet";
    KnownStorageErrorCode2["NoAuthenticationInformation"] = "NoAuthenticationInformation";
    KnownStorageErrorCode2["NoPendingCopyOperation"] = "NoPendingCopyOperation";
    KnownStorageErrorCode2["OperationNotAllowedOnIncrementalCopyBlob"] = "OperationNotAllowedOnIncrementalCopyBlob";
    KnownStorageErrorCode2["PendingCopyOperation"] = "PendingCopyOperation";
    KnownStorageErrorCode2["PreviousSnapshotCannotBeNewer"] = "PreviousSnapshotCannotBeNewer";
    KnownStorageErrorCode2["PreviousSnapshotNotFound"] = "PreviousSnapshotNotFound";
    KnownStorageErrorCode2["PreviousSnapshotOperationNotSupported"] = "PreviousSnapshotOperationNotSupported";
    KnownStorageErrorCode2["SequenceNumberConditionNotMet"] = "SequenceNumberConditionNotMet";
    KnownStorageErrorCode2["SequenceNumberIncrementTooLarge"] = "SequenceNumberIncrementTooLarge";
    KnownStorageErrorCode2["SnapshotCountExceeded"] = "SnapshotCountExceeded";
    KnownStorageErrorCode2["SnapshotOperationRateExceeded"] = "SnapshotOperationRateExceeded";
    KnownStorageErrorCode2["SnapshotsPresent"] = "SnapshotsPresent";
    KnownStorageErrorCode2["SourceConditionNotMet"] = "SourceConditionNotMet";
    KnownStorageErrorCode2["SystemInUse"] = "SystemInUse";
    KnownStorageErrorCode2["TargetConditionNotMet"] = "TargetConditionNotMet";
    KnownStorageErrorCode2["UnauthorizedBlobOverwrite"] = "UnauthorizedBlobOverwrite";
    KnownStorageErrorCode2["BlobBeingRehydrated"] = "BlobBeingRehydrated";
    KnownStorageErrorCode2["BlobArchived"] = "BlobArchived";
    KnownStorageErrorCode2["BlobNotArchived"] = "BlobNotArchived";
    KnownStorageErrorCode2["AuthorizationSourceIPMismatch"] = "AuthorizationSourceIPMismatch";
    KnownStorageErrorCode2["AuthorizationProtocolMismatch"] = "AuthorizationProtocolMismatch";
    KnownStorageErrorCode2["AuthorizationPermissionMismatch"] = "AuthorizationPermissionMismatch";
    KnownStorageErrorCode2["AuthorizationServiceMismatch"] = "AuthorizationServiceMismatch";
    KnownStorageErrorCode2["AuthorizationResourceTypeMismatch"] = "AuthorizationResourceTypeMismatch";
    KnownStorageErrorCode2["BlobAccessTierNotSupportedForAccountType"] = "BlobAccessTierNotSupportedForAccountType";
  })(KnownStorageErrorCode || (exports.KnownStorageErrorCode = KnownStorageErrorCode = {}));
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/mappers.js
var require_mappers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceGetUserDelegationKeyHeaders = exports.ServiceListContainersSegmentExceptionHeaders = exports.ServiceListContainersSegmentHeaders = exports.ServiceGetStatisticsExceptionHeaders = exports.ServiceGetStatisticsHeaders = exports.ServiceGetPropertiesExceptionHeaders = exports.ServiceGetPropertiesHeaders = exports.ServiceSetPropertiesExceptionHeaders = exports.ServiceSetPropertiesHeaders = exports.ArrowField = exports.ArrowConfiguration = exports.JsonTextConfiguration = exports.DelimitedTextConfiguration = exports.QueryFormat = exports.QuerySerialization = exports.QueryRequest = exports.ClearRange = exports.PageRange = exports.PageList = exports.Block = exports.BlockList = exports.BlockLookupList = exports.BlobPrefix = exports.BlobHierarchyListSegment = exports.ListBlobsHierarchySegmentResponse = exports.BlobPropertiesInternal = exports.BlobName = exports.BlobItemInternal = exports.BlobFlatListSegment = exports.ListBlobsFlatSegmentResponse = exports.AccessPolicy = exports.SignedIdentifier = exports.BlobTag = exports.BlobTags = exports.FilterBlobItem = exports.FilterBlobSegment = exports.UserDelegationKey = exports.KeyInfo = exports.ContainerProperties = exports.ContainerItem = exports.ListContainersSegmentResponse = exports.GeoReplication = exports.BlobServiceStatistics = exports.StorageError = exports.StaticWebsite = exports.CorsRule = exports.Metrics = exports.RetentionPolicy = exports.Logging = exports.BlobServiceProperties = undefined;
  exports.BlobUndeleteHeaders = exports.BlobDeleteExceptionHeaders = exports.BlobDeleteHeaders = exports.BlobGetPropertiesExceptionHeaders = exports.BlobGetPropertiesHeaders = exports.BlobDownloadExceptionHeaders = exports.BlobDownloadHeaders = exports.ContainerGetAccountInfoExceptionHeaders = exports.ContainerGetAccountInfoHeaders = exports.ContainerListBlobHierarchySegmentExceptionHeaders = exports.ContainerListBlobHierarchySegmentHeaders = exports.ContainerListBlobFlatSegmentExceptionHeaders = exports.ContainerListBlobFlatSegmentHeaders = exports.ContainerChangeLeaseExceptionHeaders = exports.ContainerChangeLeaseHeaders = exports.ContainerBreakLeaseExceptionHeaders = exports.ContainerBreakLeaseHeaders = exports.ContainerRenewLeaseExceptionHeaders = exports.ContainerRenewLeaseHeaders = exports.ContainerReleaseLeaseExceptionHeaders = exports.ContainerReleaseLeaseHeaders = exports.ContainerAcquireLeaseExceptionHeaders = exports.ContainerAcquireLeaseHeaders = exports.ContainerFilterBlobsExceptionHeaders = exports.ContainerFilterBlobsHeaders = exports.ContainerSubmitBatchExceptionHeaders = exports.ContainerSubmitBatchHeaders = exports.ContainerRenameExceptionHeaders = exports.ContainerRenameHeaders = exports.ContainerRestoreExceptionHeaders = exports.ContainerRestoreHeaders = exports.ContainerSetAccessPolicyExceptionHeaders = exports.ContainerSetAccessPolicyHeaders = exports.ContainerGetAccessPolicyExceptionHeaders = exports.ContainerGetAccessPolicyHeaders = exports.ContainerSetMetadataExceptionHeaders = exports.ContainerSetMetadataHeaders = exports.ContainerDeleteExceptionHeaders = exports.ContainerDeleteHeaders = exports.ContainerGetPropertiesExceptionHeaders = exports.ContainerGetPropertiesHeaders = exports.ContainerCreateExceptionHeaders = exports.ContainerCreateHeaders = exports.ServiceFilterBlobsExceptionHeaders = exports.ServiceFilterBlobsHeaders = exports.ServiceSubmitBatchExceptionHeaders = exports.ServiceSubmitBatchHeaders = exports.ServiceGetAccountInfoExceptionHeaders = exports.ServiceGetAccountInfoHeaders = exports.ServiceGetUserDelegationKeyExceptionHeaders = undefined;
  exports.PageBlobGetPageRangesHeaders = exports.PageBlobUploadPagesFromURLExceptionHeaders = exports.PageBlobUploadPagesFromURLHeaders = exports.PageBlobClearPagesExceptionHeaders = exports.PageBlobClearPagesHeaders = exports.PageBlobUploadPagesExceptionHeaders = exports.PageBlobUploadPagesHeaders = exports.PageBlobCreateExceptionHeaders = exports.PageBlobCreateHeaders = exports.BlobSetTagsExceptionHeaders = exports.BlobSetTagsHeaders = exports.BlobGetTagsExceptionHeaders = exports.BlobGetTagsHeaders = exports.BlobQueryExceptionHeaders = exports.BlobQueryHeaders = exports.BlobGetAccountInfoExceptionHeaders = exports.BlobGetAccountInfoHeaders = exports.BlobSetTierExceptionHeaders = exports.BlobSetTierHeaders = exports.BlobAbortCopyFromURLExceptionHeaders = exports.BlobAbortCopyFromURLHeaders = exports.BlobCopyFromURLExceptionHeaders = exports.BlobCopyFromURLHeaders = exports.BlobStartCopyFromURLExceptionHeaders = exports.BlobStartCopyFromURLHeaders = exports.BlobCreateSnapshotExceptionHeaders = exports.BlobCreateSnapshotHeaders = exports.BlobBreakLeaseExceptionHeaders = exports.BlobBreakLeaseHeaders = exports.BlobChangeLeaseExceptionHeaders = exports.BlobChangeLeaseHeaders = exports.BlobRenewLeaseExceptionHeaders = exports.BlobRenewLeaseHeaders = exports.BlobReleaseLeaseExceptionHeaders = exports.BlobReleaseLeaseHeaders = exports.BlobAcquireLeaseExceptionHeaders = exports.BlobAcquireLeaseHeaders = exports.BlobSetMetadataExceptionHeaders = exports.BlobSetMetadataHeaders = exports.BlobSetLegalHoldExceptionHeaders = exports.BlobSetLegalHoldHeaders = exports.BlobDeleteImmutabilityPolicyExceptionHeaders = exports.BlobDeleteImmutabilityPolicyHeaders = exports.BlobSetImmutabilityPolicyExceptionHeaders = exports.BlobSetImmutabilityPolicyHeaders = exports.BlobSetHttpHeadersExceptionHeaders = exports.BlobSetHttpHeadersHeaders = exports.BlobSetExpiryExceptionHeaders = exports.BlobSetExpiryHeaders = exports.BlobUndeleteExceptionHeaders = undefined;
  exports.BlockBlobGetBlockListExceptionHeaders = exports.BlockBlobGetBlockListHeaders = exports.BlockBlobCommitBlockListExceptionHeaders = exports.BlockBlobCommitBlockListHeaders = exports.BlockBlobStageBlockFromURLExceptionHeaders = exports.BlockBlobStageBlockFromURLHeaders = exports.BlockBlobStageBlockExceptionHeaders = exports.BlockBlobStageBlockHeaders = exports.BlockBlobPutBlobFromUrlExceptionHeaders = exports.BlockBlobPutBlobFromUrlHeaders = exports.BlockBlobUploadExceptionHeaders = exports.BlockBlobUploadHeaders = exports.AppendBlobSealExceptionHeaders = exports.AppendBlobSealHeaders = exports.AppendBlobAppendBlockFromUrlExceptionHeaders = exports.AppendBlobAppendBlockFromUrlHeaders = exports.AppendBlobAppendBlockExceptionHeaders = exports.AppendBlobAppendBlockHeaders = exports.AppendBlobCreateExceptionHeaders = exports.AppendBlobCreateHeaders = exports.PageBlobCopyIncrementalExceptionHeaders = exports.PageBlobCopyIncrementalHeaders = exports.PageBlobUpdateSequenceNumberExceptionHeaders = exports.PageBlobUpdateSequenceNumberHeaders = exports.PageBlobResizeExceptionHeaders = exports.PageBlobResizeHeaders = exports.PageBlobGetPageRangesDiffExceptionHeaders = exports.PageBlobGetPageRangesDiffHeaders = exports.PageBlobGetPageRangesExceptionHeaders = undefined;
  exports.BlobServiceProperties = {
    serializedName: "BlobServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
      name: "Composite",
      className: "BlobServiceProperties",
      modelProperties: {
        blobAnalyticsLogging: {
          serializedName: "Logging",
          xmlName: "Logging",
          type: {
            name: "Composite",
            className: "Logging"
          }
        },
        hourMetrics: {
          serializedName: "HourMetrics",
          xmlName: "HourMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        minuteMetrics: {
          serializedName: "MinuteMetrics",
          xmlName: "MinuteMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        cors: {
          serializedName: "Cors",
          xmlName: "Cors",
          xmlIsWrapped: true,
          xmlElementName: "CorsRule",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "CorsRule"
              }
            }
          }
        },
        defaultServiceVersion: {
          serializedName: "DefaultServiceVersion",
          xmlName: "DefaultServiceVersion",
          type: {
            name: "String"
          }
        },
        deleteRetentionPolicy: {
          serializedName: "DeleteRetentionPolicy",
          xmlName: "DeleteRetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        },
        staticWebsite: {
          serializedName: "StaticWebsite",
          xmlName: "StaticWebsite",
          type: {
            name: "Composite",
            className: "StaticWebsite"
          }
        }
      }
    }
  };
  exports.Logging = {
    serializedName: "Logging",
    type: {
      name: "Composite",
      className: "Logging",
      modelProperties: {
        version: {
          serializedName: "Version",
          required: true,
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        deleteProperty: {
          serializedName: "Delete",
          required: true,
          xmlName: "Delete",
          type: {
            name: "Boolean"
          }
        },
        read: {
          serializedName: "Read",
          required: true,
          xmlName: "Read",
          type: {
            name: "Boolean"
          }
        },
        write: {
          serializedName: "Write",
          required: true,
          xmlName: "Write",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  exports.RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
      name: "Composite",
      className: "RetentionPolicy",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        days: {
          constraints: {
            InclusiveMinimum: 1
          },
          serializedName: "Days",
          xmlName: "Days",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.Metrics = {
    serializedName: "Metrics",
    type: {
      name: "Composite",
      className: "Metrics",
      modelProperties: {
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        includeAPIs: {
          serializedName: "IncludeAPIs",
          xmlName: "IncludeAPIs",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  exports.CorsRule = {
    serializedName: "CorsRule",
    type: {
      name: "Composite",
      className: "CorsRule",
      modelProperties: {
        allowedOrigins: {
          serializedName: "AllowedOrigins",
          required: true,
          xmlName: "AllowedOrigins",
          type: {
            name: "String"
          }
        },
        allowedMethods: {
          serializedName: "AllowedMethods",
          required: true,
          xmlName: "AllowedMethods",
          type: {
            name: "String"
          }
        },
        allowedHeaders: {
          serializedName: "AllowedHeaders",
          required: true,
          xmlName: "AllowedHeaders",
          type: {
            name: "String"
          }
        },
        exposedHeaders: {
          serializedName: "ExposedHeaders",
          required: true,
          xmlName: "ExposedHeaders",
          type: {
            name: "String"
          }
        },
        maxAgeInSeconds: {
          constraints: {
            InclusiveMinimum: 0
          },
          serializedName: "MaxAgeInSeconds",
          required: true,
          xmlName: "MaxAgeInSeconds",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.StaticWebsite = {
    serializedName: "StaticWebsite",
    type: {
      name: "Composite",
      className: "StaticWebsite",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        indexDocument: {
          serializedName: "IndexDocument",
          xmlName: "IndexDocument",
          type: {
            name: "String"
          }
        },
        errorDocument404Path: {
          serializedName: "ErrorDocument404Path",
          xmlName: "ErrorDocument404Path",
          type: {
            name: "String"
          }
        },
        defaultIndexDocumentPath: {
          serializedName: "DefaultIndexDocumentPath",
          xmlName: "DefaultIndexDocumentPath",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.StorageError = {
    serializedName: "StorageError",
    type: {
      name: "Composite",
      className: "StorageError",
      modelProperties: {
        message: {
          serializedName: "Message",
          xmlName: "Message",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "CopySourceStatusCode",
          xmlName: "CopySourceStatusCode",
          type: {
            name: "Number"
          }
        },
        copySourceErrorCode: {
          serializedName: "CopySourceErrorCode",
          xmlName: "CopySourceErrorCode",
          type: {
            name: "String"
          }
        },
        copySourceErrorMessage: {
          serializedName: "CopySourceErrorMessage",
          xmlName: "CopySourceErrorMessage",
          type: {
            name: "String"
          }
        },
        code: {
          serializedName: "Code",
          xmlName: "Code",
          type: {
            name: "String"
          }
        },
        authenticationErrorDetail: {
          serializedName: "AuthenticationErrorDetail",
          xmlName: "AuthenticationErrorDetail",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobServiceStatistics = {
    serializedName: "BlobServiceStatistics",
    xmlName: "StorageServiceStats",
    type: {
      name: "Composite",
      className: "BlobServiceStatistics",
      modelProperties: {
        geoReplication: {
          serializedName: "GeoReplication",
          xmlName: "GeoReplication",
          type: {
            name: "Composite",
            className: "GeoReplication"
          }
        }
      }
    }
  };
  exports.GeoReplication = {
    serializedName: "GeoReplication",
    type: {
      name: "Composite",
      className: "GeoReplication",
      modelProperties: {
        status: {
          serializedName: "Status",
          required: true,
          xmlName: "Status",
          type: {
            name: "Enum",
            allowedValues: ["live", "bootstrap", "unavailable"]
          }
        },
        lastSyncOn: {
          serializedName: "LastSyncTime",
          required: true,
          xmlName: "LastSyncTime",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ListContainersSegmentResponse = {
    serializedName: "ListContainersSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListContainersSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        containerItems: {
          serializedName: "ContainerItems",
          required: true,
          xmlName: "Containers",
          xmlIsWrapped: true,
          xmlElementName: "Container",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ContainerItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerItem = {
    serializedName: "ContainerItem",
    xmlName: "Container",
    type: {
      name: "Composite",
      className: "ContainerItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        deleted: {
          serializedName: "Deleted",
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "ContainerProperties"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        }
      }
    }
  };
  exports.ContainerProperties = {
    serializedName: "ContainerProperties",
    type: {
      name: "Composite",
      className: "ContainerProperties",
      modelProperties: {
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        publicAccess: {
          serializedName: "PublicAccess",
          xmlName: "PublicAccess",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "HasImmutabilityPolicy",
          xmlName: "HasImmutabilityPolicy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "HasLegalHold",
          xmlName: "HasLegalHold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "DefaultEncryptionScope",
          xmlName: "DefaultEncryptionScope",
          type: {
            name: "String"
          }
        },
        preventEncryptionScopeOverride: {
          serializedName: "DenyEncryptionScopeOverride",
          xmlName: "DenyEncryptionScopeOverride",
          type: {
            name: "Boolean"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "ImmutableStorageWithVersioningEnabled",
          xmlName: "ImmutableStorageWithVersioningEnabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.KeyInfo = {
    serializedName: "KeyInfo",
    type: {
      name: "Composite",
      className: "KeyInfo",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          required: true,
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.UserDelegationKey = {
    serializedName: "UserDelegationKey",
    type: {
      name: "Composite",
      className: "UserDelegationKey",
      modelProperties: {
        signedObjectId: {
          serializedName: "SignedOid",
          required: true,
          xmlName: "SignedOid",
          type: {
            name: "String"
          }
        },
        signedTenantId: {
          serializedName: "SignedTid",
          required: true,
          xmlName: "SignedTid",
          type: {
            name: "String"
          }
        },
        signedStartsOn: {
          serializedName: "SignedStart",
          required: true,
          xmlName: "SignedStart",
          type: {
            name: "String"
          }
        },
        signedExpiresOn: {
          serializedName: "SignedExpiry",
          required: true,
          xmlName: "SignedExpiry",
          type: {
            name: "String"
          }
        },
        signedService: {
          serializedName: "SignedService",
          required: true,
          xmlName: "SignedService",
          type: {
            name: "String"
          }
        },
        signedVersion: {
          serializedName: "SignedVersion",
          required: true,
          xmlName: "SignedVersion",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.FilterBlobSegment = {
    serializedName: "FilterBlobSegment",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "FilterBlobSegment",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        where: {
          serializedName: "Where",
          required: true,
          xmlName: "Where",
          type: {
            name: "String"
          }
        },
        blobs: {
          serializedName: "Blobs",
          required: true,
          xmlName: "Blobs",
          xmlIsWrapped: true,
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "FilterBlobItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.FilterBlobItem = {
    serializedName: "FilterBlobItem",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "FilterBlobItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          type: {
            name: "String"
          }
        },
        tags: {
          serializedName: "Tags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        }
      }
    }
  };
  exports.BlobTags = {
    serializedName: "BlobTags",
    xmlName: "Tags",
    type: {
      name: "Composite",
      className: "BlobTags",
      modelProperties: {
        blobTagSet: {
          serializedName: "BlobTagSet",
          required: true,
          xmlName: "TagSet",
          xmlIsWrapped: true,
          xmlElementName: "Tag",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobTag"
              }
            }
          }
        }
      }
    }
  };
  exports.BlobTag = {
    serializedName: "BlobTag",
    xmlName: "Tag",
    type: {
      name: "Composite",
      className: "BlobTag",
      modelProperties: {
        key: {
          serializedName: "Key",
          required: true,
          xmlName: "Key",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
      name: "Composite",
      className: "SignedIdentifier",
      modelProperties: {
        id: {
          serializedName: "Id",
          required: true,
          xmlName: "Id",
          type: {
            name: "String"
          }
        },
        accessPolicy: {
          serializedName: "AccessPolicy",
          xmlName: "AccessPolicy",
          type: {
            name: "Composite",
            className: "AccessPolicy"
          }
        }
      }
    }
  };
  exports.AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
      name: "Composite",
      className: "AccessPolicy",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        },
        permissions: {
          serializedName: "Permission",
          xmlName: "Permission",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ListBlobsFlatSegmentResponse = {
    serializedName: "ListBlobsFlatSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsFlatSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobFlatListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobFlatListSegment = {
    serializedName: "BlobFlatListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobFlatListSegment",
      modelProperties: {
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  exports.BlobItemInternal = {
    serializedName: "BlobItemInternal",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "BlobItemInternal",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        },
        deleted: {
          serializedName: "Deleted",
          required: true,
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        snapshot: {
          serializedName: "Snapshot",
          required: true,
          xmlName: "Snapshot",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "VersionId",
          xmlName: "VersionId",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "IsCurrentVersion",
          xmlName: "IsCurrentVersion",
          type: {
            name: "Boolean"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "BlobPropertiesInternal"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobTags: {
          serializedName: "BlobTags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        },
        objectReplicationMetadata: {
          serializedName: "ObjectReplicationMetadata",
          xmlName: "OrMetadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        hasVersionsOnly: {
          serializedName: "HasVersionsOnly",
          xmlName: "HasVersionsOnly",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.BlobName = {
    serializedName: "BlobName",
    type: {
      name: "Composite",
      className: "BlobName",
      modelProperties: {
        encoded: {
          serializedName: "Encoded",
          xmlName: "Encoded",
          xmlIsAttribute: true,
          type: {
            name: "Boolean"
          }
        },
        content: {
          serializedName: "content",
          xmlName: "content",
          xmlIsMsText: true,
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobPropertiesInternal = {
    serializedName: "BlobPropertiesInternal",
    xmlName: "Properties",
    type: {
      name: "Composite",
      className: "BlobPropertiesInternal",
      modelProperties: {
        createdOn: {
          serializedName: "Creation-Time",
          xmlName: "Creation-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        contentLength: {
          serializedName: "Content-Length",
          xmlName: "Content-Length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "Content-Type",
          xmlName: "Content-Type",
          type: {
            name: "String"
          }
        },
        contentEncoding: {
          serializedName: "Content-Encoding",
          xmlName: "Content-Encoding",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "Content-Language",
          xmlName: "Content-Language",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "Content-MD5",
          xmlName: "Content-MD5",
          type: {
            name: "ByteArray"
          }
        },
        contentDisposition: {
          serializedName: "Content-Disposition",
          xmlName: "Content-Disposition",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "Cache-Control",
          xmlName: "Cache-Control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "BlobType",
          xmlName: "BlobType",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        copyId: {
          serializedName: "CopyId",
          xmlName: "CopyId",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "CopyStatus",
          xmlName: "CopyStatus",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        copySource: {
          serializedName: "CopySource",
          xmlName: "CopySource",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "CopyProgress",
          xmlName: "CopyProgress",
          type: {
            name: "String"
          }
        },
        copyCompletedOn: {
          serializedName: "CopyCompletionTime",
          xmlName: "CopyCompletionTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "CopyStatusDescription",
          xmlName: "CopyStatusDescription",
          type: {
            name: "String"
          }
        },
        serverEncrypted: {
          serializedName: "ServerEncrypted",
          xmlName: "ServerEncrypted",
          type: {
            name: "Boolean"
          }
        },
        incrementalCopy: {
          serializedName: "IncrementalCopy",
          xmlName: "IncrementalCopy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "DestinationSnapshot",
          xmlName: "DestinationSnapshot",
          type: {
            name: "String"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        accessTier: {
          serializedName: "AccessTier",
          xmlName: "AccessTier",
          type: {
            name: "Enum",
            allowedValues: [
              "P4",
              "P6",
              "P10",
              "P15",
              "P20",
              "P30",
              "P40",
              "P50",
              "P60",
              "P70",
              "P80",
              "Hot",
              "Cool",
              "Archive",
              "Cold"
            ]
          }
        },
        accessTierInferred: {
          serializedName: "AccessTierInferred",
          xmlName: "AccessTierInferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "ArchiveStatus",
          xmlName: "ArchiveStatus",
          type: {
            name: "Enum",
            allowedValues: [
              "rehydrate-pending-to-hot",
              "rehydrate-pending-to-cool",
              "rehydrate-pending-to-cold"
            ]
          }
        },
        customerProvidedKeySha256: {
          serializedName: "CustomerProvidedKeySha256",
          xmlName: "CustomerProvidedKeySha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "EncryptionScope",
          xmlName: "EncryptionScope",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "AccessTierChangeTime",
          xmlName: "AccessTierChangeTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        tagCount: {
          serializedName: "TagCount",
          xmlName: "TagCount",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "Expiry-Time",
          xmlName: "Expiry-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "Sealed",
          xmlName: "Sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "RehydratePriority",
          xmlName: "RehydratePriority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessedOn: {
          serializedName: "LastAccessTime",
          xmlName: "LastAccessTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "ImmutabilityPolicyUntilDate",
          xmlName: "ImmutabilityPolicyUntilDate",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "ImmutabilityPolicyMode",
          xmlName: "ImmutabilityPolicyMode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "LegalHold",
          xmlName: "LegalHold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.ListBlobsHierarchySegmentResponse = {
    serializedName: "ListBlobsHierarchySegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsHierarchySegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        delimiter: {
          serializedName: "Delimiter",
          xmlName: "Delimiter",
          type: {
            name: "String"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobHierarchyListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobHierarchyListSegment = {
    serializedName: "BlobHierarchyListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobHierarchyListSegment",
      modelProperties: {
        blobPrefixes: {
          serializedName: "BlobPrefixes",
          xmlName: "BlobPrefixes",
          xmlElementName: "BlobPrefix",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobPrefix"
              }
            }
          }
        },
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  exports.BlobPrefix = {
    serializedName: "BlobPrefix",
    type: {
      name: "Composite",
      className: "BlobPrefix",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        }
      }
    }
  };
  exports.BlockLookupList = {
    serializedName: "BlockLookupList",
    xmlName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockLookupList",
      modelProperties: {
        committed: {
          serializedName: "Committed",
          xmlName: "Committed",
          xmlElementName: "Committed",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        uncommitted: {
          serializedName: "Uncommitted",
          xmlName: "Uncommitted",
          xmlElementName: "Uncommitted",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        latest: {
          serializedName: "Latest",
          xmlName: "Latest",
          xmlElementName: "Latest",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        }
      }
    }
  };
  exports.BlockList = {
    serializedName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockList",
      modelProperties: {
        committedBlocks: {
          serializedName: "CommittedBlocks",
          xmlName: "CommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        },
        uncommittedBlocks: {
          serializedName: "UncommittedBlocks",
          xmlName: "UncommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        }
      }
    }
  };
  exports.Block = {
    serializedName: "Block",
    type: {
      name: "Composite",
      className: "Block",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        size: {
          serializedName: "Size",
          required: true,
          xmlName: "Size",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.PageList = {
    serializedName: "PageList",
    type: {
      name: "Composite",
      className: "PageList",
      modelProperties: {
        pageRange: {
          serializedName: "PageRange",
          xmlName: "PageRange",
          xmlElementName: "PageRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "PageRange"
              }
            }
          }
        },
        clearRange: {
          serializedName: "ClearRange",
          xmlName: "ClearRange",
          xmlElementName: "ClearRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ClearRange"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageRange = {
    serializedName: "PageRange",
    xmlName: "PageRange",
    type: {
      name: "Composite",
      className: "PageRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
      name: "Composite",
      className: "ClearRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.QueryRequest = {
    serializedName: "QueryRequest",
    xmlName: "QueryRequest",
    type: {
      name: "Composite",
      className: "QueryRequest",
      modelProperties: {
        queryType: {
          serializedName: "QueryType",
          required: true,
          xmlName: "QueryType",
          type: {
            name: "String"
          }
        },
        expression: {
          serializedName: "Expression",
          required: true,
          xmlName: "Expression",
          type: {
            name: "String"
          }
        },
        inputSerialization: {
          serializedName: "InputSerialization",
          xmlName: "InputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        },
        outputSerialization: {
          serializedName: "OutputSerialization",
          xmlName: "OutputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        }
      }
    }
  };
  exports.QuerySerialization = {
    serializedName: "QuerySerialization",
    type: {
      name: "Composite",
      className: "QuerySerialization",
      modelProperties: {
        format: {
          serializedName: "Format",
          xmlName: "Format",
          type: {
            name: "Composite",
            className: "QueryFormat"
          }
        }
      }
    }
  };
  exports.QueryFormat = {
    serializedName: "QueryFormat",
    type: {
      name: "Composite",
      className: "QueryFormat",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "Enum",
            allowedValues: ["delimited", "json", "arrow", "parquet"]
          }
        },
        delimitedTextConfiguration: {
          serializedName: "DelimitedTextConfiguration",
          xmlName: "DelimitedTextConfiguration",
          type: {
            name: "Composite",
            className: "DelimitedTextConfiguration"
          }
        },
        jsonTextConfiguration: {
          serializedName: "JsonTextConfiguration",
          xmlName: "JsonTextConfiguration",
          type: {
            name: "Composite",
            className: "JsonTextConfiguration"
          }
        },
        arrowConfiguration: {
          serializedName: "ArrowConfiguration",
          xmlName: "ArrowConfiguration",
          type: {
            name: "Composite",
            className: "ArrowConfiguration"
          }
        },
        parquetTextConfiguration: {
          serializedName: "ParquetTextConfiguration",
          xmlName: "ParquetTextConfiguration",
          type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
          }
        }
      }
    }
  };
  exports.DelimitedTextConfiguration = {
    serializedName: "DelimitedTextConfiguration",
    xmlName: "DelimitedTextConfiguration",
    type: {
      name: "Composite",
      className: "DelimitedTextConfiguration",
      modelProperties: {
        columnSeparator: {
          serializedName: "ColumnSeparator",
          xmlName: "ColumnSeparator",
          type: {
            name: "String"
          }
        },
        fieldQuote: {
          serializedName: "FieldQuote",
          xmlName: "FieldQuote",
          type: {
            name: "String"
          }
        },
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        },
        escapeChar: {
          serializedName: "EscapeChar",
          xmlName: "EscapeChar",
          type: {
            name: "String"
          }
        },
        headersPresent: {
          serializedName: "HeadersPresent",
          xmlName: "HasHeaders",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.JsonTextConfiguration = {
    serializedName: "JsonTextConfiguration",
    xmlName: "JsonTextConfiguration",
    type: {
      name: "Composite",
      className: "JsonTextConfiguration",
      modelProperties: {
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ArrowConfiguration = {
    serializedName: "ArrowConfiguration",
    xmlName: "ArrowConfiguration",
    type: {
      name: "Composite",
      className: "ArrowConfiguration",
      modelProperties: {
        schema: {
          serializedName: "Schema",
          required: true,
          xmlName: "Schema",
          xmlIsWrapped: true,
          xmlElementName: "Field",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ArrowField"
              }
            }
          }
        }
      }
    }
  };
  exports.ArrowField = {
    serializedName: "ArrowField",
    xmlName: "Field",
    type: {
      name: "Composite",
      className: "ArrowField",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "String"
          }
        },
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        precision: {
          serializedName: "Precision",
          xmlName: "Precision",
          type: {
            name: "Number"
          }
        },
        scale: {
          serializedName: "Scale",
          xmlName: "Scale",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceListContainersSegmentHeaders = {
    serializedName: "Service_listContainersSegmentHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceListContainersSegmentExceptionHeaders = {
    serializedName: "Service_listContainersSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetUserDelegationKeyHeaders = {
    serializedName: "Service_getUserDelegationKeyHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetUserDelegationKeyExceptionHeaders = {
    serializedName: "Service_getUserDelegationKeyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetAccountInfoHeaders = {
    serializedName: "Service_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetAccountInfoExceptionHeaders = {
    serializedName: "Service_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceSubmitBatchHeaders = {
    serializedName: "Service_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceSubmitBatchExceptionHeaders = {
    serializedName: "Service_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceFilterBlobsHeaders = {
    serializedName: "Service_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceFilterBlobsExceptionHeaders = {
    serializedName: "Service_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerCreateHeaders = {
    serializedName: "Container_createHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerCreateExceptionHeaders = {
    serializedName: "Container_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetPropertiesHeaders = {
    serializedName: "Container_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesHeaders",
      modelProperties: {
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "x-ms-has-immutability-policy",
          xmlName: "x-ms-has-immutability-policy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "x-ms-has-legal-hold",
          xmlName: "x-ms-has-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "x-ms-default-encryption-scope",
          xmlName: "x-ms-default-encryption-scope",
          type: {
            name: "String"
          }
        },
        denyEncryptionScopeOverride: {
          serializedName: "x-ms-deny-encryption-scope-override",
          xmlName: "x-ms-deny-encryption-scope-override",
          type: {
            name: "Boolean"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "x-ms-immutable-storage-with-versioning-enabled",
          xmlName: "x-ms-immutable-storage-with-versioning-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetPropertiesExceptionHeaders = {
    serializedName: "Container_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerDeleteHeaders = {
    serializedName: "Container_deleteHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerDeleteExceptionHeaders = {
    serializedName: "Container_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetMetadataHeaders = {
    serializedName: "Container_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetMetadataExceptionHeaders = {
    serializedName: "Container_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetAccessPolicyHeaders = {
    serializedName: "Container_getAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyHeaders",
      modelProperties: {
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetAccessPolicyExceptionHeaders = {
    serializedName: "Container_getAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetAccessPolicyHeaders = {
    serializedName: "Container_setAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetAccessPolicyExceptionHeaders = {
    serializedName: "Container_setAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRestoreHeaders = {
    serializedName: "Container_restoreHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRestoreExceptionHeaders = {
    serializedName: "Container_restoreExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRenameHeaders = {
    serializedName: "Container_renameHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRenameExceptionHeaders = {
    serializedName: "Container_renameExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSubmitBatchHeaders = {
    serializedName: "Container_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSubmitBatchExceptionHeaders = {
    serializedName: "Container_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerFilterBlobsHeaders = {
    serializedName: "Container_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerFilterBlobsExceptionHeaders = {
    serializedName: "Container_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerAcquireLeaseHeaders = {
    serializedName: "Container_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerAcquireLeaseExceptionHeaders = {
    serializedName: "Container_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerReleaseLeaseHeaders = {
    serializedName: "Container_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerReleaseLeaseExceptionHeaders = {
    serializedName: "Container_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRenewLeaseHeaders = {
    serializedName: "Container_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerRenewLeaseExceptionHeaders = {
    serializedName: "Container_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerBreakLeaseHeaders = {
    serializedName: "Container_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerBreakLeaseExceptionHeaders = {
    serializedName: "Container_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerChangeLeaseHeaders = {
    serializedName: "Container_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerChangeLeaseExceptionHeaders = {
    serializedName: "Container_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobFlatSegmentHeaders = {
    serializedName: "Container_listBlobFlatSegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobFlatSegmentExceptionHeaders = {
    serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobHierarchySegmentHeaders = {
    serializedName: "Container_listBlobHierarchySegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobHierarchySegmentExceptionHeaders = {
    serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetAccountInfoHeaders = {
    serializedName: "Container_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.ContainerGetAccountInfoExceptionHeaders = {
    serializedName: "Container_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDownloadHeaders = {
    serializedName: "Blob_downloadHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  exports.BlobDownloadExceptionHeaders = {
    serializedName: "Blob_downloadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetPropertiesHeaders = {
    serializedName: "Blob_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        isIncrementalCopy: {
          serializedName: "x-ms-incremental-copy",
          xmlName: "x-ms-incremental-copy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "x-ms-copy-destination-snapshot",
          xmlName: "x-ms-copy-destination-snapshot",
          type: {
            name: "String"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        accessTier: {
          serializedName: "x-ms-access-tier",
          xmlName: "x-ms-access-tier",
          type: {
            name: "String"
          }
        },
        accessTierInferred: {
          serializedName: "x-ms-access-tier-inferred",
          xmlName: "x-ms-access-tier-inferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "x-ms-archive-status",
          xmlName: "x-ms-archive-status",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "x-ms-access-tier-change-time",
          xmlName: "x-ms-access-tier-change-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "x-ms-expiry-time",
          xmlName: "x-ms-expiry-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "x-ms-rehydrate-priority",
          xmlName: "x-ms-rehydrate-priority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetPropertiesExceptionHeaders = {
    serializedName: "Blob_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDeleteHeaders = {
    serializedName: "Blob_deleteHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDeleteExceptionHeaders = {
    serializedName: "Blob_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobUndeleteHeaders = {
    serializedName: "Blob_undeleteHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobUndeleteExceptionHeaders = {
    serializedName: "Blob_undeleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetExpiryHeaders = {
    serializedName: "Blob_setExpiryHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobSetExpiryExceptionHeaders = {
    serializedName: "Blob_setExpiryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetHttpHeadersHeaders = {
    serializedName: "Blob_setHttpHeadersHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetHttpHeadersExceptionHeaders = {
    serializedName: "Blob_setHttpHeadersExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetImmutabilityPolicyHeaders = {
    serializedName: "Blob_setImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiry: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        }
      }
    }
  };
  exports.BlobSetImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDeleteImmutabilityPolicyHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobDeleteImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetLegalHoldHeaders = {
    serializedName: "Blob_setLegalHoldHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.BlobSetLegalHoldExceptionHeaders = {
    serializedName: "Blob_setLegalHoldExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetMetadataHeaders = {
    serializedName: "Blob_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetMetadataExceptionHeaders = {
    serializedName: "Blob_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobAcquireLeaseHeaders = {
    serializedName: "Blob_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobAcquireLeaseExceptionHeaders = {
    serializedName: "Blob_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobReleaseLeaseHeaders = {
    serializedName: "Blob_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobReleaseLeaseExceptionHeaders = {
    serializedName: "Blob_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobRenewLeaseHeaders = {
    serializedName: "Blob_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobRenewLeaseExceptionHeaders = {
    serializedName: "Blob_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobChangeLeaseHeaders = {
    serializedName: "Blob_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobChangeLeaseExceptionHeaders = {
    serializedName: "Blob_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobBreakLeaseHeaders = {
    serializedName: "Blob_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobBreakLeaseExceptionHeaders = {
    serializedName: "Blob_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobCreateSnapshotHeaders = {
    serializedName: "Blob_createSnapshotHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotHeaders",
      modelProperties: {
        snapshot: {
          serializedName: "x-ms-snapshot",
          xmlName: "x-ms-snapshot",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobCreateSnapshotExceptionHeaders = {
    serializedName: "Blob_createSnapshotExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobStartCopyFromURLHeaders = {
    serializedName: "Blob_startCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobStartCopyFromURLExceptionHeaders = {
    serializedName: "Blob_startCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlobCopyFromURLHeaders = {
    serializedName: "Blob_copyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          defaultValue: "success",
          isConstant: true,
          serializedName: "x-ms-copy-status",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobCopyFromURLExceptionHeaders = {
    serializedName: "Blob_copyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlobAbortCopyFromURLHeaders = {
    serializedName: "Blob_abortCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobAbortCopyFromURLExceptionHeaders = {
    serializedName: "Blob_abortCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTierHeaders = {
    serializedName: "Blob_setTierHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTierExceptionHeaders = {
    serializedName: "Blob_setTierExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetAccountInfoHeaders = {
    serializedName: "Blob_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.BlobGetAccountInfoExceptionHeaders = {
    serializedName: "Blob_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobQueryHeaders = {
    serializedName: "Blob_queryHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletionTime: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  exports.BlobQueryExceptionHeaders = {
    serializedName: "Blob_queryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetTagsHeaders = {
    serializedName: "Blob_getTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetTagsExceptionHeaders = {
    serializedName: "Blob_getTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTagsHeaders = {
    serializedName: "Blob_setTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTagsExceptionHeaders = {
    serializedName: "Blob_setTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCreateHeaders = {
    serializedName: "PageBlob_createHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCreateExceptionHeaders = {
    serializedName: "PageBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesHeaders = {
    serializedName: "PageBlob_uploadPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobClearPagesHeaders = {
    serializedName: "PageBlob_clearPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobClearPagesExceptionHeaders = {
    serializedName: "PageBlob_clearPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesFromURLHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesFromURLExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesHeaders = {
    serializedName: "PageBlob_getPageRangesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesDiffHeaders = {
    serializedName: "PageBlob_getPageRangesDiffHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesDiffExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobResizeHeaders = {
    serializedName: "PageBlob_resizeHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobResizeExceptionHeaders = {
    serializedName: "PageBlob_resizeExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUpdateSequenceNumberHeaders = {
    serializedName: "PageBlob_updateSequenceNumberHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUpdateSequenceNumberExceptionHeaders = {
    serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCopyIncrementalHeaders = {
    serializedName: "PageBlob_copyIncrementalHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCopyIncrementalExceptionHeaders = {
    serializedName: "PageBlob_copyIncrementalExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobCreateHeaders = {
    serializedName: "AppendBlob_createHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobCreateExceptionHeaders = {
    serializedName: "AppendBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockHeaders = {
    serializedName: "AppendBlob_appendBlockHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockFromUrlHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockFromUrlExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.AppendBlobSealHeaders = {
    serializedName: "AppendBlob_sealHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.AppendBlobSealExceptionHeaders = {
    serializedName: "AppendBlob_sealExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobUploadHeaders = {
    serializedName: "BlockBlob_uploadHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobUploadExceptionHeaders = {
    serializedName: "BlockBlob_uploadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobPutBlobFromUrlHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobPutBlobFromUrlExceptionHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockHeaders = {
    serializedName: "BlockBlob_stageBlockHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockFromURLHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockFromURLExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlockBlobCommitBlockListHeaders = {
    serializedName: "BlockBlob_commitBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobCommitBlockListExceptionHeaders = {
    serializedName: "BlockBlob_commitBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobGetBlockListHeaders = {
    serializedName: "BlockBlob_getBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobGetBlockListExceptionHeaders = {
    serializedName: "BlockBlob_getBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/parameters.js
var require_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.action3 = exports.action2 = exports.leaseId1 = exports.action1 = exports.proposedLeaseId = exports.duration = exports.action = exports.comp10 = exports.sourceLeaseId = exports.sourceContainerName = exports.comp9 = exports.deletedContainerVersion = exports.deletedContainerName = exports.comp8 = exports.containerAcl = exports.comp7 = exports.comp6 = exports.ifUnmodifiedSince = exports.ifModifiedSince = exports.leaseId = exports.preventEncryptionScopeOverride = exports.defaultEncryptionScope = exports.access = exports.metadata = exports.restype2 = exports.where = exports.comp5 = exports.multipartContentType = exports.contentLength = exports.comp4 = exports.body = exports.restype1 = exports.comp3 = exports.keyInfo = exports.include = exports.maxPageSize = exports.marker = exports.prefix = exports.comp2 = exports.comp1 = exports.accept1 = exports.requestId = exports.version = exports.timeoutInSeconds = exports.comp = exports.restype = exports.url = exports.accept = exports.blobServiceProperties = exports.contentType = undefined;
  exports.copySourceTags = exports.copySourceAuthorization = exports.sourceContentMD5 = exports.xMsRequiresSync = exports.legalHold1 = exports.sealBlob = exports.blobTagsString = exports.copySource = exports.sourceIfTags = exports.sourceIfNoneMatch = exports.sourceIfMatch = exports.sourceIfUnmodifiedSince = exports.sourceIfModifiedSince = exports.rehydratePriority = exports.tier = exports.comp14 = exports.encryptionScope = exports.legalHold = exports.comp13 = exports.immutabilityPolicyMode = exports.immutabilityPolicyExpiry = exports.comp12 = exports.blobContentDisposition = exports.blobContentLanguage = exports.blobContentEncoding = exports.blobContentMD5 = exports.blobContentType = exports.blobCacheControl = exports.expiresOn = exports.expiryOptions = exports.comp11 = exports.blobDeleteType = exports.deleteSnapshots = exports.ifTags = exports.ifNoneMatch = exports.ifMatch = exports.encryptionAlgorithm = exports.encryptionKeySha256 = exports.encryptionKey = exports.rangeGetContentCRC64 = exports.rangeGetContentMD5 = exports.range = exports.versionId = exports.snapshot = exports.delimiter = exports.startFrom = exports.include1 = exports.proposedLeaseId1 = exports.action4 = exports.breakPeriod = undefined;
  exports.listType = exports.comp25 = exports.blocks = exports.blockId = exports.comp24 = exports.copySourceBlobProperties = exports.blobType2 = exports.comp23 = exports.sourceRange1 = exports.appendPosition = exports.maxSize = exports.comp22 = exports.blobType1 = exports.comp21 = exports.sequenceNumberAction = exports.prevSnapshotUrl = exports.prevsnapshot = exports.comp20 = exports.range1 = exports.sourceContentCrc64 = exports.sourceRange = exports.sourceUrl = exports.pageWrite1 = exports.ifSequenceNumberEqualTo = exports.ifSequenceNumberLessThan = exports.ifSequenceNumberLessThanOrEqualTo = exports.pageWrite = exports.comp19 = exports.accept2 = exports.body1 = exports.contentType1 = exports.blobSequenceNumber = exports.blobContentLength = exports.blobType = exports.transactionalContentCrc64 = exports.transactionalContentMD5 = exports.tags = exports.ifNoneMatch1 = exports.ifMatch1 = exports.ifUnmodifiedSince1 = exports.ifModifiedSince1 = exports.comp18 = exports.comp17 = exports.queryRequest = exports.tier1 = exports.comp16 = exports.copyId = exports.copyActionAbortConstant = exports.comp15 = exports.fileRequestIntent = undefined;
  var mappers_js_1 = require_mappers();
  exports.contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  exports.blobServiceProperties = {
    parameterPath: "blobServiceProperties",
    mapper: mappers_js_1.BlobServiceProperties
  };
  exports.accept = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  exports.url = {
    parameterPath: "url",
    mapper: {
      serializedName: "url",
      required: true,
      xmlName: "url",
      type: {
        name: "String"
      }
    },
    skipEncoding: true
  };
  exports.restype = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "service",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  exports.comp = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "properties",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
      constraints: {
        InclusiveMinimum: 0
      },
      serializedName: "timeout",
      xmlName: "timeout",
      type: {
        name: "Number"
      }
    }
  };
  exports.version = {
    parameterPath: "version",
    mapper: {
      defaultValue: "2026-02-06",
      isConstant: true,
      serializedName: "x-ms-version",
      type: {
        name: "String"
      }
    }
  };
  exports.requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
      serializedName: "x-ms-client-request-id",
      xmlName: "x-ms-client-request-id",
      type: {
        name: "String"
      }
    }
  };
  exports.accept1 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  exports.comp1 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "stats",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.comp2 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "list",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
      serializedName: "prefix",
      xmlName: "prefix",
      type: {
        name: "String"
      }
    }
  };
  exports.marker = {
    parameterPath: ["options", "marker"],
    mapper: {
      serializedName: "marker",
      xmlName: "marker",
      type: {
        name: "String"
      }
    }
  };
  exports.maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
      constraints: {
        InclusiveMinimum: 1
      },
      serializedName: "maxresults",
      xmlName: "maxresults",
      type: {
        name: "Number"
      }
    }
  };
  exports.include = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListContainersIncludeType",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: ["metadata", "deleted", "system"]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  exports.keyInfo = {
    parameterPath: "keyInfo",
    mapper: mappers_js_1.KeyInfo
  };
  exports.comp3 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "userdelegationkey",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.restype1 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "account",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  exports.body = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  exports.comp4 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "batch",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.contentLength = {
    parameterPath: "contentLength",
    mapper: {
      serializedName: "Content-Length",
      required: true,
      xmlName: "Content-Length",
      type: {
        name: "Number"
      }
    }
  };
  exports.multipartContentType = {
    parameterPath: "multipartContentType",
    mapper: {
      serializedName: "Content-Type",
      required: true,
      xmlName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  exports.comp5 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blobs",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.where = {
    parameterPath: ["options", "where"],
    mapper: {
      serializedName: "where",
      xmlName: "where",
      type: {
        name: "String"
      }
    }
  };
  exports.restype2 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "container",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  exports.metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
      serializedName: "x-ms-meta",
      xmlName: "x-ms-meta",
      headerCollectionPrefix: "x-ms-meta-",
      type: {
        name: "Dictionary",
        value: { type: { name: "String" } }
      }
    }
  };
  exports.access = {
    parameterPath: ["options", "access"],
    mapper: {
      serializedName: "x-ms-blob-public-access",
      xmlName: "x-ms-blob-public-access",
      type: {
        name: "Enum",
        allowedValues: ["container", "blob"]
      }
    }
  };
  exports.defaultEncryptionScope = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "defaultEncryptionScope"
    ],
    mapper: {
      serializedName: "x-ms-default-encryption-scope",
      xmlName: "x-ms-default-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  exports.preventEncryptionScopeOverride = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "preventEncryptionScopeOverride"
    ],
    mapper: {
      serializedName: "x-ms-deny-encryption-scope-override",
      xmlName: "x-ms-deny-encryption-scope-override",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
      serializedName: "x-ms-lease-id",
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.ifModifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "If-Modified-Since",
      xmlName: "If-Modified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.ifUnmodifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
    mapper: {
      serializedName: "If-Unmodified-Since",
      xmlName: "If-Unmodified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.comp6 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "metadata",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.comp7 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "acl",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.containerAcl = {
    parameterPath: ["options", "containerAcl"],
    mapper: {
      serializedName: "containerAcl",
      xmlName: "SignedIdentifiers",
      xmlIsWrapped: true,
      xmlElementName: "SignedIdentifier",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "SignedIdentifier"
          }
        }
      }
    }
  };
  exports.comp8 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "undelete",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.deletedContainerName = {
    parameterPath: ["options", "deletedContainerName"],
    mapper: {
      serializedName: "x-ms-deleted-container-name",
      xmlName: "x-ms-deleted-container-name",
      type: {
        name: "String"
      }
    }
  };
  exports.deletedContainerVersion = {
    parameterPath: ["options", "deletedContainerVersion"],
    mapper: {
      serializedName: "x-ms-deleted-container-version",
      xmlName: "x-ms-deleted-container-version",
      type: {
        name: "String"
      }
    }
  };
  exports.comp9 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "rename",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceContainerName = {
    parameterPath: "sourceContainerName",
    mapper: {
      serializedName: "x-ms-source-container-name",
      required: true,
      xmlName: "x-ms-source-container-name",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceLeaseId = {
    parameterPath: ["options", "sourceLeaseId"],
    mapper: {
      serializedName: "x-ms-source-lease-id",
      xmlName: "x-ms-source-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.comp10 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "lease",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.action = {
    parameterPath: "action",
    mapper: {
      defaultValue: "acquire",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.duration = {
    parameterPath: ["options", "duration"],
    mapper: {
      serializedName: "x-ms-lease-duration",
      xmlName: "x-ms-lease-duration",
      type: {
        name: "Number"
      }
    }
  };
  exports.proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.action1 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "release",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
      serializedName: "x-ms-lease-id",
      required: true,
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.action2 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "renew",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.action3 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "break",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
      serializedName: "x-ms-lease-break-period",
      xmlName: "x-ms-lease-break-period",
      type: {
        name: "Number"
      }
    }
  };
  exports.action4 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "change",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.proposedLeaseId1 = {
    parameterPath: "proposedLeaseId",
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      required: true,
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.include1 = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListBlobsIncludeItem",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: [
              "copy",
              "deleted",
              "metadata",
              "snapshots",
              "uncommittedblobs",
              "versions",
              "tags",
              "immutabilitypolicy",
              "legalhold",
              "deletedwithversions"
            ]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  exports.startFrom = {
    parameterPath: ["options", "startFrom"],
    mapper: {
      serializedName: "startFrom",
      xmlName: "startFrom",
      type: {
        name: "String"
      }
    }
  };
  exports.delimiter = {
    parameterPath: "delimiter",
    mapper: {
      serializedName: "delimiter",
      required: true,
      xmlName: "delimiter",
      type: {
        name: "String"
      }
    }
  };
  exports.snapshot = {
    parameterPath: ["options", "snapshot"],
    mapper: {
      serializedName: "snapshot",
      xmlName: "snapshot",
      type: {
        name: "String"
      }
    }
  };
  exports.versionId = {
    parameterPath: ["options", "versionId"],
    mapper: {
      serializedName: "versionid",
      xmlName: "versionid",
      type: {
        name: "String"
      }
    }
  };
  exports.range = {
    parameterPath: ["options", "range"],
    mapper: {
      serializedName: "x-ms-range",
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  exports.rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
      serializedName: "x-ms-range-get-content-md5",
      xmlName: "x-ms-range-get-content-md5",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.rangeGetContentCRC64 = {
    parameterPath: ["options", "rangeGetContentCRC64"],
    mapper: {
      serializedName: "x-ms-range-get-content-crc64",
      xmlName: "x-ms-range-get-content-crc64",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.encryptionKey = {
    parameterPath: ["options", "cpkInfo", "encryptionKey"],
    mapper: {
      serializedName: "x-ms-encryption-key",
      xmlName: "x-ms-encryption-key",
      type: {
        name: "String"
      }
    }
  };
  exports.encryptionKeySha256 = {
    parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
    mapper: {
      serializedName: "x-ms-encryption-key-sha256",
      xmlName: "x-ms-encryption-key-sha256",
      type: {
        name: "String"
      }
    }
  };
  exports.encryptionAlgorithm = {
    parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
    mapper: {
      serializedName: "x-ms-encryption-algorithm",
      xmlName: "x-ms-encryption-algorithm",
      type: {
        name: "String"
      }
    }
  };
  exports.ifMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "If-Match",
      xmlName: "If-Match",
      type: {
        name: "String"
      }
    }
  };
  exports.ifNoneMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "If-None-Match",
      xmlName: "If-None-Match",
      type: {
        name: "String"
      }
    }
  };
  exports.ifTags = {
    parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
    mapper: {
      serializedName: "x-ms-if-tags",
      xmlName: "x-ms-if-tags",
      type: {
        name: "String"
      }
    }
  };
  exports.deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
      serializedName: "x-ms-delete-snapshots",
      xmlName: "x-ms-delete-snapshots",
      type: {
        name: "Enum",
        allowedValues: ["include", "only"]
      }
    }
  };
  exports.blobDeleteType = {
    parameterPath: ["options", "blobDeleteType"],
    mapper: {
      serializedName: "deletetype",
      xmlName: "deletetype",
      type: {
        name: "String"
      }
    }
  };
  exports.comp11 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "expiry",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.expiryOptions = {
    parameterPath: "expiryOptions",
    mapper: {
      serializedName: "x-ms-expiry-option",
      required: true,
      xmlName: "x-ms-expiry-option",
      type: {
        name: "String"
      }
    }
  };
  exports.expiresOn = {
    parameterPath: ["options", "expiresOn"],
    mapper: {
      serializedName: "x-ms-expiry-time",
      xmlName: "x-ms-expiry-time",
      type: {
        name: "String"
      }
    }
  };
  exports.blobCacheControl = {
    parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
    mapper: {
      serializedName: "x-ms-blob-cache-control",
      xmlName: "x-ms-blob-cache-control",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentType = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
    mapper: {
      serializedName: "x-ms-blob-content-type",
      xmlName: "x-ms-blob-content-type",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentMD5 = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
    mapper: {
      serializedName: "x-ms-blob-content-md5",
      xmlName: "x-ms-blob-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.blobContentEncoding = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
    mapper: {
      serializedName: "x-ms-blob-content-encoding",
      xmlName: "x-ms-blob-content-encoding",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentLanguage = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
    mapper: {
      serializedName: "x-ms-blob-content-language",
      xmlName: "x-ms-blob-content-language",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentDisposition = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
    mapper: {
      serializedName: "x-ms-blob-content-disposition",
      xmlName: "x-ms-blob-content-disposition",
      type: {
        name: "String"
      }
    }
  };
  exports.comp12 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "immutabilityPolicies",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.immutabilityPolicyExpiry = {
    parameterPath: ["options", "immutabilityPolicyExpiry"],
    mapper: {
      serializedName: "x-ms-immutability-policy-until-date",
      xmlName: "x-ms-immutability-policy-until-date",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.immutabilityPolicyMode = {
    parameterPath: ["options", "immutabilityPolicyMode"],
    mapper: {
      serializedName: "x-ms-immutability-policy-mode",
      xmlName: "x-ms-immutability-policy-mode",
      type: {
        name: "Enum",
        allowedValues: ["Mutable", "Unlocked", "Locked"]
      }
    }
  };
  exports.comp13 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "legalhold",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.legalHold = {
    parameterPath: "legalHold",
    mapper: {
      serializedName: "x-ms-legal-hold",
      required: true,
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.encryptionScope = {
    parameterPath: ["options", "encryptionScope"],
    mapper: {
      serializedName: "x-ms-encryption-scope",
      xmlName: "x-ms-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  exports.comp14 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "snapshot",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.tier = {
    parameterPath: ["options", "tier"],
    mapper: {
      serializedName: "x-ms-access-tier",
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  exports.rehydratePriority = {
    parameterPath: ["options", "rehydratePriority"],
    mapper: {
      serializedName: "x-ms-rehydrate-priority",
      xmlName: "x-ms-rehydrate-priority",
      type: {
        name: "Enum",
        allowedValues: ["High", "Standard"]
      }
    }
  };
  exports.sourceIfModifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfModifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-modified-since",
      xmlName: "x-ms-source-if-modified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.sourceIfUnmodifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfUnmodifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-unmodified-since",
      xmlName: "x-ms-source-if-unmodified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.sourceIfMatch = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
    mapper: {
      serializedName: "x-ms-source-if-match",
      xmlName: "x-ms-source-if-match",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceIfNoneMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfNoneMatch"
    ],
    mapper: {
      serializedName: "x-ms-source-if-none-match",
      xmlName: "x-ms-source-if-none-match",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceIfTags = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
    mapper: {
      serializedName: "x-ms-source-if-tags",
      xmlName: "x-ms-source-if-tags",
      type: {
        name: "String"
      }
    }
  };
  exports.copySource = {
    parameterPath: "copySource",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  exports.blobTagsString = {
    parameterPath: ["options", "blobTagsString"],
    mapper: {
      serializedName: "x-ms-tags",
      xmlName: "x-ms-tags",
      type: {
        name: "String"
      }
    }
  };
  exports.sealBlob = {
    parameterPath: ["options", "sealBlob"],
    mapper: {
      serializedName: "x-ms-seal-blob",
      xmlName: "x-ms-seal-blob",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.legalHold1 = {
    parameterPath: ["options", "legalHold"],
    mapper: {
      serializedName: "x-ms-legal-hold",
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.xMsRequiresSync = {
    parameterPath: "xMsRequiresSync",
    mapper: {
      defaultValue: "true",
      isConstant: true,
      serializedName: "x-ms-requires-sync",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceContentMD5 = {
    parameterPath: ["options", "sourceContentMD5"],
    mapper: {
      serializedName: "x-ms-source-content-md5",
      xmlName: "x-ms-source-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
      serializedName: "x-ms-copy-source-authorization",
      xmlName: "x-ms-copy-source-authorization",
      type: {
        name: "String"
      }
    }
  };
  exports.copySourceTags = {
    parameterPath: ["options", "copySourceTags"],
    mapper: {
      serializedName: "x-ms-copy-source-tag-option",
      xmlName: "x-ms-copy-source-tag-option",
      type: {
        name: "Enum",
        allowedValues: ["REPLACE", "COPY"]
      }
    }
  };
  exports.fileRequestIntent = {
    parameterPath: ["options", "fileRequestIntent"],
    mapper: {
      serializedName: "x-ms-file-request-intent",
      xmlName: "x-ms-file-request-intent",
      type: {
        name: "String"
      }
    }
  };
  exports.comp15 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "copy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
      defaultValue: "abort",
      isConstant: true,
      serializedName: "x-ms-copy-action",
      type: {
        name: "String"
      }
    }
  };
  exports.copyId = {
    parameterPath: "copyId",
    mapper: {
      serializedName: "copyid",
      required: true,
      xmlName: "copyid",
      type: {
        name: "String"
      }
    }
  };
  exports.comp16 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tier",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.tier1 = {
    parameterPath: "tier",
    mapper: {
      serializedName: "x-ms-access-tier",
      required: true,
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  exports.queryRequest = {
    parameterPath: ["options", "queryRequest"],
    mapper: mappers_js_1.QueryRequest
  };
  exports.comp17 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "query",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.comp18 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tags",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.ifModifiedSince1 = {
    parameterPath: ["options", "blobModifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "x-ms-blob-if-modified-since",
      xmlName: "x-ms-blob-if-modified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.ifUnmodifiedSince1 = {
    parameterPath: [
      "options",
      "blobModifiedAccessConditions",
      "ifUnmodifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-blob-if-unmodified-since",
      xmlName: "x-ms-blob-if-unmodified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.ifMatch1 = {
    parameterPath: ["options", "blobModifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "x-ms-blob-if-match",
      xmlName: "x-ms-blob-if-match",
      type: {
        name: "String"
      }
    }
  };
  exports.ifNoneMatch1 = {
    parameterPath: ["options", "blobModifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "x-ms-blob-if-none-match",
      xmlName: "x-ms-blob-if-none-match",
      type: {
        name: "String"
      }
    }
  };
  exports.tags = {
    parameterPath: ["options", "tags"],
    mapper: mappers_js_1.BlobTags
  };
  exports.transactionalContentMD5 = {
    parameterPath: ["options", "transactionalContentMD5"],
    mapper: {
      serializedName: "Content-MD5",
      xmlName: "Content-MD5",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.transactionalContentCrc64 = {
    parameterPath: ["options", "transactionalContentCrc64"],
    mapper: {
      serializedName: "x-ms-content-crc64",
      xmlName: "x-ms-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.blobType = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "PageBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentLength = {
    parameterPath: "blobContentLength",
    mapper: {
      serializedName: "x-ms-blob-content-length",
      required: true,
      xmlName: "x-ms-blob-content-length",
      type: {
        name: "Number"
      }
    }
  };
  exports.blobSequenceNumber = {
    parameterPath: ["options", "blobSequenceNumber"],
    mapper: {
      defaultValue: 0,
      serializedName: "x-ms-blob-sequence-number",
      xmlName: "x-ms-blob-sequence-number",
      type: {
        name: "Number"
      }
    }
  };
  exports.contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/octet-stream",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  exports.body1 = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  exports.accept2 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  exports.comp19 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "page",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.pageWrite = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "update",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  exports.ifSequenceNumberLessThanOrEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThanOrEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-le",
      xmlName: "x-ms-if-sequence-number-le",
      type: {
        name: "Number"
      }
    }
  };
  exports.ifSequenceNumberLessThan = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThan"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-lt",
      xmlName: "x-ms-if-sequence-number-lt",
      type: {
        name: "Number"
      }
    }
  };
  exports.ifSequenceNumberEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-eq",
      xmlName: "x-ms-if-sequence-number-eq",
      type: {
        name: "Number"
      }
    }
  };
  exports.pageWrite1 = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "clear",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceUrl = {
    parameterPath: "sourceUrl",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
      serializedName: "x-ms-source-range",
      required: true,
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
      serializedName: "x-ms-source-content-crc64",
      xmlName: "x-ms-source-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.range1 = {
    parameterPath: "range",
    mapper: {
      serializedName: "x-ms-range",
      required: true,
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  exports.comp20 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "pagelist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.prevsnapshot = {
    parameterPath: ["options", "prevsnapshot"],
    mapper: {
      serializedName: "prevsnapshot",
      xmlName: "prevsnapshot",
      type: {
        name: "String"
      }
    }
  };
  exports.prevSnapshotUrl = {
    parameterPath: ["options", "prevSnapshotUrl"],
    mapper: {
      serializedName: "x-ms-previous-snapshot-url",
      xmlName: "x-ms-previous-snapshot-url",
      type: {
        name: "String"
      }
    }
  };
  exports.sequenceNumberAction = {
    parameterPath: "sequenceNumberAction",
    mapper: {
      serializedName: "x-ms-sequence-number-action",
      required: true,
      xmlName: "x-ms-sequence-number-action",
      type: {
        name: "Enum",
        allowedValues: ["max", "update", "increment"]
      }
    }
  };
  exports.comp21 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "incrementalcopy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.blobType1 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "AppendBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  exports.comp22 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "appendblock",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.maxSize = {
    parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
    mapper: {
      serializedName: "x-ms-blob-condition-maxsize",
      xmlName: "x-ms-blob-condition-maxsize",
      type: {
        name: "Number"
      }
    }
  };
  exports.appendPosition = {
    parameterPath: [
      "options",
      "appendPositionAccessConditions",
      "appendPosition"
    ],
    mapper: {
      serializedName: "x-ms-blob-condition-appendpos",
      xmlName: "x-ms-blob-condition-appendpos",
      type: {
        name: "Number"
      }
    }
  };
  exports.sourceRange1 = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
      serializedName: "x-ms-source-range",
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  exports.comp23 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "seal",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.blobType2 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "BlockBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  exports.copySourceBlobProperties = {
    parameterPath: ["options", "copySourceBlobProperties"],
    mapper: {
      serializedName: "x-ms-copy-source-blob-properties",
      xmlName: "x-ms-copy-source-blob-properties",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.comp24 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "block",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.blockId = {
    parameterPath: "blockId",
    mapper: {
      serializedName: "blockid",
      required: true,
      xmlName: "blockid",
      type: {
        name: "String"
      }
    }
  };
  exports.blocks = {
    parameterPath: "blocks",
    mapper: mappers_js_1.BlockLookupList
  };
  exports.comp25 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blocklist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.listType = {
    parameterPath: "listType",
    mapper: {
      defaultValue: "committed",
      serializedName: "blocklisttype",
      required: true,
      xmlName: "blocklisttype",
      type: {
        name: "Enum",
        allowedValues: ["committed", "uncommitted", "all"]
      }
    }
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/service.js
var require_service = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceImpl = undefined;
  var tslib_1 = require_tslib();
  var coreClient = tslib_1.__importStar(require_commonjs10());
  var Mappers = tslib_1.__importStar(require_mappers());
  var Parameters = tslib_1.__importStar(require_parameters());

  class ServiceImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    setProperties(blobServiceProperties, options) {
      return this.client.sendOperationRequest({ blobServiceProperties, options }, setPropertiesOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    getStatistics(options) {
      return this.client.sendOperationRequest({ options }, getStatisticsOperationSpec);
    }
    listContainersSegment(options) {
      return this.client.sendOperationRequest({ options }, listContainersSegmentOperationSpec);
    }
    getUserDelegationKey(keyInfo, options) {
      return this.client.sendOperationRequest({ keyInfo, options }, getUserDelegationKeyOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
    submitBatch(contentLength, multipartContentType, body, options) {
      return this.client.sendOperationRequest({ contentLength, multipartContentType, body, options }, submitBatchOperationSpec);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
    }
  }
  exports.ServiceImpl = ServiceImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, true);
  var setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.ServiceSetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceSetPropertiesExceptionHeaders
      }
    },
    requestBody: Parameters.blobServiceProperties,
    queryParameters: [
      Parameters.restype,
      Parameters.comp,
      Parameters.timeoutInSeconds
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var getPropertiesOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobServiceProperties,
        headersMapper: Mappers.ServiceGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.restype,
      Parameters.comp,
      Parameters.timeoutInSeconds
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getStatisticsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobServiceStatistics,
        headersMapper: Mappers.ServiceGetStatisticsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetStatisticsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.restype,
      Parameters.timeoutInSeconds,
      Parameters.comp1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var listContainersSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListContainersSegmentResponse,
        headersMapper: Mappers.ServiceListContainersSegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceListContainersSegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.include
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getUserDelegationKeyOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.UserDelegationKey,
        headersMapper: Mappers.ServiceGetUserDelegationKeyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetUserDelegationKeyExceptionHeaders
      }
    },
    requestBody: Parameters.keyInfo,
    queryParameters: [
      Parameters.restype,
      Parameters.timeoutInSeconds,
      Parameters.comp3
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var getAccountInfoOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ServiceGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var submitBatchOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.ServiceSubmitBatchHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceSubmitBatchExceptionHeaders
      }
    },
    requestBody: Parameters.body,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp4],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var filterBlobsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.FilterBlobSegment,
        headersMapper: Mappers.ServiceFilterBlobsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.comp5,
      Parameters.where
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/container.js
var require_container = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContainerImpl = undefined;
  var tslib_1 = require_tslib();
  var coreClient = tslib_1.__importStar(require_commonjs10());
  var Mappers = tslib_1.__importStar(require_mappers());
  var Parameters = tslib_1.__importStar(require_parameters());

  class ContainerImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    create(options) {
      return this.client.sendOperationRequest({ options }, createOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
    }
    getAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, getAccessPolicyOperationSpec);
    }
    setAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, setAccessPolicyOperationSpec);
    }
    restore(options) {
      return this.client.sendOperationRequest({ options }, restoreOperationSpec);
    }
    rename(sourceContainerName, options) {
      return this.client.sendOperationRequest({ sourceContainerName, options }, renameOperationSpec);
    }
    submitBatch(contentLength, multipartContentType, body, options) {
      return this.client.sendOperationRequest({ contentLength, multipartContentType, body, options }, submitBatchOperationSpec);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
    }
    releaseLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, releaseLeaseOperationSpec);
    }
    renewLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, renewLeaseOperationSpec);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
    }
    changeLease(leaseId, proposedLeaseId, options) {
      return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options }, changeLeaseOperationSpec);
    }
    listBlobFlatSegment(options) {
      return this.client.sendOperationRequest({ options }, listBlobFlatSegmentOperationSpec);
    }
    listBlobHierarchySegment(delimiter, options) {
      return this.client.sendOperationRequest({ delimiter, options }, listBlobHierarchySegmentOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
  }
  exports.ContainerImpl = ContainerImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, true);
  var createOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.access,
      Parameters.defaultEncryptionScope,
      Parameters.preventEncryptionScopeOverride
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getPropertiesOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ContainerGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var deleteOperationSpec = {
    path: "/{containerName}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: Mappers.ContainerDeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerDeleteExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setMetadataOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerSetMetadataHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSetMetadataExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp6
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "SignedIdentifier" }
            }
          },
          serializedName: "SignedIdentifiers",
          xmlName: "SignedIdentifiers",
          xmlIsWrapped: true,
          xmlElementName: "SignedIdentifier"
        },
        headersMapper: Mappers.ContainerGetAccessPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetAccessPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp7
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerSetAccessPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSetAccessPolicyExceptionHeaders
      }
    },
    requestBody: Parameters.containerAcl,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp7
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.access,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var restoreOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerRestoreHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRestoreExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp8
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.deletedContainerName,
      Parameters.deletedContainerVersion
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var renameOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerRenameHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRenameExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp9
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.sourceContainerName,
      Parameters.sourceLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var submitBatchOperationSpec = {
    path: "/{containerName}",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.ContainerSubmitBatchHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSubmitBatchExceptionHeaders
      }
    },
    requestBody: Parameters.body,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp4,
      Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var filterBlobsOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.FilterBlobSegment,
        headersMapper: Mappers.ContainerFilterBlobsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.comp5,
      Parameters.where,
      Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var acquireLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerAcquireLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action,
      Parameters.duration,
      Parameters.proposedLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var releaseLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerReleaseLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action1,
      Parameters.leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var renewLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerRenewLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action2
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var breakLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.ContainerBreakLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action3,
      Parameters.breakPeriod
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var changeLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerChangeLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action4,
      Parameters.proposedLeaseId1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var listBlobFlatSegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListBlobsFlatSegmentResponse,
        headersMapper: Mappers.ContainerListBlobFlatSegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerListBlobFlatSegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.restype2,
      Parameters.include1,
      Parameters.startFrom
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var listBlobHierarchySegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListBlobsHierarchySegmentResponse,
        headersMapper: Mappers.ContainerListBlobHierarchySegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerListBlobHierarchySegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.restype2,
      Parameters.include1,
      Parameters.startFrom,
      Parameters.delimiter
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getAccountInfoOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ContainerGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blob.js
var require_blob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobImpl = undefined;
  var tslib_1 = require_tslib();
  var coreClient = tslib_1.__importStar(require_commonjs10());
  var Mappers = tslib_1.__importStar(require_mappers());
  var Parameters = tslib_1.__importStar(require_parameters());

  class BlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    download(options) {
      return this.client.sendOperationRequest({ options }, downloadOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec);
    }
    undelete(options) {
      return this.client.sendOperationRequest({ options }, undeleteOperationSpec);
    }
    setExpiry(expiryOptions, options) {
      return this.client.sendOperationRequest({ expiryOptions, options }, setExpiryOperationSpec);
    }
    setHttpHeaders(options) {
      return this.client.sendOperationRequest({ options }, setHttpHeadersOperationSpec);
    }
    setImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, setImmutabilityPolicyOperationSpec);
    }
    deleteImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, deleteImmutabilityPolicyOperationSpec);
    }
    setLegalHold(legalHold, options) {
      return this.client.sendOperationRequest({ legalHold, options }, setLegalHoldOperationSpec);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
    }
    releaseLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, releaseLeaseOperationSpec);
    }
    renewLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, renewLeaseOperationSpec);
    }
    changeLease(leaseId, proposedLeaseId, options) {
      return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options }, changeLeaseOperationSpec);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
    }
    createSnapshot(options) {
      return this.client.sendOperationRequest({ options }, createSnapshotOperationSpec);
    }
    startCopyFromURL(copySource, options) {
      return this.client.sendOperationRequest({ copySource, options }, startCopyFromURLOperationSpec);
    }
    copyFromURL(copySource, options) {
      return this.client.sendOperationRequest({ copySource, options }, copyFromURLOperationSpec);
    }
    abortCopyFromURL(copyId, options) {
      return this.client.sendOperationRequest({ copyId, options }, abortCopyFromURLOperationSpec);
    }
    setTier(tier, options) {
      return this.client.sendOperationRequest({ tier, options }, setTierOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
    query(options) {
      return this.client.sendOperationRequest({ options }, queryOperationSpec);
    }
    getTags(options) {
      return this.client.sendOperationRequest({ options }, getTagsOperationSpec);
    }
    setTags(options) {
      return this.client.sendOperationRequest({ options }, setTagsOperationSpec);
    }
  }
  exports.BlobImpl = BlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, true);
  var downloadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobDownloadHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobDownloadHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDownloadExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.rangeGetContentMD5,
      Parameters.rangeGetContentCRC64,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getPropertiesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "HEAD",
    responses: {
      200: {
        headersMapper: Mappers.BlobGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var deleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: Mappers.BlobDeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDeleteExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.blobDeleteType
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.deleteSnapshots
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var undeleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobUndeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobUndeleteExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp8],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setExpiryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetExpiryHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetExpiryExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp11],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.expiryOptions,
      Parameters.expiresOn
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setHttpHeadersOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetHttpHeadersHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetHttpHeadersExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp12
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifUnmodifiedSince,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var deleteImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      200: {
        headersMapper: Mappers.BlobDeleteImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDeleteImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp12
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setLegalHoldOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetLegalHoldHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetLegalHoldExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp13
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.legalHold
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setMetadataOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetMetadataHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetMetadataExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp6],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var acquireLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlobAcquireLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action,
      Parameters.duration,
      Parameters.proposedLeaseId,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var releaseLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobReleaseLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action1,
      Parameters.leaseId1,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var renewLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobRenewLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action2,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var changeLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobChangeLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action4,
      Parameters.proposedLeaseId1,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var breakLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobBreakLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action3,
      Parameters.breakPeriod,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var createSnapshotOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlobCreateSnapshotHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobCreateSnapshotExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp14],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var startCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobStartCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobStartCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.tier,
      Parameters.rehydratePriority,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceIfTags,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.sealBlob,
      Parameters.legalHold1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var copyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.xMsRequiresSync,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.copySourceTags,
      Parameters.fileRequestIntent
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var abortCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: Mappers.BlobAbortCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobAbortCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp15,
      Parameters.copyId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.copyActionAbortConstant
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setTierOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetTierHeaders
      },
      202: {
        headersMapper: Mappers.BlobSetTierHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetTierExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp16
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags,
      Parameters.rehydratePriority,
      Parameters.tier1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getAccountInfoOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.BlobGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var queryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobQueryHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobQueryHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobQueryExceptionHeaders
      }
    },
    requestBody: Parameters.queryRequest,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.comp17
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var getTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobTags,
        headersMapper: Mappers.BlobGetTagsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetTagsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp18
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags,
      Parameters.ifModifiedSince1,
      Parameters.ifUnmodifiedSince1,
      Parameters.ifMatch1,
      Parameters.ifNoneMatch1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var setTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: Mappers.BlobSetTagsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetTagsExceptionHeaders
      }
    },
    requestBody: Parameters.tags,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.versionId,
      Parameters.comp18
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.leaseId,
      Parameters.ifTags,
      Parameters.ifModifiedSince1,
      Parameters.ifUnmodifiedSince1,
      Parameters.ifMatch1,
      Parameters.ifNoneMatch1,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/pageBlob.js
var require_pageBlob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PageBlobImpl = undefined;
  var tslib_1 = require_tslib();
  var coreClient = tslib_1.__importStar(require_commonjs10());
  var Mappers = tslib_1.__importStar(require_mappers());
  var Parameters = tslib_1.__importStar(require_parameters());

  class PageBlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    create(contentLength, blobContentLength, options) {
      return this.client.sendOperationRequest({ contentLength, blobContentLength, options }, createOperationSpec);
    }
    uploadPages(contentLength, body, options) {
      return this.client.sendOperationRequest({ contentLength, body, options }, uploadPagesOperationSpec);
    }
    clearPages(contentLength, options) {
      return this.client.sendOperationRequest({ contentLength, options }, clearPagesOperationSpec);
    }
    uploadPagesFromURL(sourceUrl, sourceRange, contentLength, range, options) {
      return this.client.sendOperationRequest({ sourceUrl, sourceRange, contentLength, range, options }, uploadPagesFromURLOperationSpec);
    }
    getPageRanges(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesOperationSpec);
    }
    getPageRangesDiff(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesDiffOperationSpec);
    }
    resize(blobContentLength, options) {
      return this.client.sendOperationRequest({ blobContentLength, options }, resizeOperationSpec);
    }
    updateSequenceNumber(sequenceNumberAction, options) {
      return this.client.sendOperationRequest({ sequenceNumberAction, options }, updateSequenceNumberOperationSpec);
    }
    copyIncremental(copySource, options) {
      return this.client.sendOperationRequest({ copySource, options }, copyIncrementalOperationSpec);
    }
  }
  exports.PageBlobImpl = PageBlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, true);
  var createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.blobType,
      Parameters.blobContentLength,
      Parameters.blobSequenceNumber
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var uploadPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobUploadPagesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUploadPagesExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.pageWrite,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var clearPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobClearPagesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobClearPagesExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo,
      Parameters.pageWrite1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var uploadPagesFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobUploadPagesFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUploadPagesFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.pageWrite,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo,
      Parameters.sourceUrl,
      Parameters.sourceRange,
      Parameters.sourceContentCrc64,
      Parameters.range1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getPageRangesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.PageList,
        headersMapper: Mappers.PageBlobGetPageRangesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobGetPageRangesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.snapshot,
      Parameters.comp20
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var getPageRangesDiffOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.PageList,
        headersMapper: Mappers.PageBlobGetPageRangesDiffHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobGetPageRangesDiffExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.snapshot,
      Parameters.comp20,
      Parameters.prevsnapshot
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.prevSnapshotUrl
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var resizeOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.PageBlobResizeHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobResizeExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.blobContentLength
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var updateSequenceNumberOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.PageBlobUpdateSequenceNumberHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUpdateSequenceNumberExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobSequenceNumber,
      Parameters.sequenceNumberAction
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var copyIncrementalOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.PageBlobCopyIncrementalHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobCopyIncrementalExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp21],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.copySource
    ],
    isXML: true,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/appendBlob.js
var require_appendBlob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppendBlobImpl = undefined;
  var tslib_1 = require_tslib();
  var coreClient = tslib_1.__importStar(require_commonjs10());
  var Mappers = tslib_1.__importStar(require_mappers());
  var Parameters = tslib_1.__importStar(require_parameters());

  class AppendBlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    create(contentLength, options) {
      return this.client.sendOperationRequest({ contentLength, options }, createOperationSpec);
    }
    appendBlock(contentLength, body, options) {
      return this.client.sendOperationRequest({ contentLength, body, options }, appendBlockOperationSpec);
    }
    appendBlockFromUrl(sourceUrl, contentLength, options) {
      return this.client.sendOperationRequest({ sourceUrl, contentLength, options }, appendBlockFromUrlOperationSpec);
    }
    seal(options) {
      return this.client.sendOperationRequest({ options }, sealOperationSpec);
    }
  }
  exports.AppendBlobImpl = AppendBlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, true);
  var createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.blobType1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var appendBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobAppendBlockHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobAppendBlockExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.maxSize,
      Parameters.appendPosition
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var appendBlockFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobAppendBlockFromUrlHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobAppendBlockFromUrlExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.transactionalContentMD5,
      Parameters.sourceUrl,
      Parameters.sourceContentCrc64,
      Parameters.maxSize,
      Parameters.appendPosition,
      Parameters.sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var sealOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.AppendBlobSealHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobSealExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp23],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.appendPosition
    ],
    isXML: true,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blockBlob.js
var require_blockBlob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlockBlobImpl = undefined;
  var tslib_1 = require_tslib();
  var coreClient = tslib_1.__importStar(require_commonjs10());
  var Mappers = tslib_1.__importStar(require_mappers());
  var Parameters = tslib_1.__importStar(require_parameters());

  class BlockBlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    upload(contentLength, body, options) {
      return this.client.sendOperationRequest({ contentLength, body, options }, uploadOperationSpec);
    }
    putBlobFromUrl(contentLength, copySource, options) {
      return this.client.sendOperationRequest({ contentLength, copySource, options }, putBlobFromUrlOperationSpec);
    }
    stageBlock(blockId, contentLength, body, options) {
      return this.client.sendOperationRequest({ blockId, contentLength, body, options }, stageBlockOperationSpec);
    }
    stageBlockFromURL(blockId, contentLength, sourceUrl, options) {
      return this.client.sendOperationRequest({ blockId, contentLength, sourceUrl, options }, stageBlockFromURLOperationSpec);
    }
    commitBlockList(blocks, options) {
      return this.client.sendOperationRequest({ blocks, options }, commitBlockListOperationSpec);
    }
    getBlockList(listType, options) {
      return this.client.sendOperationRequest({ listType, options }, getBlockListOperationSpec);
    }
  }
  exports.BlockBlobImpl = BlockBlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, true);
  var uploadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobUploadHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobUploadExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.blobType2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var putBlobFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobPutBlobFromUrlHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobPutBlobFromUrlExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceIfTags,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.copySourceTags,
      Parameters.fileRequestIntent,
      Parameters.transactionalContentMD5,
      Parameters.blobType2,
      Parameters.copySourceBlobProperties
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var stageBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobStageBlockHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobStageBlockExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp24,
      Parameters.blockId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var stageBlockFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobStageBlockFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobStageBlockFromURLExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp24,
      Parameters.blockId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.sourceUrl,
      Parameters.sourceContentCrc64,
      Parameters.sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var commitBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobCommitBlockListHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobCommitBlockListExceptionHeaders
      }
    },
    requestBody: Parameters.blocks,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp25],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var getBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlockList,
        headersMapper: Mappers.BlockBlobGetBlockListHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobGetBlockListExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.comp25,
      Parameters.listType
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/index.js
var require_operations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_service(), exports);
  tslib_1.__exportStar(require_container(), exports);
  tslib_1.__exportStar(require_blob(), exports);
  tslib_1.__exportStar(require_pageBlob(), exports);
  tslib_1.__exportStar(require_appendBlob(), exports);
  tslib_1.__exportStar(require_blockBlob(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/storageClient.js
var require_storageClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageClient = undefined;
  var tslib_1 = require_tslib();
  var coreHttpCompat = tslib_1.__importStar(require_commonjs11());
  var index_js_1 = require_operations();

  class StorageClient extends coreHttpCompat.ExtendedServiceClient {
    url;
    version;
    constructor(url, options) {
      if (url === undefined) {
        throw new Error("'url' cannot be null");
      }
      if (!options) {
        options = {};
      }
      const defaults = {
        requestContentType: "application/json; charset=utf-8"
      };
      const packageDetails = `azsdk-js-azure-storage-blob/12.30.0`;
      const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      const optionsWithDefaults = {
        ...defaults,
        ...options,
        userAgentOptions: {
          userAgentPrefix
        },
        endpoint: options.endpoint ?? options.baseUri ?? "{url}"
      };
      super(optionsWithDefaults);
      this.url = url;
      this.version = options.version || "2026-02-06";
      this.service = new index_js_1.ServiceImpl(this);
      this.container = new index_js_1.ContainerImpl(this);
      this.blob = new index_js_1.BlobImpl(this);
      this.pageBlob = new index_js_1.PageBlobImpl(this);
      this.appendBlob = new index_js_1.AppendBlobImpl(this);
      this.blockBlob = new index_js_1.BlockBlobImpl(this);
    }
    service;
    container;
    blob;
    pageBlob;
    appendBlob;
    blockBlob;
  }
  exports.StorageClient = StorageClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/service.js
var require_service2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/container.js
var require_container2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blob.js
var require_blob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/pageBlob.js
var require_pageBlob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/appendBlob.js
var require_appendBlob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blockBlob.js
var require_blockBlob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/index.js
var require_operationsInterfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_service2(), exports);
  tslib_1.__exportStar(require_container2(), exports);
  tslib_1.__exportStar(require_blob2(), exports);
  tslib_1.__exportStar(require_pageBlob2(), exports);
  tslib_1.__exportStar(require_appendBlob2(), exports);
  tslib_1.__exportStar(require_blockBlob2(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/index.js
var require_src2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageClient = undefined;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_models(), exports);
  var storageClient_js_1 = require_storageClient();
  Object.defineProperty(exports, "StorageClient", { enumerable: true, get: function() {
    return storageClient_js_1.StorageClient;
  } });
  tslib_1.__exportStar(require_operationsInterfaces(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageContextClient.js
var require_StorageContextClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageContextClient = undefined;
  var index_js_1 = require_src2();

  class StorageContextClient extends index_js_1.StorageClient {
    async sendOperationRequest(operationArguments, operationSpec) {
      const operationSpecToSend = { ...operationSpec };
      if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") {
        operationSpecToSend.path = "";
      }
      return super.sendOperationRequest(operationArguments, operationSpecToSend);
    }
  }
  exports.StorageContextClient = StorageContextClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/utils.common.js
var require_utils_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeURLPath = escapeURLPath;
  exports.getValueInConnString = getValueInConnString;
  exports.extractConnectionStringParts = extractConnectionStringParts;
  exports.appendToURLPath = appendToURLPath;
  exports.setURLParameter = setURLParameter;
  exports.getURLParameter = getURLParameter;
  exports.setURLHost = setURLHost;
  exports.getURLPath = getURLPath;
  exports.getURLScheme = getURLScheme;
  exports.getURLPathAndQuery = getURLPathAndQuery;
  exports.getURLQueries = getURLQueries;
  exports.appendToURLQuery = appendToURLQuery;
  exports.truncatedISO8061Date = truncatedISO8061Date;
  exports.base64encode = base64encode;
  exports.base64decode = base64decode;
  exports.generateBlockID = generateBlockID;
  exports.delay = delay;
  exports.padStart = padStart;
  exports.sanitizeURL = sanitizeURL;
  exports.sanitizeHeaders = sanitizeHeaders;
  exports.iEqual = iEqual;
  exports.getAccountNameFromUrl = getAccountNameFromUrl;
  exports.isIpEndpointStyle = isIpEndpointStyle;
  exports.toBlobTagsString = toBlobTagsString;
  exports.toBlobTags = toBlobTags;
  exports.toTags = toTags;
  exports.toQuerySerialization = toQuerySerialization;
  exports.parseObjectReplicationRecord = parseObjectReplicationRecord;
  exports.attachCredential = attachCredential;
  exports.httpAuthorizationToString = httpAuthorizationToString;
  exports.BlobNameToString = BlobNameToString;
  exports.ConvertInternalResponseOfListBlobFlat = ConvertInternalResponseOfListBlobFlat;
  exports.ConvertInternalResponseOfListBlobHierarchy = ConvertInternalResponseOfListBlobHierarchy;
  exports.ExtractPageRangeInfoItems = ExtractPageRangeInfoItems;
  exports.EscapePath = EscapePath;
  exports.assertResponse = assertResponse;
  var core_rest_pipeline_1 = require_commonjs8();
  var core_util_1 = require_commonjs6();
  var constants_js_1 = require_constants9();
  function escapeURLPath(url) {
    const urlParsed = new URL(url);
    let path = urlParsed.pathname;
    path = path || "/";
    path = escape(path);
    urlParsed.pathname = path;
    return urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      const matchCredentials = connectionString.split(";");
      for (const element of matchCredentials) {
        if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
        }
      }
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
      if (element.trim().startsWith(argument)) {
        return element.trim().match(argument + "=(.*)")[1];
      }
    }
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
      proxyUri = getProxyUriFromDevConnString(connectionString);
      connectionString = constants_js_1.DevelopmentConnectionString;
    }
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "";
      let accountName = "";
      let accountKey = Buffer.from("accountKey", "base64");
      let endpointSuffix = "";
      accountName = getValueInConnString(connectionString, "AccountName");
      accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
      if (!blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
          throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
        if (!endpointSuffix) {
          throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
      } else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
      }
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
      let accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName) {
        accountName = getAccountNameFromUrl(blobEndpoint);
      }
      if (!blobEndpoint) {
        throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
      } else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      }
      if (accountSas.startsWith("?")) {
        accountSas = accountSas.substring(1);
      }
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url, name) {
    const urlParsed = new URL(url);
    let path = urlParsed.pathname;
    path = path ? path.endsWith("/") ? `${path}${name}` : `${path}/${name}` : name;
    urlParsed.pathname = path;
    return urlParsed.toString();
  }
  function setURLParameter(url, name, value) {
    const urlParsed = new URL(url);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : undefined;
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")) {
      if (pair) {
        const [key] = pair.split("=", 2);
        if (key !== encodedName) {
          searchPieces.push(pair);
        }
      }
    }
    if (encodedValue) {
      searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
  }
  function getURLParameter(url, name) {
    const urlParsed = new URL(url);
    return urlParsed.searchParams.get(name) ?? undefined;
  }
  function setURLHost(url, host) {
    const urlParsed = new URL(url);
    urlParsed.hostname = host;
    return urlParsed.toString();
  }
  function getURLPath(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.pathname;
    } catch (e) {
      return;
    }
  }
  function getURLScheme(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return;
    }
  }
  function getURLPathAndQuery(url) {
    const urlParsed = new URL(url);
    const pathString = urlParsed.pathname;
    if (!pathString) {
      throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    }
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url) {
    let queryString = new URL(url).search;
    if (!queryString) {
      return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      const indexOfEqual = value.indexOf("=");
      const lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
      const splitResults = querySubString.split("=");
      const key = splitResults[0];
      const value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url, queryParts) {
    const urlParsed = new URL(url);
    let query = urlParsed.search;
    if (query) {
      query += "&" + queryParts;
    } else {
      query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = true) {
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000" + "Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode(content) {
    return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function base64decode(encodedString) {
    return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    const maxSourceStringLength = 48;
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
      blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode(res);
  }
  async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
      let timeout;
      const abortHandler = () => {
        if (timeout !== undefined) {
          clearTimeout(timeout);
        }
        reject(abortError);
      };
      const resolveHandler = () => {
        if (aborter !== undefined) {
          aborter.removeEventListener("abort", abortHandler);
        }
        resolve();
      };
      timeout = setTimeout(resolveHandler, timeInMs);
      if (aborter !== undefined) {
        aborter.addEventListener("abort", abortHandler);
      }
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart) {
      return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
      return currentString;
    } else {
      targetLength = targetLength - currentString.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function sanitizeURL(url) {
    let safeURL = url;
    if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) {
      safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
    }
    return safeURL;
  }
  function sanitizeHeaders(originalHeader) {
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)();
    for (const [name, value] of originalHeader) {
      if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) {
        headers.set(name, "*****");
      } else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) {
        headers.set(name, sanitizeURL(value));
      } else {
        headers.set(name, value);
      }
    }
    return headers;
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url) {
    const parsedUrl = new URL(url);
    let accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob") {
        accountName = parsedUrl.hostname.split(".")[0];
      } else if (isIpEndpointStyle(parsedUrl)) {
        accountName = parsedUrl.pathname.split("/")[1];
      } else {
        accountName = "";
      }
      return accountName;
    } catch (error) {
      throw new Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
  }
  function toBlobTagsString(tags) {
    if (tags === undefined) {
      return;
    }
    const tagPairs = [];
    for (const key in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, key)) {
        const value = tags[key];
        tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
      }
    }
    return tagPairs.join("&");
  }
  function toBlobTags(tags) {
    if (tags === undefined) {
      return;
    }
    const res = {
      blobTagSet: []
    };
    for (const key in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, key)) {
        const value = tags[key];
        res.blobTagSet.push({
          key,
          value
        });
      }
    }
    return res;
  }
  function toTags(tags) {
    if (tags === undefined) {
      return;
    }
    const res = {};
    for (const blobTag of tags.blobTagSet) {
      res[blobTag.key] = blobTag.value;
    }
    return res;
  }
  function toQuerySerialization(textConfiguration) {
    if (textConfiguration === undefined) {
      return;
    }
    switch (textConfiguration.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: textConfiguration.columnSeparator || ",",
              fieldQuote: textConfiguration.fieldQuote || "",
              recordSeparator: textConfiguration.recordSeparator,
              escapeChar: textConfiguration.escapeCharacter || "",
              headersPresent: textConfiguration.hasHeaders || false
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: textConfiguration.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: textConfiguration.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
  }
  function parseObjectReplicationRecord(objectReplicationRecord) {
    if (!objectReplicationRecord) {
      return;
    }
    if ("policy-id" in objectReplicationRecord) {
      return;
    }
    const orProperties = [];
    for (const key in objectReplicationRecord) {
      const ids = key.split("_");
      const policyPrefix = "or-";
      if (ids[0].startsWith(policyPrefix)) {
        ids[0] = ids[0].substring(policyPrefix.length);
      }
      const rule = {
        ruleId: ids[1],
        replicationStatus: objectReplicationRecord[key]
      };
      const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
      if (policyIndex > -1) {
        orProperties[policyIndex].rules.push(rule);
      } else {
        orProperties.push({
          policyId: ids[0],
          rules: [rule]
        });
      }
    }
    return orProperties;
  }
  function attachCredential(thing, credential) {
    thing.credential = credential;
    return thing;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : undefined;
  }
  function BlobNameToString(name) {
    if (name.encoded) {
      return decodeURIComponent(name.content);
    } else {
      return name.content;
    }
  }
  function ConvertInternalResponseOfListBlobFlat(internalResponse) {
    return {
      ...internalResponse,
      segment: {
        blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
          const blobItem = {
            ...blobItemInteral,
            name: BlobNameToString(blobItemInteral.name)
          };
          return blobItem;
        })
      }
    };
  }
  function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
    return {
      ...internalResponse,
      segment: {
        blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {
          const blobPrefix = {
            ...blobPrefixInternal,
            name: BlobNameToString(blobPrefixInternal.name)
          };
          return blobPrefix;
        }),
        blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
          const blobItem = {
            ...blobItemInteral,
            name: BlobNameToString(blobItemInteral.name)
          };
          return blobItem;
        })
      }
    };
  }
  function* ExtractPageRangeInfoItems(getPageRangesSegment) {
    let pageRange = [];
    let clearRange = [];
    if (getPageRangesSegment.pageRange)
      pageRange = getPageRangesSegment.pageRange;
    if (getPageRangesSegment.clearRange)
      clearRange = getPageRangesSegment.clearRange;
    let pageRangeIndex = 0;
    let clearRangeIndex = 0;
    while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {
      if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
        yield {
          start: pageRange[pageRangeIndex].start,
          end: pageRange[pageRangeIndex].end,
          isClear: false
        };
        ++pageRangeIndex;
      } else {
        yield {
          start: clearRange[clearRangeIndex].start,
          end: clearRange[clearRangeIndex].end,
          isClear: true
        };
        ++clearRangeIndex;
      }
    }
    for (;pageRangeIndex < pageRange.length; ++pageRangeIndex) {
      yield {
        start: pageRange[pageRangeIndex].start,
        end: pageRange[pageRangeIndex].end,
        isClear: false
      };
    }
    for (;clearRangeIndex < clearRange.length; ++clearRangeIndex) {
      yield {
        start: clearRange[clearRangeIndex].start,
        end: clearRange[clearRangeIndex].end,
        isClear: true
      };
    }
  }
  function EscapePath(blobName) {
    const split = blobName.split("/");
    for (let i = 0;i < split.length; i++) {
      split[i] = encodeURIComponent(split[i]);
    }
    return split.join("/");
  }
  function assertResponse(response) {
    if (`_response` in response) {
      return response;
    }
    throw new TypeError(`Unexpected response object ${response}`);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageClient.js
var require_StorageClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageClient = undefined;
  var StorageContextClient_js_1 = require_StorageContextClient();
  var Pipeline_js_1 = require_Pipeline();
  var utils_common_js_1 = require_utils_common2();

  class StorageClient {
    url;
    accountName;
    pipeline;
    credential;
    storageClientContext;
    isHttps;
    constructor(url, pipeline) {
      this.url = (0, utils_common_js_1.escapeURLPath)(url);
      this.accountName = (0, utils_common_js_1.getAccountNameFromUrl)(url);
      this.pipeline = pipeline;
      this.storageClientContext = new StorageContextClient_js_1.StorageContextClient(this.url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline));
      this.isHttps = (0, utils_common_js_1.iEqual)((0, utils_common_js_1.getURLScheme)(this.url) || "", "https");
      this.credential = (0, Pipeline_js_1.getCredentialFromPipeline)(pipeline);
      const storageClientContext = this.storageClientContext;
      storageClientContext.requestContentType = undefined;
    }
  }
  exports.StorageClient = StorageClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/tracing.js
var require_tracing = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tracingClient = undefined;
  var core_tracing_1 = require_commonjs7();
  var constants_js_1 = require_constants9();
  exports.tracingClient = (0, core_tracing_1.createTracingClient)({
    packageName: "@azure/storage-blob",
    packageVersion: constants_js_1.SDK_VERSION,
    namespace: "Microsoft.Storage"
  });
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASPermissions.js
var require_BlobSASPermissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobSASPermissions = undefined;

  class BlobSASPermissions {
    static parse(permissions) {
      const blobSASPermissions = new BlobSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            blobSASPermissions.read = true;
            break;
          case "a":
            blobSASPermissions.add = true;
            break;
          case "c":
            blobSASPermissions.create = true;
            break;
          case "w":
            blobSASPermissions.write = true;
            break;
          case "d":
            blobSASPermissions.delete = true;
            break;
          case "x":
            blobSASPermissions.deleteVersion = true;
            break;
          case "t":
            blobSASPermissions.tag = true;
            break;
          case "m":
            blobSASPermissions.move = true;
            break;
          case "e":
            blobSASPermissions.execute = true;
            break;
          case "i":
            blobSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            blobSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission: ${char}`);
        }
      }
      return blobSASPermissions;
    }
    static from(permissionLike) {
      const blobSASPermissions = new BlobSASPermissions;
      if (permissionLike.read) {
        blobSASPermissions.read = true;
      }
      if (permissionLike.add) {
        blobSASPermissions.add = true;
      }
      if (permissionLike.create) {
        blobSASPermissions.create = true;
      }
      if (permissionLike.write) {
        blobSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        blobSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        blobSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        blobSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        blobSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        blobSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        blobSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        blobSASPermissions.permanentDelete = true;
      }
      return blobSASPermissions;
    }
    read = false;
    add = false;
    create = false;
    write = false;
    delete = false;
    deleteVersion = false;
    tag = false;
    move = false;
    execute = false;
    setImmutabilityPolicy = false;
    permanentDelete = false;
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }
  exports.BlobSASPermissions = BlobSASPermissions;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/ContainerSASPermissions.js
var require_ContainerSASPermissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContainerSASPermissions = undefined;

  class ContainerSASPermissions {
    static parse(permissions) {
      const containerSASPermissions = new ContainerSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            containerSASPermissions.read = true;
            break;
          case "a":
            containerSASPermissions.add = true;
            break;
          case "c":
            containerSASPermissions.create = true;
            break;
          case "w":
            containerSASPermissions.write = true;
            break;
          case "d":
            containerSASPermissions.delete = true;
            break;
          case "l":
            containerSASPermissions.list = true;
            break;
          case "t":
            containerSASPermissions.tag = true;
            break;
          case "x":
            containerSASPermissions.deleteVersion = true;
            break;
          case "m":
            containerSASPermissions.move = true;
            break;
          case "e":
            containerSASPermissions.execute = true;
            break;
          case "i":
            containerSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            containerSASPermissions.permanentDelete = true;
            break;
          case "f":
            containerSASPermissions.filterByTags = true;
            break;
          default:
            throw new RangeError(`Invalid permission ${char}`);
        }
      }
      return containerSASPermissions;
    }
    static from(permissionLike) {
      const containerSASPermissions = new ContainerSASPermissions;
      if (permissionLike.read) {
        containerSASPermissions.read = true;
      }
      if (permissionLike.add) {
        containerSASPermissions.add = true;
      }
      if (permissionLike.create) {
        containerSASPermissions.create = true;
      }
      if (permissionLike.write) {
        containerSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        containerSASPermissions.delete = true;
      }
      if (permissionLike.list) {
        containerSASPermissions.list = true;
      }
      if (permissionLike.deleteVersion) {
        containerSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        containerSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        containerSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        containerSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        containerSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        containerSASPermissions.permanentDelete = true;
      }
      if (permissionLike.filterByTags) {
        containerSASPermissions.filterByTags = true;
      }
      return containerSASPermissions;
    }
    read = false;
    add = false;
    create = false;
    write = false;
    delete = false;
    deleteVersion = false;
    list = false;
    tag = false;
    move = false;
    execute = false;
    setImmutabilityPolicy = false;
    permanentDelete = false;
    filterByTags = false;
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      if (this.filterByTags) {
        permissions.push("f");
      }
      return permissions.join("");
    }
  }
  exports.ContainerSASPermissions = ContainerSASPermissions;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/SasIPRange.js
var require_SasIPRange = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ipRangeToString = ipRangeToString;
  function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/SASQueryParameters.js
var require_SASQueryParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SASQueryParameters = exports.SASProtocol = undefined;
  var SasIPRange_js_1 = require_SasIPRange();
  var utils_common_js_1 = require_utils_common2();
  var SASProtocol;
  (function(SASProtocol2) {
    SASProtocol2["Https"] = "https";
    SASProtocol2["HttpsAndHttp"] = "https,http";
  })(SASProtocol || (exports.SASProtocol = SASProtocol = {}));

  class SASQueryParameters {
    version;
    protocol;
    startsOn;
    expiresOn;
    permissions;
    services;
    resourceTypes;
    identifier;
    delegatedUserObjectId;
    encryptionScope;
    resource;
    signature;
    cacheControl;
    contentDisposition;
    contentEncoding;
    contentLanguage;
    contentType;
    ipRangeInner;
    signedOid;
    signedTenantId;
    signedStartsOn;
    signedExpiresOn;
    signedService;
    signedVersion;
    preauthorizedAgentObjectId;
    correlationId;
    get ipRange() {
      if (this.ipRangeInner) {
        return {
          end: this.ipRangeInner.end,
          start: this.ipRangeInner.start
        };
      }
      return;
    }
    constructor(version, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope, delegatedUserObjectId) {
      this.version = version;
      this.signature = signature;
      if (permissionsOrOptions !== undefined && typeof permissionsOrOptions !== "string") {
        this.permissions = permissionsOrOptions.permissions;
        this.services = permissionsOrOptions.services;
        this.resourceTypes = permissionsOrOptions.resourceTypes;
        this.protocol = permissionsOrOptions.protocol;
        this.startsOn = permissionsOrOptions.startsOn;
        this.expiresOn = permissionsOrOptions.expiresOn;
        this.ipRangeInner = permissionsOrOptions.ipRange;
        this.identifier = permissionsOrOptions.identifier;
        this.delegatedUserObjectId = permissionsOrOptions.delegatedUserObjectId;
        this.encryptionScope = permissionsOrOptions.encryptionScope;
        this.resource = permissionsOrOptions.resource;
        this.cacheControl = permissionsOrOptions.cacheControl;
        this.contentDisposition = permissionsOrOptions.contentDisposition;
        this.contentEncoding = permissionsOrOptions.contentEncoding;
        this.contentLanguage = permissionsOrOptions.contentLanguage;
        this.contentType = permissionsOrOptions.contentType;
        if (permissionsOrOptions.userDelegationKey) {
          this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
          this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
          this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
          this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
          this.signedService = permissionsOrOptions.userDelegationKey.signedService;
          this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
          this.correlationId = permissionsOrOptions.correlationId;
        }
      } else {
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn;
        this.permissions = permissionsOrOptions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.delegatedUserObjectId = delegatedUserObjectId;
        this.encryptionScope = encryptionScope;
        this.identifier = identifier;
        this.resource = resource;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType;
        if (userDelegationKey) {
          this.signedOid = userDelegationKey.signedObjectId;
          this.signedTenantId = userDelegationKey.signedTenantId;
          this.signedStartsOn = userDelegationKey.signedStartsOn;
          this.signedExpiresOn = userDelegationKey.signedExpiresOn;
          this.signedService = userDelegationKey.signedService;
          this.signedVersion = userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
          this.correlationId = correlationId;
        }
      }
    }
    toString() {
      const params = [
        "sv",
        "ss",
        "srt",
        "spr",
        "st",
        "se",
        "sip",
        "si",
        "ses",
        "skoid",
        "sktid",
        "skt",
        "ske",
        "sks",
        "skv",
        "sr",
        "sp",
        "sig",
        "rscc",
        "rscd",
        "rsce",
        "rscl",
        "rsct",
        "saoid",
        "scid",
        "sduoid"
      ];
      const queries = [];
      for (const param of params) {
        switch (param) {
          case "sv":
            this.tryAppendQueryParameter(queries, param, this.version);
            break;
          case "ss":
            this.tryAppendQueryParameter(queries, param, this.services);
            break;
          case "srt":
            this.tryAppendQueryParameter(queries, param, this.resourceTypes);
            break;
          case "spr":
            this.tryAppendQueryParameter(queries, param, this.protocol);
            break;
          case "st":
            this.tryAppendQueryParameter(queries, param, this.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.startsOn, false) : undefined);
            break;
          case "se":
            this.tryAppendQueryParameter(queries, param, this.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.expiresOn, false) : undefined);
            break;
          case "sip":
            this.tryAppendQueryParameter(queries, param, this.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(this.ipRange) : undefined);
            break;
          case "si":
            this.tryAppendQueryParameter(queries, param, this.identifier);
            break;
          case "ses":
            this.tryAppendQueryParameter(queries, param, this.encryptionScope);
            break;
          case "skoid":
            this.tryAppendQueryParameter(queries, param, this.signedOid);
            break;
          case "sktid":
            this.tryAppendQueryParameter(queries, param, this.signedTenantId);
            break;
          case "skt":
            this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedStartsOn, false) : undefined);
            break;
          case "ske":
            this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedExpiresOn, false) : undefined);
            break;
          case "sks":
            this.tryAppendQueryParameter(queries, param, this.signedService);
            break;
          case "skv":
            this.tryAppendQueryParameter(queries, param, this.signedVersion);
            break;
          case "sr":
            this.tryAppendQueryParameter(queries, param, this.resource);
            break;
          case "sp":
            this.tryAppendQueryParameter(queries, param, this.permissions);
            break;
          case "sig":
            this.tryAppendQueryParameter(queries, param, this.signature);
            break;
          case "rscc":
            this.tryAppendQueryParameter(queries, param, this.cacheControl);
            break;
          case "rscd":
            this.tryAppendQueryParameter(queries, param, this.contentDisposition);
            break;
          case "rsce":
            this.tryAppendQueryParameter(queries, param, this.contentEncoding);
            break;
          case "rscl":
            this.tryAppendQueryParameter(queries, param, this.contentLanguage);
            break;
          case "rsct":
            this.tryAppendQueryParameter(queries, param, this.contentType);
            break;
          case "saoid":
            this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
            break;
          case "scid":
            this.tryAppendQueryParameter(queries, param, this.correlationId);
            break;
          case "sduoid":
            this.tryAppendQueryParameter(queries, param, this.delegatedUserObjectId);
            break;
        }
      }
      return queries.join("&");
    }
    tryAppendQueryParameter(queries, key, value) {
      if (!value) {
        return;
      }
      key = encodeURIComponent(key);
      value = encodeURIComponent(value);
      if (key.length > 0 && value.length > 0) {
        queries.push(`${key}=${value}`);
      }
    }
  }
  exports.SASQueryParameters = SASQueryParameters;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASSignatureValues.js
var require_BlobSASSignatureValues = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
  exports.generateBlobSASQueryParametersInternal = generateBlobSASQueryParametersInternal;
  var BlobSASPermissions_js_1 = require_BlobSASPermissions();
  var ContainerSASPermissions_js_1 = require_ContainerSASPermissions();
  var storage_common_1 = require_commonjs13();
  var SasIPRange_js_1 = require_SasIPRange();
  var SASQueryParameters_js_1 = require_SASQueryParameters();
  var constants_js_1 = require_constants9();
  var utils_common_js_1 = require_utils_common2();
  var storage_common_2 = require_commonjs13();
  function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
  }
  function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof storage_common_1.StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : undefined;
    let userDelegationKeyCredential;
    if (sharedKeyCredential === undefined && accountName !== undefined) {
      userDelegationKeyCredential = new storage_common_2.UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {
      throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    if (version >= "2020-12-06") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
      } else {
        if (version >= "2025-07-05") {
          return generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential);
        } else {
          return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
        }
      }
    }
    if (version >= "2018-11-09") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
      } else {
        if (version >= "2020-02-10") {
          return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
        } else {
          return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
        }
      }
    }
    if (version >= "2015-04-05") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
      } else {
        throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
      }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
  }
  function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    if (blobSASSignatureValues.blobName) {
      resource = "b";
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, undefined, undefined, undefined, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      undefined,
      blobSASSignatureValues.delegatedUserObjectId,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope, blobSASSignatureValues.delegatedUserObjectId),
      stringToSign
    };
  }
  function getCanonicalName(accountName, containerName, blobName) {
    const elements = [`/blob/${accountName}/${containerName}`];
    if (blobName) {
      elements.push(`/${blobName}`);
    }
    return elements.join("");
  }
  function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
    const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    if (blobSASSignatureValues.snapshotTime && version < "2018-11-09") {
      throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {
      throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.versionId && version < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {
      throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
    }
    if (version < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
    }
    if (version < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {
      throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
    }
    if (version < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
    }
    if (blobSASSignatureValues.encryptionScope && version < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    blobSASSignatureValues.version = version;
    return blobSASSignatureValues;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobLeaseClient.js
var require_BlobLeaseClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobLeaseClient = undefined;
  var core_util_1 = require_commonjs6();
  var constants_js_1 = require_constants9();
  var tracing_js_1 = require_tracing();
  var utils_common_js_1 = require_utils_common2();

  class BlobLeaseClient {
    _leaseId;
    _url;
    _containerOrBlobOperation;
    _isContainer;
    get leaseId() {
      return this._leaseId;
    }
    get url() {
      return this._url;
    }
    constructor(client, leaseId) {
      const clientContext = client.storageClientContext;
      this._url = client.url;
      if (client.name === undefined) {
        this._isContainer = true;
        this._containerOrBlobOperation = clientContext.container;
      } else {
        this._isContainer = false;
        this._containerOrBlobOperation = clientContext.blob;
      }
      if (!leaseId) {
        leaseId = (0, core_util_1.randomUUID)();
      }
      this._leaseId = leaseId;
    }
    async acquireLease(duration, options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-acquireLease", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.acquireLease({
          abortSignal: options.abortSignal,
          duration,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          proposedLeaseId: this._leaseId,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async changeLease(proposedLeaseId, options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-changeLease", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        this._leaseId = proposedLeaseId;
        return response;
      });
    }
    async releaseLease(options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-releaseLease", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async renewLease(options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-renewLease", options, async (updatedOptions) => {
        return this._containerOrBlobOperation.renewLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    async breakLease(breakPeriod, options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-breakLease", options, async (updatedOptions) => {
        const operationOptions = {
          abortSignal: options.abortSignal,
          breakPeriod,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        };
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.breakLease(operationOptions));
      });
    }
  }
  exports.BlobLeaseClient = BlobLeaseClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/RetriableReadableStream.js
var require_RetriableReadableStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RetriableReadableStream = undefined;
  var abort_controller_1 = require_commonjs5();
  var node_stream_1 = __require("node:stream");

  class RetriableReadableStream extends node_stream_1.Readable {
    start;
    offset;
    end;
    getter;
    source;
    retries = 0;
    maxRetryRequests;
    onProgress;
    options;
    constructor(source, getter, offset, count, options = {}) {
      super({ highWaterMark: options.highWaterMark });
      this.getter = getter;
      this.source = source;
      this.start = offset;
      this.offset = offset;
      this.end = offset + count - 1;
      this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
      this.onProgress = options.onProgress;
      this.options = options;
      this.setSourceEventHandlers();
    }
    _read() {
      this.source.resume();
    }
    setSourceEventHandlers() {
      this.source.on("data", this.sourceDataHandler);
      this.source.on("end", this.sourceErrorOrEndHandler);
      this.source.on("error", this.sourceErrorOrEndHandler);
      this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
      this.source.removeListener("data", this.sourceDataHandler);
      this.source.removeListener("end", this.sourceErrorOrEndHandler);
      this.source.removeListener("error", this.sourceErrorOrEndHandler);
      this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    sourceDataHandler = (data) => {
      if (this.options.doInjectErrorOnce) {
        this.options.doInjectErrorOnce = undefined;
        this.source.pause();
        this.sourceErrorOrEndHandler();
        this.source.destroy();
        return;
      }
      this.offset += data.length;
      if (this.onProgress) {
        this.onProgress({ loadedBytes: this.offset - this.start });
      }
      if (!this.push(data)) {
        this.source.pause();
      }
    };
    sourceAbortedHandler = () => {
      const abortError = new abort_controller_1.AbortError("The operation was aborted.");
      this.destroy(abortError);
    };
    sourceErrorOrEndHandler = (err) => {
      if (err && err.name === "AbortError") {
        this.destroy(err);
        return;
      }
      this.removeSourceEventHandlers();
      if (this.offset - 1 === this.end) {
        this.push(null);
      } else if (this.offset <= this.end) {
        if (this.retries < this.maxRetryRequests) {
          this.retries += 1;
          this.getter(this.offset).then((newSource) => {
            this.source = newSource;
            this.setSourceEventHandlers();
            return;
          }).catch((error) => {
            this.destroy(error);
          });
        } else {
          this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
        }
      } else {
        this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
      }
    };
    _destroy(error, callback) {
      this.removeSourceEventHandlers();
      this.source.destroy();
      callback(error === null ? undefined : error);
    }
  }
  exports.RetriableReadableStream = RetriableReadableStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobDownloadResponse.js
var require_BlobDownloadResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobDownloadResponse = undefined;
  var core_util_1 = require_commonjs6();
  var RetriableReadableStream_js_1 = require_RetriableReadableStream();

  class BlobDownloadResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return this.originalResponse.copyCompletedOn;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get tagCount() {
      return this.originalResponse.tagCount;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get lastAccessed() {
      return this.originalResponse.lastAccessed;
    }
    get createdOn() {
      return this.originalResponse.createdOn;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get versionId() {
      return this.originalResponse.versionId;
    }
    get isCurrentVersion() {
      return this.originalResponse.isCurrentVersion;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get objectReplicationDestinationPolicyId() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    get objectReplicationSourceProperties() {
      return this.originalResponse.objectReplicationSourceProperties;
    }
    get isSealed() {
      return this.originalResponse.isSealed;
    }
    get immutabilityPolicyExpiresOn() {
      return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    get immutabilityPolicyMode() {
      return this.originalResponse.immutabilityPolicyMode;
    }
    get legalHold() {
      return this.originalResponse.legalHold;
    }
    get contentAsBlob() {
      return this.originalResponse.blobBody;
    }
    get readableStreamBody() {
      return core_util_1.isNodeLike ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    constructor(originalResponse, getter, offset, count, options = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new RetriableReadableStream_js_1.RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
  }
  exports.BlobDownloadResponse = BlobDownloadResponse;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroConstants.js
var require_AvroConstants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AVRO_SCHEMA_KEY = exports.AVRO_CODEC_KEY = exports.AVRO_INIT_BYTES = exports.AVRO_SYNC_MARKER_SIZE = undefined;
  exports.AVRO_SYNC_MARKER_SIZE = 16;
  exports.AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
  exports.AVRO_CODEC_KEY = "avro.codec";
  exports.AVRO_SCHEMA_KEY = "avro.schema";
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroParser.js
var require_AvroParser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AvroType = exports.AvroParser = undefined;

  class AvroParser {
    static async readFixedBytes(stream, length, options = {}) {
      const bytes = await stream.read(length, { abortSignal: options.abortSignal });
      if (bytes.length !== length) {
        throw new Error("Hit stream end.");
      }
      return bytes;
    }
    static async readByte(stream, options = {}) {
      const buf = await AvroParser.readFixedBytes(stream, 1, options);
      return buf[0];
    }
    static async readZigZagLong(stream, options = {}) {
      let zigZagEncoded = 0;
      let significanceInBit = 0;
      let byte, haveMoreByte, significanceInFloat;
      do {
        byte = await AvroParser.readByte(stream, options);
        haveMoreByte = byte & 128;
        zigZagEncoded |= (byte & 127) << significanceInBit;
        significanceInBit += 7;
      } while (haveMoreByte && significanceInBit < 28);
      if (haveMoreByte) {
        zigZagEncoded = zigZagEncoded;
        significanceInFloat = 268435456;
        do {
          byte = await AvroParser.readByte(stream, options);
          zigZagEncoded += (byte & 127) * significanceInFloat;
          significanceInFloat *= 128;
        } while (byte & 128);
        const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
        if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {
          throw new Error("Integer overflow.");
        }
        return res;
      }
      return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
    }
    static async readLong(stream, options = {}) {
      return AvroParser.readZigZagLong(stream, options);
    }
    static async readInt(stream, options = {}) {
      return AvroParser.readZigZagLong(stream, options);
    }
    static async readNull() {
      return null;
    }
    static async readBoolean(stream, options = {}) {
      const b = await AvroParser.readByte(stream, options);
      if (b === 1) {
        return true;
      } else if (b === 0) {
        return false;
      } else {
        throw new Error("Byte was not a boolean.");
      }
    }
    static async readFloat(stream, options = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream, 4, options);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat32(0, true);
    }
    static async readDouble(stream, options = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream, 8, options);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat64(0, true);
    }
    static async readBytes(stream, options = {}) {
      const size = await AvroParser.readLong(stream, options);
      if (size < 0) {
        throw new Error("Bytes size was negative.");
      }
      return stream.read(size, { abortSignal: options.abortSignal });
    }
    static async readString(stream, options = {}) {
      const u8arr = await AvroParser.readBytes(stream, options);
      const utf8decoder = new TextDecoder;
      return utf8decoder.decode(u8arr);
    }
    static async readMapPair(stream, readItemMethod, options = {}) {
      const key = await AvroParser.readString(stream, options);
      const value = await readItemMethod(stream, options);
      return { key, value };
    }
    static async readMap(stream, readItemMethod, options = {}) {
      const readPairMethod = (s, opts = {}) => {
        return AvroParser.readMapPair(s, readItemMethod, opts);
      };
      const pairs = await AvroParser.readArray(stream, readPairMethod, options);
      const dict = {};
      for (const pair of pairs) {
        dict[pair.key] = pair.value;
      }
      return dict;
    }
    static async readArray(stream, readItemMethod, options = {}) {
      const items = [];
      for (let count = await AvroParser.readLong(stream, options);count !== 0; count = await AvroParser.readLong(stream, options)) {
        if (count < 0) {
          await AvroParser.readLong(stream, options);
          count = -count;
        }
        while (count--) {
          const item = await readItemMethod(stream, options);
          items.push(item);
        }
      }
      return items;
    }
  }
  exports.AvroParser = AvroParser;
  var AvroComplex;
  (function(AvroComplex2) {
    AvroComplex2["RECORD"] = "record";
    AvroComplex2["ENUM"] = "enum";
    AvroComplex2["ARRAY"] = "array";
    AvroComplex2["MAP"] = "map";
    AvroComplex2["UNION"] = "union";
    AvroComplex2["FIXED"] = "fixed";
  })(AvroComplex || (AvroComplex = {}));
  var AvroPrimitive;
  (function(AvroPrimitive2) {
    AvroPrimitive2["NULL"] = "null";
    AvroPrimitive2["BOOLEAN"] = "boolean";
    AvroPrimitive2["INT"] = "int";
    AvroPrimitive2["LONG"] = "long";
    AvroPrimitive2["FLOAT"] = "float";
    AvroPrimitive2["DOUBLE"] = "double";
    AvroPrimitive2["BYTES"] = "bytes";
    AvroPrimitive2["STRING"] = "string";
  })(AvroPrimitive || (AvroPrimitive = {}));

  class AvroType {
    static fromSchema(schema) {
      if (typeof schema === "string") {
        return AvroType.fromStringSchema(schema);
      } else if (Array.isArray(schema)) {
        return AvroType.fromArraySchema(schema);
      } else {
        return AvroType.fromObjectSchema(schema);
      }
    }
    static fromStringSchema(schema) {
      switch (schema) {
        case AvroPrimitive.NULL:
        case AvroPrimitive.BOOLEAN:
        case AvroPrimitive.INT:
        case AvroPrimitive.LONG:
        case AvroPrimitive.FLOAT:
        case AvroPrimitive.DOUBLE:
        case AvroPrimitive.BYTES:
        case AvroPrimitive.STRING:
          return new AvroPrimitiveType(schema);
        default:
          throw new Error(`Unexpected Avro type ${schema}`);
      }
    }
    static fromArraySchema(schema) {
      return new AvroUnionType(schema.map(AvroType.fromSchema));
    }
    static fromObjectSchema(schema) {
      const type = schema.type;
      try {
        return AvroType.fromStringSchema(type);
      } catch {}
      switch (type) {
        case AvroComplex.RECORD:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.name) {
            throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
          }
          const fields = {};
          if (!schema.fields) {
            throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
          }
          for (const field of schema.fields) {
            fields[field.name] = AvroType.fromSchema(field.type);
          }
          return new AvroRecordType(fields, schema.name);
        case AvroComplex.ENUM:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.symbols) {
            throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
          }
          return new AvroEnumType(schema.symbols);
        case AvroComplex.MAP:
          if (!schema.values) {
            throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
          }
          return new AvroMapType(AvroType.fromSchema(schema.values));
        case AvroComplex.ARRAY:
        case AvroComplex.FIXED:
        default:
          throw new Error(`Unexpected Avro type ${type} in ${schema}`);
      }
    }
  }
  exports.AvroType = AvroType;

  class AvroPrimitiveType extends AvroType {
    _primitive;
    constructor(primitive) {
      super();
      this._primitive = primitive;
    }
    read(stream, options = {}) {
      switch (this._primitive) {
        case AvroPrimitive.NULL:
          return AvroParser.readNull();
        case AvroPrimitive.BOOLEAN:
          return AvroParser.readBoolean(stream, options);
        case AvroPrimitive.INT:
          return AvroParser.readInt(stream, options);
        case AvroPrimitive.LONG:
          return AvroParser.readLong(stream, options);
        case AvroPrimitive.FLOAT:
          return AvroParser.readFloat(stream, options);
        case AvroPrimitive.DOUBLE:
          return AvroParser.readDouble(stream, options);
        case AvroPrimitive.BYTES:
          return AvroParser.readBytes(stream, options);
        case AvroPrimitive.STRING:
          return AvroParser.readString(stream, options);
        default:
          throw new Error("Unknown Avro Primitive");
      }
    }
  }

  class AvroEnumType extends AvroType {
    _symbols;
    constructor(symbols) {
      super();
      this._symbols = symbols;
    }
    async read(stream, options = {}) {
      const value = await AvroParser.readInt(stream, options);
      return this._symbols[value];
    }
  }

  class AvroUnionType extends AvroType {
    _types;
    constructor(types) {
      super();
      this._types = types;
    }
    async read(stream, options = {}) {
      const typeIndex = await AvroParser.readInt(stream, options);
      return this._types[typeIndex].read(stream, options);
    }
  }

  class AvroMapType extends AvroType {
    _itemType;
    constructor(itemType) {
      super();
      this._itemType = itemType;
    }
    read(stream, options = {}) {
      const readItemMethod = (s, opts) => {
        return this._itemType.read(s, opts);
      };
      return AvroParser.readMap(stream, readItemMethod, options);
    }
  }

  class AvroRecordType extends AvroType {
    _name;
    _fields;
    constructor(fields, name) {
      super();
      this._fields = fields;
      this._name = name;
    }
    async read(stream, options = {}) {
      const record = {};
      record["$schema"] = this._name;
      for (const key in this._fields) {
        if (Object.prototype.hasOwnProperty.call(this._fields, key)) {
          record[key] = await this._fields[key].read(stream, options);
        }
      }
      return record;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/utils/utils.common.js
var require_utils_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arraysEqual = arraysEqual;
  function arraysEqual(a, b) {
    if (a === b)
      return true;
    if (a == null || b == null)
      return false;
    if (a.length !== b.length)
      return false;
    for (let i = 0;i < a.length; ++i) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReader.js
var require_AvroReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AvroReader = undefined;
  var AvroConstants_js_1 = require_AvroConstants();
  var AvroParser_js_1 = require_AvroParser();
  var utils_common_js_1 = require_utils_common3();

  class AvroReader {
    _dataStream;
    _headerStream;
    _syncMarker;
    _metadata;
    _itemType;
    _itemsRemainingInBlock;
    _initialBlockOffset;
    _blockOffset;
    get blockOffset() {
      return this._blockOffset;
    }
    _objectIndex;
    get objectIndex() {
      return this._objectIndex;
    }
    _initialized;
    constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
      this._dataStream = dataStream;
      this._headerStream = headerStream || dataStream;
      this._initialized = false;
      this._blockOffset = currentBlockOffset || 0;
      this._objectIndex = indexWithinCurrentBlock || 0;
      this._initialBlockOffset = currentBlockOffset || 0;
    }
    async initialize(options = {}) {
      const header = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_INIT_BYTES.length, {
        abortSignal: options.abortSignal
      });
      if (!(0, utils_common_js_1.arraysEqual)(header, AvroConstants_js_1.AVRO_INIT_BYTES)) {
        throw new Error("Stream is not an Avro file.");
      }
      this._metadata = await AvroParser_js_1.AvroParser.readMap(this._headerStream, AvroParser_js_1.AvroParser.readString, {
        abortSignal: options.abortSignal
      });
      const codec = this._metadata[AvroConstants_js_1.AVRO_CODEC_KEY];
      if (!(codec === undefined || codec === null || codec === "null")) {
        throw new Error("Codecs are not supported");
      }
      this._syncMarker = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
        abortSignal: options.abortSignal
      });
      const schema = JSON.parse(this._metadata[AvroConstants_js_1.AVRO_SCHEMA_KEY]);
      this._itemType = AvroParser_js_1.AvroType.fromSchema(schema);
      if (this._blockOffset === 0) {
        this._blockOffset = this._initialBlockOffset + this._dataStream.position;
      }
      this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
        abortSignal: options.abortSignal
      });
      await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
      this._initialized = true;
      if (this._objectIndex && this._objectIndex > 0) {
        for (let i = 0;i < this._objectIndex; i++) {
          await this._itemType.read(this._dataStream, { abortSignal: options.abortSignal });
          this._itemsRemainingInBlock--;
        }
      }
    }
    hasNext() {
      return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    async* parseObjects(options = {}) {
      if (!this._initialized) {
        await this.initialize(options);
      }
      while (this.hasNext()) {
        const result = await this._itemType.read(this._dataStream, {
          abortSignal: options.abortSignal
        });
        this._itemsRemainingInBlock--;
        this._objectIndex++;
        if (this._itemsRemainingInBlock === 0) {
          const marker = await AvroParser_js_1.AvroParser.readFixedBytes(this._dataStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
            abortSignal: options.abortSignal
          });
          this._blockOffset = this._initialBlockOffset + this._dataStream.position;
          this._objectIndex = 0;
          if (!(0, utils_common_js_1.arraysEqual)(this._syncMarker, marker)) {
            throw new Error("Stream is not a valid Avro file.");
          }
          try {
            this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
              abortSignal: options.abortSignal
            });
          } catch {
            this._itemsRemainingInBlock = 0;
          }
          if (this._itemsRemainingInBlock > 0) {
            await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
          }
        }
        yield result;
      }
    }
  }
  exports.AvroReader = AvroReader;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadable.js
var require_AvroReadable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AvroReadable = undefined;

  class AvroReadable {
  }
  exports.AvroReadable = AvroReadable;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadableFromStream.js
var require_AvroReadableFromStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AvroReadableFromStream = undefined;
  var AvroReadable_js_1 = require_AvroReadable();
  var abort_controller_1 = require_commonjs5();
  var buffer_1 = __require("buffer");
  var ABORT_ERROR = new abort_controller_1.AbortError("Reading from the avro stream was aborted.");

  class AvroReadableFromStream extends AvroReadable_js_1.AvroReadable {
    _position;
    _readable;
    toUint8Array(data) {
      if (typeof data === "string") {
        return buffer_1.Buffer.from(data);
      }
      return data;
    }
    constructor(readable) {
      super();
      this._readable = readable;
      this._position = 0;
    }
    get position() {
      return this._position;
    }
    async read(size, options = {}) {
      if (options.abortSignal?.aborted) {
        throw ABORT_ERROR;
      }
      if (size < 0) {
        throw new Error(`size parameter should be positive: ${size}`);
      }
      if (size === 0) {
        return new Uint8Array;
      }
      if (!this._readable.readable) {
        throw new Error("Stream no longer readable.");
      }
      const chunk = this._readable.read(size);
      if (chunk) {
        this._position += chunk.length;
        return this.toUint8Array(chunk);
      } else {
        return new Promise((resolve, reject) => {
          const cleanUp = () => {
            this._readable.removeListener("readable", readableCallback);
            this._readable.removeListener("error", rejectCallback);
            this._readable.removeListener("end", rejectCallback);
            this._readable.removeListener("close", rejectCallback);
            if (options.abortSignal) {
              options.abortSignal.removeEventListener("abort", abortHandler);
            }
          };
          const readableCallback = () => {
            const callbackChunk = this._readable.read(size);
            if (callbackChunk) {
              this._position += callbackChunk.length;
              cleanUp();
              resolve(this.toUint8Array(callbackChunk));
            }
          };
          const rejectCallback = () => {
            cleanUp();
            reject();
          };
          const abortHandler = () => {
            cleanUp();
            reject(ABORT_ERROR);
          };
          this._readable.on("readable", readableCallback);
          this._readable.once("error", rejectCallback);
          this._readable.once("end", rejectCallback);
          this._readable.once("close", rejectCallback);
          if (options.abortSignal) {
            options.abortSignal.addEventListener("abort", abortHandler);
          }
        });
      }
    }
  }
  exports.AvroReadableFromStream = AvroReadableFromStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/index.js
var require_internal_avro = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AvroReadableFromStream = exports.AvroReadable = exports.AvroReader = undefined;
  var AvroReader_js_1 = require_AvroReader();
  Object.defineProperty(exports, "AvroReader", { enumerable: true, get: function() {
    return AvroReader_js_1.AvroReader;
  } });
  var AvroReadable_js_1 = require_AvroReadable();
  Object.defineProperty(exports, "AvroReadable", { enumerable: true, get: function() {
    return AvroReadable_js_1.AvroReadable;
  } });
  var AvroReadableFromStream_js_1 = require_AvroReadableFromStream();
  Object.defineProperty(exports, "AvroReadableFromStream", { enumerable: true, get: function() {
    return AvroReadableFromStream_js_1.AvroReadableFromStream;
  } });
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/BlobQuickQueryStream.js
var require_BlobQuickQueryStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobQuickQueryStream = undefined;
  var node_stream_1 = __require("node:stream");
  var index_js_1 = require_internal_avro();

  class BlobQuickQueryStream extends node_stream_1.Readable {
    source;
    avroReader;
    avroIter;
    avroPaused = true;
    onProgress;
    onError;
    constructor(source, options = {}) {
      super();
      this.source = source;
      this.onProgress = options.onProgress;
      this.onError = options.onError;
      this.avroReader = new index_js_1.AvroReader(new index_js_1.AvroReadableFromStream(this.source));
      this.avroIter = this.avroReader.parseObjects({ abortSignal: options.abortSignal });
    }
    _read() {
      if (this.avroPaused) {
        this.readInternal().catch((err) => {
          this.emit("error", err);
        });
      }
    }
    async readInternal() {
      this.avroPaused = false;
      let avroNext;
      do {
        avroNext = await this.avroIter.next();
        if (avroNext.done) {
          break;
        }
        const obj = avroNext.value;
        const schema = obj.$schema;
        if (typeof schema !== "string") {
          throw Error("Missing schema in avro record.");
        }
        switch (schema) {
          case "com.microsoft.azure.storage.queryBlobContents.resultData":
            {
              const data = obj.data;
              if (data instanceof Uint8Array === false) {
                throw Error("Invalid data in avro result record.");
              }
              if (!this.push(Buffer.from(data))) {
                this.avroPaused = true;
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.progress":
            {
              const bytesScanned = obj.bytesScanned;
              if (typeof bytesScanned !== "number") {
                throw Error("Invalid bytesScanned in avro progress record.");
              }
              if (this.onProgress) {
                this.onProgress({ loadedBytes: bytesScanned });
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.end":
            if (this.onProgress) {
              const totalBytes = obj.totalBytes;
              if (typeof totalBytes !== "number") {
                throw Error("Invalid totalBytes in avro end record.");
              }
              this.onProgress({ loadedBytes: totalBytes });
            }
            this.push(null);
            break;
          case "com.microsoft.azure.storage.queryBlobContents.error":
            if (this.onError) {
              const fatal = obj.fatal;
              if (typeof fatal !== "boolean") {
                throw Error("Invalid fatal in avro error record.");
              }
              const name = obj.name;
              if (typeof name !== "string") {
                throw Error("Invalid name in avro error record.");
              }
              const description = obj.description;
              if (typeof description !== "string") {
                throw Error("Invalid description in avro error record.");
              }
              const position = obj.position;
              if (typeof position !== "number") {
                throw Error("Invalid position in avro error record.");
              }
              this.onError({
                position,
                name,
                isFatal: fatal,
                description
              });
            }
            break;
          default:
            throw Error(`Unknown schema ${schema} in avro progress record.`);
        }
      } while (!avroNext.done && !this.avroPaused);
    }
  }
  exports.BlobQuickQueryStream = BlobQuickQueryStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobQueryResponse.js
var require_BlobQueryResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobQueryResponse = undefined;
  var core_util_1 = require_commonjs6();
  var BlobQuickQueryStream_js_1 = require_BlobQuickQueryStream();

  class BlobQueryResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get blobBody() {
      return;
    }
    get readableStreamBody() {
      return core_util_1.isNodeLike ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    constructor(originalResponse, options = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new BlobQuickQueryStream_js_1.BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
    }
  }
  exports.BlobQueryResponse = BlobQueryResponse;
});

// node_modules/@azure/storage-blob/dist/commonjs/models.js
var require_models2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = undefined;
  exports.toAccessTier = toAccessTier;
  exports.ensureCpkIfSpecified = ensureCpkIfSpecified;
  exports.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
  var constants_js_1 = require_constants9();
  var BlockBlobTier;
  (function(BlockBlobTier2) {
    BlockBlobTier2["Hot"] = "Hot";
    BlockBlobTier2["Cool"] = "Cool";
    BlockBlobTier2["Cold"] = "Cold";
    BlockBlobTier2["Archive"] = "Archive";
  })(BlockBlobTier || (exports.BlockBlobTier = BlockBlobTier = {}));
  var PremiumPageBlobTier;
  (function(PremiumPageBlobTier2) {
    PremiumPageBlobTier2["P4"] = "P4";
    PremiumPageBlobTier2["P6"] = "P6";
    PremiumPageBlobTier2["P10"] = "P10";
    PremiumPageBlobTier2["P15"] = "P15";
    PremiumPageBlobTier2["P20"] = "P20";
    PremiumPageBlobTier2["P30"] = "P30";
    PremiumPageBlobTier2["P40"] = "P40";
    PremiumPageBlobTier2["P50"] = "P50";
    PremiumPageBlobTier2["P60"] = "P60";
    PremiumPageBlobTier2["P70"] = "P70";
    PremiumPageBlobTier2["P80"] = "P80";
  })(PremiumPageBlobTier || (exports.PremiumPageBlobTier = PremiumPageBlobTier = {}));
  function toAccessTier(tier) {
    if (tier === undefined) {
      return;
    }
    return tier;
  }
  function ensureCpkIfSpecified(cpk, isHttps) {
    if (cpk && !isHttps) {
      throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
    }
    if (cpk && !cpk.encryptionAlgorithm) {
      cpk.encryptionAlgorithm = constants_js_1.EncryptionAlgorithmAES25;
    }
  }
  var StorageBlobAudience;
  (function(StorageBlobAudience2) {
    StorageBlobAudience2["StorageOAuthScopes"] = "https://storage.azure.com/.default";
    StorageBlobAudience2["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
  })(StorageBlobAudience || (exports.StorageBlobAudience = StorageBlobAudience = {}));
  function getBlobServiceAccountAudience(storageAccountName) {
    return `https://${storageAccountName}.blob.core.windows.net/.default`;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/PageBlobRangeResponse.js
var require_PageBlobRangeResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rangeResponseFromModel = rangeResponseFromModel;
  function rangeResponseFromModel(response) {
    const pageRange = (response._response.parsedBody.pageRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    const clearRange = (response._response.parsedBody.clearRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    return {
      ...response,
      pageRange,
      clearRange,
      _response: {
        ...response._response,
        parsedBody: {
          pageRange,
          clearRange
        }
      }
    };
  }
});

// node_modules/@azure/core-lro/dist/commonjs/logger.js
var require_logger2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs4();
  exports.logger = (0, logger_1.createClientLogger)("core-lro");
});

// node_modules/@azure/core-lro/dist/commonjs/poller/constants.js
var require_constants10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.terminalStates = exports.POLL_INTERVAL_IN_MS = undefined;
  exports.POLL_INTERVAL_IN_MS = 2000;
  exports.terminalStates = ["succeeded", "canceled", "failed"];
});

// node_modules/@azure/core-lro/dist/commonjs/poller/operation.js
var require_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollOperation = exports.initOperation = exports.deserializeState = undefined;
  var logger_js_1 = require_logger2();
  var constants_js_1 = require_constants10();
  function deserializeState(serializedState) {
    try {
      return JSON.parse(serializedState).state;
    } catch (e) {
      throw new Error(`Unable to deserialize input state: ${serializedState}`);
    }
  }
  exports.deserializeState = deserializeState;
  function setStateError(inputs) {
    const { state, stateProxy, isOperationError } = inputs;
    return (error) => {
      if (isOperationError(error)) {
        stateProxy.setError(state, error);
        stateProxy.setFailed(state);
      }
      throw error;
    };
  }
  function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".") {
      message = message + ".";
    }
    return message + " " + innerMessage;
  }
  function simplifyError(err) {
    let message = err.message;
    let code = err.code;
    let curErr = err;
    while (curErr.innererror) {
      curErr = curErr.innererror;
      code = curErr.code;
      message = appendReadableErrorMessage(message, curErr.message);
    }
    return {
      code,
      message
    };
  }
  function processOperationStatus(result) {
    const { state, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } = result;
    switch (status) {
      case "succeeded": {
        stateProxy.setSucceeded(state);
        break;
      }
      case "failed": {
        const err = getError === null || getError === undefined ? undefined : getError(response);
        let postfix = "";
        if (err) {
          const { code, message } = simplifyError(err);
          postfix = `. ${code}. ${message}`;
        }
        const errStr = `The long-running operation has failed${postfix}`;
        stateProxy.setError(state, new Error(errStr));
        stateProxy.setFailed(state);
        logger_js_1.logger.warning(errStr);
        break;
      }
      case "canceled": {
        stateProxy.setCanceled(state);
        break;
      }
    }
    if ((isDone === null || isDone === undefined ? undefined : isDone(response, state)) || isDone === undefined && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
      stateProxy.setResult(state, buildResult({
        response,
        state,
        processResult
      }));
    }
  }
  function buildResult(inputs) {
    const { processResult, response, state } = inputs;
    return processResult ? processResult(response, state) : response;
  }
  async function initOperation(inputs) {
    const { init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs;
    const { operationLocation, resourceLocation, metadata, response } = await init();
    if (operationLocation)
      withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
    const config = {
      metadata,
      operationLocation,
      resourceLocation
    };
    logger_js_1.logger.verbose(`LRO: Operation description:`, config);
    const state = stateProxy.initState(config);
    const status = getOperationStatus({ response, state, operationLocation });
    processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });
    return state;
  }
  exports.initOperation = initOperation;
  async function pollOperationHelper(inputs) {
    const { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options } = inputs;
    const response = await poll(operationLocation, options).catch(setStateError({
      state,
      stateProxy,
      isOperationError
    }));
    const status = getOperationStatus(response, state);
    logger_js_1.logger.verbose(`LRO: Status:
	Polling from: ${state.config.operationLocation}
	Operation status: ${status}
	Polling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`);
    if (status === "succeeded") {
      const resourceLocation = getResourceLocation(response, state);
      if (resourceLocation !== undefined) {
        return {
          response: await poll(resourceLocation).catch(setStateError({ state, stateProxy, isOperationError })),
          status
        };
      }
    }
    return { response, status };
  }
  async function pollOperation(inputs) {
    const { poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs;
    const { operationLocation } = state.config;
    if (operationLocation !== undefined) {
      const { response, status } = await pollOperationHelper({
        poll,
        getOperationStatus,
        state,
        stateProxy,
        operationLocation,
        getResourceLocation,
        isOperationError,
        options
      });
      processOperationStatus({
        status,
        response,
        state,
        stateProxy,
        isDone,
        processResult,
        getError,
        setErrorAsResult
      });
      if (!constants_js_1.terminalStates.includes(status)) {
        const intervalInMs = getPollingInterval === null || getPollingInterval === undefined ? undefined : getPollingInterval(response);
        if (intervalInMs)
          setDelay(intervalInMs);
        const location = getOperationLocation === null || getOperationLocation === undefined ? undefined : getOperationLocation(response, state);
        if (location !== undefined) {
          const isUpdated = operationLocation !== location;
          state.config.operationLocation = location;
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(location, isUpdated);
        } else
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
      }
      updateState === null || updateState === undefined || updateState(state, response);
    }
  }
  exports.pollOperation = pollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/http/operation.js
var require_operation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollHttpOperation = exports.isOperationError = exports.getResourceLocation = exports.getOperationStatus = exports.getOperationLocation = exports.initHttpOperation = exports.getStatusFromInitialResponse = exports.getErrorFromResponse = exports.parseRetryAfter = exports.inferLroMode = undefined;
  var operation_js_1 = require_operation();
  var logger_js_1 = require_logger2();
  function getOperationLocationPollingUrl(inputs) {
    const { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== undefined ? operationLocation : azureAsyncOperation;
  }
  function getLocationHeader(rawResponse) {
    return rawResponse.headers["location"];
  }
  function getOperationLocationHeader(rawResponse) {
    return rawResponse.headers["operation-location"];
  }
  function getAzureAsyncOperationHeader(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
  }
  function findResourceLocation(inputs) {
    var _a;
    const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
    switch (requestMethod) {
      case "PUT": {
        return requestPath;
      }
      case "DELETE": {
        return;
      }
      case "PATCH": {
        return (_a = getDefault()) !== null && _a !== undefined ? _a : requestPath;
      }
      default: {
        return getDefault();
      }
    }
    function getDefault() {
      switch (resourceLocationConfig) {
        case "azure-async-operation": {
          return;
        }
        case "original-uri": {
          return requestPath;
        }
        case "location":
        default: {
          return location;
        }
      }
    }
  }
  function inferLroMode(inputs) {
    const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
    const operationLocation = getOperationLocationHeader(rawResponse);
    const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
    const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
    const location = getLocationHeader(rawResponse);
    const normalizedRequestMethod = requestMethod === null || requestMethod === undefined ? undefined : requestMethod.toLocaleUpperCase();
    if (pollingUrl !== undefined) {
      return {
        mode: "OperationLocation",
        operationLocation: pollingUrl,
        resourceLocation: findResourceLocation({
          requestMethod: normalizedRequestMethod,
          location,
          requestPath,
          resourceLocationConfig
        })
      };
    } else if (location !== undefined) {
      return {
        mode: "ResourceLocation",
        operationLocation: location
      };
    } else if (normalizedRequestMethod === "PUT" && requestPath) {
      return {
        mode: "Body",
        operationLocation: requestPath
      };
    } else {
      return;
    }
  }
  exports.inferLroMode = inferLroMode;
  function transformStatus(inputs) {
    const { status, statusCode } = inputs;
    if (typeof status !== "string" && status !== undefined) {
      throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
    }
    switch (status === null || status === undefined ? undefined : status.toLocaleLowerCase()) {
      case undefined:
        return toOperationStatus(statusCode);
      case "succeeded":
        return "succeeded";
      case "failed":
        return "failed";
      case "running":
      case "accepted":
      case "started":
      case "canceling":
      case "cancelling":
        return "running";
      case "canceled":
      case "cancelled":
        return "canceled";
      default: {
        logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`);
        return status;
      }
    }
  }
  function getStatus(rawResponse) {
    var _a;
    const { status } = (_a = rawResponse.body) !== null && _a !== undefined ? _a : {};
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function getProvisioningState(rawResponse) {
    var _a, _b;
    const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== undefined ? _a : {};
    const status = (_b = properties === null || properties === undefined ? undefined : properties.provisioningState) !== null && _b !== undefined ? _b : provisioningState;
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function toOperationStatus(statusCode) {
    if (statusCode === 202) {
      return "running";
    } else if (statusCode < 300) {
      return "succeeded";
    } else {
      return "failed";
    }
  }
  function parseRetryAfter({ rawResponse }) {
    const retryAfter = rawResponse.headers["retry-after"];
    if (retryAfter !== undefined) {
      const retryAfterInSeconds = parseInt(retryAfter);
      return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;
    }
    return;
  }
  exports.parseRetryAfter = parseRetryAfter;
  function getErrorFromResponse(response) {
    const error = accessBodyProperty(response, "error");
    if (!error) {
      logger_js_1.logger.warning(`The long-running operation failed but there is no error property in the response's body`);
      return;
    }
    if (!error.code || !error.message) {
      logger_js_1.logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
      return;
    }
    return error;
  }
  exports.getErrorFromResponse = getErrorFromResponse;
  function calculatePollingIntervalFromDate(retryAfterDate) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
      return retryAfterTime - timeNow;
    }
    return;
  }
  function getStatusFromInitialResponse(inputs) {
    const { response, state, operationLocation } = inputs;
    function helper() {
      var _a;
      const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
      switch (mode) {
        case undefined:
          return toOperationStatus(response.rawResponse.statusCode);
        case "Body":
          return getOperationStatus(response, state);
        default:
          return "running";
      }
    }
    const status = helper();
    return status === "running" && operationLocation === undefined ? "succeeded" : status;
  }
  exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
  async function initHttpOperation(inputs) {
    const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
    return (0, operation_js_1.initOperation)({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = inferLroMode({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      stateProxy,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse,
      getOperationStatus: getStatusFromInitialResponse,
      setErrorAsResult
    });
  }
  exports.initHttpOperation = initHttpOperation;
  function getOperationLocation({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getOperationLocationPollingUrl({
          operationLocation: getOperationLocationHeader(rawResponse),
          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
        });
      }
      case "ResourceLocation": {
        return getLocationHeader(rawResponse);
      }
      case "Body":
      default: {
        return;
      }
    }
  }
  exports.getOperationLocation = getOperationLocation;
  function getOperationStatus({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getStatus(rawResponse);
      }
      case "ResourceLocation": {
        return toOperationStatus(rawResponse.statusCode);
      }
      case "Body": {
        return getProvisioningState(rawResponse);
      }
      default:
        throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
    }
  }
  exports.getOperationStatus = getOperationStatus;
  function accessBodyProperty({ flatResponse, rawResponse }, prop) {
    var _a, _b;
    return (_a = flatResponse === null || flatResponse === undefined ? undefined : flatResponse[prop]) !== null && _a !== undefined ? _a : (_b = rawResponse.body) === null || _b === undefined ? undefined : _b[prop];
  }
  function getResourceLocation(res, state) {
    const loc = accessBodyProperty(res, "resourceLocation");
    if (loc && typeof loc === "string") {
      state.config.resourceLocation = loc;
    }
    return state.config.resourceLocation;
  }
  exports.getResourceLocation = getResourceLocation;
  function isOperationError(e) {
    return e.name === "RestError";
  }
  exports.isOperationError = isOperationError;
  async function pollHttpOperation(inputs) {
    const { lro, stateProxy, options, processResult, updateState, setDelay, state, setErrorAsResult } = inputs;
    return (0, operation_js_1.pollOperation)({
      state,
      stateProxy,
      setDelay,
      processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
      getError: getErrorFromResponse,
      updateState,
      getPollingInterval: parseRetryAfter,
      getOperationLocation,
      getOperationStatus,
      isOperationError,
      getResourceLocation,
      options,
      poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
      setErrorAsResult
    });
  }
  exports.pollHttpOperation = pollHttpOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/poller/poller.js
var require_poller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildCreatePoller = undefined;
  var operation_js_1 = require_operation();
  var constants_js_1 = require_constants10();
  var core_util_1 = require_commonjs6();
  var createStateProxy = () => ({
    initState: (config) => ({ status: "running", config }),
    setCanceled: (state) => state.status = "canceled",
    setError: (state, error) => state.error = error,
    setResult: (state, result) => state.result = result,
    setRunning: (state) => state.status = "running",
    setSucceeded: (state) => state.status = "succeeded",
    setFailed: (state) => state.status = "failed",
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => state.status === "canceled",
    isFailed: (state) => state.status === "failed",
    isRunning: (state) => state.status === "running",
    isSucceeded: (state) => state.status === "succeeded"
  });
  function buildCreatePoller(inputs) {
    const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
    return async ({ init, poll }, options) => {
      const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options || {};
      const stateProxy = createStateProxy();
      const withOperationLocation = withOperationLocationCallback ? (() => {
        let called = false;
        return (operationLocation, isUpdated) => {
          if (isUpdated)
            withOperationLocationCallback(operationLocation);
          else if (!called)
            withOperationLocationCallback(operationLocation);
          called = true;
        };
      })() : undefined;
      const state = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
        init,
        stateProxy,
        processResult,
        getOperationStatus: getStatusFromInitialResponse,
        withOperationLocation,
        setErrorAsResult: !resolveOnUnsuccessful
      });
      let resultPromise;
      const abortController = new AbortController;
      const handlers = new Map;
      const handleProgressEvents = async () => handlers.forEach((h) => h(state));
      const cancelErrMsg = "Operation was canceled";
      let currentPollIntervalInMs = intervalInMs;
      const poller = {
        getOperationState: () => state,
        getResult: () => state.result,
        isDone: () => ["succeeded", "failed", "canceled"].includes(state.status),
        isStopped: () => resultPromise === undefined,
        stopPolling: () => {
          abortController.abort();
        },
        toString: () => JSON.stringify({
          state
        }),
        onProgress: (callback) => {
          const s = Symbol();
          handlers.set(s, callback);
          return () => handlers.delete(s);
        },
        pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== undefined ? resultPromise : resultPromise = (async () => {
          const { abortSignal: inputAbortSignal } = pollOptions || {};
          function abortListener() {
            abortController.abort();
          }
          const abortSignal = abortController.signal;
          if (inputAbortSignal === null || inputAbortSignal === undefined ? undefined : inputAbortSignal.aborted) {
            abortController.abort();
          } else if (!abortSignal.aborted) {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.addEventListener("abort", abortListener, { once: true });
          }
          try {
            if (!poller.isDone()) {
              await poller.poll({ abortSignal });
              while (!poller.isDone()) {
                await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal });
                await poller.poll({ abortSignal });
              }
            }
          } finally {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.removeEventListener("abort", abortListener);
          }
          if (resolveOnUnsuccessful) {
            return poller.getResult();
          } else {
            switch (state.status) {
              case "succeeded":
                return poller.getResult();
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
              case "notStarted":
              case "running":
                throw new Error(`Polling completed without succeeding or failing`);
            }
          }
        })().finally(() => {
          resultPromise = undefined;
        }),
        async poll(pollOptions) {
          if (resolveOnUnsuccessful) {
            if (poller.isDone())
              return;
          } else {
            switch (state.status) {
              case "succeeded":
                return;
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
            }
          }
          await (0, operation_js_1.pollOperation)({
            poll,
            state,
            stateProxy,
            getOperationLocation,
            isOperationError,
            withOperationLocation,
            getPollingInterval,
            getOperationStatus: getStatusFromPollResponse,
            getResourceLocation,
            processResult,
            getError,
            updateState,
            options: pollOptions,
            setDelay: (pollIntervalInMs) => {
              currentPollIntervalInMs = pollIntervalInMs;
            },
            setErrorAsResult: !resolveOnUnsuccessful
          });
          await handleProgressEvents();
          if (!resolveOnUnsuccessful) {
            switch (state.status) {
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
            }
          }
        }
      };
      return poller;
    };
  }
  exports.buildCreatePoller = buildCreatePoller;
});

// node_modules/@azure/core-lro/dist/commonjs/http/poller.js
var require_poller2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var operation_js_1 = require_operation2();
  var poller_js_1 = require_poller();
  async function createHttpPoller(lro, options) {
    const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options || {};
    return (0, poller_js_1.buildCreatePoller)({
      getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
      getStatusFromPollResponse: operation_js_1.getOperationStatus,
      isOperationError: operation_js_1.isOperationError,
      getOperationLocation: operation_js_1.getOperationLocation,
      getResourceLocation: operation_js_1.getResourceLocation,
      getPollingInterval: operation_js_1.parseRetryAfter,
      getError: operation_js_1.getErrorFromResponse,
      resolveOnUnsuccessful
    })({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = (0, operation_js_1.inferLroMode)({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      poll: lro.sendPollRequest
    }, {
      intervalInMs,
      withOperationLocation,
      restoreFrom,
      updateState,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse
    });
  }
  exports.createHttpPoller = createHttpPoller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/operation.js
var require_operation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GenericPollOperation = undefined;
  var operation_js_1 = require_operation2();
  var logger_js_1 = require_logger2();
  var createStateProxy = () => ({
    initState: (config) => ({ config, isStarted: true }),
    setCanceled: (state) => state.isCancelled = true,
    setError: (state, error) => state.error = error,
    setResult: (state, result) => state.result = result,
    setRunning: (state) => state.isStarted = true,
    setSucceeded: (state) => state.isCompleted = true,
    setFailed: () => {},
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => !!state.isCancelled,
    isFailed: (state) => !!state.error,
    isRunning: (state) => !!state.isStarted,
    isSucceeded: (state) => Boolean(state.isCompleted && !state.isCancelled && !state.error)
  });

  class GenericPollOperation {
    constructor(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
      this.state = state;
      this.lro = lro;
      this.setErrorAsResult = setErrorAsResult;
      this.lroResourceLocationConfig = lroResourceLocationConfig;
      this.processResult = processResult;
      this.updateState = updateState;
      this.isDone = isDone;
    }
    setPollerConfig(pollerConfig) {
      this.pollerConfig = pollerConfig;
    }
    async update(options) {
      var _a;
      const stateProxy = createStateProxy();
      if (!this.state.isStarted) {
        this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
          lro: this.lro,
          stateProxy,
          resourceLocationConfig: this.lroResourceLocationConfig,
          processResult: this.processResult,
          setErrorAsResult: this.setErrorAsResult
        }));
      }
      const updateState = this.updateState;
      const isDone = this.isDone;
      if (!this.state.isCompleted && this.state.error === undefined) {
        await (0, operation_js_1.pollHttpOperation)({
          lro: this.lro,
          state: this.state,
          stateProxy,
          processResult: this.processResult,
          updateState: updateState ? (state, { rawResponse }) => updateState(state, rawResponse) : undefined,
          isDone: isDone ? ({ flatResponse }, state) => isDone(flatResponse, state) : undefined,
          options,
          setDelay: (intervalInMs) => {
            this.pollerConfig.intervalInMs = intervalInMs;
          },
          setErrorAsResult: this.setErrorAsResult
        });
      }
      (_a = options === null || options === undefined ? undefined : options.fireProgress) === null || _a === undefined || _a.call(options, this.state);
      return this;
    }
    async cancel() {
      logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
      return this;
    }
    toString() {
      return JSON.stringify({
        state: this.state
      });
    }
  }
  exports.GenericPollOperation = GenericPollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/poller.js
var require_poller3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Poller = exports.PollerCancelledError = exports.PollerStoppedError = undefined;

  class PollerStoppedError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerStoppedError";
      Object.setPrototypeOf(this, PollerStoppedError.prototype);
    }
  }
  exports.PollerStoppedError = PollerStoppedError;

  class PollerCancelledError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerCancelledError";
      Object.setPrototypeOf(this, PollerCancelledError.prototype);
    }
  }
  exports.PollerCancelledError = PollerCancelledError;

  class Poller {
    constructor(operation) {
      this.resolveOnUnsuccessful = false;
      this.stopped = true;
      this.pollProgressCallbacks = [];
      this.operation = operation;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      this.promise.catch(() => {});
    }
    async startPolling(pollOptions = {}) {
      if (this.stopped) {
        this.stopped = false;
      }
      while (!this.isStopped() && !this.isDone()) {
        await this.poll(pollOptions);
        await this.delay();
      }
    }
    async pollOnce(options = {}) {
      if (!this.isDone()) {
        this.operation = await this.operation.update({
          abortSignal: options.abortSignal,
          fireProgress: this.fireProgress.bind(this)
        });
      }
      this.processUpdatedState();
    }
    fireProgress(state) {
      for (const callback of this.pollProgressCallbacks) {
        callback(state);
      }
    }
    async cancelOnce(options = {}) {
      this.operation = await this.operation.cancel(options);
    }
    poll(options = {}) {
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(options);
        const clearPollOncePromise = () => {
          this.pollOncePromise = undefined;
        };
        this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
      }
      return this.pollOncePromise;
    }
    processUpdatedState() {
      if (this.operation.state.error) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          this.reject(this.operation.state.error);
          throw this.operation.state.error;
        }
      }
      if (this.operation.state.isCancelled) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          const error = new PollerCancelledError("Operation was canceled");
          this.reject(error);
          throw error;
        }
      }
      if (this.isDone() && this.resolve) {
        this.resolve(this.getResult());
      }
    }
    async pollUntilDone(pollOptions = {}) {
      if (this.stopped) {
        this.startPolling(pollOptions).catch(this.reject);
      }
      this.processUpdatedState();
      return this.promise;
    }
    onProgress(callback) {
      this.pollProgressCallbacks.push(callback);
      return () => {
        this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);
      };
    }
    isDone() {
      const state = this.operation.state;
      return Boolean(state.isCompleted || state.isCancelled || state.error);
    }
    stopPolling() {
      if (!this.stopped) {
        this.stopped = true;
        if (this.reject) {
          this.reject(new PollerStoppedError("This poller is already stopped"));
        }
      }
    }
    isStopped() {
      return this.stopped;
    }
    cancelOperation(options = {}) {
      if (!this.cancelPromise) {
        this.cancelPromise = this.cancelOnce(options);
      } else if (options.abortSignal) {
        throw new Error("A cancel request is currently pending");
      }
      return this.cancelPromise;
    }
    getOperationState() {
      return this.operation.state;
    }
    getResult() {
      const state = this.operation.state;
      return state.result;
    }
    toString() {
      return this.operation.toString();
    }
  }
  exports.Poller = Poller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/lroEngine.js
var require_lroEngine = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var operation_js_1 = require_operation3();
  var constants_js_1 = require_constants10();
  var poller_js_1 = require_poller3();
  var operation_js_2 = require_operation();

  class LroEngine extends poller_js_1.Poller {
    constructor(lro, options) {
      const { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = false, isDone, lroResourceLocationConfig, processResult, updateState } = options || {};
      const state = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {};
      const operation = new operation_js_1.GenericPollOperation(state, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
      super(operation);
      this.resolveOnUnsuccessful = resolveOnUnsuccessful;
      this.config = { intervalInMs };
      operation.setPollerConfig(this.config);
    }
    delay() {
      return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));
    }
  }
  exports.LroEngine = LroEngine;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/index.js
var require_lroEngine2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var lroEngine_js_1 = require_lroEngine();
  Object.defineProperty(exports, "LroEngine", { enumerable: true, get: function() {
    return lroEngine_js_1.LroEngine;
  } });
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/pollOperation.js
var require_pollOperation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/core-lro/dist/commonjs/index.js
var require_commonjs14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var tslib_1 = require_tslib();
  var poller_js_1 = require_poller2();
  Object.defineProperty(exports, "createHttpPoller", { enumerable: true, get: function() {
    return poller_js_1.createHttpPoller;
  } });
  tslib_1.__exportStar(require_lroEngine2(), exports);
  tslib_1.__exportStar(require_poller3(), exports);
  tslib_1.__exportStar(require_pollOperation(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/pollers/BlobStartCopyFromUrlPoller.js
var require_BlobStartCopyFromUrlPoller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobBeginCopyFromUrlPoller = undefined;
  var core_util_1 = require_commonjs6();
  var core_lro_1 = require_commonjs14();

  class BlobBeginCopyFromUrlPoller extends core_lro_1.Poller {
    intervalInMs;
    constructor(options) {
      const { blobClient, copySource, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options;
      let state;
      if (resumeFrom) {
        state = JSON.parse(resumeFrom).state;
      }
      const operation = makeBlobBeginCopyFromURLPollOperation({
        ...state,
        blobClient,
        copySource,
        startCopyFromURLOptions
      });
      super(operation);
      if (typeof onProgress === "function") {
        this.onProgress(onProgress);
      }
      this.intervalInMs = intervalInMs;
    }
    delay() {
      return (0, core_util_1.delay)(this.intervalInMs);
    }
  }
  exports.BlobBeginCopyFromUrlPoller = BlobBeginCopyFromUrlPoller;
  var cancel = async function cancel(options = {}) {
    const state = this.state;
    const { copyId } = state;
    if (state.isCompleted) {
      return makeBlobBeginCopyFromURLPollOperation(state);
    }
    if (!copyId) {
      state.isCancelled = true;
      return makeBlobBeginCopyFromURLPollOperation(state);
    }
    await state.blobClient.abortCopyFromURL(copyId, {
      abortSignal: options.abortSignal
    });
    state.isCancelled = true;
    return makeBlobBeginCopyFromURLPollOperation(state);
  };
  var update = async function update(options = {}) {
    const state = this.state;
    const { blobClient, copySource, startCopyFromURLOptions } = state;
    if (!state.isStarted) {
      state.isStarted = true;
      const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);
      state.copyId = result.copyId;
      if (result.copyStatus === "success") {
        state.result = result;
        state.isCompleted = true;
      }
    } else if (!state.isCompleted) {
      try {
        const result = await state.blobClient.getProperties({ abortSignal: options.abortSignal });
        const { copyStatus, copyProgress } = result;
        const prevCopyProgress = state.copyProgress;
        if (copyProgress) {
          state.copyProgress = copyProgress;
        }
        if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress === "function") {
          options.fireProgress(state);
        } else if (copyStatus === "success") {
          state.result = result;
          state.isCompleted = true;
        } else if (copyStatus === "failed") {
          state.error = new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
          state.isCompleted = true;
        }
      } catch (err) {
        state.error = err;
        state.isCompleted = true;
      }
    }
    return makeBlobBeginCopyFromURLPollOperation(state);
  };
  var toString = function toString() {
    return JSON.stringify({ state: this.state }, (key, value) => {
      if (key === "blobClient") {
        return;
      }
      return value;
    });
  };
  function makeBlobBeginCopyFromURLPollOperation(state) {
    return {
      state: { ...state },
      cancel,
      toString,
      update
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/Range.js
var require_Range = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rangeToString = rangeToString;
  function rangeToString(iRange) {
    if (iRange.offset < 0) {
      throw new RangeError(`Range.offset cannot be smaller than 0.`);
    }
    if (iRange.count && iRange.count <= 0) {
      throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
    }
    return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/Batch.js
var require_Batch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Batch = undefined;
  var events_1 = __require("events");
  var BatchStates;
  (function(BatchStates2) {
    BatchStates2[BatchStates2["Good"] = 0] = "Good";
    BatchStates2[BatchStates2["Error"] = 1] = "Error";
  })(BatchStates || (BatchStates = {}));

  class Batch {
    concurrency;
    actives = 0;
    completed = 0;
    offset = 0;
    operations = [];
    state = BatchStates.Good;
    emitter;
    constructor(concurrency = 5) {
      if (concurrency < 1) {
        throw new RangeError("concurrency must be larger than 0");
      }
      this.concurrency = concurrency;
      this.emitter = new events_1.EventEmitter;
    }
    addOperation(operation) {
      this.operations.push(async () => {
        try {
          this.actives++;
          await operation();
          this.actives--;
          this.completed++;
          this.parallelExecute();
        } catch (error) {
          this.emitter.emit("error", error);
        }
      });
    }
    async do() {
      if (this.operations.length === 0) {
        return Promise.resolve();
      }
      this.parallelExecute();
      return new Promise((resolve, reject) => {
        this.emitter.on("finish", resolve);
        this.emitter.on("error", (error) => {
          this.state = BatchStates.Error;
          reject(error);
        });
      });
    }
    nextOperation() {
      if (this.offset < this.operations.length) {
        return this.operations[this.offset++];
      }
      return null;
    }
    parallelExecute() {
      if (this.state === BatchStates.Error) {
        return;
      }
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      while (this.actives < this.concurrency) {
        const operation = this.nextOperation();
        if (operation) {
          operation();
        } else {
          return;
        }
      }
    }
  }
  exports.Batch = Batch;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/utils.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fsCreateReadStream = exports.fsStat = undefined;
  exports.streamToBuffer = streamToBuffer;
  exports.streamToBuffer2 = streamToBuffer2;
  exports.streamToBuffer3 = streamToBuffer3;
  exports.readStreamToLocalFile = readStreamToLocalFile;
  var tslib_1 = require_tslib();
  var node_fs_1 = tslib_1.__importDefault(__require("node:fs"));
  var node_util_1 = tslib_1.__importDefault(__require("node:util"));
  var constants_js_1 = require_constants9();
  async function streamToBuffer(stream, buffer, offset, end, encoding) {
    let pos = 0;
    const count = end - offset;
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error(`The operation cannot be completed in timeout.`)), constants_js_1.REQUEST_TIMEOUT);
      stream.on("readable", () => {
        if (pos >= count) {
          clearTimeout(timeout);
          resolve();
          return;
        }
        let chunk = stream.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
        buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
        pos += chunkLength;
      });
      stream.on("end", () => {
        clearTimeout(timeout);
        if (pos < count) {
          reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
        }
        resolve();
      });
      stream.on("error", (msg) => {
        clearTimeout(timeout);
        reject(msg);
      });
    });
  }
  async function streamToBuffer2(stream, buffer, encoding) {
    let pos = 0;
    const bufferSize = buffer.length;
    return new Promise((resolve, reject) => {
      stream.on("readable", () => {
        let chunk = stream.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        if (pos + chunk.length > bufferSize) {
          reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
          return;
        }
        buffer.fill(chunk, pos, pos + chunk.length);
        pos += chunk.length;
      });
      stream.on("end", () => {
        resolve(pos);
      });
      stream.on("error", reject);
    });
  }
  async function streamToBuffer3(readableStream, encoding) {
    return new Promise((resolve, reject) => {
      const chunks = [];
      readableStream.on("data", (data) => {
        chunks.push(typeof data === "string" ? Buffer.from(data, encoding) : data);
      });
      readableStream.on("end", () => {
        resolve(Buffer.concat(chunks));
      });
      readableStream.on("error", reject);
    });
  }
  async function readStreamToLocalFile(rs, file) {
    return new Promise((resolve, reject) => {
      const ws = node_fs_1.default.createWriteStream(file);
      rs.on("error", (err) => {
        reject(err);
      });
      ws.on("error", (err) => {
        reject(err);
      });
      ws.on("close", resolve);
      rs.pipe(ws);
    });
  }
  exports.fsStat = node_util_1.default.promisify(node_fs_1.default.stat);
  exports.fsCreateReadStream = node_fs_1.default.createReadStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/Clients.js
var require_Clients = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PageBlobClient = exports.BlockBlobClient = exports.AppendBlobClient = exports.BlobClient = undefined;
  var core_rest_pipeline_1 = require_commonjs8();
  var core_auth_1 = require_commonjs9();
  var core_util_1 = require_commonjs6();
  var core_util_2 = require_commonjs6();
  var BlobDownloadResponse_js_1 = require_BlobDownloadResponse();
  var BlobQueryResponse_js_1 = require_BlobQueryResponse();
  var storage_common_1 = require_commonjs13();
  var models_js_1 = require_models2();
  var PageBlobRangeResponse_js_1 = require_PageBlobRangeResponse();
  var Pipeline_js_1 = require_Pipeline();
  var BlobStartCopyFromUrlPoller_js_1 = require_BlobStartCopyFromUrlPoller();
  var Range_js_1 = require_Range();
  var StorageClient_js_1 = require_StorageClient();
  var Batch_js_1 = require_Batch();
  var storage_common_2 = require_commonjs13();
  var constants_js_1 = require_constants9();
  var tracing_js_1 = require_tracing();
  var utils_common_js_1 = require_utils_common2();
  var utils_js_1 = require_utils4();
  var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
  var BlobLeaseClient_js_1 = require_BlobLeaseClient();

  class BlobClient extends StorageClient_js_1.StorageClient {
    blobContext;
    _name;
    _containerName;
    _versionId;
    _snapshot;
    get name() {
      return this._name;
    }
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      options = options || {};
      let pipeline;
      let url;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof storage_common_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options = blobNameOrOptions;
        }
        pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new storage_common_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline);
      ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl());
      this.blobContext = this.storageClientContext.blob;
      this._snapshot = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT);
      this._versionId = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID);
    }
    withSnapshot(snapshot) {
      return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    }
    withVersion(versionId) {
      return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID, versionId.length === 0 ? undefined : versionId), this.pipeline);
    }
    getAppendBlobClient() {
      return new AppendBlobClient(this.url, this.pipeline);
    }
    getBlockBlobClient() {
      return new BlockBlobClient(this.url, this.pipeline);
    }
    getPageBlobClient() {
      return new PageBlobClient(this.url, this.pipeline);
    }
    async download(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-download", options, async (updatedOptions) => {
        const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.download({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onDownloadProgress: core_util_1.isNodeLike ? undefined : options.onProgress
          },
          range: offset === 0 && !count ? undefined : (0, Range_js_1.rangeToString)({ offset, count }),
          rangeGetContentMD5: options.rangeGetContentMD5,
          rangeGetContentCRC64: options.rangeGetContentCrc64,
          snapshot: options.snapshot,
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedRes = {
          ...res,
          _response: res._response,
          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
          objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
        };
        if (!core_util_1.isNodeLike) {
          return wrappedRes;
        }
        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
          options.maxRetryRequests = constants_js_1.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
        }
        if (res.contentLength === undefined) {
          throw new RangeError(`File download response doesn't contain valid content length header`);
        }
        if (!res.etag) {
          throw new RangeError(`File download response doesn't contain valid etag header`);
        }
        return new BlobDownloadResponse_js_1.BlobDownloadResponse(wrappedRes, async (start) => {
          const updatedDownloadOptions = {
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ifMatch: options.conditions.ifMatch || res.etag,
              ifModifiedSince: options.conditions.ifModifiedSince,
              ifNoneMatch: options.conditions.ifNoneMatch,
              ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
              ifTags: options.conditions?.tagConditions
            },
            range: (0, Range_js_1.rangeToString)({
              count: offset + res.contentLength - start,
              offset: start
            }),
            rangeGetContentMD5: options.rangeGetContentMD5,
            rangeGetContentCRC64: options.rangeGetContentCrc64,
            snapshot: options.snapshot,
            cpkInfo: options.customerProvidedKey
          };
          return (await this.blobContext.download({
            abortSignal: options.abortSignal,
            ...updatedDownloadOptions
          })).readableStreamBody;
        }, offset, res.contentLength, {
          maxRetryRequests: options.maxRetryRequests,
          onProgress: options.onProgress
        });
      });
    }
    async exists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-exists", options, async (updatedOptions) => {
        try {
          (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
          await this.getProperties({
            abortSignal: options.abortSignal,
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          } else if (e.statusCode === 409 && (e.details.errorCode === constants_js_1.BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === constants_js_1.BlobDoesNotUseCustomerSpecifiedEncryption)) {
            return true;
          }
          throw e;
        }
      });
    }
    async getProperties(options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-getProperties", options, async (updatedOptions) => {
        const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.getProperties({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...res,
          _response: res._response,
          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
          objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
        };
      });
    }
    async delete(options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("BlobClient-delete", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.delete({
          abortSignal: options.abortSignal,
          deleteSnapshots: options.deleteSnapshots,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-deleteIfExists", options, async (updatedOptions) => {
        try {
          const res = (0, utils_common_js_1.assertResponse)(await this.delete(updatedOptions));
          return {
            succeeded: true,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobNotFound") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    async undelete(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-undelete", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.undelete({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setHTTPHeaders(blobHTTPHeaders, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-setHTTPHeaders", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setHttpHeaders({
          abortSignal: options.abortSignal,
          blobHttpHeaders: blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setMetadata(metadata, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-setMetadata", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setTags(tags, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setTags", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          blobModifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions,
          tags: (0, utils_common_js_1.toBlobTags)(tags)
        }));
      });
    }
    async getTags(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-getTags", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this.blobContext.getTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          blobModifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response,
          _response: response._response,
          tags: (0, utils_common_js_1.toTags)({ blobTagSet: response.blobTagSet }) || {}
        };
        return wrappedResponse;
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
    }
    async createSnapshot(options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-createSnapshot", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.createSnapshot({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async beginCopyFromURL(copySource, options = {}) {
      const client = {
        abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
        getProperties: (...args) => this.getProperties(...args),
        startCopyFromURL: (...args) => this.startCopyFromURL(...args)
      };
      const poller = new BlobStartCopyFromUrlPoller_js_1.BlobBeginCopyFromUrlPoller({
        blobClient: client,
        copySource,
        intervalInMs: options.intervalInMs,
        onProgress: options.onProgress,
        resumeFrom: options.resumeFrom,
        startCopyFromURLOptions: options
      });
      await poller.poll();
      return poller;
    }
    async abortCopyFromURL(copyId, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-abortCopyFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.abortCopyFromURL(copyId, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncCopyFromURL(copySource, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      return tracing_js_1.tracingClient.withSpan("BlobClient-syncCopyFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.copyFromURL(copySource, {
          abortSignal: options.abortSignal,
          metadata: options.metadata,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
          },
          sourceContentMD5: options.sourceContentMD5,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          encryptionScope: options.encryptionScope,
          copySourceTags: options.copySourceTags,
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setAccessTier(tier, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setAccessTier", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTier((0, models_js_1.toAccessTier)(tier), {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          rehydratePriority: options.rehydratePriority,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async downloadToBuffer(param1, param2, param3, param4 = {}) {
      let buffer;
      let offset = 0;
      let count = 0;
      let options = param4;
      if (param1 instanceof Buffer) {
        buffer = param1;
        offset = param2 || 0;
        count = typeof param3 === "number" ? param3 : 0;
      } else {
        offset = typeof param1 === "number" ? param1 : 0;
        count = typeof param2 === "number" ? param2 : 0;
        options = param3 || {};
      }
      let blockSize = options.blockSize ?? 0;
      if (blockSize < 0) {
        throw new RangeError("blockSize option must be >= 0");
      }
      if (blockSize === 0) {
        blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
      }
      if (offset < 0) {
        throw new RangeError("offset option must be >= 0");
      }
      if (count && count <= 0) {
        throw new RangeError("count option must be greater than 0");
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToBuffer", options, async (updatedOptions) => {
        if (!count) {
          const response = await this.getProperties({
            ...options,
            tracingOptions: updatedOptions.tracingOptions
          });
          count = response.contentLength - offset;
          if (count < 0) {
            throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
          }
        }
        if (!buffer) {
          try {
            buffer = Buffer.alloc(count);
          } catch (error) {
            throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ${error.message}`);
          }
        }
        if (buffer.length < count) {
          throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
        }
        let transferProgress = 0;
        const batch = new Batch_js_1.Batch(options.concurrency);
        for (let off = offset;off < offset + count; off = off + blockSize) {
          batch.addOperation(async () => {
            let chunkEnd = offset + count;
            if (off + blockSize < chunkEnd) {
              chunkEnd = off + blockSize;
            }
            const response = await this.download(off, chunkEnd - off, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              maxRetryRequests: options.maxRetryRequestsPerBlock,
              customerProvidedKey: options.customerProvidedKey,
              tracingOptions: updatedOptions.tracingOptions
            });
            const stream = response.readableStreamBody;
            await (0, utils_js_1.streamToBuffer)(stream, buffer, off - offset, chunkEnd - offset);
            transferProgress += chunkEnd - off;
            if (options.onProgress) {
              options.onProgress({ loadedBytes: transferProgress });
            }
          });
        }
        await batch.do();
        return buffer;
      });
    }
    async downloadToFile(filePath, offset = 0, count, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToFile", options, async (updatedOptions) => {
        const response = await this.download(offset, count, {
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        });
        if (response.readableStreamBody) {
          await (0, utils_js_1.readStreamToLocalFile)(response.readableStreamBody, filePath);
        }
        response.blobDownloadStream = undefined;
        return response;
      });
    }
    getBlobAndContainerNamesFromUrl() {
      let containerName;
      let blobName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.host.split(".")[1] === "blob") {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        } else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
          containerName = pathComponents[2];
          blobName = pathComponents[4];
        } else {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        }
        containerName = decodeURIComponent(containerName);
        blobName = decodeURIComponent(blobName);
        blobName = blobName.replace(/\\/g, "/");
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return { blobName, containerName };
      } catch (error) {
        throw new Error("Unable to extract blobName and containerName with provided information.");
      }
    }
    async startCopyFromURL(copySource, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-startCopyFromURL", options, async (updatedOptions) => {
        options.conditions = options.conditions || {};
        options.sourceConditions = options.sourceConditions || {};
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.startCopyFromURL(copySource, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions.ifMatch,
            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
            sourceIfTags: options.sourceConditions.tagConditions
          },
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          rehydratePriority: options.rehydratePriority,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          sealBlob: options.sealBlob,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    generateSasUrl(options) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof storage_common_1.StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options
        }, this.credential).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof storage_common_1.StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...options
      }, this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve) => {
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options
        }, userDelegationKey, this.accountName).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...options
      }, userDelegationKey, this.accountName).stringToSign;
    }
    async deleteImmutabilityPolicy(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.deleteImmutabilityPolicy({
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setImmutabilityPolicy(immutabilityPolicy, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setImmutabilityPolicy({
          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
          immutabilityPolicyMode: immutabilityPolicy.policyMode,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setLegalHold(legalHoldEnabled, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setLegalHold", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setLegalHold(legalHoldEnabled, {
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-getAccountInfo", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.BlobClient = BlobClient;

  class AppendBlobClient extends BlobClient {
    appendBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url;
      options = options || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof storage_common_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new storage_common_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline);
      this.appendBlobContext = this.storageClientContext.appendBlob;
    }
    withSnapshot(snapshot) {
      return new AppendBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    }
    async create(options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-create", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.create(0, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(options = {}) {
      const conditions = { ifNoneMatch: constants_js_1.ETagAny };
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-createIfNotExists", options, async (updatedOptions) => {
        try {
          const res = (0, utils_common_js_1.assertResponse)(await this.create({
            ...updatedOptions,
            conditions
          }));
          return {
            succeeded: true,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobAlreadyExists") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    async seal(options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-seal", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.seal({
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlock(body, contentLength, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlock", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlock(contentLength, body, {
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
          abortSignal: options.abortSignal,
          sourceRange: (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }),
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          appendPositionAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
          },
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.AppendBlobClient = AppendBlobClient;

  class BlockBlobClient extends BlobClient {
    _blobContext;
    blockBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url;
      options = options || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof storage_common_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options = blobNameOrOptions;
        }
        pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new storage_common_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline);
      this.blockBlobContext = this.storageClientContext.blockBlob;
      this._blobContext = this.storageClientContext.blob;
    }
    withSnapshot(snapshot) {
      return new BlockBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    }
    async query(query, options = {}) {
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      if (!core_util_1.isNodeLike) {
        throw new Error("This operation currently is only supported in Node.js.");
      }
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-query", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this._blobContext.query({
          abortSignal: options.abortSignal,
          queryRequest: {
            queryType: "SQL",
            expression: query,
            inputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.inputTextConfiguration),
            outputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.outputTextConfiguration)
          },
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return new BlobQueryResponse_js_1.BlobQueryResponse(response, {
          abortSignal: options.abortSignal,
          onProgress: options.onProgress,
          onError: options.onError
        });
      });
    }
    async upload(body, contentLength, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-upload", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.upload(contentLength, body, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncUploadFromURL(sourceURL, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, {
          ...options,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince,
            sourceIfTags: options.sourceConditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          copySourceTags: options.copySourceTags,
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async stageBlock(blockId, body, contentLength, options = {}) {
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlock", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlock(blockId, contentLength, body, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          sourceRange: offset === 0 && !count ? undefined : (0, Range_js_1.rangeToString)({ offset, count }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async commitBlockList(blocks, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-commitBlockList", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.commitBlockList({ latest: blocks }, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getBlockList(listType, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-getBlockList", options, async (updatedOptions) => {
        const res = (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.getBlockList(listType, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        if (!res.committedBlocks) {
          res.committedBlocks = [];
        }
        if (!res.uncommittedBlocks) {
          res.uncommittedBlocks = [];
        }
        return res;
      });
    }
    async uploadData(data, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadData", options, async (updatedOptions) => {
        if (core_util_1.isNodeLike) {
          let buffer;
          if (data instanceof Buffer) {
            buffer = data;
          } else if (data instanceof ArrayBuffer) {
            buffer = Buffer.from(data);
          } else {
            data = data;
            buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
          }
          return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);
        } else {
          const browserBlob = new Blob([data]);
          return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
        }
      });
    }
    async uploadBrowserData(browserData, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options, async (updatedOptions) => {
        const browserBlob = new Blob([browserData]);
        return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
      });
    }
    async uploadSeekableInternal(bodyFactory, size, options = {}) {
      let blockSize = options.blockSize ?? 0;
      if (blockSize < 0 || blockSize > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
        throw new RangeError(`blockSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
      }
      const maxSingleShotSize = options.maxSingleShotSize ?? constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
      if (maxSingleShotSize < 0 || maxSingleShotSize > constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
        throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
      }
      if (blockSize === 0) {
        if (size > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * constants_js_1.BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`${size} is too larger to upload to a block blob.`);
        }
        if (size > maxSingleShotSize) {
          blockSize = Math.ceil(size / constants_js_1.BLOCK_BLOB_MAX_BLOCKS);
          if (blockSize < constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
            blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
          }
        }
      }
      if (!options.blobHTTPHeaders) {
        options.blobHTTPHeaders = {};
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options, async (updatedOptions) => {
        if (size <= maxSingleShotSize) {
          return (0, utils_common_js_1.assertResponse)(await this.upload(bodyFactory(0, size), size, updatedOptions));
        }
        const numBlocks = Math.floor((size - 1) / blockSize) + 1;
        if (numBlocks > constants_js_1.BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` + `the number of blocks must be <= ${constants_js_1.BLOCK_BLOB_MAX_BLOCKS}`);
        }
        const blockList = [];
        const blockIDPrefix = (0, core_util_2.randomUUID)();
        let transferProgress = 0;
        const batch = new Batch_js_1.Batch(options.concurrency);
        for (let i = 0;i < numBlocks; i++) {
          batch.addOperation(async () => {
            const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, i);
            const start = blockSize * i;
            const end = i === numBlocks - 1 ? size : start + blockSize;
            const contentLength = end - start;
            blockList.push(blockID);
            await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              encryptionScope: options.encryptionScope,
              tracingOptions: updatedOptions.tracingOptions
            });
            transferProgress += contentLength;
            if (options.onProgress) {
              options.onProgress({
                loadedBytes: transferProgress
              });
            }
          });
        }
        await batch.do();
        return this.commitBlockList(blockList, updatedOptions);
      });
    }
    async uploadFile(filePath, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadFile", options, async (updatedOptions) => {
        const size = (await (0, utils_js_1.fsStat)(filePath)).size;
        return this.uploadSeekableInternal((offset, count) => {
          return () => (0, utils_js_1.fsCreateReadStream)(filePath, {
            autoClose: true,
            end: count ? offset + count - 1 : Infinity,
            start: offset
          });
        }, size, {
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    async uploadStream(stream, bufferSize = constants_js_1.DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {
      if (!options.blobHTTPHeaders) {
        options.blobHTTPHeaders = {};
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadStream", options, async (updatedOptions) => {
        let blockNum = 0;
        const blockIDPrefix = (0, core_util_2.randomUUID)();
        let transferProgress = 0;
        const blockList = [];
        const scheduler = new storage_common_2.BufferScheduler(stream, bufferSize, maxConcurrency, async (body, length) => {
          const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, blockNum);
          blockList.push(blockID);
          blockNum++;
          await this.stageBlock(blockID, body, length, {
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          });
          transferProgress += length;
          if (options.onProgress) {
            options.onProgress({ loadedBytes: transferProgress });
          }
        }, Math.ceil(maxConcurrency / 4 * 3));
        await scheduler.do();
        return (0, utils_common_js_1.assertResponse)(await this.commitBlockList(blockList, {
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.BlockBlobClient = BlockBlobClient;

  class PageBlobClient extends BlobClient {
    pageBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url;
      options = options || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof storage_common_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new storage_common_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline);
      this.pageBlobContext = this.storageClientContext.pageBlob;
    }
    withSnapshot(snapshot) {
      return new PageBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    }
    async create(size, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-create", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.create(0, size, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          blobSequenceNumber: options.blobSequenceNumber,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(size, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-createIfNotExists", options, async (updatedOptions) => {
        try {
          const conditions = { ifNoneMatch: constants_js_1.ETagAny };
          const res = (0, utils_common_js_1.assertResponse)(await this.create(size, {
            ...options,
            conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
          return {
            succeeded: true,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobAlreadyExists") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    async uploadPages(body, offset, count, options = {}) {
      options.conditions = options.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPages", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPages(count, body, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPagesFromURL(sourceURL, (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }), 0, (0, Range_js_1.rangeToString)({ offset: destOffset, count }), {
          abortSignal: options.abortSignal,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          sequenceNumberAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async clearPages(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-clearPages", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.clearPages(0, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getPageRanges(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRanges", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
      });
    }
    async listPageRangesSegment(offset = 0, count, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          marker,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async* listPageRangeItemSegments(offset = 0, count, marker, options = {}) {
      let getPageRangeItemSegmentsResponse;
      if (!!marker || marker === undefined) {
        do {
          getPageRangeItemSegmentsResponse = await this.listPageRangesSegment(offset, count, marker, options);
          marker = getPageRangeItemSegmentsResponse.continuationToken;
          yield await getPageRangeItemSegmentsResponse;
        } while (marker);
      }
    }
    async* listPageRangeItems(offset = 0, count, options = {}) {
      let marker;
      for await (const getPageRangesSegment of this.listPageRangeItemSegments(offset, count, marker, options)) {
        yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
      }
    }
    listPageRanges(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      const iter = this.listPageRangeItems(offset, count, options);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeItemSegments(offset, count, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...options
          });
        }
      };
    }
    async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options, async (updatedOptions) => {
        const result = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          prevsnapshot: prevSnapshot,
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(result);
      });
    }
    async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options?.abortSignal,
          leaseAccessConditions: options?.conditions,
          modifiedAccessConditions: {
            ...options?.conditions,
            ifTags: options?.conditions?.tagConditions
          },
          prevsnapshot: prevSnapshotOrUrl,
          range: (0, Range_js_1.rangeToString)({
            offset,
            count
          }),
          marker,
          maxPageSize: options?.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async* listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {
      let getPageRangeItemSegmentsResponse;
      if (!!marker || marker === undefined) {
        do {
          getPageRangeItemSegmentsResponse = await this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options);
          marker = getPageRangeItemSegmentsResponse.continuationToken;
          yield await getPageRangeItemSegmentsResponse;
        } while (marker);
      }
    }
    async* listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {
      let marker;
      for await (const getPageRangesSegment of this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options)) {
        yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
      }
    }
    listPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      options.conditions = options.conditions || {};
      const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, {
        ...options
      });
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...options
          });
        }
      };
    }
    async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          prevSnapshotUrl,
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
      });
    }
    async resize(size, options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-resize", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.resize(size, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, {
          abortSignal: options.abortSignal,
          blobSequenceNumber: sequenceNumber,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async startCopyIncremental(copySource, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-startCopyIncremental", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.copyIncremental(copySource, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.PageBlobClient = PageBlobClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchUtils.js
var require_BatchUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBodyAsText = getBodyAsText;
  exports.utf8ByteLength = utf8ByteLength;
  var utils_js_1 = require_utils4();
  var constants_js_1 = require_constants9();
  async function getBodyAsText(batchResponse) {
    let buffer = Buffer.alloc(constants_js_1.BATCH_MAX_PAYLOAD_IN_BYTES);
    const responseLength = await (0, utils_js_1.streamToBuffer2)(batchResponse.readableStreamBody, buffer);
    buffer = buffer.slice(0, responseLength);
    return buffer.toString();
  }
  function utf8ByteLength(str) {
    return Buffer.byteLength(str);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchResponseParser.js
var require_BatchResponseParser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchResponseParser = undefined;
  var core_rest_pipeline_1 = require_commonjs8();
  var core_http_compat_1 = require_commonjs11();
  var constants_js_1 = require_constants9();
  var BatchUtils_js_1 = require_BatchUtils();
  var log_js_1 = require_log5();
  var HTTP_HEADER_DELIMITER = ": ";
  var SPACE_DELIMITER = " ";
  var NOT_FOUND = -1;

  class BatchResponseParser {
    batchResponse;
    responseBatchBoundary;
    perResponsePrefix;
    batchResponseEnding;
    subRequests;
    constructor(batchResponse, subRequests) {
      if (!batchResponse || !batchResponse.contentType) {
        throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
      }
      if (!subRequests || subRequests.size === 0) {
        throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
      }
      this.batchResponse = batchResponse;
      this.subRequests = subRequests;
      this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
      this.perResponsePrefix = `--${this.responseBatchBoundary}${constants_js_1.HTTP_LINE_ENDING}`;
      this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
    }
    async parseBatchResponse() {
      if (this.batchResponse._response.status !== constants_js_1.HTTPURLConnection.HTTP_ACCEPTED) {
        throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
      }
      const responseBodyAsText = await (0, BatchUtils_js_1.getBodyAsText)(this.batchResponse);
      const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
      const subResponseCount = subResponses.length;
      if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {
        throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
      }
      const deserializedSubResponses = new Array(subResponseCount);
      let subResponsesSucceededCount = 0;
      let subResponsesFailedCount = 0;
      for (let index = 0;index < subResponseCount; index++) {
        const subResponse = subResponses[index];
        const deserializedSubResponse = {};
        deserializedSubResponse.headers = (0, core_http_compat_1.toHttpHeadersLike)((0, core_rest_pipeline_1.createHttpHeaders)());
        const responseLines = subResponse.split(`${constants_js_1.HTTP_LINE_ENDING}`);
        let subRespHeaderStartFound = false;
        let subRespHeaderEndFound = false;
        let subRespFailed = false;
        let contentId = NOT_FOUND;
        for (const responseLine of responseLines) {
          if (!subRespHeaderStartFound) {
            if (responseLine.startsWith(constants_js_1.HeaderConstants.CONTENT_ID)) {
              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
            }
            if (responseLine.startsWith(constants_js_1.HTTP_VERSION_1_1)) {
              subRespHeaderStartFound = true;
              const tokens = responseLine.split(SPACE_DELIMITER);
              deserializedSubResponse.status = parseInt(tokens[1]);
              deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
            }
            continue;
          }
          if (responseLine.trim() === "") {
            if (!subRespHeaderEndFound) {
              subRespHeaderEndFound = true;
            }
            continue;
          }
          if (!subRespHeaderEndFound) {
            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {
              throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
            }
            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
            deserializedSubResponse.headers.set(tokens[0], tokens[1]);
            if (tokens[0] === constants_js_1.HeaderConstants.X_MS_ERROR_CODE) {
              deserializedSubResponse.errorCode = tokens[1];
              subRespFailed = true;
            }
          } else {
            if (!deserializedSubResponse.bodyAsText) {
              deserializedSubResponse.bodyAsText = "";
            }
            deserializedSubResponse.bodyAsText += responseLine;
          }
        }
        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {
          deserializedSubResponse._request = this.subRequests.get(contentId);
          deserializedSubResponses[contentId] = deserializedSubResponse;
        } else {
          log_js_1.logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
        }
        if (subRespFailed) {
          subResponsesFailedCount++;
        } else {
          subResponsesSucceededCount++;
        }
      }
      return {
        subResponses: deserializedSubResponses,
        subResponsesSucceededCount,
        subResponsesFailedCount
      };
    }
  }
  exports.BatchResponseParser = BatchResponseParser;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/Mutex.js
var require_Mutex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Mutex = undefined;
  var MutexLockStatus;
  (function(MutexLockStatus2) {
    MutexLockStatus2[MutexLockStatus2["LOCKED"] = 0] = "LOCKED";
    MutexLockStatus2[MutexLockStatus2["UNLOCKED"] = 1] = "UNLOCKED";
  })(MutexLockStatus || (MutexLockStatus = {}));

  class Mutex {
    static async lock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {
          this.keys[key] = MutexLockStatus.LOCKED;
          resolve();
        } else {
          this.onUnlockEvent(key, () => {
            this.keys[key] = MutexLockStatus.LOCKED;
            resolve();
          });
        }
      });
    }
    static async unlock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === MutexLockStatus.LOCKED) {
          this.emitUnlockEvent(key);
        }
        delete this.keys[key];
        resolve();
      });
    }
    static keys = {};
    static listeners = {};
    static onUnlockEvent(key, handler) {
      if (this.listeners[key] === undefined) {
        this.listeners[key] = [handler];
      } else {
        this.listeners[key].push(handler);
      }
    }
    static emitUnlockEvent(key) {
      if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {
        const handler = this.listeners[key].shift();
        setImmediate(() => {
          handler.call(this);
        });
      }
    }
  }
  exports.Mutex = Mutex;
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobBatch.js
var require_BlobBatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobBatch = undefined;
  var core_util_1 = require_commonjs6();
  var core_auth_1 = require_commonjs9();
  var core_rest_pipeline_1 = require_commonjs8();
  var core_util_2 = require_commonjs6();
  var storage_common_1 = require_commonjs13();
  var Clients_js_1 = require_Clients();
  var Mutex_js_1 = require_Mutex();
  var Pipeline_js_1 = require_Pipeline();
  var utils_common_js_1 = require_utils_common2();
  var core_xml_1 = require_commonjs12();
  var constants_js_1 = require_constants9();
  var tracing_js_1 = require_tracing();
  var core_client_1 = require_commonjs10();

  class BlobBatch {
    batchRequest;
    batch = "batch";
    batchType;
    constructor() {
      this.batchRequest = new InnerBatchRequest;
    }
    getMultiPartContentType() {
      return this.batchRequest.getMultipartContentType();
    }
    getHttpRequestBody() {
      return this.batchRequest.getHttpRequestBody();
    }
    getSubRequests() {
      return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
      await Mutex_js_1.Mutex.lock(this.batch);
      try {
        this.batchRequest.preAddSubRequest(subRequest);
        await assembleSubRequestFunc();
        this.batchRequest.postAddSubRequest(subRequest);
      } finally {
        await Mutex_js_1.Mutex.unlock(this.batch);
      }
    }
    setBatchType(batchType) {
      if (!this.batchType) {
        this.batchType = batchType;
      }
      if (this.batchType !== batchType) {
        throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
      }
    }
    async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
      let url;
      let credential;
      if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrOptions instanceof storage_common_1.StorageSharedKeyCredential || credentialOrOptions instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrOptions))) {
        url = urlOrBlobClient;
        credential = credentialOrOptions;
      } else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
        url = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        options = credentialOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options) {
        options = {};
      }
      return tracing_js_1.tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("delete");
        await this.addSubRequestInternal({
          url,
          credential
        }, async () => {
          await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
        });
      });
    }
    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
      let url;
      let credential;
      let tier;
      if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrTier instanceof storage_common_1.StorageSharedKeyCredential || credentialOrTier instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrTier))) {
        url = urlOrBlobClient;
        credential = credentialOrTier;
        tier = tierOrOptions;
      } else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
        url = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        tier = credentialOrTier;
        options = tierOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options) {
        options = {};
      }
      return tracing_js_1.tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("setAccessTier");
        await this.addSubRequestInternal({
          url,
          credential
        }, async () => {
          await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);
        });
      });
    }
  }
  exports.BlobBatch = BlobBatch;

  class InnerBatchRequest {
    operationCount;
    body;
    subRequests;
    boundary;
    subRequestPrefix;
    multipartContentType;
    batchRequestEnding;
    constructor() {
      this.operationCount = 0;
      this.body = "";
      const tempGuid = (0, core_util_1.randomUUID)();
      this.boundary = `batch_${tempGuid}`;
      this.subRequestPrefix = `--${this.boundary}${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TYPE}: application/http${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
      this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
      this.batchRequestEnding = `--${this.boundary}--`;
      this.subRequests = new Map;
    }
    createPipeline(credential) {
      const corePipeline = (0, core_rest_pipeline_1.createEmptyPipeline)();
      corePipeline.addPolicy((0, core_client_1.serializationPolicy)({
        stringifyXML: core_xml_1.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }), { phase: "Serialize" });
      corePipeline.addPolicy(batchHeaderFilterPolicy());
      corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" });
      if ((0, core_auth_1.isTokenCredential)(credential)) {
        corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
          credential,
          scopes: constants_js_1.StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof storage_common_1.StorageSharedKeyCredential) {
        corePipeline.addPolicy((0, storage_common_1.storageSharedKeyCredentialPolicy)({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      const pipeline = new Pipeline_js_1.Pipeline([]);
      pipeline._credential = credential;
      pipeline._corePipeline = corePipeline;
      return pipeline;
    }
    appendSubRequestToBody(request) {
      this.body += [
        this.subRequestPrefix,
        `${constants_js_1.HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
        "",
        `${request.method.toString()} ${(0, utils_common_js_1.getURLPathAndQuery)(request.url)} ${constants_js_1.HTTP_VERSION_1_1}${constants_js_1.HTTP_LINE_ENDING}`
      ].join(constants_js_1.HTTP_LINE_ENDING);
      for (const [name, value] of request.headers) {
        this.body += `${name}: ${value}${constants_js_1.HTTP_LINE_ENDING}`;
      }
      this.body += constants_js_1.HTTP_LINE_ENDING;
    }
    preAddSubRequest(subRequest) {
      if (this.operationCount >= constants_js_1.BATCH_MAX_REQUEST) {
        throw new RangeError(`Cannot exceed ${constants_js_1.BATCH_MAX_REQUEST} sub requests in a single batch`);
      }
      const path = (0, utils_common_js_1.getURLPath)(subRequest.url);
      if (!path || path === "") {
        throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
      }
    }
    postAddSubRequest(subRequest) {
      this.subRequests.set(this.operationCount, subRequest);
      this.operationCount++;
    }
    getHttpRequestBody() {
      return `${this.body}${this.batchRequestEnding}${constants_js_1.HTTP_LINE_ENDING}`;
    }
    getMultipartContentType() {
      return this.multipartContentType;
    }
    getSubRequests() {
      return this.subRequests;
    }
  }
  function batchRequestAssemblePolicy(batchRequest) {
    return {
      name: "batchRequestAssemblePolicy",
      async sendRequest(request) {
        batchRequest.appendSubRequestToBody(request);
        return {
          request,
          status: 200,
          headers: (0, core_rest_pipeline_1.createHttpHeaders)()
        };
      }
    };
  }
  function batchHeaderFilterPolicy() {
    return {
      name: "batchHeaderFilterPolicy",
      async sendRequest(request, next) {
        let xMsHeaderName = "";
        for (const [name] of request.headers) {
          if ((0, utils_common_js_1.iEqual)(name, constants_js_1.HeaderConstants.X_MS_VERSION)) {
            xMsHeaderName = name;
          }
        }
        if (xMsHeaderName !== "") {
          request.headers.delete(xMsHeaderName);
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobBatchClient.js
var require_BlobBatchClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobBatchClient = undefined;
  var BatchResponseParser_js_1 = require_BatchResponseParser();
  var BatchUtils_js_1 = require_BatchUtils();
  var BlobBatch_js_1 = require_BlobBatch();
  var tracing_js_1 = require_tracing();
  var storage_common_1 = require_commonjs13();
  var StorageContextClient_js_1 = require_StorageContextClient();
  var Pipeline_js_1 = require_Pipeline();
  var utils_common_js_1 = require_utils_common2();

  class BlobBatchClient {
    serviceOrContainerContext;
    constructor(url, credentialOrPipeline, options) {
      let pipeline;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) {
        pipeline = credentialOrPipeline;
      } else if (!credentialOrPipeline) {
        pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
      } else {
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
      }
      const storageClientContext = new StorageContextClient_js_1.StorageContextClient(url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline));
      const path = (0, utils_common_js_1.getURLPath)(url);
      if (path && path !== "/") {
        this.serviceOrContainerContext = storageClientContext.container;
      } else {
        this.serviceOrContainerContext = storageClientContext.service;
      }
    }
    createBatch() {
      return new BlobBatch_js_1.BlobBatch;
    }
    async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options) {
      const batch = new BlobBatch_js_1.BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
        } else {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
      const batch = new BlobBatch_js_1.BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
        } else {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async submitBatch(batchRequest, options = {}) {
      if (!batchRequest || batchRequest.getSubRequests().size === 0) {
        throw new RangeError("Batch request should contain one or more sub requests.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobBatchClient-submitBatch", options, async (updatedOptions) => {
        const batchRequestBody = batchRequest.getHttpRequestBody();
        const rawBatchResponse = (0, utils_common_js_1.assertResponse)(await this.serviceOrContainerContext.submitBatch((0, BatchUtils_js_1.utf8ByteLength)(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, {
          ...updatedOptions
        }));
        const batchResponseParser = new BatchResponseParser_js_1.BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
        const responseSummary = await batchResponseParser.parseBatchResponse();
        const res = {
          _response: rawBatchResponse._response,
          contentType: rawBatchResponse.contentType,
          errorCode: rawBatchResponse.errorCode,
          requestId: rawBatchResponse.requestId,
          clientRequestId: rawBatchResponse.clientRequestId,
          version: rawBatchResponse.version,
          subResponses: responseSummary.subResponses,
          subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
          subResponsesFailedCount: responseSummary.subResponsesFailedCount
        };
        return res;
      });
    }
  }
  exports.BlobBatchClient = BlobBatchClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/ContainerClient.js
var require_ContainerClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContainerClient = undefined;
  var core_rest_pipeline_1 = require_commonjs8();
  var core_util_1 = require_commonjs6();
  var core_auth_1 = require_commonjs9();
  var storage_common_1 = require_commonjs13();
  var Pipeline_js_1 = require_Pipeline();
  var StorageClient_js_1 = require_StorageClient();
  var tracing_js_1 = require_tracing();
  var utils_common_js_1 = require_utils_common2();
  var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
  var BlobLeaseClient_js_1 = require_BlobLeaseClient();
  var Clients_js_1 = require_Clients();
  var BlobBatchClient_js_1 = require_BlobBatchClient();

  class ContainerClient extends StorageClient_js_1.StorageClient {
    containerContext;
    _containerName;
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
      let pipeline;
      let url;
      options = options || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof storage_common_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new storage_common_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName));
            if (!options.proxyOptions) {
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
          pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName parameter");
      }
      super(url, pipeline);
      this._containerName = this.getContainerNameFromUrl();
      this.containerContext = this.storageClientContext.container;
    }
    async create(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-create", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.create(updatedOptions));
      });
    }
    async createIfNotExists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-createIfNotExists", options, async (updatedOptions) => {
        try {
          const res = await this.create(updatedOptions);
          return {
            succeeded: true,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "ContainerAlreadyExists") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          } else {
            throw e;
          }
        }
      });
    }
    async exists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-exists", options, async (updatedOptions) => {
        try {
          await this.getProperties({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          }
          throw e;
        }
      });
    }
    getBlobClient(blobName) {
      return new Clients_js_1.BlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    getAppendBlobClient(blobName) {
      return new Clients_js_1.AppendBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    getBlockBlobClient(blobName) {
      return new Clients_js_1.BlockBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    getPageBlobClient(blobName) {
      return new Clients_js_1.PageBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    async getProperties(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getProperties", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.getProperties({
          abortSignal: options.abortSignal,
          ...options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async delete(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-delete", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.delete({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteIfExists", options, async (updatedOptions) => {
        try {
          const res = await this.delete(updatedOptions);
          return {
            succeeded: true,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "ContainerNotFound") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    async setMetadata(metadata, options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      if (options.conditions.ifUnmodifiedSince) {
        throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-setMetadata", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccessPolicy(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccessPolicy", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccessPolicy({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const res = {
          _response: response._response,
          blobPublicAccess: response.blobPublicAccess,
          date: response.date,
          etag: response.etag,
          errorCode: response.errorCode,
          lastModified: response.lastModified,
          requestId: response.requestId,
          clientRequestId: response.clientRequestId,
          signedIdentifiers: [],
          version: response.version
        };
        for (const identifier of response) {
          let accessPolicy = undefined;
          if (identifier.accessPolicy) {
            accessPolicy = {
              permissions: identifier.accessPolicy.permissions
            };
            if (identifier.accessPolicy.expiresOn) {
              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
            }
            if (identifier.accessPolicy.startsOn) {
              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
            }
          }
          res.signedIdentifiers.push({
            accessPolicy,
            id: identifier.id
          });
        }
        return res;
      });
    }
    async setAccessPolicy(access, containerAcl, options = {}) {
      options.conditions = options.conditions || {};
      return tracing_js_1.tracingClient.withSpan("ContainerClient-setAccessPolicy", options, async (updatedOptions) => {
        const acl = [];
        for (const identifier of containerAcl || []) {
          acl.push({
            accessPolicy: {
              expiresOn: identifier.accessPolicy.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.expiresOn) : "",
              permissions: identifier.accessPolicy.permissions,
              startsOn: identifier.accessPolicy.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.startsOn) : ""
            },
            id: identifier.id
          });
        }
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.setAccessPolicy({
          abortSignal: options.abortSignal,
          access,
          containerAcl: acl,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
    }
    async uploadBlockBlob(blobName, body, contentLength, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-uploadBlockBlob", options, async (updatedOptions) => {
        const blockBlobClient = this.getBlockBlobClient(blobName);
        const response = await blockBlobClient.upload(body, contentLength, updatedOptions);
        return {
          blockBlobClient,
          response
        };
      });
    }
    async deleteBlob(blobName, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteBlob", options, async (updatedOptions) => {
        let blobClient = this.getBlobClient(blobName);
        if (options.versionId) {
          blobClient = blobClient.withVersion(options.versionId);
        }
        return blobClient.delete(updatedOptions);
      });
    }
    async listBlobFlatSegment(marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobFlatSegment({
          marker,
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response,
          _response: {
            ...response._response,
            parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobFlat)(response._response.parsedBody)
          },
          segment: {
            ...response.segment,
            blobItems: response.segment.blobItems.map((blobItemInternal) => {
              const blobItem = {
                ...blobItemInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
              };
              return blobItem;
            })
          }
        };
        return wrappedResponse;
      });
    }
    async listBlobHierarchySegment(delimiter, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobHierarchySegment(delimiter, {
          marker,
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response,
          _response: {
            ...response._response,
            parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobHierarchy)(response._response.parsedBody)
          },
          segment: {
            ...response.segment,
            blobItems: response.segment.blobItems.map((blobItemInternal) => {
              const blobItem = {
                ...blobItemInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
              };
              return blobItem;
            }),
            blobPrefixes: response.segment.blobPrefixes?.map((blobPrefixInternal) => {
              const blobPrefix = {
                ...blobPrefixInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobPrefixInternal.name)
              };
              return blobPrefix;
            })
          }
        };
        return wrappedResponse;
      });
    }
    async* listSegments(marker, options = {}) {
      let listBlobsFlatSegmentResponse;
      if (!!marker || marker === undefined) {
        do {
          listBlobsFlatSegmentResponse = await this.listBlobFlatSegment(marker, options);
          marker = listBlobsFlatSegmentResponse.continuationToken;
          yield await listBlobsFlatSegmentResponse;
        } while (marker);
      }
    }
    async* listItems(options = {}) {
      let marker;
      for await (const listBlobsFlatSegmentResponse of this.listSegments(marker, options)) {
        yield* listBlobsFlatSegmentResponse.segment.blobItems;
      }
    }
    listBlobsFlat(options = {}) {
      const include = [];
      if (options.includeCopy) {
        include.push("copy");
      }
      if (options.includeDeleted) {
        include.push("deleted");
      }
      if (options.includeMetadata) {
        include.push("metadata");
      }
      if (options.includeSnapshots) {
        include.push("snapshots");
      }
      if (options.includeVersions) {
        include.push("versions");
      }
      if (options.includeUncommitedBlobs) {
        include.push("uncommittedblobs");
      }
      if (options.includeTags) {
        include.push("tags");
      }
      if (options.includeDeletedWithVersions) {
        include.push("deletedwithversions");
      }
      if (options.includeImmutabilityPolicy) {
        include.push("immutabilitypolicy");
      }
      if (options.includeLegalHold) {
        include.push("legalhold");
      }
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const updatedOptions = {
        ...options,
        ...include.length > 0 ? { include } : {}
      };
      const iter = this.listItems(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...updatedOptions
          });
        }
      };
    }
    async* listHierarchySegments(delimiter, marker, options = {}) {
      let listBlobsHierarchySegmentResponse;
      if (!!marker || marker === undefined) {
        do {
          listBlobsHierarchySegmentResponse = await this.listBlobHierarchySegment(delimiter, marker, options);
          marker = listBlobsHierarchySegmentResponse.continuationToken;
          yield await listBlobsHierarchySegmentResponse;
        } while (marker);
      }
    }
    async* listItemsByHierarchy(delimiter, options = {}) {
      let marker;
      for await (const listBlobsHierarchySegmentResponse of this.listHierarchySegments(delimiter, marker, options)) {
        const segment = listBlobsHierarchySegmentResponse.segment;
        if (segment.blobPrefixes) {
          for (const prefix of segment.blobPrefixes) {
            yield {
              kind: "prefix",
              ...prefix
            };
          }
        }
        for (const blob of segment.blobItems) {
          yield { kind: "blob", ...blob };
        }
      }
    }
    listBlobsByHierarchy(delimiter, options = {}) {
      if (delimiter === "") {
        throw new RangeError("delimiter should contain one or more characters");
      }
      const include = [];
      if (options.includeCopy) {
        include.push("copy");
      }
      if (options.includeDeleted) {
        include.push("deleted");
      }
      if (options.includeMetadata) {
        include.push("metadata");
      }
      if (options.includeSnapshots) {
        include.push("snapshots");
      }
      if (options.includeVersions) {
        include.push("versions");
      }
      if (options.includeUncommitedBlobs) {
        include.push("uncommittedblobs");
      }
      if (options.includeTags) {
        include.push("tags");
      }
      if (options.includeDeletedWithVersions) {
        include.push("deletedwithversions");
      }
      if (options.includeImmutabilityPolicy) {
        include.push("immutabilitypolicy");
      }
      if (options.includeLegalHold) {
        include.push("legalhold");
      }
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const updatedOptions = {
        ...options,
        ...include.length > 0 ? { include } : {}
      };
      const iter = this.listItemsByHierarchy(delimiter, updatedOptions);
      return {
        async next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listHierarchySegments(delimiter, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...updatedOptions
          });
        }
      };
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response,
          _response: response._response,
          blobs: response.blobs.map((blob) => {
            let tagValue = "";
            if (blob.tags?.blobTagSet.length === 1) {
              tagValue = blob.tags.blobTagSet[0].value;
            }
            return { ...blob, tags: (0, utils_common_js_1.toTags)(blob.tags), tagValue };
          })
        };
        return wrappedResponse;
      });
    }
    async* findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
      let response;
      if (!!marker || marker === undefined) {
        do {
          response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
          response.blobs = response.blobs || [];
          marker = response.continuationToken;
          yield response;
        } while (marker);
      }
    }
    async* findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
      let marker;
      for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)) {
        yield* segment.blobs;
      }
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      const listSegmentOptions = {
        ...options
      };
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    async getAccountInfo(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccountInfo", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getContainerNameFromUrl() {
      let containerName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.hostname.split(".")[1] === "blob") {
          containerName = parsedUrl.pathname.split("/")[1];
        } else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
          containerName = parsedUrl.pathname.split("/")[2];
        } else {
          containerName = parsedUrl.pathname.split("/")[1];
        }
        containerName = decodeURIComponent(containerName);
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return containerName;
      } catch (error) {
        throw new Error("Unable to extract containerName with provided information.");
      }
    }
    generateSasUrl(options) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof storage_common_1.StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          ...options
        }, this.credential).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof storage_common_1.StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        ...options
      }, this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve) => {
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          ...options
        }, userDelegationKey, this.accountName).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        ...options
      }, userDelegationKey, this.accountName).stringToSign;
    }
    getBlobBatchClient() {
      return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
    }
  }
  exports.ContainerClient = ContainerClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASPermissions.js
var require_AccountSASPermissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AccountSASPermissions = undefined;

  class AccountSASPermissions {
    static parse(permissions) {
      const accountSASPermissions = new AccountSASPermissions;
      for (const c of permissions) {
        switch (c) {
          case "r":
            accountSASPermissions.read = true;
            break;
          case "w":
            accountSASPermissions.write = true;
            break;
          case "d":
            accountSASPermissions.delete = true;
            break;
          case "x":
            accountSASPermissions.deleteVersion = true;
            break;
          case "l":
            accountSASPermissions.list = true;
            break;
          case "a":
            accountSASPermissions.add = true;
            break;
          case "c":
            accountSASPermissions.create = true;
            break;
          case "u":
            accountSASPermissions.update = true;
            break;
          case "p":
            accountSASPermissions.process = true;
            break;
          case "t":
            accountSASPermissions.tag = true;
            break;
          case "f":
            accountSASPermissions.filter = true;
            break;
          case "i":
            accountSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            accountSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission character: ${c}`);
        }
      }
      return accountSASPermissions;
    }
    static from(permissionLike) {
      const accountSASPermissions = new AccountSASPermissions;
      if (permissionLike.read) {
        accountSASPermissions.read = true;
      }
      if (permissionLike.write) {
        accountSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        accountSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        accountSASPermissions.deleteVersion = true;
      }
      if (permissionLike.filter) {
        accountSASPermissions.filter = true;
      }
      if (permissionLike.tag) {
        accountSASPermissions.tag = true;
      }
      if (permissionLike.list) {
        accountSASPermissions.list = true;
      }
      if (permissionLike.add) {
        accountSASPermissions.add = true;
      }
      if (permissionLike.create) {
        accountSASPermissions.create = true;
      }
      if (permissionLike.update) {
        accountSASPermissions.update = true;
      }
      if (permissionLike.process) {
        accountSASPermissions.process = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        accountSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        accountSASPermissions.permanentDelete = true;
      }
      return accountSASPermissions;
    }
    read = false;
    write = false;
    delete = false;
    deleteVersion = false;
    list = false;
    add = false;
    create = false;
    update = false;
    process = false;
    tag = false;
    filter = false;
    setImmutabilityPolicy = false;
    permanentDelete = false;
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.filter) {
        permissions.push("f");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.update) {
        permissions.push("u");
      }
      if (this.process) {
        permissions.push("p");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }
  exports.AccountSASPermissions = AccountSASPermissions;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASResourceTypes.js
var require_AccountSASResourceTypes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AccountSASResourceTypes = undefined;

  class AccountSASResourceTypes {
    static parse(resourceTypes) {
      const accountSASResourceTypes = new AccountSASResourceTypes;
      for (const c of resourceTypes) {
        switch (c) {
          case "s":
            accountSASResourceTypes.service = true;
            break;
          case "c":
            accountSASResourceTypes.container = true;
            break;
          case "o":
            accountSASResourceTypes.object = true;
            break;
          default:
            throw new RangeError(`Invalid resource type: ${c}`);
        }
      }
      return accountSASResourceTypes;
    }
    service = false;
    container = false;
    object = false;
    toString() {
      const resourceTypes = [];
      if (this.service) {
        resourceTypes.push("s");
      }
      if (this.container) {
        resourceTypes.push("c");
      }
      if (this.object) {
        resourceTypes.push("o");
      }
      return resourceTypes.join("");
    }
  }
  exports.AccountSASResourceTypes = AccountSASResourceTypes;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASServices.js
var require_AccountSASServices = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AccountSASServices = undefined;

  class AccountSASServices {
    static parse(services) {
      const accountSASServices = new AccountSASServices;
      for (const c of services) {
        switch (c) {
          case "b":
            accountSASServices.blob = true;
            break;
          case "f":
            accountSASServices.file = true;
            break;
          case "q":
            accountSASServices.queue = true;
            break;
          case "t":
            accountSASServices.table = true;
            break;
          default:
            throw new RangeError(`Invalid service character: ${c}`);
        }
      }
      return accountSASServices;
    }
    blob = false;
    file = false;
    queue = false;
    table = false;
    toString() {
      const services = [];
      if (this.blob) {
        services.push("b");
      }
      if (this.table) {
        services.push("t");
      }
      if (this.queue) {
        services.push("q");
      }
      if (this.file) {
        services.push("f");
      }
      return services.join("");
    }
  }
  exports.AccountSASServices = AccountSASServices;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASSignatureValues.js
var require_AccountSASSignatureValues = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
  exports.generateAccountSASQueryParametersInternal = generateAccountSASQueryParametersInternal;
  var AccountSASPermissions_js_1 = require_AccountSASPermissions();
  var AccountSASResourceTypes_js_1 = require_AccountSASResourceTypes();
  var AccountSASServices_js_1 = require_AccountSASServices();
  var SasIPRange_js_1 = require_SasIPRange();
  var SASQueryParameters_js_1 = require_SASQueryParameters();
  var constants_js_1 = require_constants9();
  var utils_common_js_1 = require_utils_common2();
  function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
  }
  function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
    const version = accountSASSignatureValues.version ? accountSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
    }
    if (accountSASSignatureValues.encryptionScope && version < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    const parsedPermissions = AccountSASPermissions_js_1.AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
    const parsedServices = AccountSASServices_js_1.AccountSASServices.parse(accountSASSignatureValues.services).toString();
    const parsedResourceTypes = AccountSASResourceTypes_js_1.AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    let stringToSign;
    if (version >= "2020-12-06") {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
        (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
        ""
      ].join(`
`);
    } else {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
        (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        ""
      ].join(`
`);
    }
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(version, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, accountSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobServiceClient.js
var require_BlobServiceClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobServiceClient = undefined;
  var core_auth_1 = require_commonjs9();
  var core_rest_pipeline_1 = require_commonjs8();
  var core_util_1 = require_commonjs6();
  var Pipeline_js_1 = require_Pipeline();
  var ContainerClient_js_1 = require_ContainerClient();
  var utils_common_js_1 = require_utils_common2();
  var storage_common_1 = require_commonjs13();
  var utils_common_js_2 = require_utils_common2();
  var tracing_js_1 = require_tracing();
  var BlobBatchClient_js_1 = require_BlobBatchClient();
  var StorageClient_js_1 = require_StorageClient();
  var AccountSASPermissions_js_1 = require_AccountSASPermissions();
  var AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues();
  var AccountSASServices_js_1 = require_AccountSASServices();

  class BlobServiceClient extends StorageClient_js_1.StorageClient {
    serviceContext;
    static fromConnectionString(connectionString, options) {
      options = options || {};
      const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(connectionString);
      if (extractedCreds.kind === "AccountConnString") {
        if (core_util_1.isNodeLike) {
          const sharedKeyCredential = new storage_common_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          if (!options.proxyOptions) {
            options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
          }
          const pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          return new BlobServiceClient(extractedCreds.url, pipeline);
        } else {
          throw new Error("Account connection string is only supported in Node.js environment");
        }
      } else if (extractedCreds.kind === "SASConnString") {
        const pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
        return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
      } else {
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
      }
    }
    constructor(url, credentialOrPipeline, options) {
      let pipeline;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) {
        pipeline = credentialOrPipeline;
      } else if (core_util_1.isNodeLike && credentialOrPipeline instanceof storage_common_1.StorageSharedKeyCredential || credentialOrPipeline instanceof storage_common_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipeline)) {
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
      } else {
        pipeline = (0, Pipeline_js_1.newPipeline)(new storage_common_1.AnonymousCredential, options);
      }
      super(url, pipeline);
      this.serviceContext = this.storageClientContext.service;
    }
    getContainerClient(containerName) {
      return new ContainerClient_js_1.ContainerClient((0, utils_common_js_1.appendToURLPath)(this.url, encodeURIComponent(containerName)), this.pipeline);
    }
    async createContainer(containerName, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-createContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        const containerCreateResponse = await containerClient.create(updatedOptions);
        return {
          containerClient,
          containerCreateResponse
        };
      });
    }
    async deleteContainer(containerName, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-deleteContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        return containerClient.delete(updatedOptions);
      });
    }
    async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-undeleteContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName);
        const containerContext = containerClient["storageClientContext"].container;
        const containerUndeleteResponse = (0, utils_common_js_2.assertResponse)(await containerContext.restore({
          deletedContainerName,
          deletedContainerVersion,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return { containerClient, containerUndeleteResponse };
      });
    }
    async getProperties(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getProperties", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getProperties({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setProperties(properties, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-setProperties", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.setProperties(properties, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getStatistics(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getStatistics", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getStatistics({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getAccountInfo", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async listContainersSegment(marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-listContainersSegment", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.listContainersSegment({
          abortSignal: options.abortSignal,
          marker,
          ...options,
          include: typeof options.include === "string" ? [options.include] : options.include,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        const response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response,
          _response: response._response,
          blobs: response.blobs.map((blob) => {
            let tagValue = "";
            if (blob.tags?.blobTagSet.length === 1) {
              tagValue = blob.tags.blobTagSet[0].value;
            }
            return { ...blob, tags: (0, utils_common_js_1.toTags)(blob.tags), tagValue };
          })
        };
        return wrappedResponse;
      });
    }
    async* findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
      let response;
      if (!!marker || marker === undefined) {
        do {
          response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
          response.blobs = response.blobs || [];
          marker = response.continuationToken;
          yield response;
        } while (marker);
      }
    }
    async* findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
      let marker;
      for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)) {
        yield* segment.blobs;
      }
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      const listSegmentOptions = {
        ...options
      };
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    async* listSegments(marker, options = {}) {
      let listContainersSegmentResponse;
      if (!!marker || marker === undefined) {
        do {
          listContainersSegmentResponse = await this.listContainersSegment(marker, options);
          listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
          marker = listContainersSegmentResponse.continuationToken;
          yield await listContainersSegmentResponse;
        } while (marker);
      }
    }
    async* listItems(options = {}) {
      let marker;
      for await (const segment of this.listSegments(marker, options)) {
        yield* segment.containerItems;
      }
    }
    listContainers(options = {}) {
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const include = [];
      if (options.includeDeleted) {
        include.push("deleted");
      }
      if (options.includeMetadata) {
        include.push("metadata");
      }
      if (options.includeSystem) {
        include.push("system");
      }
      const listSegmentOptions = {
        ...options,
        ...include.length > 0 ? { include } : {}
      };
      const iter = this.listItems(listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    async getUserDelegationKey(startsOn, expiresOn, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options, async (updatedOptions) => {
        const response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.getUserDelegationKey({
          startsOn: (0, utils_common_js_2.truncatedISO8061Date)(startsOn, false),
          expiresOn: (0, utils_common_js_2.truncatedISO8061Date)(expiresOn, false)
        }, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const userDelegationKey = {
          signedObjectId: response.signedObjectId,
          signedTenantId: response.signedTenantId,
          signedStartsOn: new Date(response.signedStartsOn),
          signedExpiresOn: new Date(response.signedExpiresOn),
          signedService: response.signedService,
          signedVersion: response.signedVersion,
          value: response.value
        };
        const res = {
          _response: response._response,
          requestId: response.requestId,
          clientRequestId: response.clientRequestId,
          version: response.version,
          date: response.date,
          errorCode: response.errorCode,
          ...userDelegationKey
        };
        return res;
      });
    }
    getBlobBatchClient() {
      return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
    }
    generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof storage_common_1.StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn === undefined) {
        const now = new Date;
        expiresOn = new Date(now.getTime() + 3600 * 1000);
      }
      const sas = (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParameters)({
        permissions,
        expiresOn,
        resourceTypes,
        services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
        ...options
      }, this.credential).toString();
      return (0, utils_common_js_1.appendToURLQuery)(this.url, sas);
    }
    generateSasStringToSign(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof storage_common_1.StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn === undefined) {
        const now = new Date;
        expiresOn = new Date(now.getTime() + 3600 * 1000);
      }
      return (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParametersInternal)({
        permissions,
        expiresOn,
        resourceTypes,
        services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
        ...options
      }, this.credential).stringToSign;
    }
  }
  exports.BlobServiceClient = BlobServiceClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchResponse.js
var require_BatchResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/storage-blob/dist/commonjs/generatedModels.js
var require_generatedModels = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KnownEncryptionAlgorithmType = undefined;
  var KnownEncryptionAlgorithmType;
  (function(KnownEncryptionAlgorithmType2) {
    KnownEncryptionAlgorithmType2["AES256"] = "AES256";
  })(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
});

// node_modules/@azure/storage-blob/dist/commonjs/index.js
var require_commonjs15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = exports.RestError = exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = exports.StorageSharedKeyCredentialPolicy = exports.StorageSharedKeyCredential = exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = exports.Credential = exports.CredentialPolicy = exports.BaseRequestPolicy = exports.AnonymousCredentialPolicy = exports.AnonymousCredential = exports.StorageOAuthScopes = exports.newPipeline = exports.isPipelineLike = exports.Pipeline = exports.getBlobServiceAccountAudience = exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = exports.generateBlobSASQueryParameters = exports.generateAccountSASQueryParameters = undefined;
  var tslib_1 = require_tslib();
  var core_rest_pipeline_1 = require_commonjs8();
  Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
    return core_rest_pipeline_1.RestError;
  } });
  tslib_1.__exportStar(require_BlobServiceClient(), exports);
  tslib_1.__exportStar(require_Clients(), exports);
  tslib_1.__exportStar(require_ContainerClient(), exports);
  tslib_1.__exportStar(require_BlobLeaseClient(), exports);
  tslib_1.__exportStar(require_AccountSASPermissions(), exports);
  tslib_1.__exportStar(require_AccountSASResourceTypes(), exports);
  tslib_1.__exportStar(require_AccountSASServices(), exports);
  var AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues();
  Object.defineProperty(exports, "generateAccountSASQueryParameters", { enumerable: true, get: function() {
    return AccountSASSignatureValues_js_1.generateAccountSASQueryParameters;
  } });
  tslib_1.__exportStar(require_BlobBatch(), exports);
  tslib_1.__exportStar(require_BlobBatchClient(), exports);
  tslib_1.__exportStar(require_BatchResponse(), exports);
  tslib_1.__exportStar(require_BlobSASPermissions(), exports);
  var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
  Object.defineProperty(exports, "generateBlobSASQueryParameters", { enumerable: true, get: function() {
    return BlobSASSignatureValues_js_1.generateBlobSASQueryParameters;
  } });
  tslib_1.__exportStar(require_ContainerSASPermissions(), exports);
  var models_js_1 = require_models2();
  Object.defineProperty(exports, "BlockBlobTier", { enumerable: true, get: function() {
    return models_js_1.BlockBlobTier;
  } });
  Object.defineProperty(exports, "PremiumPageBlobTier", { enumerable: true, get: function() {
    return models_js_1.PremiumPageBlobTier;
  } });
  Object.defineProperty(exports, "StorageBlobAudience", { enumerable: true, get: function() {
    return models_js_1.StorageBlobAudience;
  } });
  Object.defineProperty(exports, "getBlobServiceAccountAudience", { enumerable: true, get: function() {
    return models_js_1.getBlobServiceAccountAudience;
  } });
  var Pipeline_js_1 = require_Pipeline();
  Object.defineProperty(exports, "Pipeline", { enumerable: true, get: function() {
    return Pipeline_js_1.Pipeline;
  } });
  Object.defineProperty(exports, "isPipelineLike", { enumerable: true, get: function() {
    return Pipeline_js_1.isPipelineLike;
  } });
  Object.defineProperty(exports, "newPipeline", { enumerable: true, get: function() {
    return Pipeline_js_1.newPipeline;
  } });
  Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: true, get: function() {
    return Pipeline_js_1.StorageOAuthScopes;
  } });
  var storage_common_1 = require_commonjs13();
  Object.defineProperty(exports, "AnonymousCredential", { enumerable: true, get: function() {
    return storage_common_1.AnonymousCredential;
  } });
  Object.defineProperty(exports, "AnonymousCredentialPolicy", { enumerable: true, get: function() {
    return storage_common_1.AnonymousCredentialPolicy;
  } });
  Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: true, get: function() {
    return storage_common_1.BaseRequestPolicy;
  } });
  Object.defineProperty(exports, "CredentialPolicy", { enumerable: true, get: function() {
    return storage_common_1.CredentialPolicy;
  } });
  Object.defineProperty(exports, "Credential", { enumerable: true, get: function() {
    return storage_common_1.Credential;
  } });
  Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: true, get: function() {
    return storage_common_1.StorageRetryPolicyType;
  } });
  Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: true, get: function() {
    return storage_common_1.StorageRetryPolicy;
  } });
  Object.defineProperty(exports, "StorageRetryPolicyFactory", { enumerable: true, get: function() {
    return storage_common_1.StorageRetryPolicyFactory;
  } });
  Object.defineProperty(exports, "StorageSharedKeyCredential", { enumerable: true, get: function() {
    return storage_common_1.StorageSharedKeyCredential;
  } });
  Object.defineProperty(exports, "StorageSharedKeyCredentialPolicy", { enumerable: true, get: function() {
    return storage_common_1.StorageSharedKeyCredentialPolicy;
  } });
  Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: true, get: function() {
    return storage_common_1.StorageBrowserPolicy;
  } });
  Object.defineProperty(exports, "StorageBrowserPolicyFactory", { enumerable: true, get: function() {
    return storage_common_1.StorageBrowserPolicyFactory;
  } });
  tslib_1.__exportStar(require_SASQueryParameters(), exports);
  tslib_1.__exportStar(require_generatedModels(), exports);
  var log_js_1 = require_log5();
  Object.defineProperty(exports, "logger", { enumerable: true, get: function() {
    return log_js_1.logger;
  } });
});

// node_modules/@actions/artifact/lib/internal/upload/blob-upload.js
var require_blob_upload = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uploadZipToBlobStorage = uploadZipToBlobStorage;
  var storage_blob_1 = require_commonjs15();
  var config_1 = require_config();
  var core = __importStar(require_core());
  var crypto2 = __importStar(__require("crypto"));
  var stream = __importStar(__require("stream"));
  var errors_1 = require_errors2();
  function uploadZipToBlobStorage(authenticatedUploadURL, zipUploadStream) {
    return __awaiter(this, undefined, undefined, function* () {
      let uploadByteCount = 0;
      let lastProgressTime = Date.now();
      const abortController = new AbortController;
      const chunkTimer = (interval) => __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => {
          const timer = setInterval(() => {
            if (Date.now() - lastProgressTime > interval) {
              reject(new Error("Upload progress stalled."));
            }
          }, interval);
          abortController.signal.addEventListener("abort", () => {
            clearInterval(timer);
            resolve();
          });
        });
      });
      const maxConcurrency = (0, config_1.getConcurrency)();
      const bufferSize = (0, config_1.getUploadChunkSize)();
      const blobClient = new storage_blob_1.BlobClient(authenticatedUploadURL);
      const blockBlobClient = blobClient.getBlockBlobClient();
      core.debug(`Uploading artifact zip to blob storage with maxConcurrency: ${maxConcurrency}, bufferSize: ${bufferSize}`);
      const uploadCallback = (progress) => {
        core.info(`Uploaded bytes ${progress.loadedBytes}`);
        uploadByteCount = progress.loadedBytes;
        lastProgressTime = Date.now();
      };
      const options = {
        blobHTTPHeaders: { blobContentType: "zip" },
        onProgress: uploadCallback,
        abortSignal: abortController.signal
      };
      let sha256Hash = undefined;
      const uploadStream = new stream.PassThrough;
      const hashStream = crypto2.createHash("sha256");
      zipUploadStream.pipe(uploadStream);
      zipUploadStream.pipe(hashStream).setEncoding("hex");
      core.info("Beginning upload of artifact content to blob storage");
      try {
        yield Promise.race([
          blockBlobClient.uploadStream(uploadStream, bufferSize, maxConcurrency, options),
          chunkTimer((0, config_1.getUploadChunkTimeout)())
        ]);
      } catch (error) {
        if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === undefined ? undefined : error.code)) {
          throw new errors_1.NetworkError(error === null || error === undefined ? undefined : error.code);
        }
        throw error;
      } finally {
        abortController.abort();
      }
      core.info("Finished uploading artifact content to blob storage!");
      hashStream.end();
      sha256Hash = hashStream.read();
      core.info(`SHA256 digest of uploaded artifact zip is ${sha256Hash}`);
      if (uploadByteCount === 0) {
        core.warning(`No data was uploaded to blob storage. Reported upload byte count is 0.`);
      }
      return {
        uploadSize: uploadByteCount,
        sha256Hash
      };
    });
  }
});

// node_modules/readdir-glob/node_modules/minimatch/lib/path.js
var require_path = __commonJS((exports, module) => {
  var isWindows = typeof process === "object" && process && process.platform === "win32";
  module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  module.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00";
  var escOpen = "\x00OPEN" + Math.random() + "\x00";
  var escClose = "\x00CLOSE" + Math.random() + "\x00";
  var escComma = "\x00COMMA" + Math.random() + "\x00";
  var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m)
      return [str];
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    if (/\$$/.test(m.pre)) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,(?!,).*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x;test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0;j < n.length; j++) {
          N.push.apply(N, expand(n[j], false));
        }
      }
      for (var j = 0;j < N.length; j++) {
        for (var k = 0;k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    }
    return expansions;
  }
});

// node_modules/readdir-glob/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  var minimatch = module.exports = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  module.exports = minimatch;
  var path = require_path();
  minimatch.sep = path.sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var expand = require_brace_expansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var charSet = (s) => s.split("").reduce((set, c) => {
    set[c] = true;
    return set;
  }, {});
  var reSpecials = charSet("().*{}+?[]^$\\!");
  var addPatternStartSet = charSet("[.(");
  var slashSplit = /\/+/;
  minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
  var ext = (a, b = {}) => {
    const t = {};
    Object.keys(a).forEach((k) => t[k] = a[k]);
    Object.keys(b).forEach((k) => t[k] = b[k]);
    return t;
  };
  minimatch.defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
    m.Minimatch = class Minimatch2 extends orig.Minimatch {
      constructor(pattern, options) {
        super(pattern, ext(def, options));
      }
    };
    m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
    m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
    m.defaults = (options) => orig.defaults(ext(def, options));
    m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
    m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
    m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
    return m;
  };
  minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
  var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  };
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  var SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
  minimatch.match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
  var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");

  class Minimatch {
    constructor(pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    debug() {}
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      let set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, set);
      set = this.globParts = set.map((s) => s.split(slashSplit));
      this.debug(this.pattern, set);
      set = set.map((s, si, set2) => s.map(this.parse, this));
      this.debug(this.pattern, set);
      set = set.filter((s) => s.indexOf(false) === -1);
      this.debug(this.pattern, set);
      this.set = set;
    }
    parseNegate() {
      if (this.options.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    matchOne(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { this: this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (;fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      let re = "";
      let hasMagic = false;
      let escaping = false;
      const patternListStack = [];
      const negativeLists = [];
      let stateChar;
      let inClass = false;
      let reClassStart = -1;
      let classStart = -1;
      let cs;
      let pl;
      let sp;
      let dotTravAllowed = pattern.charAt(0) === ".";
      let dotFileAllowed = options.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      };
      for (let i = 0, c;i < pattern.length && (c = pattern.charAt(i)); i++) {
        this.debug("%s\t%s %s %j", pattern, i, re, c);
        if (escaping) {
          if (c === "/") {
            return false;
          }
          if (reSpecials[c]) {
            re += "\\";
          }
          re += c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c;
              continue;
            }
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "\t", plEntry);
            patternListStack.push(plEntry);
            re += plEntry.open;
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            patternListStack.pop();
            clearStateChar();
            hasMagic = true;
            pl = plEntry;
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            }
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            clearStateChar();
            re += "|";
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            continue;
          }
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
              re += c;
            } catch (er) {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic = true;
            inClass = false;
            continue;
          default:
            clearStateChar();
            if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
            break;
        }
      }
      if (inClass) {
        cs = pattern.slice(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substring(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug(`tail=%j
   %s`, tail, tail, pl, re);
        const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      const addPatternStart = addPatternStartSet[re.charAt(0)];
      for (let n = negativeLists.length - 1;n > -1; n--) {
        const nl = negativeLists[n];
        const nlBefore = re.slice(0, nl.reStart);
        const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        let nlAfter = re.slice(nl.reEnd);
        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
        const closeParensBefore = nlBefore.split(")").length;
        const openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0;i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart() + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (options.nocase && !hasMagic) {
        hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      const flags = options.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch (er) {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      const flags = options.nocase ? "i" : "";
      let re = set.map((pattern) => {
        pattern = pattern.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set2, p) => {
          if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
            set2.push(p);
          }
          return set2;
        }, []);
        pattern.forEach((p, i) => {
          if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
            return;
          }
          if (i === 0) {
            if (pattern.length > 1) {
              pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
            } else {
              pattern[i] = twoStar;
            }
          } else if (i === pattern.length - 1) {
            pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
          } else {
            pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
            pattern[i + 1] = GLOBSTAR;
          }
        });
        return pattern.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      const options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename;
      for (let i = f.length - 1;i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (let i = 0;i < set.length; i++) {
        const pattern = set[i];
        let file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  }
  minimatch.Minimatch = Minimatch;
});

// node_modules/readdir-glob/index.js
var require_readdir_glob = __commonJS((exports, module) => {
  module.exports = readdirGlob;
  var fs = __require("fs");
  var { EventEmitter } = __require("events");
  var { Minimatch } = require_minimatch();
  var { resolve } = __require("path");
  function readdir(dir, strict) {
    return new Promise((resolve2, reject) => {
      fs.readdir(dir, { withFileTypes: true }, (err, files) => {
        if (err) {
          switch (err.code) {
            case "ENOTDIR":
              if (strict) {
                reject(err);
              } else {
                resolve2([]);
              }
              break;
            case "ENOTSUP":
            case "ENOENT":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              resolve2([]);
              break;
            case "ELOOP":
            default:
              reject(err);
              break;
          }
        } else {
          resolve2(files);
        }
      });
    });
  }
  function stat(file, followSymlinks) {
    return new Promise((resolve2, reject) => {
      const statFunc = followSymlinks ? fs.stat : fs.lstat;
      statFunc(file, (err, stats) => {
        if (err) {
          switch (err.code) {
            case "ENOENT":
              if (followSymlinks) {
                resolve2(stat(file, false));
              } else {
                resolve2(null);
              }
              break;
            default:
              resolve2(null);
              break;
          }
        } else {
          resolve2(stats);
        }
      });
    });
  }
  async function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {
    let files = await readdir(path + dir, strict);
    for (const file of files) {
      let name = file.name;
      if (name === undefined) {
        name = file;
        useStat = true;
      }
      const filename = dir + "/" + name;
      const relative = filename.slice(1);
      const absolute = path + "/" + relative;
      let stats = null;
      if (useStat || followSymlinks) {
        stats = await stat(absolute, followSymlinks);
      }
      if (!stats && file.name !== undefined) {
        stats = file;
      }
      if (stats === null) {
        stats = { isDirectory: () => false };
      }
      if (stats.isDirectory()) {
        if (!shouldSkip(relative)) {
          yield { relative, absolute, stats };
          yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);
        }
      } else {
        yield { relative, absolute, stats };
      }
    }
  }
  async function* explore(path, followSymlinks, useStat, shouldSkip) {
    yield* exploreWalkAsync("", path, followSymlinks, useStat, shouldSkip, true);
  }
  function readOptions(options) {
    return {
      pattern: options.pattern,
      dot: !!options.dot,
      noglobstar: !!options.noglobstar,
      matchBase: !!options.matchBase,
      nocase: !!options.nocase,
      ignore: options.ignore,
      skip: options.skip,
      follow: !!options.follow,
      stat: !!options.stat,
      nodir: !!options.nodir,
      mark: !!options.mark,
      silent: !!options.silent,
      absolute: !!options.absolute
    };
  }

  class ReaddirGlob extends EventEmitter {
    constructor(cwd, options, cb) {
      super();
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      this.options = readOptions(options || {});
      this.matchers = [];
      if (this.options.pattern) {
        const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
        this.matchers = matchers.map((m) => new Minimatch(m, {
          dot: this.options.dot,
          noglobstar: this.options.noglobstar,
          matchBase: this.options.matchBase,
          nocase: this.options.nocase
        }));
      }
      this.ignoreMatchers = [];
      if (this.options.ignore) {
        const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
        this.ignoreMatchers = ignorePatterns.map((ignore) => new Minimatch(ignore, { dot: true }));
      }
      this.skipMatchers = [];
      if (this.options.skip) {
        const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
        this.skipMatchers = skipPatterns.map((skip) => new Minimatch(skip, { dot: true }));
      }
      this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
      this.paused = false;
      this.inactive = false;
      this.aborted = false;
      if (cb) {
        this._matches = [];
        this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative));
        this.on("error", (err) => cb(err));
        this.on("end", () => cb(null, this._matches));
      }
      setTimeout(() => this._next(), 0);
    }
    _shouldSkipDirectory(relative) {
      return this.skipMatchers.some((m) => m.match(relative));
    }
    _fileMatches(relative, isDirectory) {
      const file = relative + (isDirectory ? "/" : "");
      return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file))) && !this.ignoreMatchers.some((m) => m.match(file)) && (!this.options.nodir || !isDirectory);
    }
    _next() {
      if (!this.paused && !this.aborted) {
        this.iterator.next().then((obj) => {
          if (!obj.done) {
            const isDirectory = obj.value.stats.isDirectory();
            if (this._fileMatches(obj.value.relative, isDirectory)) {
              let relative = obj.value.relative;
              let absolute = obj.value.absolute;
              if (this.options.mark && isDirectory) {
                relative += "/";
                absolute += "/";
              }
              if (this.options.stat) {
                this.emit("match", { relative, absolute, stat: obj.value.stats });
              } else {
                this.emit("match", { relative, absolute });
              }
            }
            this._next(this.iterator);
          } else {
            this.emit("end");
          }
        }).catch((err) => {
          this.abort();
          this.emit("error", err);
          if (!err.code && !this.options.silent) {
            console.error(err);
          }
        });
      } else {
        this.inactive = true;
      }
    }
    abort() {
      this.aborted = true;
    }
    pause() {
      this.paused = true;
    }
    resume() {
      this.paused = false;
      if (this.inactive) {
        this.inactive = false;
        this._next();
      }
    }
  }
  function readdirGlob(pattern, options, cb) {
    return new ReaddirGlob(pattern, options, cb);
  }
  readdirGlob.ReaddirGlob = ReaddirGlob;
});

// node_modules/async/dist/async.js
var require_async = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.async = {}));
  })(exports, function(exports2) {
    function apply(fn, ...args) {
      return (...callArgs) => fn(...args, ...callArgs);
    }
    function initialParams(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    }
    var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer$1;
    if (hasQueueMicrotask) {
      _defer$1 = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else {
      _defer$1 = fallback;
    }
    var setImmediate$1 = wrap(_defer$1);
    function asyncify(func) {
      if (isAsync(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return initialParams(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        setImmediate$1((e) => {
          throw e;
        }, err);
      }
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject2) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    function applyEach$1(eachfn) {
      return function applyEach(fns, ...callArgs) {
        const go = awaitify(function(callback) {
          var that = this;
          return eachfn(fns, (fn, cb) => {
            wrapAsync(fn).apply(that, callArgs.concat(cb));
          }, callback);
        });
        return go;
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      arr = arr || [];
      var results = [];
      var counter = 0;
      var _iteratee = wrapAsync(iteratee);
      return eachfn(arr, (value, _2, iterCb) => {
        var index2 = counter++;
        _iteratee(value, (err, v) => {
          results[index2] = v;
          iterCb(err);
        });
      }, (err) => {
        callback(err, results);
      });
    }
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    const breakLoop = {};
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    function getIterator(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if (isArrayLike(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = getIterator(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === breakLoop || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    var eachOfLimit$2 = (limit) => {
      return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if (isAsyncGenerator(obj)) {
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj)) {
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    function eachOfLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$1 = awaitify(eachOfLimit, 4);
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback);
      var index2 = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === breakLoop) {
          callback(null);
        }
      }
      for (;index2 < length; index2++) {
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return eachOfLimit$1(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    function map(coll, iteratee, callback) {
      return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3);
    var applyEach = applyEach$1(map$1);
    function eachOfSeries(coll, iteratee, callback) {
      return eachOfLimit$1(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    function mapSeries(coll, iteratee, callback) {
      return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3);
    var applyEachSeries = applyEach$1(mapSeries$1);
    const PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
      let resolve, reject2;
      function callback(err, ...args) {
        if (err)
          return reject2(err);
        resolve(args.length > 1 ? args : args[0]);
      }
      callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject2 = rej;
      });
      return callback;
    }
    function auto(tasks, concurrency, callback) {
      if (typeof concurrency !== "number") {
        callback = concurrency;
        concurrency = null;
      }
      callback = once(callback || promiseCallback());
      var numTasks = Object.keys(tasks).length;
      if (!numTasks) {
        return callback(null);
      }
      if (!concurrency) {
        concurrency = numTasks;
      }
      var results = {};
      var runningTasks = 0;
      var canceled = false;
      var hasError = false;
      var listeners = Object.create(null);
      var readyTasks = [];
      var readyToCheck = [];
      var uncheckedDependencies = {};
      Object.keys(tasks).forEach((key) => {
        var task = tasks[key];
        if (!Array.isArray(task)) {
          enqueueTask(key, [task]);
          readyToCheck.push(key);
          return;
        }
        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
          readyToCheck.push(key);
          return;
        }
        uncheckedDependencies[key] = remainingDependencies;
        dependencies.forEach((dependencyName) => {
          if (!tasks[dependencyName]) {
            throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
          }
          addListener(dependencyName, () => {
            remainingDependencies--;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
            }
          });
        });
      });
      checkForDeadlocks();
      processQueue();
      function enqueueTask(key, task) {
        readyTasks.push(() => runTask(key, task));
      }
      function processQueue() {
        if (canceled)
          return;
        if (readyTasks.length === 0 && runningTasks === 0) {
          return callback(null, results);
        }
        while (readyTasks.length && runningTasks < concurrency) {
          var run = readyTasks.shift();
          run();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
          taskListeners = listeners[taskName] = [];
        }
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach((fn) => fn());
        processQueue();
      }
      function runTask(key, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce((err, ...result) => {
          runningTasks--;
          if (err === false) {
            canceled = true;
            return;
          }
          if (result.length < 2) {
            [result] = result;
          }
          if (err) {
            var safeResults = {};
            Object.keys(results).forEach((rkey) => {
              safeResults[rkey] = results[rkey];
            });
            safeResults[key] = result;
            hasError = true;
            listeners = Object.create(null);
            if (canceled)
              return;
            callback(err, safeResults);
          } else {
            results[key] = result;
            taskComplete(key);
          }
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
          taskFn(results, taskCallback);
        } else {
          taskFn(taskCallback);
        }
      }
      function checkForDeadlocks() {
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
          currentTask = readyToCheck.pop();
          counter++;
          getDependents(currentTask).forEach((dependent) => {
            if (--uncheckedDependencies[dependent] === 0) {
              readyToCheck.push(dependent);
            }
          });
        }
        if (counter !== numTasks) {
          throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
      }
      function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach((key) => {
          const task = tasks[key];
          if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
            result.push(key);
          }
        });
        return result;
      }
      return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    function stripComments(string) {
      let stripped = "";
      let index2 = 0;
      let endBlockComment = string.indexOf("*/");
      while (index2 < string.length) {
        if (string[index2] === "/" && string[index2 + 1] === "/") {
          let endIndex = string.indexOf(`
`, index2);
          index2 = endIndex === -1 ? string.length : endIndex;
        } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
          let endIndex = string.indexOf("*/", index2);
          if (endIndex !== -1) {
            index2 = endIndex + 2;
            endBlockComment = string.indexOf("*/", index2);
          } else {
            stripped += string[index2];
            index2++;
          }
        } else {
          stripped += string[index2];
          index2++;
        }
      }
      return stripped;
    }
    function parseParams(func) {
      const src = stripComments(func.toString());
      let match = src.match(FN_ARGS);
      if (!match) {
        match = src.match(ARROW_FN_ARGS);
      }
      if (!match)
        throw new Error(`could not parse args in autoInject
Source:
` + src);
      let [, args] = match;
      return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      Object.keys(tasks).forEach((key) => {
        var taskFn = tasks[key];
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (Array.isArray(taskFn)) {
          params = [...taskFn];
          taskFn = params.pop();
          newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
          newTasks[key] = taskFn;
        } else {
          params = parseParams(taskFn);
          if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
            throw new Error("autoInject task functions require explicit parameters.");
          }
          if (!fnIsAsync)
            params.pop();
          newTasks[key] = params.concat(newTask);
        }
        function newTask(results, taskCb) {
          var newArgs = params.map((name) => results[name]);
          newArgs.push(taskCb);
          wrapAsync(taskFn)(...newArgs);
        }
      });
      return auto(newTasks, callback);
    }

    class DLL {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var { next } = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    }
    function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
    }
    function queue$1(worker, concurrency, payload) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new RangeError("Concurrency must not be zero");
      }
      var _worker = wrapAsync(worker);
      var numRunning = 0;
      var workersList = [];
      const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
      };
      function on(event, handler) {
        events[event].push(handler);
      }
      function once2(event, handler) {
        const handleAndRemove = (...args) => {
          off(event, handleAndRemove);
          handler(...args);
        };
        events[event].push(handleAndRemove);
      }
      function off(event, handler) {
        if (!event)
          return Object.keys(events).forEach((ev) => events[ev] = []);
        if (!handler)
          return events[event] = [];
        events[event] = events[event].filter((ev) => ev !== handler);
      }
      function trigger(event, ...args) {
        events[event].forEach((handler) => handler(...args));
      }
      var processingScheduled = false;
      function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        var res, rej;
        function promiseCallback2(err, ...args) {
          if (err)
            return rejectOnError ? rej(err) : res();
          if (args.length <= 1)
            return res(args[0]);
          res(args);
        }
        var item = q._createTaskItem(data, rejectOnError ? promiseCallback2 : callback || promiseCallback2);
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
        if (!processingScheduled) {
          processingScheduled = true;
          setImmediate$1(() => {
            processingScheduled = false;
            q.process();
          });
        }
        if (rejectOnError || !callback) {
          return new Promise((resolve, reject2) => {
            res = resolve;
            rej = reject2;
          });
        }
      }
      function _createCB(tasks) {
        return function(err, ...args) {
          numRunning -= 1;
          for (var i = 0, l = tasks.length;i < l; i++) {
            var task = tasks[i];
            var index2 = workersList.indexOf(task);
            if (index2 === 0) {
              workersList.shift();
            } else if (index2 > 0) {
              workersList.splice(index2, 1);
            }
            task.callback(err, ...args);
            if (err != null) {
              trigger("error", err, task.data);
            }
          }
          if (numRunning <= q.concurrency - q.buffer) {
            trigger("unsaturated");
          }
          if (q.idle()) {
            trigger("drain");
          }
          q.process();
        };
      }
      function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
          setImmediate$1(() => trigger("drain"));
          return true;
        }
        return false;
      }
      const eventMethod = (name) => (handler) => {
        if (!handler) {
          return new Promise((resolve, reject2) => {
            once2(name, (err, data) => {
              if (err)
                return reject2(err);
              resolve(data);
            });
          });
        }
        off(name);
        on(name, handler);
      };
      var isProcessing = false;
      var q = {
        _tasks: new DLL,
        _createTaskItem(data, callback) {
          return {
            data,
            callback
          };
        },
        *[Symbol.iterator]() {
          yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, false, callback));
          }
          return _insert(data, false, false, callback);
        },
        pushAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, true, callback));
          }
          return _insert(data, false, true, callback);
        },
        kill() {
          off();
          q._tasks.empty();
        },
        unshift(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, false, callback));
          }
          return _insert(data, true, false, callback);
        },
        unshiftAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, true, callback));
          }
          return _insert(data, true, true, callback);
        },
        remove(testFn) {
          q._tasks.remove(testFn);
        },
        process() {
          if (isProcessing) {
            return;
          }
          isProcessing = true;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [];
            var l = q._tasks.length;
            if (q.payload)
              l = Math.min(l, q.payload);
            for (var i = 0;i < l; i++) {
              var node = q._tasks.shift();
              tasks.push(node);
              workersList.push(node);
              data.push(node.data);
            }
            numRunning += 1;
            if (q._tasks.length === 0) {
              trigger("empty");
            }
            if (numRunning === q.concurrency) {
              trigger("saturated");
            }
            var cb = onlyOnce(_createCB(tasks));
            _worker(data, cb);
          }
          isProcessing = false;
        },
        length() {
          return q._tasks.length;
        },
        running() {
          return numRunning;
        },
        workersList() {
          return workersList;
        },
        idle() {
          return q._tasks.length + numRunning === 0;
        },
        pause() {
          q.paused = true;
        },
        resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          setImmediate$1(q.process);
        }
      };
      Object.defineProperties(q, {
        saturated: {
          writable: false,
          value: eventMethod("saturated")
        },
        unsaturated: {
          writable: false,
          value: eventMethod("unsaturated")
        },
        empty: {
          writable: false,
          value: eventMethod("empty")
        },
        drain: {
          writable: false,
          value: eventMethod("drain")
        },
        error: {
          writable: false,
          value: eventMethod("error")
        }
      });
      return q;
    }
    function cargo$1(worker, payload) {
      return queue$1(worker, 1, payload);
    }
    function cargo(worker, concurrency, payload) {
      return queue$1(worker, concurrency, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
      callback = once(callback);
      var _iteratee = wrapAsync(iteratee);
      return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
          memo = v;
          iterCb(err);
        });
      }, (err) => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);
    function seq(...functions) {
      var _functions = functions.map(wrapAsync);
      return function(...args) {
        var that = this;
        var cb = args[args.length - 1];
        if (typeof cb == "function") {
          args.pop();
        } else {
          cb = promiseCallback();
        }
        reduce$1(_functions, args, (newargs, fn, iterCb) => {
          fn.apply(that, newargs.concat((err, ...nextargs) => {
            iterCb(err, nextargs);
          }));
        }, (err, results) => cb(err, ...results));
        return cb[PROMISE_SYMBOL];
      };
    }
    function compose(...args) {
      return seq(...args.reverse());
    }
    function mapLimit(coll, limit, iteratee, callback) {
      return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    function concatLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args) => {
          if (err)
            return iterCb(err);
          return iterCb(err, args);
        });
      }, (err, mapResults) => {
        var result = [];
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            result = result.concat(...mapResults[i]);
          }
        }
        return callback(err, result);
      });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    function concat(coll, iteratee, callback) {
      return concatLimit$1(coll, Infinity, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    function concatSeries(coll, iteratee, callback) {
      return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    function constant$1(...args) {
      return function(...ignoredArgs) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args);
      };
    }
    function _createTester(check, getResult) {
      return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _2, callback) => {
          iteratee(value, (err, result) => {
            if (err || err === false)
              return callback(err);
            if (check(result) && !testResult) {
              testPassed = true;
              testResult = getResult(true, value);
              return callback(null, breakLoop);
            }
            callback();
          });
        }, (err) => {
          if (err)
            return cb(err);
          cb(null, testPassed ? testResult : getResult(false));
        });
      };
    }
    function detect(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    function detectLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    function detectSeries(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name) {
      return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
        if (typeof console === "object") {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          } else if (console[name]) {
            resultArgs.forEach((x) => console[name](x));
          }
        }
      });
    }
    var dir = consoleFunc("dir");
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results;
      function next(err, ...args) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        results = args;
        _test(...args, check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return check(null, true);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    function doUntil(iteratee, test, callback) {
      const _test = wrapAsync(test);
      return doWhilst$1(iteratee, (...args) => {
        const cb = args.pop();
        _test(...args, (err, truth) => cb(err, !truth));
      }, callback);
    }
    function _withoutIndex(iteratee) {
      return (value, index2, callback) => iteratee(value, callback);
    }
    function eachLimit$2(coll, iteratee, callback) {
      return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit$2, 3);
    function eachLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$1 = awaitify(eachLimit, 4);
    function eachSeries(coll, iteratee, callback) {
      return eachLimit$1(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return function(...args) {
        var callback = args.pop();
        var sync = true;
        args.push((...innerArgs) => {
          if (sync) {
            setImmediate$1(() => callback(...innerArgs));
          } else {
            callback(...innerArgs);
          }
        });
        fn.apply(this, args);
        sync = false;
      };
    }
    function every(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every, 3);
    function everyLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    function everySeries(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index2] = !!v;
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results = [];
        for (var i = 0;i < arr.length; i++) {
          if (truthValues[i])
            results.push(arr[i]);
        }
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v) {
            results.push({ index: index2, value: x });
          }
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
      return filter2(eachfn, coll, wrapAsync(iteratee), callback);
    }
    function filter(coll, iteratee, callback) {
      return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter, 3);
    function filterLimit(coll, limit, iteratee, callback) {
      return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    function filterSeries(coll, iteratee, callback) {
      return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    function forever(fn, errback) {
      var done = onlyOnce(errback);
      var task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        if (err === false)
          return;
        task(next);
      }
      return next();
    }
    var forever$1 = awaitify(forever, 2);
    function groupByLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key) => {
          if (err)
            return iterCb(err);
          return iterCb(err, { key, val });
        });
      }, (err, mapResults) => {
        var result = {};
        var { hasOwnProperty } = Object.prototype;
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            var { key } = mapResults[i];
            var { val } = mapResults[i];
            if (hasOwnProperty.call(result, key)) {
              result[key].push(val);
            } else {
              result[key] = [val];
            }
          }
        }
        return callback(err, result);
      });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    function groupBy(coll, iteratee, callback) {
      return groupByLimit$1(coll, Infinity, iteratee, callback);
    }
    function groupBySeries(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1, iteratee, callback);
    }
    var log = consoleFunc("log");
    function mapValuesLimit(obj, limit, iteratee, callback) {
      callback = once(callback);
      var newObj = {};
      var _iteratee = wrapAsync(iteratee);
      return eachOfLimit$2(limit)(obj, (val, key, next) => {
        _iteratee(val, key, (err, result) => {
          if (err)
            return next(err);
          newObj[key] = result;
          next(err);
        });
      }, (err) => callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    function mapValues(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, Infinity, iteratee, callback);
    }
    function mapValuesSeries(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, 1, iteratee, callback);
    }
    function memoize(fn, hasher = (v) => v) {
      var memo = Object.create(null);
      var queues = Object.create(null);
      var _fn = wrapAsync(fn);
      var memoized = initialParams((args, callback) => {
        var key = hasher(...args);
        if (key in memo) {
          setImmediate$1(() => callback(null, ...memo[key]));
        } else if (key in queues) {
          queues[key].push(callback);
        } else {
          queues[key] = [callback];
          _fn(...args, (err, ...resultArgs) => {
            if (!err) {
              memo[key] = resultArgs;
            }
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length;i < l; i++) {
              q[i](err, ...resultArgs);
            }
          });
        }
      });
      memoized.memo = memo;
      memoized.unmemoized = fn;
      return memoized;
    }
    var _defer;
    if (hasNextTick) {
      _defer = process.nextTick;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else {
      _defer = fallback;
    }
    var nextTick = wrap(_defer);
    var _parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    function parallel(tasks, callback) {
      return _parallel(eachOf$1, tasks, callback);
    }
    function parallelLimit(tasks, limit, callback) {
      return _parallel(eachOfLimit$2(limit), tasks, callback);
    }
    function queue(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue$1((items, cb) => {
        _worker(items[0], cb);
      }, concurrency, 1);
    }

    class Heap {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t;
          index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
            l = l + 1;
          }
          if (smaller(this.heap[index2], this.heap[l])) {
            break;
          }
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l];
          this.heap[l] = t;
          index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0;i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0;i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1);i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    }
    function leftChi(i) {
      return (i << 1) + 1;
    }
    function parent(i) {
      return (i + 1 >> 1) - 1;
    }
    function smaller(x, y) {
      if (x.priority !== y.priority) {
        return x.priority < y.priority;
      } else {
        return x.pushCount < y.pushCount;
      }
    }
    function priorityQueue(worker, concurrency) {
      var q = queue(worker, concurrency);
      var {
        push,
        pushAsync
      } = q;
      q._tasks = new Heap;
      q._createTaskItem = ({ data, priority }, callback) => {
        return {
          data,
          priority,
          callback
        };
      };
      function createDataItems(tasks, priority) {
        if (!Array.isArray(tasks)) {
          return { data: tasks, priority };
        }
        return tasks.map((data) => {
          return { data, priority };
        });
      }
      q.push = function(data, priority = 0, callback) {
        return push(createDataItems(data, priority), callback);
      };
      q.pushAsync = function(data, priority = 0, callback) {
        return pushAsync(createDataItems(data, priority), callback);
      };
      delete q.unshift;
      delete q.unshiftAsync;
      return q;
    }
    function race(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i = 0, l = tasks.length;i < l; i++) {
        wrapAsync(tasks[i])(callback);
      }
    }
    var race$1 = awaitify(race, 2);
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = [...array].reverse();
      return reduce$1(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function reflectOn(args, reflectCallback) {
        args.push((error, ...cbArgs) => {
          let retVal = {};
          if (error) {
            retVal.error = error;
          }
          if (cbArgs.length > 0) {
            var value = cbArgs;
            if (cbArgs.length <= 1) {
              [value] = cbArgs;
            }
            retVal.value = value;
          }
          reflectCallback(null, retVal);
        });
        return _fn.apply(this, args);
      });
    }
    function reflectAll(tasks) {
      var results;
      if (Array.isArray(tasks)) {
        results = tasks.map(reflect);
      } else {
        results = {};
        Object.keys(tasks).forEach((key) => {
          results[key] = reflect.call(this, tasks[key]);
        });
      }
      return results;
    }
    function reject$2(eachfn, arr, _iteratee, callback) {
      const iteratee = wrapAsync(_iteratee);
      return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    function reject(coll, iteratee, callback) {
      return reject$2(eachOf$1, coll, iteratee, callback);
    }
    var reject$1 = awaitify(reject, 3);
    function rejectLimit(coll, limit, iteratee, callback) {
      return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    function rejectSeries(coll, iteratee, callback) {
      return reject$2(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant(value) {
      return function() {
        return value;
      };
    }
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
      var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
      };
      if (arguments.length < 3 && typeof opts === "function") {
        callback = task || promiseCallback();
        task = opts;
      } else {
        parseTimes(options, opts);
        callback = callback || promiseCallback();
      }
      if (typeof task !== "function") {
        throw new Error("Invalid arguments for async.retry");
      }
      var _task = wrapAsync(task);
      var attempt = 1;
      function retryAttempt() {
        _task((err, ...args) => {
          if (err === false)
            return;
          if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
            setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
          } else {
            callback(err, ...args);
          }
        });
      }
      retryAttempt();
      return callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
      if (typeof t === "object") {
        acc.times = +t.times || DEFAULT_TIMES;
        acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
        acc.errorFilter = t.errorFilter;
      } else if (typeof t === "number" || typeof t === "string") {
        acc.times = +t || DEFAULT_TIMES;
      } else {
        throw new Error("Invalid arguments for async.retry");
      }
    }
    function retryable(opts, task) {
      if (!task) {
        task = opts;
        opts = null;
      }
      let arity = opts && opts.arity || task.length;
      if (isAsync(task)) {
        arity += 1;
      }
      var _task = wrapAsync(task);
      return initialParams((args, callback) => {
        if (args.length < arity - 1 || callback == null) {
          args.push(callback);
          callback = promiseCallback();
        }
        function taskFn(cb) {
          _task(...args, cb);
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
        return callback[PROMISE_SYMBOL];
      });
    }
    function series(tasks, callback) {
      return _parallel(eachOfSeries$1, tasks, callback);
    }
    function some(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some, 3);
    function someLimit(coll, limit, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    function someSeries(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
          if (err)
            return iterCb(err);
          iterCb(err, { value: x, criteria });
        });
      }, (err, results) => {
        if (err)
          return callback(err);
        callback(null, results.sort(comparator).map((v) => v.value));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams((args, callback) => {
        var timedOut = false;
        var timer;
        function timeoutCallback() {
          var name = asyncFn.name || "anonymous";
          var error = new Error('Callback function "' + name + '" timed out.');
          error.code = "ETIMEDOUT";
          if (info) {
            error.info = info;
          }
          timedOut = true;
          callback(error);
        }
        args.push((...cbArgs) => {
          if (!timedOut) {
            callback(...cbArgs);
            clearTimeout(timer);
          }
        });
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args);
      });
    }
    function range(size) {
      var result = Array(size);
      while (size--) {
        result[size] = size;
      }
      return result;
    }
    function timesLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    function times(n, iteratee, callback) {
      return timesLimit(n, Infinity, iteratee, callback);
    }
    function timesSeries(n, iteratee, callback) {
      return timesLimit(n, 1, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3 && typeof accumulator === "function") {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
      }
      callback = once(callback || promiseCallback());
      var _iteratee = wrapAsync(iteratee);
      eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
      }, (err) => callback(err, accumulator));
      return callback[PROMISE_SYMBOL];
    }
    function tryEach(tasks, callback) {
      var error = null;
      var result;
      return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args) => {
          if (err === false)
            return taskCb(err);
          if (args.length < 2) {
            [result] = args;
          } else {
            result = args;
          }
          error = err;
          taskCb(err ? null : {});
        });
      }, () => callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    function unmemoize(fn) {
      return (...args) => {
        return (fn.unmemoized || fn)(...args);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results = [];
      function next(err, ...rest) {
        if (err)
          return callback(err);
        results = rest;
        if (err === false)
          return;
        _test(check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);
    function until(test, iteratee, callback) {
      const _test = wrapAsync(test);
      return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
    }
    function waterfall(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args, onlyOnce(next));
      }
      function next(err, ...args) {
        if (err === false)
          return;
        if (err || taskIndex === tasks.length) {
          return callback(err, ...args);
        }
        nextTask(args);
      }
      nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall);
    var index = {
      apply,
      applyEach,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo: cargo$1,
      cargoQueue: cargo,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant: constant$1,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$1,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$1,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel,
      parallelLimit,
      priorityQueue,
      queue,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$1,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$1,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$1,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    exports2.all = every$1;
    exports2.allLimit = everyLimit$1;
    exports2.allSeries = everySeries$1;
    exports2.any = some$1;
    exports2.anyLimit = someLimit$1;
    exports2.anySeries = someSeries$1;
    exports2.apply = apply;
    exports2.applyEach = applyEach;
    exports2.applyEachSeries = applyEachSeries;
    exports2.asyncify = asyncify;
    exports2.auto = auto;
    exports2.autoInject = autoInject;
    exports2.cargo = cargo$1;
    exports2.cargoQueue = cargo;
    exports2.compose = compose;
    exports2.concat = concat$1;
    exports2.concatLimit = concatLimit$1;
    exports2.concatSeries = concatSeries$1;
    exports2.constant = constant$1;
    exports2.default = index;
    exports2.detect = detect$1;
    exports2.detectLimit = detectLimit$1;
    exports2.detectSeries = detectSeries$1;
    exports2.dir = dir;
    exports2.doDuring = doWhilst$1;
    exports2.doUntil = doUntil;
    exports2.doWhilst = doWhilst$1;
    exports2.during = whilst$1;
    exports2.each = each;
    exports2.eachLimit = eachLimit$1;
    exports2.eachOf = eachOf$1;
    exports2.eachOfLimit = eachOfLimit$1;
    exports2.eachOfSeries = eachOfSeries$1;
    exports2.eachSeries = eachSeries$1;
    exports2.ensureAsync = ensureAsync;
    exports2.every = every$1;
    exports2.everyLimit = everyLimit$1;
    exports2.everySeries = everySeries$1;
    exports2.filter = filter$1;
    exports2.filterLimit = filterLimit$1;
    exports2.filterSeries = filterSeries$1;
    exports2.find = detect$1;
    exports2.findLimit = detectLimit$1;
    exports2.findSeries = detectSeries$1;
    exports2.flatMap = concat$1;
    exports2.flatMapLimit = concatLimit$1;
    exports2.flatMapSeries = concatSeries$1;
    exports2.foldl = reduce$1;
    exports2.foldr = reduceRight;
    exports2.forEach = each;
    exports2.forEachLimit = eachLimit$1;
    exports2.forEachOf = eachOf$1;
    exports2.forEachOfLimit = eachOfLimit$1;
    exports2.forEachOfSeries = eachOfSeries$1;
    exports2.forEachSeries = eachSeries$1;
    exports2.forever = forever$1;
    exports2.groupBy = groupBy;
    exports2.groupByLimit = groupByLimit$1;
    exports2.groupBySeries = groupBySeries;
    exports2.inject = reduce$1;
    exports2.log = log;
    exports2.map = map$1;
    exports2.mapLimit = mapLimit$1;
    exports2.mapSeries = mapSeries$1;
    exports2.mapValues = mapValues;
    exports2.mapValuesLimit = mapValuesLimit$1;
    exports2.mapValuesSeries = mapValuesSeries;
    exports2.memoize = memoize;
    exports2.nextTick = nextTick;
    exports2.parallel = parallel;
    exports2.parallelLimit = parallelLimit;
    exports2.priorityQueue = priorityQueue;
    exports2.queue = queue;
    exports2.race = race$1;
    exports2.reduce = reduce$1;
    exports2.reduceRight = reduceRight;
    exports2.reflect = reflect;
    exports2.reflectAll = reflectAll;
    exports2.reject = reject$1;
    exports2.rejectLimit = rejectLimit$1;
    exports2.rejectSeries = rejectSeries$1;
    exports2.retry = retry;
    exports2.retryable = retryable;
    exports2.select = filter$1;
    exports2.selectLimit = filterLimit$1;
    exports2.selectSeries = filterSeries$1;
    exports2.seq = seq;
    exports2.series = series;
    exports2.setImmediate = setImmediate$1;
    exports2.some = some$1;
    exports2.someLimit = someLimit$1;
    exports2.someSeries = someSeries$1;
    exports2.sortBy = sortBy$1;
    exports2.timeout = timeout;
    exports2.times = times;
    exports2.timesLimit = timesLimit;
    exports2.timesSeries = timesSeries;
    exports2.transform = transform;
    exports2.tryEach = tryEach$1;
    exports2.unmemoize = unmemoize;
    exports2.until = until;
    exports2.waterfall = waterfall$1;
    exports2.whilst = whilst$1;
    exports2.wrapSync = asyncify;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports, module) => {
  var constants = __require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {}
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module.exports = patch;
  function patch(fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs);
    }
    if (!fs.lutimes) {
      patchLutimes(fs);
    }
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    if (fs.chmod && !fs.lchmod) {
      fs.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
      fs.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchownSync = function() {};
    }
    if (platform === "win32") {
      fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              setTimeout(function() {
                fs.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs.rename);
    }
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _2, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs.readSync);
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs2.fchmod(fd, mode, function(err2) {
            fs2.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs2.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs2.closeSync(fd);
            } catch (er) {}
          } else {
            fs2.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
        fs2.lutimes = function(path, at, mt, cb) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs2.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {}
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs2.futimes) {
        fs2.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lutimesSync = function() {};
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  module.exports = legacy;
  function legacy(fs) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === undefined) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
        this.flush();
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports, module) => {
  module.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports, module) => {
  var fs = __require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util = __require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {}
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util.debuglog)
    debug = util.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `);
      console.error(m);
    };
  if (!fs[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    fs.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs[gracefulQueue]);
        __require("assert").equal(fs[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
  }
  module.exports = patch(clone(fs));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
  }
  function patch(fs2) {
    polyfills(fs2);
    fs2.gracefulify = patch;
    fs2.createReadStream = createReadStream;
    fs2.createWriteStream = createWriteStream;
    var fs$readFile = fs2.readFile;
    fs2.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs2.writeFile;
    fs2.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs2.appendFile;
    if (fs$appendFile)
      fs2.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs2.copyFile;
    if (fs$copyFile)
      fs2.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs2.readdir;
    fs2.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
      } : function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs2);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs2.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs2.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs2, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs2, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs2, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs2, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs2.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs2.WriteStream(path, options);
    }
    var fs$open = fs2.open;
    fs2.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs2;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0;i < fs[gracefulQueue].length; ++i) {
      if (fs[gracefulQueue][i].length > 2) {
        fs[gracefulQueue][i][3] = now;
        fs[gracefulQueue][i][4] = now;
      }
    }
    retry();
  }
  function retry() {
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0)
      return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === undefined) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === undefined) {
      retryTimer = setTimeout(retry, 0);
    }
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module.exports = isStream;
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports, module) => {
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module.exports = { nextTick };
  } else {
    module.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/lazystream/node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util11 = __commonJS((exports) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === undefined;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node2 = __commonJS((exports, module) => {
  module.exports = __require("util").deprecate;
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util11());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node2()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util.inherits(Writable, Stream);
  function nop() {}
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_2) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util11());
  util.inherits = require_inherits();
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util11());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {};
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex();
  var util = Object.create(require_util11());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  var util = Object.create(require_util11());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/lazystream/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
  }
});

// node_modules/lazystream/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS((exports, module) => {
  module.exports = require_readable2().PassThrough;
});

// node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS((exports, module) => {
  var util = __require("util");
  var PassThrough = require_passthrough();
  module.exports = {
    Readable,
    Writable
  };
  util.inherits(Readable, PassThrough);
  util.inherits(Writable, PassThrough);
  function beforeFirstCall(instance, method, callback) {
    instance[method] = function() {
      delete instance[method];
      callback.apply(this, arguments);
      return this[method].apply(this, arguments);
    };
  }
  function Readable(fn, options) {
    if (!(this instanceof Readable))
      return new Readable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_read", function() {
      var source = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      source.on("error", emit);
      source.pipe(this);
    });
    this.emit("readable");
  }
  function Writable(fn, options) {
    if (!(this instanceof Writable))
      return new Writable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_write", function() {
      var destination = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      destination.on("error", emit);
      this.pipe(destination);
    });
    this.emit("writable");
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS((exports, module) => {
  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(path, stripTrailing) {
    if (typeof path !== "string") {
      throw new TypeError("expected path to be a string");
    }
    if (path === "\\" || path === "/")
      return "/";
    var len = path.length;
    if (len <= 1)
      return path;
    var prefix = "";
    if (len > 4 && path[3] === "\\") {
      var ch = path[2];
      if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
        path = path.slice(2);
        prefix = "//";
      }
    }
    var segs = path.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
      segs.pop();
    }
    return prefix + segs.join("/");
  };
});

// node_modules/archiver-utils/node_modules/lodash/identity.js
var require_identity = __commonJS((exports, module) => {
  function identity(value) {
    return value;
  }
  module.exports = identity;
});

// node_modules/archiver-utils/node_modules/lodash/_apply.js
var require__apply = __commonJS((exports, module) => {
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  module.exports = apply;
});

// node_modules/archiver-utils/node_modules/lodash/_overRest.js
var require__overRest = __commonJS((exports, module) => {
  var apply = require__apply();
  var nativeMax = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  module.exports = overRest;
});

// node_modules/archiver-utils/node_modules/lodash/constant.js
var require_constant = __commonJS((exports, module) => {
  function constant(value) {
    return function() {
      return value;
    };
  }
  module.exports = constant;
});

// node_modules/archiver-utils/node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/archiver-utils/node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/archiver-utils/node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/archiver-utils/node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  module.exports = getRawTag;
});

// node_modules/archiver-utils/node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  module.exports = objectToString;
});

// node_modules/archiver-utils/node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  module.exports = baseGetTag;
});

// node_modules/archiver-utils/node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module.exports = isObject;
});

// node_modules/archiver-utils/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  module.exports = isFunction;
});

// node_modules/archiver-utils/node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/archiver-utils/node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  module.exports = isMasked;
});

// node_modules/archiver-utils/node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  module.exports = toSource;
});

// node_modules/archiver-utils/node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  module.exports = baseIsNative;
});

// node_modules/archiver-utils/node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  module.exports = getValue;
});

// node_modules/archiver-utils/node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  module.exports = getNative;
});

// node_modules/archiver-utils/node_modules/lodash/_defineProperty.js
var require__defineProperty = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {}
  }();
  module.exports = defineProperty;
});

// node_modules/archiver-utils/node_modules/lodash/_baseSetToString.js
var require__baseSetToString = __commonJS((exports, module) => {
  var constant = require_constant();
  var defineProperty = require__defineProperty();
  var identity = require_identity();
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      configurable: true,
      enumerable: false,
      value: constant(string),
      writable: true
    });
  };
  module.exports = baseSetToString;
});

// node_modules/archiver-utils/node_modules/lodash/_shortOut.js
var require__shortOut = __commonJS((exports, module) => {
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }
  module.exports = shortOut;
});

// node_modules/archiver-utils/node_modules/lodash/_setToString.js
var require__setToString = __commonJS((exports, module) => {
  var baseSetToString = require__baseSetToString();
  var shortOut = require__shortOut();
  var setToString = shortOut(baseSetToString);
  module.exports = setToString;
});

// node_modules/archiver-utils/node_modules/lodash/_baseRest.js
var require__baseRest = __commonJS((exports, module) => {
  var identity = require_identity();
  var overRest = require__overRest();
  var setToString = require__setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  module.exports = baseRest;
});

// node_modules/archiver-utils/node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  module.exports = eq;
});

// node_modules/archiver-utils/node_modules/lodash/isLength.js
var require_isLength = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  module.exports = isLength;
});

// node_modules/archiver-utils/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  var isFunction = require_isFunction();
  var isLength = require_isLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  module.exports = isArrayLike;
});

// node_modules/archiver-utils/node_modules/lodash/_isIndex.js
var require__isIndex = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  module.exports = isIndex;
});

// node_modules/archiver-utils/node_modules/lodash/_isIterateeCall.js
var require__isIterateeCall = __commonJS((exports, module) => {
  var eq = require_eq();
  var isArrayLike = require_isArrayLike();
  var isIndex = require__isIndex();
  var isObject = require_isObject();
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  }
  module.exports = isIterateeCall;
});

// node_modules/archiver-utils/node_modules/lodash/_baseTimes.js
var require__baseTimes = __commonJS((exports, module) => {
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  module.exports = baseTimes;
});

// node_modules/archiver-utils/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  module.exports = isObjectLike;
});

// node_modules/archiver-utils/node_modules/lodash/_baseIsArguments.js
var require__baseIsArguments = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  module.exports = baseIsArguments;
});

// node_modules/archiver-utils/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS((exports, module) => {
  var baseIsArguments = require__baseIsArguments();
  var isObjectLike = require_isObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  module.exports = isArguments;
});

// node_modules/archiver-utils/node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/archiver-utils/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS((exports, module) => {
  function stubFalse() {
    return false;
  }
  module.exports = stubFalse;
});

// node_modules/archiver-utils/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS((exports, module) => {
  var root = require__root();
  var stubFalse = require_stubFalse();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
});

// node_modules/archiver-utils/node_modules/lodash/_baseIsTypedArray.js
var require__baseIsTypedArray = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isLength = require_isLength();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  module.exports = baseIsTypedArray;
});

// node_modules/archiver-utils/node_modules/lodash/_baseUnary.js
var require__baseUnary = __commonJS((exports, module) => {
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  module.exports = baseUnary;
});

// node_modules/archiver-utils/node_modules/lodash/_nodeUtil.js
var require__nodeUtil = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {}
  }();
  module.exports = nodeUtil;
});

// node_modules/archiver-utils/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS((exports, module) => {
  var baseIsTypedArray = require__baseIsTypedArray();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
});

// node_modules/archiver-utils/node_modules/lodash/_arrayLikeKeys.js
var require__arrayLikeKeys = __commonJS((exports, module) => {
  var baseTimes = require__baseTimes();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isIndex = require__isIndex();
  var isTypedArray = require_isTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = arrayLikeKeys;
});

// node_modules/archiver-utils/node_modules/lodash/_isPrototype.js
var require__isPrototype = __commonJS((exports, module) => {
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  module.exports = isPrototype;
});

// node_modules/archiver-utils/node_modules/lodash/_nativeKeysIn.js
var require__nativeKeysIn = __commonJS((exports, module) => {
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = nativeKeysIn;
});

// node_modules/archiver-utils/node_modules/lodash/_baseKeysIn.js
var require__baseKeysIn = __commonJS((exports, module) => {
  var isObject = require_isObject();
  var isPrototype = require__isPrototype();
  var nativeKeysIn = require__nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = baseKeysIn;
});

// node_modules/archiver-utils/node_modules/lodash/keysIn.js
var require_keysIn = __commonJS((exports, module) => {
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeysIn = require__baseKeysIn();
  var isArrayLike = require_isArrayLike();
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  module.exports = keysIn;
});

// node_modules/archiver-utils/node_modules/lodash/defaults.js
var require_defaults = __commonJS((exports, module) => {
  var baseRest = require__baseRest();
  var eq = require_eq();
  var isIterateeCall = require__isIterateeCall();
  var keysIn = require_keysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var defaults = baseRest(function(object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];
        if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          object[key] = source[key];
        }
      }
    }
    return object;
  });
  module.exports = defaults;
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS((exports, module) => {
  class AggregateError extends Error {
    constructor(errors) {
      if (!Array.isArray(errors)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
      }
      let message = "";
      for (let i = 0;i < errors.length; i++) {
        message += `    ${errors[i].stack}
`;
      }
      super(message);
      this.name = "AggregateError";
      this.errors = errors;
    }
  }
  module.exports = {
    AggregateError,
    ArrayIsArray(self2) {
      return Array.isArray(self2);
    },
    ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    },
    ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    },
    ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    },
    ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    },
    ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    },
    ArrayPrototypePush(self2, el) {
      return self2.push(el);
    },
    ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    Error,
    FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    },
    FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    },
    MathFloor: Math.floor,
    Number,
    NumberIsInteger: Number.isInteger,
    NumberIsNaN: Number.isNaN,
    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
    NumberParseInt: Number.parseInt,
    ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    },
    ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    },
    ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    },
    ObjectKeys(obj) {
      return Object.keys(obj);
    },
    ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    },
    Promise,
    PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    },
    PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    },
    PromiseReject(err) {
      return Promise.reject(err);
    },
    PromiseResolve(val) {
      return Promise.resolve(val);
    },
    ReflectApply: Reflect.apply,
    RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    },
    SafeSet: Set,
    String,
    StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    },
    StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    },
    StringPrototypeTrim(self2) {
      return self2.trim();
    },
    Symbol,
    SymbolFor: Symbol.for,
    SymbolAsyncIterator: Symbol.asyncIterator,
    SymbolHasInstance: Symbol.hasInstance,
    SymbolIterator: Symbol.iterator,
    SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
    SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
    TypedArrayPrototypeSet(self2, buf, len) {
      return self2.set(buf, len);
    },
    Boolean,
    Uint8Array
  };
});

// node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect2 = __commonJS((exports, module) => {
  module.exports = {
    format(format, ...args) {
      return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
        const replacement = args.shift();
        if (type === "f") {
          return replacement.toFixed(6);
        } else if (type === "j") {
          return JSON.stringify(replacement);
        } else if (type === "s" && typeof replacement === "object") {
          const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
          return `${ctor} {}`.trim();
        } else {
          return replacement.toString();
        }
      });
    },
    inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"')) {
              return `"${value}"`;
            } else if (!value.includes("`") && !value.includes("${")) {
              return `\`${value}\``;
            }
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value)) {
            return "NaN";
          } else if (Object.is(value, -0)) {
            return String(value);
          }
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    }
  };
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors3 = __commonJS((exports, module) => {
  var { format, inspect } = require_inspect2();
  var { AggregateError: CustomAggregateError } = require_primordials();
  var AggregateError = globalThis.AggregateError || CustomAggregateError;
  var kIsNodeError = Symbol("kIsNodeError");
  var kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
  ];
  var classRegExp = /^([A-Z][a-z0-9]*)+$/;
  var nodeInternalPrefix = "__node_internal_";
  var codes = {};
  function assert(value, message) {
    if (!value) {
      throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
  }
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (;i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function getMessage(key, msg, args) {
    if (typeof msg === "function") {
      assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);
      return msg(...args);
    }
    const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
    assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
    if (args.length === 0) {
      return msg;
    }
    return format(msg, ...args);
  }
  function E(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    class NodeError extends Base {
      constructor(...args) {
        super(getMessage(code, message, args));
      }
      toString() {
        return `${this.name} [${code}]: ${this.message}`;
      }
    }
    Object.defineProperties(NodeError.prototype, {
      name: {
        value: Base.name,
        writable: true,
        enumerable: false,
        configurable: true
      },
      toString: {
        value() {
          return `${this.name} [${code}]: ${this.message}`;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    NodeError.prototype.code = code;
    NodeError.prototype[kIsNodeError] = true;
    codes[code] = NodeError;
  }
  function hideStackFrames(fn) {
    const hidden = nodeInternalPrefix + fn.name;
    Object.defineProperty(fn, "name", {
      value: hidden
    });
    return fn;
  }
  function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
      if (Array.isArray(outerError.errors)) {
        outerError.errors.push(innerError);
        return outerError;
      }
      const err = new AggregateError([outerError, innerError], outerError.message);
      err.code = outerError.code;
      return err;
    }
    return innerError || outerError;
  }

  class AbortError extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  }
  E("ERR_ASSERTION", "%s", Error);
  E("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
    assert(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let msg = "The ";
    if (name.endsWith(" argument")) {
      msg += `${name} `;
    } else {
      msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      assert(typeof value === "string", "All expected entries have to be of type string");
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.test(value)) {
        instances.push(value);
      } else {
        assert(value !== "object", 'The value "object" should be written as "Object"');
        other.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.splice(types, pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`;
          break;
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`;
          break;
        default: {
          const last = types.pop();
          msg += `one of type ${types.join(", ")}, or ${last}`;
        }
      }
      if (instances.length > 0 || other.length > 0) {
        msg += " or ";
      }
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`;
          break;
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`;
          break;
        default: {
          const last = instances.pop();
          msg += `an instance of ${instances.join(", ")}, or ${last}`;
        }
      }
      if (other.length > 0) {
        msg += " or ";
      }
    }
    switch (other.length) {
      case 0:
        break;
      case 1:
        if (other[0].toLowerCase() !== other[0]) {
          msg += "an ";
        }
        msg += `${other[0]}`;
        break;
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`;
        break;
      default: {
        const last = other.pop();
        msg += `one of ${other.join(", ")}, or ${last}`;
      }
    }
    if (actual == null) {
      msg += `. Received ${actual}`;
    } else if (typeof actual === "function" && actual.name) {
      msg += `. Received function ${actual.name}`;
    } else if (typeof actual === "object") {
      var _actual$constructor;
      if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name) {
        msg += `. Received an instance of ${actual.constructor.name}`;
      } else {
        const inspected = inspect(actual, {
          depth: -1
        });
        msg += `. Received ${inspected}`;
      }
    } else {
      let inspected = inspect(actual, {
        colors: false
      });
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      msg += `. Received type ${typeof actual} (${inspected})`;
    }
    return msg;
  }, TypeError);
  E("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128) {
      inspected = inspected.slice(0, 128) + "...";
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  }, TypeError);
  E("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
    var _value$constructor;
    const type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`;
  }, TypeError);
  E("ERR_MISSING_ARGS", (...args) => {
    assert(args.length > 0, "At least one arg needs to be specified");
    let msg;
    const len = args.length;
    args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
    switch (len) {
      case 1:
        msg += `The ${args[0]} argument`;
        break;
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`;
        break;
      default:
        {
          const last = args.pop();
          msg += `The ${args.join(", ")}, and ${last} arguments`;
        }
        break;
    }
    return `${msg} must be specified`;
  }, TypeError);
  E("ERR_OUT_OF_RANGE", (str, range, input) => {
    assert(range, 'Missing "range" argument');
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      const limit = BigInt(2) ** BigInt(32);
      if (input > limit || input < -limit) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect(input);
    }
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
  }, RangeError);
  E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
  E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
  E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
  E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
  E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
  E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
  E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
  E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
  E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
  E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
  module.exports = {
    AbortError,
    aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
    hideStackFrames,
    codes
  };
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var privateData = new WeakMap;
  var wrappers = new WeakMap;
  function pd(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
  }
  function setCancelFlag(data) {
    if (data.passiveListener != null) {
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
      }
      return;
    }
    if (!data.event.cancelable) {
      return;
    }
    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
      data.event.preventDefault();
    }
  }
  function Event2(eventTarget, event) {
    privateData.set(this, {
      eventTarget,
      event,
      eventPhase: 2,
      currentTarget: eventTarget,
      canceled: false,
      stopped: false,
      immediateStopped: false,
      passiveListener: null,
      timeStamp: event.timeStamp || Date.now()
    });
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
    const keys = Object.keys(event);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (!(key in this)) {
        Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
  }
  Event2.prototype = {
    get type() {
      return pd(this).event.type;
    },
    get target() {
      return pd(this).eventTarget;
    },
    get currentTarget() {
      return pd(this).currentTarget;
    },
    composedPath() {
      const currentTarget = pd(this).currentTarget;
      if (currentTarget == null) {
        return [];
      }
      return [currentTarget];
    },
    get NONE() {
      return 0;
    },
    get CAPTURING_PHASE() {
      return 1;
    },
    get AT_TARGET() {
      return 2;
    },
    get BUBBLING_PHASE() {
      return 3;
    },
    get eventPhase() {
      return pd(this).eventPhase;
    },
    stopPropagation() {
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.stopPropagation === "function") {
        data.event.stopPropagation();
      }
    },
    stopImmediatePropagation() {
      const data = pd(this);
      data.stopped = true;
      data.immediateStopped = true;
      if (typeof data.event.stopImmediatePropagation === "function") {
        data.event.stopImmediatePropagation();
      }
    },
    get bubbles() {
      return Boolean(pd(this).event.bubbles);
    },
    get cancelable() {
      return Boolean(pd(this).event.cancelable);
    },
    preventDefault() {
      setCancelFlag(pd(this));
    },
    get defaultPrevented() {
      return pd(this).canceled;
    },
    get composed() {
      return Boolean(pd(this).event.composed);
    },
    get timeStamp() {
      return pd(this).timeStamp;
    },
    get srcElement() {
      return pd(this).eventTarget;
    },
    get cancelBubble() {
      return pd(this).stopped;
    },
    set cancelBubble(value) {
      if (!value) {
        return;
      }
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.cancelBubble === "boolean") {
        data.event.cancelBubble = true;
      }
    },
    get returnValue() {
      return !pd(this).canceled;
    },
    set returnValue(value) {
      if (!value) {
        setCancelFlag(pd(this));
      }
    },
    initEvent() {}
  };
  Object.defineProperty(Event2.prototype, "constructor", {
    value: Event2,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event2.prototype, window.Event.prototype);
    wrappers.set(window.Event.prototype, Event2);
  }
  function defineRedirectDescriptor(key) {
    return {
      get() {
        return pd(this).event[key];
      },
      set(value) {
        pd(this).event[key] = value;
      },
      configurable: true,
      enumerable: true
    };
  }
  function defineCallDescriptor(key) {
    return {
      value() {
        const event = pd(this).event;
        return event[key].apply(event, arguments);
      },
      configurable: true,
      enumerable: true
    };
  }
  function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
      return BaseEvent;
    }
    function CustomEvent(eventTarget, event) {
      BaseEvent.call(this, eventTarget, event);
    }
    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
      constructor: { value: CustomEvent, configurable: true, writable: true }
    });
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (!(key in BaseEvent.prototype)) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, key);
        const isFunc = typeof descriptor.value === "function";
        Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
      }
    }
    return CustomEvent;
  }
  function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
      return Event2;
    }
    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
      wrappers.set(proto, wrapper);
    }
    return wrapper;
  }
  function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event);
  }
  function isStopped(event) {
    return pd(event).immediateStopped;
  }
  function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
  }
  function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
  }
  function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
  }
  var listenersMap = new WeakMap;
  var CAPTURE = 1;
  var BUBBLE = 2;
  var ATTRIBUTE = 3;
  function isObject(x) {
    return x !== null && typeof x === "object";
  }
  function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
      throw new TypeError("'this' is expected an EventTarget object, but got another value.");
    }
    return listeners;
  }
  function defineEventAttributeDescriptor(eventName) {
    return {
      get() {
        const listeners = getListeners(this);
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            return node.listener;
          }
          node = node.next;
        }
        return null;
      },
      set(listener) {
        if (typeof listener !== "function" && !isObject(listener)) {
          listener = null;
        }
        const listeners = getListeners(this);
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          node = node.next;
        }
        if (listener !== null) {
          const newNode = {
            listener,
            listenerType: ATTRIBUTE,
            passive: false,
            once: false,
            next: null
          };
          if (prev === null) {
            listeners.set(eventName, newNode);
          } else {
            prev.next = newNode;
          }
        }
      },
      configurable: true,
      enumerable: true
    };
  }
  function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
  }
  function defineCustomEventTarget(eventNames) {
    function CustomEventTarget() {
      EventTarget2.call(this);
    }
    CustomEventTarget.prototype = Object.create(EventTarget2.prototype, {
      constructor: {
        value: CustomEventTarget,
        configurable: true,
        writable: true
      }
    });
    for (let i = 0;i < eventNames.length; ++i) {
      defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }
    return CustomEventTarget;
  }
  function EventTarget2() {
    if (this instanceof EventTarget2) {
      listenersMap.set(this, new Map);
      return;
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return defineCustomEventTarget(arguments[0]);
    }
    if (arguments.length > 0) {
      const types = new Array(arguments.length);
      for (let i = 0;i < arguments.length; ++i) {
        types[i] = arguments[i];
      }
      return defineCustomEventTarget(types);
    }
    throw new TypeError("Cannot call a class as a function");
  }
  EventTarget2.prototype = {
    addEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      if (typeof listener !== "function" && !isObject(listener)) {
        throw new TypeError("'listener' should be a function or an object.");
      }
      const listeners = getListeners(this);
      const optionsIsObj = isObject(options);
      const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
      const listenerType = capture ? CAPTURE : BUBBLE;
      const newNode = {
        listener,
        listenerType,
        passive: optionsIsObj && Boolean(options.passive),
        once: optionsIsObj && Boolean(options.once),
        next: null
      };
      let node = listeners.get(eventName);
      if (node === undefined) {
        listeners.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          return;
        }
        prev = node;
        node = node.next;
      }
      prev.next = newNode;
    },
    removeEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      const listeners = getListeners(this);
      const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
      const listenerType = capture ? CAPTURE : BUBBLE;
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
          return;
        }
        prev = node;
        node = node.next;
      }
    },
    dispatchEvent(event) {
      if (event == null || typeof event.type !== "string") {
        throw new TypeError('"event.type" should be a string.');
      }
      const listeners = getListeners(this);
      const eventName = event.type;
      let node = listeners.get(eventName);
      if (node == null) {
        return true;
      }
      const wrappedEvent = wrapEvent(this, event);
      let prev = null;
      while (node != null) {
        if (node.once) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
        if (typeof node.listener === "function") {
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(err);
            }
          }
        } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
          node.listener.handleEvent(wrappedEvent);
        }
        if (isStopped(wrappedEvent)) {
          break;
        }
        node = node.next;
      }
      setPassiveListener(wrappedEvent, null);
      setEventPhase(wrappedEvent, 0);
      setCurrentTarget(wrappedEvent, null);
      return !wrappedEvent.defaultPrevented;
    }
  };
  Object.defineProperty(EventTarget2.prototype, "constructor", {
    value: EventTarget2,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget2.prototype, window.EventTarget.prototype);
  }
  exports.defineEventAttribute = defineEventAttribute;
  exports.EventTarget = EventTarget2;
  exports.default = EventTarget2;
  module.exports = EventTarget2;
  module.exports.EventTarget = module.exports["default"] = EventTarget2;
  module.exports.defineEventAttribute = defineEventAttribute;
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var eventTargetShim = require_event_target_shim();

  class AbortSignal2 extends eventTargetShim.EventTarget {
    constructor() {
      super();
      throw new TypeError("AbortSignal cannot be constructed directly");
    }
    get aborted() {
      const aborted = abortedFlags.get(this);
      if (typeof aborted !== "boolean") {
        throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
      }
      return aborted;
    }
  }
  eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
  function createAbortSignal() {
    const signal = Object.create(AbortSignal2.prototype);
    eventTargetShim.EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
  }
  function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
      return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
  }
  var abortedFlags = new WeakMap;
  Object.defineProperties(AbortSignal2.prototype, {
    aborted: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortSignal"
    });
  }

  class AbortController2 {
    constructor() {
      signals.set(this, createAbortSignal());
    }
    get signal() {
      return getSignal(this);
    }
    abort() {
      abortSignal(getSignal(this));
    }
  }
  var signals = new WeakMap;
  function getSignal(controller) {
    const signal = signals.get(controller);
    if (signal == null) {
      throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
  }
  Object.defineProperties(AbortController2.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortController"
    });
  }
  exports.AbortController = AbortController2;
  exports.AbortSignal = AbortSignal2;
  exports.default = AbortController2;
  module.exports = AbortController2;
  module.exports.AbortController = module.exports["default"] = AbortController2;
  module.exports.AbortSignal = AbortSignal2;
});

// node_modules/readable-stream/lib/ours/util.js
var require_util12 = __commonJS((exports, module) => {
  var bufferModule = __require("buffer");
  var { format, inspect } = require_inspect2();
  var {
    codes: { ERR_INVALID_ARG_TYPE }
  } = require_errors3();
  var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials();
  var AbortSignal2 = globalThis.AbortSignal || require_abort_controller().AbortSignal;
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;
  var Blob2 = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob2 !== "undefined" ? function isBlob(b) {
    return b instanceof Blob2;
  } : function isBlob(b) {
    return false;
  };
  var validateAbortSignal = (signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  };
  var validateFunction = (value, name) => {
    if (typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
  };
  module.exports = {
    AggregateError,
    kEmptyObject: Object.freeze({}),
    once(callback) {
      let called = false;
      return function(...args) {
        if (called) {
          return;
        }
        called = true;
        callback.apply(this, args);
      };
    },
    createDeferredPromise: function() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return {
        promise,
        resolve,
        reject
      };
    },
    promisify(fn) {
      return new Promise((resolve, reject) => {
        fn((err, ...args) => {
          if (err) {
            return reject(err);
          }
          return resolve(...args);
        });
      });
    },
    debuglog() {
      return function() {};
    },
    format,
    inspect,
    types: {
      isAsyncFunction(fn) {
        return fn instanceof AsyncFunction;
      },
      isArrayBufferView(arr) {
        return ArrayBuffer.isView(arr);
      }
    },
    isBlob,
    deprecate(fn, message) {
      return fn;
    },
    addAbortListener: __require("events").addAbortListener || function addAbortListener(signal, listener) {
      if (signal === undefined) {
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
      }
      validateAbortSignal(signal, "signal");
      validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted) {
        queueMicrotask(() => listener());
      } else {
        signal.addEventListener("abort", listener, {
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        });
        removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      }
      return {
        __proto__: null,
        [SymbolDispose]() {
          var _removeEventListener;
          (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
        }
      };
    },
    AbortSignalAny: AbortSignal2.any || function AbortSignalAny(signals) {
      if (signals.length === 1) {
        return signals[0];
      }
      const ac = new AbortController2;
      const abort = () => ac.abort();
      signals.forEach((signal) => {
        validateAbortSignal(signal, "signals");
        signal.addEventListener("abort", abort, {
          once: true
        });
      });
      ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort));
      }, {
        once: true
      });
      return ac.signal;
    }
  };
  module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS((exports, module) => {
  var {
    ArrayIsArray,
    ArrayPrototypeIncludes,
    ArrayPrototypeJoin,
    ArrayPrototypeMap,
    NumberIsInteger,
    NumberIsNaN,
    NumberMAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER,
    NumberParseInt,
    ObjectPrototypeHasOwnProperty,
    RegExpPrototypeExec,
    String: String2,
    StringPrototypeToUpperCase,
    StringPrototypeTrim
  } = require_primordials();
  var {
    hideStackFrames,
    codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
  } = require_errors3();
  var { normalizeEncoding } = require_util12();
  var { isAsyncFunction, isArrayBufferView } = require_util12().types;
  var signals = {};
  function isInt32(value) {
    return value === (value | 0);
  }
  function isUint32(value) {
    return value === value >>> 0;
  }
  var octalReg = /^[0-7]+$/;
  var modeDesc = "must be a 32-bit unsigned integer or an octal string";
  function parseFileMode(value, name, def) {
    if (typeof value === "undefined") {
      value = def;
    }
    if (typeof value === "string") {
      if (RegExpPrototypeExec(octalReg, value) === null) {
        throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
      }
      value = NumberParseInt(value, 8);
    }
    validateUint32(value, name);
    return value;
  }
  var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    if (!NumberIsInteger(value))
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    if (value < min || value > max)
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  });
  var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  var validateUint32 = hideStackFrames((value, name, positive = false) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min = positive ? 1 : 0;
    const max = 4294967295;
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  function validateString(value, name) {
    if (typeof value !== "string")
      throw new ERR_INVALID_ARG_TYPE(name, "string", value);
  }
  function validateNumber(value, name, min = undefined, max) {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
      throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
    }
  }
  var validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!ArrayPrototypeIncludes(oneOf, value)) {
      const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)), ", ");
      const reason = "must be one of: " + allowed;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateBoolean(value, name) {
    if (typeof value !== "boolean")
      throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
  }
  function getOwnPropertyValueOrDefault(options, key, defaultValue) {
    return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
  }
  var validateObject = hideStackFrames((value, name, options = null) => {
    const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
    const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
    const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
    if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
      throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
  });
  var validateDictionary = hideStackFrames((value, name) => {
    if (value != null && typeof value !== "object" && typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
    }
  });
  var validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!ArrayIsArray(value)) {
      throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
      const reason = `must be longer than ${minLength}`;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateStringArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateString(value[i], `${name}[${i}]`);
    }
  }
  function validateBooleanArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateBoolean(value[i], `${name}[${i}]`);
    }
  }
  function validateAbortSignalArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      const signal = value[i];
      const indexedName = `${name}[${i}]`;
      if (signal == null) {
        throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
      }
      validateAbortSignal(signal, indexedName);
    }
  }
  function validateSignalName(signal, name = "signal") {
    validateString(signal, name);
    if (signals[signal] === undefined) {
      if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
        throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
      }
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
  }
  var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
    }
  });
  function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
      throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
  }
  function validatePort(port, name = "Port", allowZero = true) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
      throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }
    return port | 0;
  }
  var validateAbortSignal = hideStackFrames((signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  });
  var validateFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
  });
  var validatePlainFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function" || isAsyncFunction(value))
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
  });
  var validateUndefined = hideStackFrames((value, name) => {
    if (value !== undefined)
      throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
  });
  function validateUnion(value, name, union) {
    if (!ArrayPrototypeIncludes(union, value)) {
      throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
  }
  var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
  function validateLinkHeaderFormat(value, name) {
    if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
      throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
  }
  function validateLinkHeaderValue(hints) {
    if (typeof hints === "string") {
      validateLinkHeaderFormat(hints, "hints");
      return hints;
    } else if (ArrayIsArray(hints)) {
      const hintsLength = hints.length;
      let result = "";
      if (hintsLength === 0) {
        return result;
      }
      for (let i = 0;i < hintsLength; i++) {
        const link = hints[i];
        validateLinkHeaderFormat(link, "hints");
        result += link;
        if (i !== hintsLength - 1) {
          result += ", ";
        }
      }
      return result;
    }
    throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
  }
  module.exports = {
    isInt32,
    isUint32,
    parseFileMode,
    validateArray,
    validateStringArray,
    validateBooleanArray,
    validateAbortSignalArray,
    validateBoolean,
    validateBuffer,
    validateDictionary,
    validateEncoding,
    validateFunction,
    validateInt32,
    validateInteger,
    validateNumber,
    validateObject,
    validateOneOf,
    validatePlainFunction,
    validatePort,
    validateSignalName,
    validateString,
    validateUint32,
    validateUndefined,
    validateUnion,
    validateAbortSignal,
    validateLinkHeaderValue
  };
});

// node_modules/process/index.js
var require_process = __commonJS((exports, module) => {
  module.exports = global.process;
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils5 = __commonJS((exports, module) => {
  var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
  var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
  var kIsErrored = SymbolFor("nodejs.stream.errored");
  var kIsReadable = SymbolFor("nodejs.stream.readable");
  var kIsWritable = SymbolFor("nodejs.stream.writable");
  var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
  var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
  var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
  function isReadableNodeStream(obj, strict = false) {
    var _obj$_readableState;
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
  }
  function isWritableNodeStream(obj) {
    var _obj$_writableState;
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
  }
  function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
  }
  function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
  }
  function isReadableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
  }
  function isWritableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
  }
  function isTransformStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
  }
  function isWebStream(obj) {
    return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
  }
  function isIterable(obj, isAsync) {
    if (obj == null)
      return false;
    if (isAsync === true)
      return typeof obj[SymbolAsyncIterator] === "function";
    if (isAsync === false)
      return typeof obj[SymbolIterator] === "function";
    return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
  }
  function isDestroyed(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
  }
  function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableEnded === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
      return null;
    return wState.ended;
  }
  function isWritableFinished(stream, strict) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableFinished === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
      return null;
    return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
  }
  function isReadableEnded(stream) {
    if (!isReadableNodeStream(stream))
      return null;
    if (stream.readableEnded === true)
      return true;
    const rState = stream._readableState;
    if (!rState || rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
      return null;
    return rState.ended;
  }
  function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream))
      return null;
    const rState = stream._readableState;
    if (rState !== null && rState !== undefined && rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
      return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
  }
  function isReadable(stream) {
    if (stream && stream[kIsReadable] != null)
      return stream[kIsReadable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
  }
  function isWritable(stream) {
    if (stream && stream[kIsWritable] != null)
      return stream[kIsWritable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
  }
  function isFinished(stream, opts) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (isDestroyed(stream)) {
      return true;
    }
    if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
      return false;
    }
    if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
      return false;
    }
    return true;
  }
  function isWritableErrored(stream) {
    var _stream$_writableStat, _stream$_writableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.writableErrored) {
      return stream.writableErrored;
    }
    return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
  }
  function isReadableErrored(stream) {
    var _stream$_readableStat, _stream$_readableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.readableErrored) {
      return stream.readableErrored;
    }
    return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
  }
  function isClosed(stream) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (typeof stream.closed === "boolean") {
      return stream.closed;
    }
    const wState = stream._writableState;
    const rState = stream._readableState;
    if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean") {
      return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
    }
    if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
      return stream._closed;
    }
    return null;
  }
  function isOutgoingMessage(stream) {
    return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
  }
  function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
  }
  function isServerRequest(stream) {
    var _stream$req;
    return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
  }
  function willEmitClose(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
  }
  function isDisturbed(stream) {
    var _stream$kIsDisturbed;
    return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
  }
  function isErrored(stream) {
    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
    return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
  }
  module.exports = {
    isDestroyed,
    kIsDestroyed,
    isDisturbed,
    kIsDisturbed,
    isErrored,
    kIsErrored,
    isReadable,
    kIsReadable,
    kIsClosedPromise,
    kControllerErrorFunction,
    kIsWritable,
    isClosed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isReadableNodeStream,
    isReadableStream,
    isReadableEnded,
    isReadableFinished,
    isReadableErrored,
    isNodeStream,
    isWebStream,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableEnded,
    isWritableFinished,
    isWritableErrored,
    isServerRequest,
    isServerResponse,
    willEmitClose,
    isTransformStream
  };
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var process2 = require_process();
  var { AbortError, codes } = require_errors3();
  var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
  var { kEmptyObject, once } = require_util12();
  var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
  var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
  var {
    isClosed,
    isReadable,
    isReadableNodeStream,
    isReadableStream,
    isReadableFinished,
    isReadableErrored,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableFinished,
    isWritableErrored,
    isNodeStream,
    willEmitClose: _willEmitClose,
    kIsClosedPromise
  } = require_utils5();
  var addAbortListener;
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  var nop = () => {};
  function eos(stream, options, callback) {
    var _options$readable, _options$writable;
    if (arguments.length === 2) {
      callback = options;
      options = kEmptyObject;
    } else if (options == null) {
      options = kEmptyObject;
    } else {
      validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    if (isReadableStream(stream) || isWritableStream(stream)) {
      return eosWeb(stream, options, callback);
    }
    if (!isNodeStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);
    const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const onlegacyfinish = () => {
      if (!stream.writable) {
        onfinish();
      }
    };
    let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
    let writableFinished = isWritableFinished(stream, false);
    const onfinish = () => {
      writableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.readable || readable)) {
        return;
      }
      if (!readable || readableFinished) {
        callback.call(stream);
      }
    };
    let readableFinished = isReadableFinished(stream, false);
    const onend = () => {
      readableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.writable || writable)) {
        return;
      }
      if (!writable || writableFinished) {
        callback.call(stream);
      }
    };
    const onerror = (err) => {
      callback.call(stream, err);
    };
    let closed = isClosed(stream);
    const onclose = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
        if (!isReadableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      if (writable && !writableFinished) {
        if (!isWritableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      callback.call(stream);
    };
    const onclosed = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      callback.call(stream);
    };
    const onrequest = () => {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      if (!willEmitClose) {
        stream.on("abort", onclose);
      }
      if (stream.req) {
        onrequest();
      } else {
        stream.on("request", onrequest);
      }
    } else if (writable && !wState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
      stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) {
      stream.on("error", onerror);
    }
    stream.on("close", onclose);
    if (closed) {
      process2.nextTick(onclose);
    } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
      if (!willEmitClose) {
        process2.nextTick(onclosed);
      }
    } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
      process2.nextTick(onclosed);
    } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
      process2.nextTick(onclosed);
    } else if (rState && stream.req && stream.aborted) {
      process2.nextTick(onclosed);
    }
    const cleanup = () => {
      callback = nop;
      stream.removeListener("aborted", onclose);
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
      const abort = () => {
        const endCallback = callback;
        cleanup();
        endCallback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util12().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    return cleanup;
  }
  function eosWeb(stream, options, callback) {
    let isAborted = false;
    let abort = nop;
    if (options.signal) {
      abort = () => {
        isAborted = true;
        callback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util12().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    const resolverFn = (...args) => {
      if (!isAborted) {
        process2.nextTick(() => callback.apply(stream, args));
      }
    };
    PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
    return nop;
  }
  function finished(stream, opts) {
    var _opts;
    let autoCleanup = false;
    if (opts === null) {
      opts = kEmptyObject;
    }
    if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
      validateBoolean(opts.cleanup, "cleanup");
      autoCleanup = opts.cleanup;
    }
    return new Promise2((resolve, reject) => {
      const cleanup = eos(stream, opts, (err) => {
        if (autoCleanup) {
          cleanup();
        }
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  module.exports = eos;
  module.exports.finished = finished;
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports, module) => {
  var process2 = require_process();
  var {
    aggregateTwoErrors,
    codes: { ERR_MULTIPLE_CALLBACK },
    AbortError
  } = require_errors3();
  var { Symbol: Symbol2 } = require_primordials();
  var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils5();
  var kDestroy = Symbol2("kDestroy");
  var kConstruct = Symbol2("kConstruct");
  function checkError(err, w, r) {
    if (err) {
      err.stack;
      if (w && !w.errored) {
        w.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
    }
  }
  function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {
      if (typeof cb === "function") {
        cb();
      }
      return this;
    }
    checkError(err, w, r);
    if (w) {
      w.destroyed = true;
    }
    if (r) {
      r.destroyed = true;
    }
    if (!s.constructed) {
      this.once(kDestroy, function(er) {
        _destroy(this, aggregateTwoErrors(er, err), cb);
      });
    } else {
      _destroy(this, err, cb);
    }
    return this;
  }
  function _destroy(self2, err, cb) {
    let called = false;
    function onDestroy(err2) {
      if (called) {
        return;
      }
      called = true;
      const r = self2._readableState;
      const w = self2._writableState;
      checkError(err2, w, r);
      if (w) {
        w.closed = true;
      }
      if (r) {
        r.closed = true;
      }
      if (typeof cb === "function") {
        cb(err2);
      }
      if (err2) {
        process2.nextTick(emitErrorCloseNT, self2, err2);
      } else {
        process2.nextTick(emitCloseNT, self2);
      }
    }
    try {
      self2._destroy(err || null, onDestroy);
    } catch (err2) {
      onDestroy(err2);
    }
  }
  function emitErrorCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    const r = self2._readableState;
    const w = self2._writableState;
    if (w) {
      w.closeEmitted = true;
    }
    if (r) {
      r.closeEmitted = true;
    }
    if (w !== null && w !== undefined && w.emitClose || r !== null && r !== undefined && r.emitClose) {
      self2.emit("close");
    }
  }
  function emitErrorNT(self2, err) {
    const r = self2._readableState;
    const w = self2._writableState;
    if (w !== null && w !== undefined && w.errorEmitted || r !== null && r !== undefined && r.errorEmitted) {
      return;
    }
    if (w) {
      w.errorEmitted = true;
    }
    if (r) {
      r.errorEmitted = true;
    }
    self2.emit("error", err);
  }
  function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
      r.constructed = true;
      r.closed = false;
      r.closeEmitted = false;
      r.destroyed = false;
      r.errored = null;
      r.errorEmitted = false;
      r.reading = false;
      r.ended = r.readable === false;
      r.endEmitted = r.readable === false;
    }
    if (w) {
      w.constructed = true;
      w.destroyed = false;
      w.closed = false;
      w.closeEmitted = false;
      w.errored = null;
      w.errorEmitted = false;
      w.finalCalled = false;
      w.prefinished = false;
      w.ended = w.writable === false;
      w.ending = w.writable === false;
      w.finished = w.writable === false;
    }
  }
  function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {
      return this;
    }
    if (r !== null && r !== undefined && r.autoDestroy || w !== null && w !== undefined && w.autoDestroy)
      stream.destroy(err);
    else if (err) {
      err.stack;
      if (w && !w.errored) {
        w.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
      if (sync) {
        process2.nextTick(emitErrorNT, stream, err);
      } else {
        emitErrorNT(stream, err);
      }
    }
  }
  function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
      return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
      r.constructed = false;
    }
    if (w) {
      w.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
      return;
    }
    process2.nextTick(constructNT, stream);
  }
  function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
        return;
      }
      called = true;
      const r = stream._readableState;
      const w = stream._writableState;
      const s = w || r;
      if (r) {
        r.constructed = true;
      }
      if (w) {
        w.constructed = true;
      }
      if (s.destroyed) {
        stream.emit(kDestroy, err);
      } else if (err) {
        errorOrDestroy(stream, err, true);
      } else {
        process2.nextTick(emitConstructNT, stream);
      }
    }
    try {
      stream._construct((err) => {
        process2.nextTick(onConstruct, err);
      });
    } catch (err) {
      process2.nextTick(onConstruct, err);
    }
  }
  function emitConstructNT(stream) {
    stream.emit(kConstruct);
  }
  function isRequest(stream) {
    return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
  }
  function emitCloseLegacy(stream) {
    stream.emit("close");
  }
  function emitErrorCloseLegacy(stream, err) {
    stream.emit("error", err);
    process2.nextTick(emitCloseLegacy, stream);
  }
  function destroyer(stream, err) {
    if (!stream || isDestroyed(stream)) {
      return;
    }
    if (!err && !isFinished(stream)) {
      err = new AbortError;
    }
    if (isServerRequest(stream)) {
      stream.socket = null;
      stream.destroy(err);
    } else if (isRequest(stream)) {
      stream.abort();
    } else if (isRequest(stream.req)) {
      stream.req.abort();
    } else if (typeof stream.destroy === "function") {
      stream.destroy(err);
    } else if (typeof stream.close === "function") {
      stream.close();
    } else if (err) {
      process2.nextTick(emitErrorCloseLegacy, stream, err);
    } else {
      process2.nextTick(emitCloseLegacy, stream);
    }
    if (!stream.destroyed) {
      stream[kIsDestroyed] = true;
    }
  }
  module.exports = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
  var { EventEmitter: EE } = __require("events");
  function Stream(opts) {
    EE.call(this, opts);
  }
  ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
  ObjectSetPrototypeOf(Stream, EE);
  Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
      if (dest.writable && dest.write(chunk) === false && source.pause) {
        source.pause();
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        this.emit("error", er);
      }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (ArrayIsArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  module.exports = {
    Stream,
    prependListener
  };
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS((exports, module) => {
  var { SymbolDispose } = require_primordials();
  var { AbortError, codes } = require_errors3();
  var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils5();
  var eos = require_end_of_stream();
  var { ERR_INVALID_ARG_TYPE } = codes;
  var addAbortListener;
  var validateAbortSignal = (signal, name) => {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  };
  exports.addAbortSignal = function addAbortSignal(signal, stream) {
    validateAbortSignal(signal, "signal");
    if (!isNodeStream(stream) && !isWebStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    return exports.addAbortSignalNoValidate(signal, stream);
  };
  exports.addAbortSignalNoValidate = function(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      return stream;
    }
    const onAbort = isNodeStream(stream) ? () => {
      stream.destroy(new AbortError(undefined, {
        cause: signal.reason
      }));
    } : () => {
      stream[kControllerErrorFunction](new AbortError(undefined, {
        cause: signal.reason
      }));
    };
    if (signal.aborted) {
      onAbort();
    } else {
      addAbortListener = addAbortListener || require_util12().addAbortListener;
      const disposable = addAbortListener(signal, onAbort);
      eos(stream, disposable[SymbolDispose]);
    }
    return stream;
  };
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
  var { Buffer: Buffer2 } = __require("buffer");
  var { inspect } = require_util12();
  module.exports = class BufferList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    push(v) {
      const entry = {
        data: v,
        next: null
      };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    }
    unshift(v) {
      const entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    }
    shift() {
      if (this.length === 0)
        return;
      const ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    }
    clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
    join(s) {
      if (this.length === 0)
        return "";
      let p = this.head;
      let ret = "" + p.data;
      while ((p = p.next) !== null)
        ret += s + p.data;
      return ret;
    }
    concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      const ret = Buffer2.allocUnsafe(n >>> 0);
      let p = this.head;
      let i = 0;
      while (p) {
        TypedArrayPrototypeSet(ret, p.data, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }
    consume(n, hasStrings) {
      const data = this.head.data;
      if (n < data.length) {
        const slice = data.slice(0, n);
        this.head.data = data.slice(n);
        return slice;
      }
      if (n === data.length) {
        return this.shift();
      }
      return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
      return this.head.data;
    }
    *[SymbolIterator]() {
      for (let p = this.head;p; p = p.next) {
        yield p.data;
      }
    }
    _getString(n) {
      let ret = "";
      let p = this.head;
      let c = 0;
      do {
        const str = p.data;
        if (n > str.length) {
          ret += str;
          n -= str.length;
        } else {
          if (n === str.length) {
            ret += str;
            ++c;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            ret += StringPrototypeSlice(str, 0, n);
            this.head = p;
            p.data = StringPrototypeSlice(str, n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    _getBuffer(n) {
      const ret = Buffer2.allocUnsafe(n);
      const retLen = n;
      let p = this.head;
      let c = 0;
      do {
        const buf = p.data;
        if (n > buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n);
          n -= buf.length;
        } else {
          if (n === buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            ++c;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
            this.head = p;
            p.data = buf.slice(n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
      return inspect(this, {
        ...options,
        depth: 0,
        customInspect: false
      });
    }
  };
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state3 = __commonJS((exports, module) => {
  var { MathFloor, NumberIsInteger } = require_primordials();
  var { validateInteger } = require_validators();
  var { ERR_INVALID_ARG_VALUE } = require_errors3().codes;
  var defaultHighWaterMarkBytes = 16 * 1024;
  var defaultHighWaterMarkObjectMode = 16;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getDefaultHighWaterMark(objectMode) {
    return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
  }
  function setDefaultHighWaterMark(objectMode, value) {
    validateInteger(value, "value", 0);
    if (objectMode) {
      defaultHighWaterMarkObjectMode = value;
    } else {
      defaultHighWaterMarkBytes = value;
    }
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!NumberIsInteger(hwm) || hwm < 0) {
        const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
        throw new ERR_INVALID_ARG_VALUE(name, hwm);
      }
      return MathFloor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
  }
  module.exports = {
    getHighWaterMark,
    getDefaultHighWaterMark,
    setDefaultHighWaterMark
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer2().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  var process2 = require_process();
  var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
  var { Buffer: Buffer2 } = __require("buffer");
  var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors3().codes;
  function from(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer2) {
      return new Readable({
        objectMode: true,
        ...opts,
        read() {
          this.push(iterable);
          this.push(null);
        }
      });
    }
    let isAsync;
    if (iterable && iterable[SymbolAsyncIterator]) {
      isAsync = true;
      iterator = iterable[SymbolAsyncIterator]();
    } else if (iterable && iterable[SymbolIterator]) {
      isAsync = false;
      iterator = iterable[SymbolIterator]();
    } else {
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    }
    const readable = new Readable({
      objectMode: true,
      highWaterMark: 1,
      ...opts
    });
    let reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    readable._destroy = function(error, cb) {
      PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e) => process2.nextTick(cb, e || error));
    };
    async function close(error) {
      const hadError = error !== undefined && error !== null;
      const hasThrow = typeof iterator.throw === "function";
      if (hadError && hasThrow) {
        const { value, done } = await iterator.throw(error);
        await value;
        if (done) {
          return;
        }
      }
      if (typeof iterator.return === "function") {
        const { value } = await iterator.return();
        await value;
      }
    }
    async function next() {
      for (;; ) {
        try {
          const { value, done } = isAsync ? await iterator.next() : iterator.next();
          if (done) {
            readable.push(null);
          } else {
            const res = value && typeof value.then === "function" ? await value : value;
            if (res === null) {
              reading = false;
              throw new ERR_STREAM_NULL_VALUES;
            } else if (readable.push(res)) {
              continue;
            } else {
              reading = false;
            }
          }
        } catch (err) {
          readable.destroy(err);
        }
        break;
      }
    }
    return readable;
  }
  module.exports = from;
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable3 = __commonJS((exports, module) => {
  var process2 = require_process();
  var {
    ArrayPrototypeIndexOf,
    NumberIsInteger,
    NumberIsNaN,
    NumberParseInt,
    ObjectDefineProperties,
    ObjectKeys,
    ObjectSetPrototypeOf,
    Promise: Promise2,
    SafeSet,
    SymbolAsyncDispose,
    SymbolAsyncIterator,
    Symbol: Symbol2
  } = require_primordials();
  module.exports = Readable;
  Readable.ReadableState = ReadableState;
  var { EventEmitter: EE } = __require("events");
  var { Stream, prependListener } = require_legacy();
  var { Buffer: Buffer2 } = __require("buffer");
  var { addAbortSignal } = require_add_abort_signal();
  var eos = require_end_of_stream();
  var debug = require_util12().debuglog("stream", (fn) => {
    debug = fn;
  });
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy2();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state3();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_OUT_OF_RANGE,
      ERR_STREAM_PUSH_AFTER_EOF,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT
    },
    AbortError
  } = require_errors3();
  var { validateObject } = require_validators();
  var kPaused = Symbol2("kPaused");
  var { StringDecoder } = require_string_decoder2();
  var from = require_from();
  ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Readable, Stream);
  var nop = () => {};
  var { errorOrDestroy } = destroyImpl;
  var kObjectMode = 1 << 0;
  var kEnded = 1 << 1;
  var kEndEmitted = 1 << 2;
  var kReading = 1 << 3;
  var kConstructed = 1 << 4;
  var kSync = 1 << 5;
  var kNeedReadable = 1 << 6;
  var kEmittedReadable = 1 << 7;
  var kReadableListening = 1 << 8;
  var kResumeScheduled = 1 << 9;
  var kErrorEmitted = 1 << 10;
  var kEmitClose = 1 << 11;
  var kAutoDestroy = 1 << 12;
  var kDestroyed = 1 << 13;
  var kClosed = 1 << 14;
  var kCloseEmitted = 1 << 15;
  var kMultiAwaitDrain = 1 << 16;
  var kReadingMore = 1 << 17;
  var kDataEmitted = 1 << 18;
  function makeBitMapDescriptor(bit) {
    return {
      enumerable: false,
      get() {
        return (this.state & bit) !== 0;
      },
      set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      }
    };
  }
  ObjectDefineProperties(ReadableState.prototype, {
    objectMode: makeBitMapDescriptor(kObjectMode),
    ended: makeBitMapDescriptor(kEnded),
    endEmitted: makeBitMapDescriptor(kEndEmitted),
    reading: makeBitMapDescriptor(kReading),
    constructed: makeBitMapDescriptor(kConstructed),
    sync: makeBitMapDescriptor(kSync),
    needReadable: makeBitMapDescriptor(kNeedReadable),
    emittedReadable: makeBitMapDescriptor(kEmittedReadable),
    readableListening: makeBitMapDescriptor(kReadableListening),
    resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
    errorEmitted: makeBitMapDescriptor(kErrorEmitted),
    emitClose: makeBitMapDescriptor(kEmitClose),
    autoDestroy: makeBitMapDescriptor(kAutoDestroy),
    destroyed: makeBitMapDescriptor(kDestroyed),
    closed: makeBitMapDescriptor(kClosed),
    closeEmitted: makeBitMapDescriptor(kCloseEmitted),
    multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
    readingMore: makeBitMapDescriptor(kReadingMore),
    dataEmitted: makeBitMapDescriptor(kDataEmitted)
  });
  function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
    if (options && options.objectMode)
      this.state |= kObjectMode;
    if (isDuplex && options && options.readableObjectMode)
      this.state |= kObjectMode;
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this[kPaused] = null;
    if (options && options.emitClose === false)
      this.state &= ~kEmitClose;
    if (options && options.autoDestroy === false)
      this.state &= ~kAutoDestroy;
    this.errored = null;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    const isDuplex = this instanceof require_duplex();
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal && !isDuplex)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      if (this._readableState.needReadable) {
        maybeReadMore(this, this._readableState);
      }
    });
  }
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  Readable.prototype[SymbolAsyncDispose] = function() {
    let error;
    if (!this.destroyed) {
      error = this.readableEnded ? null : new AbortError;
      this.destroy(error);
    }
    return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
  };
  Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if ((state.state & kObjectMode) === 0) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (state.encoding !== encoding) {
          if (addToFront && state.encoding) {
            chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
          } else {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "";
      } else if (chunk != null) {
        err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    if (err) {
      errorOrDestroy(stream, err);
    } else if (chunk === null) {
      state.state &= ~kReading;
      onEofChunk(stream, state);
    } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
      if (addToFront) {
        if ((state.state & kEndEmitted) !== 0)
          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
        else if (state.destroyed || state.errored)
          return false;
        else
          addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
      } else if (state.destroyed || state.errored) {
        return false;
      } else {
        state.state &= ~kReading;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.state &= ~kReading;
      maybeReadMore(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
      if ((state.state & kMultiAwaitDrain) !== 0) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
      state.dataEmitted = true;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if ((state.state & kNeedReadable) !== 0)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  Readable.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content = "";
    for (const data of buffer) {
      content += decoder.write(data);
    }
    buffer.clear();
    if (content !== "")
      buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n > MAX_HWM) {
      throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if ((state.state & kObjectMode) !== 0)
      return 1;
    if (NumberIsNaN(n)) {
      if (state.flowing && state.length)
        return state.buffer.first().length;
      return state.length;
    }
    if (n <= state.length)
      return n;
    return state.ended ? state.length : 0;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
      n = NaN;
    } else if (!NumberIsInteger(n)) {
      n = NumberParseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n !== 0)
      state.state &= ~kEmittedReadable;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    let doRead = (state.state & kNeedReadable) !== 0;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
      doRead = false;
      debug("reading, ended or constructing", doRead);
    } else if (doRead) {
      debug("do read");
      state.state |= kReading | kSync;
      if (state.length === 0)
        state.state |= kNeedReadable;
      try {
        this._read(state.highWaterMark);
      } catch (err) {
        errorOrDestroy(this, err);
      }
      state.state &= ~kSync;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    let ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      if (state.multiAwaitDrain) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
      state.dataEmitted = true;
      this.emit("data", ret);
    }
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      const chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
  function emitReadable(stream) {
    const state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process2.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    const state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
      state.readingMore = true;
      process2.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      const len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
      if (!state.multiAwaitDrain) {
        state.multiAwaitDrain = true;
        state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
    }
    state.pipes.push(dest);
    debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process2.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      if (ondrain) {
        dest.removeListener("drain", ondrain);
      }
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    function pause() {
      if (!cleanedUp) {
        if (state.pipes.length === 1 && state.pipes[0] === dest) {
          debug("false write response, pause", 0);
          state.awaitDrainWriters = dest;
          state.multiAwaitDrain = false;
        } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
          debug("false write response, pause", state.awaitDrainWriters.size);
          state.awaitDrainWriters.add(dest);
        }
        src.pause();
      }
      if (!ondrain) {
        ondrain = pipeOnDrain(src, dest);
        dest.on("drain", ondrain);
      }
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      const ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (dest.listenerCount("error") === 0) {
        const s = dest._writableState || dest._readableState;
        if (s && !s.errorEmitted) {
          errorOrDestroy(dest, er);
        } else {
          dest.emit("error", er);
        }
      }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
      pause();
    } else if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
      const state = src._readableState;
      if (state.awaitDrainWriters === dest) {
        debug("pipeOnDrain", 1);
        state.awaitDrainWriters = null;
      } else if (state.multiAwaitDrain) {
        debug("pipeOnDrain", state.awaitDrainWriters.size);
        state.awaitDrainWriters.delete(dest);
      }
      if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
        src.resume();
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipes.length === 0)
      return this;
    if (!dest) {
      const dests = state.pipes;
      state.pipes = [];
      this.pause();
      for (let i = 0;i < dests.length; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    const index = ArrayPrototypeIndexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    if (state.pipes.length === 0)
      this.pause();
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process2.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.off = Readable.prototype.removeListener;
  Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    const state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused] === false) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    } else if (!state.readableListening) {
      state.flowing = null;
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state[kPaused] = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process2.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
  };
  function flow(stream) {
    const state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk) => {
      if (!this.push(chunk) && stream.pause) {
        paused = true;
        stream.pause();
      }
    });
    stream.on("end", () => {
      this.push(null);
    });
    stream.on("error", (err) => {
      errorOrDestroy(this, err);
    });
    stream.on("close", () => {
      this.destroy();
    });
    stream.on("destroy", () => {
      this.destroy();
    });
    this._read = () => {
      if (paused && stream.resume) {
        paused = false;
        stream.resume();
      }
    };
    const streamKeys = ObjectKeys(stream);
    for (let j = 1;j < streamKeys.length; j++) {
      const i = streamKeys[j];
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = stream[i].bind(stream);
      }
    }
    return this;
  };
  Readable.prototype[SymbolAsyncIterator] = function() {
    return streamToAsyncIterator(this);
  };
  Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
      validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
  };
  function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
      stream = Readable.wrap(stream, {
        objectMode: true
      });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
  }
  async function* createAsyncIterator(stream, options) {
    let callback = nop;
    function next(resolve) {
      if (this === stream) {
        callback();
        callback = nop;
      } else {
        callback = resolve;
      }
    }
    stream.on("readable", next);
    let error;
    const cleanup = eos(stream, {
      writable: false
    }, (err) => {
      error = err ? aggregateTwoErrors(error, err) : null;
      callback();
      callback = nop;
    });
    try {
      while (true) {
        const chunk = stream.destroyed ? null : stream.read();
        if (chunk !== null) {
          yield chunk;
        } else if (error) {
          throw error;
        } else if (error === null) {
          return;
        } else {
          await new Promise2(next);
        }
      }
    } catch (err) {
      error = aggregateTwoErrors(error, err);
      throw error;
    } finally {
      if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) {
        destroyImpl.destroyer(stream, null);
      } else {
        stream.off("readable", next);
        cleanup();
      }
    }
  }
  ObjectDefineProperties(Readable.prototype, {
    readable: {
      __proto__: null,
      get() {
        const r = this._readableState;
        return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
      },
      set(val) {
        if (this._readableState) {
          this._readableState.readable = !!val;
        }
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.objectMode : false;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.destroyed : false;
      },
      set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.endEmitted : false;
      }
    }
  });
  ObjectDefineProperties(ReadableState.prototype, {
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    paused: {
      __proto__: null,
      get() {
        return this[kPaused] !== false;
      },
      set(value) {
        this[kPaused] = !!value;
      }
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    let ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    const state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process2.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.emit("end");
      if (stream.writable && stream.allowHalfOpen === false) {
        process2.nextTick(endWritableNT, stream);
      } else if (state.autoDestroy) {
        const wState = stream._writableState;
        const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
  }
  function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
      stream.end();
    }
  }
  Readable.from = function(iterable, opts) {
    return from(Readable, iterable, opts);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Readable.fromWeb = function(readableStream, options) {
    return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
  };
  Readable.toWeb = function(streamReadable, options) {
    return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
  };
  Readable.wrap = function(src, options) {
    var _ref, _src$readableObjectMo;
    return new Readable({
      objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,
      ...options,
      destroy(err, callback) {
        destroyImpl.destroyer(src, err);
        callback(err);
      }
    }).wrap(src);
  };
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS((exports, module) => {
  var process2 = require_process();
  var {
    ArrayPrototypeSlice,
    Error: Error2,
    FunctionPrototypeSymbolHasInstance,
    ObjectDefineProperty,
    ObjectDefineProperties,
    ObjectSetPrototypeOf,
    StringPrototypeToLowerCase,
    Symbol: Symbol2,
    SymbolHasInstance
  } = require_primordials();
  module.exports = Writable;
  Writable.WritableState = WritableState;
  var { EventEmitter: EE } = __require("events");
  var Stream = require_legacy().Stream;
  var { Buffer: Buffer2 } = __require("buffer");
  var destroyImpl = require_destroy2();
  var { addAbortSignal } = require_add_abort_signal();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state3();
  var {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING
  } = require_errors3().codes;
  var { errorOrDestroy } = destroyImpl;
  ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Writable, Stream);
  function nop() {}
  var kOnFinished = Symbol2("kOnFinished");
  function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex)
      this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
  }
  function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
  };
  ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Writable(options) {
    const isDuplex = this instanceof require_duplex();
    if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      const state = this._writableState;
      if (!state.writing) {
        clearBuffer(this, state);
      }
      finishMaybe(this, state);
    });
  }
  ObjectDefineProperty(Writable, SymbolHasInstance, {
    __proto__: null,
    value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return true;
      if (this !== Writable)
        return false;
      return object && object._writableState instanceof WritableState;
    }
  });
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = state.defaultEncoding;
    } else {
      if (!encoding)
        encoding = state.defaultEncoding;
      else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      if (typeof cb !== "function")
        cb = nop;
    }
    if (chunk === null) {
      throw new ERR_STREAM_NULL_VALUES;
    } else if (!state.objectMode) {
      if (typeof chunk === "string") {
        if (state.decodeStrings !== false) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "buffer";
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "buffer";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "buffer";
      } else {
        throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    let err;
    if (state.ending) {
      err = new ERR_STREAM_WRITE_AFTER_END;
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
      process2.nextTick(cb, err);
      errorOrDestroy(stream, err, true);
      return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = StringPrototypeToLowerCase(encoding);
    if (!Buffer2.isEncoding(encoding))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked || state.errored || !state.constructed) {
      state.buffered.push({
        chunk,
        encoding,
        callback
      });
      if (state.allBuffers && encoding !== "buffer") {
        state.allBuffers = false;
      }
      if (state.allNoop && callback !== nop) {
        state.allNoop = false;
      }
    } else {
      state.writelen = len;
      state.writecb = callback;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, er, cb) {
    --state.pendingcb;
    cb(er);
    errorBuffer(state);
    errorOrDestroy(stream, er);
  }
  function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
      errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
      return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er) {
      er.stack;
      if (!state.errored) {
        state.errored = er;
      }
      if (stream._readableState && !stream._readableState.errored) {
        stream._readableState.errored = er;
      }
      if (sync) {
        process2.nextTick(onwriteError, stream, state, er, cb);
      } else {
        onwriteError(stream, state, er, cb);
      }
    } else {
      if (state.buffered.length > state.bufferedIndex) {
        clearBuffer(stream, state);
      }
      if (sync) {
        if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
          state.afterWriteTickInfo.count++;
        } else {
          state.afterWriteTickInfo = {
            count: 1,
            cb,
            stream,
            state
          };
          process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
        }
      } else {
        afterWrite(stream, state, 1, cb);
      }
    }
  }
  function afterWriteTick({ stream, state, count, cb }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
  }
  function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
    while (count-- > 0) {
      state.pendingcb--;
      cb();
    }
    if (state.destroyed) {
      errorBuffer(state);
    }
    finishMaybe(stream, state);
  }
  function errorBuffer(state) {
    if (state.writing) {
      return;
    }
    for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
      var _state$errored;
      const { chunk, callback } = state.buffered[n];
      const len = state.objectMode ? 1 : chunk.length;
      state.length -= len;
      callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      var _state$errored2;
      onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
  }
  function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
      return;
    }
    const { buffered, bufferedIndex, objectMode } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
      return;
    }
    let i = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
      state.pendingcb -= bufferedLength - 1;
      const callback = state.allNoop ? nop : (err) => {
        for (let n = i;n < buffered.length; ++n) {
          buffered[n].callback(err);
        }
      };
      const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
      chunks.allBuffers = state.allBuffers;
      doWrite(stream, state, true, state.length, chunks, "", callback);
      resetBuffer(state);
    } else {
      do {
        const { chunk, encoding, callback } = buffered[i];
        buffered[i++] = null;
        const len = objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, callback);
      } while (i < buffered.length && !state.writing);
      if (i === buffered.length) {
        resetBuffer(state);
      } else if (i > 256) {
        buffered.splice(0, i);
        state.bufferedIndex = 0;
      } else {
        state.bufferedIndex = i;
      }
    }
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
      this._writev([
        {
          chunk,
          encoding
        }
      ], cb);
    } else {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
      const ret = _write(this, chunk, encoding);
      if (ret instanceof Error2) {
        err = ret;
      }
    }
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (err) {} else if (!state.errored && !state.ending) {
      state.ending = true;
      finishMaybe(this, state, true);
      state.ended = true;
    } else if (state.finished) {
      err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
      if (err || state.finished) {
        process2.nextTick(cb, err);
      } else {
        state[kOnFinished].push(cb);
      }
    }
    return this;
  };
  function needFinish(state) {
    return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
  }
  function callFinal(stream, state) {
    let called = false;
    function onFinish(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
        return;
      }
      called = true;
      state.pendingcb--;
      if (err) {
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i = 0;i < onfinishCallbacks.length; i++) {
          onfinishCallbacks[i](err);
        }
        errorOrDestroy(stream, err, state.sync);
      } else if (needFinish(state)) {
        state.prefinished = true;
        stream.emit("prefinish");
        state.pendingcb++;
        process2.nextTick(finish, stream, state);
      }
    }
    state.sync = true;
    state.pendingcb++;
    try {
      stream._final(onFinish);
    } catch (err) {
      onFinish(err);
    }
    state.sync = false;
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.finalCalled = true;
        callFinal(stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        if (sync) {
          state.pendingcb++;
          process2.nextTick((stream2, state2) => {
            if (needFinish(state2)) {
              finish(stream2, state2);
            } else {
              state2.pendingcb--;
            }
          }, stream, state);
        } else if (needFinish(state)) {
          state.pendingcb++;
          finish(stream, state);
        }
      }
    }
  }
  function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      onfinishCallbacks[i]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
      const rState = stream._readableState;
      const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
  ObjectDefineProperties(Writable.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : false;
      },
      set(value) {
        if (this._writableState) {
          this._writableState.destroyed = value;
        }
      }
    },
    writable: {
      __proto__: null,
      get() {
        const w = this._writableState;
        return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
      },
      set(val) {
        if (this._writableState) {
          this._writableState.writable = !!val;
        }
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : false;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : false;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : false;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const wState = this._writableState;
        if (!wState)
          return false;
        return !wState.destroyed && !wState.ending && wState.needDrain;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  var destroy = destroyImpl.destroy;
  Writable.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
      process2.nextTick(errorBuffer, state);
    }
    destroy.call(this, err, cb);
    return this;
  };
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Writable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Writable.fromWeb = function(writableStream, options) {
    return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
  };
  Writable.toWeb = function(streamWritable) {
    return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
  };
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS((exports, module) => {
  var process2 = require_process();
  var bufferModule = __require("buffer");
  var {
    isReadable,
    isWritable,
    isIterable,
    isNodeStream,
    isReadableNodeStream,
    isWritableNodeStream,
    isDuplexNodeStream,
    isReadableStream,
    isWritableStream
  } = require_utils5();
  var eos = require_end_of_stream();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
  } = require_errors3();
  var { destroyer } = require_destroy2();
  var Duplex = require_duplex();
  var Readable = require_readable3();
  var Writable = require_writable();
  var { createDeferredPromise } = require_util12();
  var from = require_from();
  var Blob2 = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob2 !== "undefined" ? function isBlob(b) {
    return b instanceof Blob2;
  } : function isBlob(b) {
    return false;
  };
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var { FunctionPrototypeCall } = require_primordials();

  class Duplexify extends Duplex {
    constructor(options) {
      super(options);
      if ((options === null || options === undefined ? undefined : options.readable) === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if ((options === null || options === undefined ? undefined : options.writable) === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    }
  }
  module.exports = function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
      return body;
    }
    if (isReadableNodeStream(body)) {
      return _duplexify({
        readable: body
      });
    }
    if (isWritableNodeStream(body)) {
      return _duplexify({
        writable: body
      });
    }
    if (isNodeStream(body)) {
      return _duplexify({
        writable: false,
        readable: false
      });
    }
    if (isReadableStream(body)) {
      return _duplexify({
        readable: Readable.fromWeb(body)
      });
    }
    if (isWritableStream(body)) {
      return _duplexify({
        writable: Writable.fromWeb(body)
      });
    }
    if (typeof body === "function") {
      const { value, write, final, destroy } = fromAsyncGen(body);
      if (isIterable(value)) {
        return from(Duplexify, value, {
          objectMode: true,
          write,
          final,
          destroy
        });
      }
      const then2 = value === null || value === undefined ? undefined : value.then;
      if (typeof then2 === "function") {
        let d;
        const promise = FunctionPrototypeCall(then2, value, (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }
        }, (err) => {
          destroyer(d, err);
        });
        return d = new Duplexify({
          objectMode: true,
          readable: false,
          write,
          final(cb) {
            final(async () => {
              try {
                await promise;
                process2.nextTick(cb, null);
              } catch (err) {
                process2.nextTick(cb, err);
              }
            });
          },
          destroy
        });
      }
      throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body)) {
      return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
      return from(Duplexify, body, {
        objectMode: true,
        writable: false
      });
    }
    if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable)) {
      return Duplexify.fromWeb(body);
    }
    if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
      const readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined;
      const writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
      return _duplexify({
        readable,
        writable
      });
    }
    const then = body === null || body === undefined ? undefined : body.then;
    if (typeof then === "function") {
      let d;
      FunctionPrototypeCall(then, body, (val) => {
        if (val != null) {
          d.push(val);
        }
        d.push(null);
      }, (err) => {
        destroyer(d, err);
      });
      return d = new Duplexify({
        objectMode: true,
        writable: false,
        read() {}
      });
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
      "Blob",
      "ReadableStream",
      "WritableStream",
      "Stream",
      "Iterable",
      "AsyncIterable",
      "Function",
      "{ readable, writable } pair",
      "Promise"
    ], body);
  };
  function fromAsyncGen(fn) {
    let { promise, resolve } = createDeferredPromise();
    const ac = new AbortController2;
    const signal = ac.signal;
    const value = fn(async function* () {
      while (true) {
        const _promise = promise;
        promise = null;
        const { chunk, done, cb } = await _promise;
        process2.nextTick(cb);
        if (done)
          return;
        if (signal.aborted)
          throw new AbortError(undefined, {
            cause: signal.reason
          });
        ({ promise, resolve } = createDeferredPromise());
        yield chunk;
      }
    }(), {
      signal
    });
    return {
      value,
      write(chunk, encoding, cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          chunk,
          done: false,
          cb
        });
      },
      final(cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          done: true,
          cb
        });
      },
      destroy(err, cb) {
        ac.abort();
        cb(err);
      }
    };
  }
  function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable = !!isReadable(r);
    let writable = !!isWritable(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d.destroy(err);
      }
    }
    d = new Duplexify({
      readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
      writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),
      readable,
      writable
    });
    if (writable) {
      eos(w, (err) => {
        writable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      d._write = function(chunk, encoding, callback) {
        if (w.write(chunk, encoding)) {
          callback();
        } else {
          ondrain = callback;
        }
      };
      d._final = function(callback) {
        w.end();
        onfinish = callback;
      };
      w.on("drain", function() {
        if (ondrain) {
          const cb = ondrain;
          ondrain = null;
          cb();
        }
      });
      w.on("finish", function() {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      eos(r, (err) => {
        readable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      r.on("readable", function() {
        if (onreadable) {
          const cb = onreadable;
          onreadable = null;
          cb();
        }
      });
      r.on("end", function() {
        d.push(null);
      });
      d._read = function() {
        while (true) {
          const buf = r.read();
          if (buf === null) {
            onreadable = d._read;
            return;
          }
          if (!d.push(buf)) {
            return;
          }
        }
      };
    }
    d._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        destroyer(w, err);
        destroyer(r, err);
      }
    };
    return d;
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS((exports, module) => {
  var {
    ObjectDefineProperties,
    ObjectGetOwnPropertyDescriptor,
    ObjectKeys,
    ObjectSetPrototypeOf
  } = require_primordials();
  module.exports = Duplex;
  var Readable = require_readable3();
  var Writable = require_writable();
  ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
  ObjectSetPrototypeOf(Duplex, Readable);
  {
    const keys = ObjectKeys(Writable.prototype);
    for (let i = 0;i < keys.length; i++) {
      const method = keys[i];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options) {
      this.allowHalfOpen = options.allowHalfOpen !== false;
      if (options.readable === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if (options.writable === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    } else {
      this.allowHalfOpen = true;
    }
  }
  ObjectDefineProperties(Duplex.prototype, {
    writable: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        if (this._readableState === undefined || this._writableState === undefined) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState && this._writableState) {
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      }
    }
  });
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Duplex.fromWeb = function(pair, options) {
    return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
  };
  Duplex.toWeb = function(duplex) {
    return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
  };
  var duplexify;
  Duplex.from = function(body) {
    if (!duplexify) {
      duplexify = require_duplexify();
    }
    return duplexify(body, "body");
  };
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
  module.exports = Transform;
  var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors3().codes;
  var Duplex = require_duplex();
  var { getHighWaterMark } = require_state3();
  ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
  ObjectSetPrototypeOf(Transform, Duplex);
  var kCallback = Symbol2("kCallback");
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
    if (readableHighWaterMark === 0) {
      options = {
        ...options,
        highWaterMark: null,
        readableHighWaterMark,
        writableHighWaterMark: options.writableHighWaterMark || 0
      };
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function final(cb) {
    if (typeof this._flush === "function" && !this.destroyed) {
      this._flush((er, data) => {
        if (er) {
          if (cb) {
            cb(er);
          } else {
            this.destroy(er);
          }
          return;
        }
        if (data != null) {
          this.push(data);
        }
        this.push(null);
        if (cb) {
          cb();
        }
      });
    } else {
      this.push(null);
      if (cb) {
        cb();
      }
    }
  }
  function prefinish() {
    if (this._final !== final) {
      final.call(this);
    }
  }
  Transform.prototype._final = final;
  Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
  };
  Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    this._transform(chunk, encoding, (err, val) => {
      if (err) {
        callback(err);
        return;
      }
      if (val != null) {
        this.push(val);
      }
      if (wState.ended || length === rState.length || rState.length < rState.highWaterMark) {
        callback();
      } else {
        this[kCallback] = callback;
      }
    });
  };
  Transform.prototype._read = function() {
    if (this[kCallback]) {
      const callback = this[kCallback];
      this[kCallback] = null;
      callback();
    }
  };
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough2 = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf } = require_primordials();
  module.exports = PassThrough;
  var Transform = require_transform();
  ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
  ObjectSetPrototypeOf(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline4 = __commonJS((exports, module) => {
  var process2 = require_process();
  var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
  var eos = require_end_of_stream();
  var { once } = require_util12();
  var destroyImpl = require_destroy2();
  var Duplex = require_duplex();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_RETURN_VALUE,
      ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_PREMATURE_CLOSE
    },
    AbortError
  } = require_errors3();
  var { validateFunction, validateAbortSignal } = require_validators();
  var {
    isIterable,
    isReadable,
    isReadableNodeStream,
    isNodeStream,
    isTransformStream,
    isWebStream,
    isReadableStream,
    isReadableFinished
  } = require_utils5();
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var PassThrough;
  var Readable;
  var addAbortListener;
  function destroyer(stream, reading, writing) {
    let finished = false;
    stream.on("close", () => {
      finished = true;
    });
    const cleanup = eos(stream, {
      readable: reading,
      writable: writing
    }, (err) => {
      finished = !err;
    });
    return {
      destroy: (err) => {
        if (finished)
          return;
        finished = true;
        destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      },
      cleanup
    };
  }
  function popCallback(streams) {
    validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
    return streams.pop();
  }
  function makeAsyncIterable(val) {
    if (isIterable(val)) {
      return val;
    } else if (isReadableNodeStream(val)) {
      return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
  }
  async function* fromReadable(val) {
    if (!Readable) {
      Readable = require_readable3();
    }
    yield* Readable.prototype[SymbolAsyncIterator].call(val);
  }
  async function pumpToNode(iterable, writable, finish, { end }) {
    let error;
    let onresolve = null;
    const resume = (err) => {
      if (err) {
        error = err;
      }
      if (onresolve) {
        const callback = onresolve;
        onresolve = null;
        callback();
      }
    };
    const wait = () => new Promise2((resolve, reject) => {
      if (error) {
        reject(error);
      } else {
        onresolve = () => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        };
      }
    });
    writable.on("drain", resume);
    const cleanup = eos(writable, {
      readable: false
    }, resume);
    try {
      if (writable.writableNeedDrain) {
        await wait();
      }
      for await (const chunk of iterable) {
        if (!writable.write(chunk)) {
          await wait();
        }
      }
      if (end) {
        writable.end();
        await wait();
      }
      finish();
    } catch (err) {
      finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally {
      cleanup();
      writable.off("drain", resume);
    }
  }
  async function pumpToWeb(readable, writable, finish, { end }) {
    if (isTransformStream(writable)) {
      writable = writable.writable;
    }
    const writer = writable.getWriter();
    try {
      for await (const chunk of readable) {
        await writer.ready;
        writer.write(chunk).catch(() => {});
      }
      await writer.ready;
      if (end) {
        await writer.close();
      }
      finish();
    } catch (err) {
      try {
        await writer.abort(err);
        finish(err);
      } catch (err2) {
        finish(err2);
      }
    }
  }
  function pipeline(...streams) {
    return pipelineImpl(streams, once(popCallback(streams)));
  }
  function pipelineImpl(streams, callback, opts) {
    if (streams.length === 1 && ArrayIsArray(streams[0])) {
      streams = streams[0];
    }
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController2;
    const signal = ac.signal;
    const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;
    const lastStreamCleanup = [];
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
      finishImpl(new AbortError);
    }
    addAbortListener = addAbortListener || require_util12().addAbortListener;
    let disposable;
    if (outerSignal) {
      disposable = addAbortListener(outerSignal, abort);
    }
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err) {
      finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, final) {
      var _disposable;
      if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
        error = err;
      }
      if (!error && !final) {
        return;
      }
      while (destroys.length) {
        destroys.shift()(error);
      }
      (_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose]();
      ac.abort();
      if (final) {
        if (!error) {
          lastStreamCleanup.forEach((fn) => fn());
        }
        process2.nextTick(callback, error, value);
      }
    }
    let ret;
    for (let i = 0;i < streams.length; i++) {
      const stream = streams[i];
      const reading = i < streams.length - 1;
      const writing = i > 0;
      const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;
      const isLastStream = i === streams.length - 1;
      if (isNodeStream(stream)) {
        let onError2 = function(err) {
          if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            finish(err);
          }
        };
        var onError = onError2;
        if (end) {
          const { destroy, cleanup } = destroyer(stream, reading, writing);
          destroys.push(destroy);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
        stream.on("error", onError2);
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(() => {
            stream.removeListener("error", onError2);
          });
        }
      }
      if (i === 0) {
        if (typeof stream === "function") {
          ret = stream({
            signal
          });
          if (!isIterable(ret)) {
            throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          }
        } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      } else if (typeof stream === "function") {
        if (isTransformStream(ret)) {
          var _ret;
          ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
        } else {
          ret = makeAsyncIterable(ret);
        }
        ret = stream(ret, {
          signal
        });
        if (reading) {
          if (!isIterable(ret, true)) {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
          }
        } else {
          var _ret2;
          if (!PassThrough) {
            PassThrough = require_passthrough2();
          }
          const pt = new PassThrough({
            objectMode: true
          });
          const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
          if (typeof then === "function") {
            finishCount++;
            then.call(ret, (val) => {
              value = val;
              if (val != null) {
                pt.write(val);
              }
              if (end) {
                pt.end();
              }
              process2.nextTick(finish);
            }, (err) => {
              pt.destroy(err);
              process2.nextTick(finish, err);
            });
          } else if (isIterable(ret, true)) {
            finishCount++;
            pumpToNode(ret, pt, finish, {
              end
            });
          } else if (isReadableStream(ret) || isTransformStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, pt, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
          }
          ret = pt;
          const { destroy, cleanup } = destroyer(ret, false, true);
          destroys.push(destroy);
          if (isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
      } else if (isNodeStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount += 2;
          const cleanup = pipe(ret, stream, finish, {
            end
          });
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        } else if (isTransformStream(ret) || isReadableStream(ret)) {
          const toRead = ret.readable || ret;
          finishCount++;
          pumpToNode(toRead, stream, finish, {
            end
          });
        } else if (isIterable(ret)) {
          finishCount++;
          pumpToNode(ret, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else if (isWebStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount++;
          pumpToWeb(makeAsyncIterable(ret), stream, finish, {
            end
          });
        } else if (isReadableStream(ret) || isIterable(ret)) {
          finishCount++;
          pumpToWeb(ret, stream, finish, {
            end
          });
        } else if (isTransformStream(ret)) {
          finishCount++;
          pumpToWeb(ret.readable, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else {
        ret = Duplex.from(stream);
      }
    }
    if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {
      process2.nextTick(abort);
    }
    return ret;
  }
  function pipe(src, dst, finish, { end }) {
    let ended = false;
    dst.on("close", () => {
      if (!ended) {
        finish(new ERR_STREAM_PREMATURE_CLOSE);
      }
    });
    src.pipe(dst, {
      end: false
    });
    if (end) {
      let endFn2 = function() {
        ended = true;
        dst.end();
      };
      var endFn = endFn2;
      if (isReadableFinished(src)) {
        process2.nextTick(endFn2);
      } else {
        src.once("end", endFn2);
      }
    } else {
      finish();
    }
    eos(src, {
      readable: true,
      writable: false
    }, (err) => {
      const rState = src._readableState;
      if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
        src.once("end", finish).once("error", finish);
      } else {
        finish(err);
      }
    });
    return eos(dst, {
      readable: false,
      writable: true
    }, finish);
  }
  module.exports = {
    pipelineImpl,
    pipeline
  };
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS((exports, module) => {
  var { pipeline } = require_pipeline4();
  var Duplex = require_duplex();
  var { destroyer } = require_destroy2();
  var {
    isNodeStream,
    isReadable,
    isWritable,
    isWebStream,
    isTransformStream,
    isWritableStream,
    isReadableStream
  } = require_utils5();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
  } = require_errors3();
  var eos = require_end_of_stream();
  module.exports = function compose(...streams) {
    if (streams.length === 0) {
      throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
      return Duplex.from(streams[0]);
    }
    const orgStreams = [...streams];
    if (typeof streams[0] === "function") {
      streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
      const idx = streams.length - 1;
      streams[idx] = Duplex.from(streams[idx]);
    }
    for (let n = 0;n < streams.length; ++n) {
      if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
        continue;
      }
      if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
      }
      if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
      }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d.destroy(err);
      } else if (!readable && !writable) {
        d.destroy();
      }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
    const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
    d = new Duplex({
      writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
      readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
      writable,
      readable
    });
    if (writable) {
      if (isNodeStream(head)) {
        d._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          head.end();
          onfinish = callback;
        };
        head.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
      } else if (isWebStream(head)) {
        const writable2 = isTransformStream(head) ? head.writable : head;
        const writer = writable2.getWriter();
        d._write = async function(chunk, encoding, callback) {
          try {
            await writer.ready;
            writer.write(chunk).catch(() => {});
            callback();
          } catch (err) {
            callback(err);
          }
        };
        d._final = async function(callback) {
          try {
            await writer.ready;
            writer.close().catch(() => {});
            onfinish = callback;
          } catch (err) {
            callback(err);
          }
        };
      }
      const toRead = isTransformStream(tail) ? tail.readable : tail;
      eos(toRead, () => {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      if (isNodeStream(tail)) {
        tail.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        tail.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = tail.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      } else if (isWebStream(tail)) {
        const readable2 = isTransformStream(tail) ? tail.readable : tail;
        const reader = readable2.getReader();
        d._read = async function() {
          while (true) {
            try {
              const { value, done } = await reader.read();
              if (!d.push(value)) {
                return;
              }
              if (done) {
                d.push(null);
                return;
              }
            } catch {
              return;
            }
          }
        };
      }
    }
    d._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        if (isNodeStream(tail)) {
          destroyer(tail, err);
        }
      }
    };
    return d;
  };
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS((exports, module) => {
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var {
    codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
    AbortError
  } = require_errors3();
  var { validateAbortSignal, validateInteger, validateObject } = require_validators();
  var kWeakHandler = require_primordials().Symbol("kWeak");
  var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
  var { finished } = require_end_of_stream();
  var staticCompose = require_compose();
  var { addAbortSignalNoValidate } = require_add_abort_signal();
  var { isWritable, isNodeStream } = require_utils5();
  var { deprecate } = require_util12();
  var {
    ArrayPrototypePush,
    Boolean: Boolean2,
    MathFloor,
    Number: Number2,
    NumberIsNaN,
    Promise: Promise2,
    PromiseReject,
    PromiseResolve,
    PromisePrototypeThen,
    Symbol: Symbol2
  } = require_primordials();
  var kEmpty = Symbol2("kEmpty");
  var kEof = Symbol2("kEof");
  function compose(stream, options) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    if (isNodeStream(stream) && !isWritable(stream)) {
      throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
    }
    const composedStream = staticCompose(this, stream);
    if (options !== null && options !== undefined && options.signal) {
      addAbortSignalNoValidate(options.signal, composedStream);
    }
    return composedStream;
  }
  function map(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let concurrency = 1;
    if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
      concurrency = MathFloor(options.concurrency);
    }
    let highWaterMark = concurrency - 1;
    if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
      highWaterMark = MathFloor(options.highWaterMark);
    }
    validateInteger(concurrency, "options.concurrency", 1);
    validateInteger(highWaterMark, "options.highWaterMark", 0);
    highWaterMark += concurrency;
    return async function* map() {
      const signal = require_util12().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean2));
      const stream = this;
      const queue = [];
      const signalOpt = {
        signal
      };
      let next;
      let resume;
      let done = false;
      let cnt = 0;
      function onCatch() {
        done = true;
        afterItemProcessed();
      }
      function afterItemProcessed() {
        cnt -= 1;
        maybeResume();
      }
      function maybeResume() {
        if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
          resume();
          resume = null;
        }
      }
      async function pump() {
        try {
          for await (let val of stream) {
            if (done) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            try {
              val = fn(val, signalOpt);
              if (val === kEmpty) {
                continue;
              }
              val = PromiseResolve(val);
            } catch (err) {
              val = PromiseReject(err);
            }
            cnt += 1;
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
            if (next) {
              next();
              next = null;
            }
            if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
              await new Promise2((resolve) => {
                resume = resolve;
              });
            }
          }
          queue.push(kEof);
        } catch (err) {
          const val = PromiseReject(err);
          PromisePrototypeThen(val, afterItemProcessed, onCatch);
          queue.push(val);
        } finally {
          done = true;
          if (next) {
            next();
            next = null;
          }
        }
      }
      pump();
      try {
        while (true) {
          while (queue.length > 0) {
            const val = await queue[0];
            if (val === kEof) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            if (val !== kEmpty) {
              yield val;
            }
            queue.shift();
            maybeResume();
          }
          await new Promise2((resolve) => {
            next = resolve;
          });
        }
      } finally {
        done = true;
        if (resume) {
          resume();
          resume = null;
        }
      }
    }.call(this);
  }
  function asIndexedPairs(options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    return async function* asIndexedPairs() {
      let index = 0;
      for await (const val of this) {
        var _options$signal;
        if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {
          throw new AbortError({
            cause: options.signal.reason
          });
        }
        yield [index++, val];
      }
    }.call(this);
  }
  async function some(fn, options = undefined) {
    for await (const unused of filter.call(this, fn, options)) {
      return true;
    }
    return false;
  }
  async function every(fn, options = undefined) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    return !await some.call(this, async (...args) => {
      return !await fn(...args);
    }, options);
  }
  async function find(fn, options) {
    for await (const result of filter.call(this, fn, options)) {
      return result;
    }
    return;
  }
  async function forEach(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    async function forEachFn(value, options2) {
      await fn(value, options2);
      return kEmpty;
    }
    for await (const unused of map.call(this, forEachFn, options))
      ;
  }
  function filter(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    async function filterFn(value, options2) {
      if (await fn(value, options2)) {
        return value;
      }
      return kEmpty;
    }
    return map.call(this, filterFn, options);
  }

  class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
    constructor() {
      super("reduce");
      this.message = "Reduce of an empty stream requires an initial value";
    }
  }
  async function reduce(reducer, initialValue, options) {
    var _options$signal2;
    if (typeof reducer !== "function") {
      throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
    }
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let hasInitialValue = arguments.length > 1;
    if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
      const err = new AbortError(undefined, {
        cause: options.signal.reason
      });
      this.once("error", () => {});
      await finished(this.destroy(err));
      throw err;
    }
    const ac = new AbortController2;
    const signal = ac.signal;
    if (options !== null && options !== undefined && options.signal) {
      const opts = {
        once: true,
        [kWeakHandler]: this,
        [kResistStopPropagation]: true
      };
      options.signal.addEventListener("abort", () => ac.abort(), opts);
    }
    let gotAnyItemFromStream = false;
    try {
      for await (const value of this) {
        var _options$signal3;
        gotAnyItemFromStream = true;
        if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {
          throw new AbortError;
        }
        if (!hasInitialValue) {
          initialValue = value;
          hasInitialValue = true;
        } else {
          initialValue = await reducer(initialValue, value, {
            signal
          });
        }
      }
      if (!gotAnyItemFromStream && !hasInitialValue) {
        throw new ReduceAwareErrMissingArgs;
      }
    } finally {
      ac.abort();
    }
    return initialValue;
  }
  async function toArray(options) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    const result = [];
    for await (const val of this) {
      var _options$signal4;
      if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {
        throw new AbortError(undefined, {
          cause: options.signal.reason
        });
      }
      ArrayPrototypePush(result, val);
    }
    return result;
  }
  function flatMap(fn, options) {
    const values = map.call(this, fn, options);
    return async function* flatMap() {
      for await (const val of values) {
        yield* val;
      }
    }.call(this);
  }
  function toIntegerOrInfinity(number) {
    number = Number2(number);
    if (NumberIsNaN(number)) {
      return 0;
    }
    if (number < 0) {
      throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
    }
    return number;
  }
  function drop(number, options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return async function* drop() {
      var _options$signal5;
      if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal6;
        if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {
          throw new AbortError;
        }
        if (number-- <= 0) {
          yield val;
        }
      }
    }.call(this);
  }
  function take(number, options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return async function* take() {
      var _options$signal7;
      if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal8;
        if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {
          throw new AbortError;
        }
        if (number-- > 0) {
          yield val;
        }
        if (number <= 0) {
          return;
        }
      }
    }.call(this);
  }
  exports.streamReturningOperators = {
    asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
    drop,
    filter,
    flatMap,
    map,
    take,
    compose
  };
  exports.promiseReturningOperators = {
    every,
    forEach,
    reduce,
    toArray,
    some,
    find
  };
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS((exports, module) => {
  var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
  var { isIterable, isNodeStream, isWebStream } = require_utils5();
  var { pipelineImpl: pl } = require_pipeline4();
  var { finished } = require_end_of_stream();
  require_stream();
  function pipeline(...streams) {
    return new Promise2((resolve, reject) => {
      let signal;
      let end;
      const lastArg = streams[streams.length - 1];
      if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
        const options = ArrayPrototypePop(streams);
        signal = options.signal;
        end = options.end;
      }
      pl(streams, (err, value) => {
        if (err) {
          reject(err);
        } else {
          resolve(value);
        }
      }, {
        signal,
        end
      });
    });
  }
  module.exports = {
    finished,
    pipeline
  };
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("buffer");
  var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
  var {
    promisify: { custom: customPromisify }
  } = require_util12();
  var { streamReturningOperators, promiseReturningOperators } = require_operators();
  var {
    codes: { ERR_ILLEGAL_CONSTRUCTOR }
  } = require_errors3();
  var compose = require_compose();
  var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state3();
  var { pipeline } = require_pipeline4();
  var { destroyer } = require_destroy2();
  var eos = require_end_of_stream();
  var promises = require_promises();
  var utils = require_utils5();
  var Stream = module.exports = require_legacy().Stream;
  Stream.isDestroyed = utils.isDestroyed;
  Stream.isDisturbed = utils.isDisturbed;
  Stream.isErrored = utils.isErrored;
  Stream.isReadable = utils.isReadable;
  Stream.isWritable = utils.isWritable;
  Stream.Readable = require_readable3();
  for (const key of ObjectKeys(streamReturningOperators)) {
    let fn = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return Stream.Readable.from(ReflectApply(op, this, args));
    };
    const op = streamReturningOperators[key];
    ObjectDefineProperty(fn, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  for (const key of ObjectKeys(promiseReturningOperators)) {
    let fn = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return ReflectApply(op, this, args);
    };
    const op = promiseReturningOperators[key];
    ObjectDefineProperty(fn, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  Stream.Writable = require_writable();
  Stream.Duplex = require_duplex();
  Stream.Transform = require_transform();
  Stream.PassThrough = require_passthrough2();
  Stream.pipeline = pipeline;
  var { addAbortSignal } = require_add_abort_signal();
  Stream.addAbortSignal = addAbortSignal;
  Stream.finished = eos;
  Stream.destroy = destroyer;
  Stream.compose = compose;
  Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
  Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
  ObjectDefineProperty(Stream, "promises", {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get() {
      return promises;
    }
  });
  ObjectDefineProperty(pipeline, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.pipeline;
    }
  });
  ObjectDefineProperty(eos, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.finished;
    }
  });
  Stream.Stream = Stream;
  Stream._isUint8Array = function isUint8Array(value) {
    return value instanceof Uint8Array;
  };
  Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  };
});

// node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (Stream && process.env.READABLE_STREAM === "disable") {
    const promises = Stream.promises;
    module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
    module.exports._isUint8Array = Stream._isUint8Array;
    module.exports.isDisturbed = Stream.isDisturbed;
    module.exports.isErrored = Stream.isErrored;
    module.exports.isReadable = Stream.isReadable;
    module.exports.Readable = Stream.Readable;
    module.exports.Writable = Stream.Writable;
    module.exports.Duplex = Stream.Duplex;
    module.exports.Transform = Stream.Transform;
    module.exports.PassThrough = Stream.PassThrough;
    module.exports.addAbortSignal = Stream.addAbortSignal;
    module.exports.finished = Stream.finished;
    module.exports.destroy = Stream.destroy;
    module.exports.pipeline = Stream.pipeline;
    module.exports.compose = Stream.compose;
    Object.defineProperty(Stream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = Stream.Stream;
  } else {
    const CustomStream = require_stream();
    const promises = require_promises();
    const originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
  }
  module.exports.default = module.exports;
});

// node_modules/archiver-utils/node_modules/lodash/_arrayPush.js
var require__arrayPush = __commonJS((exports, module) => {
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  module.exports = arrayPush;
});

// node_modules/archiver-utils/node_modules/lodash/_isFlattenable.js
var require__isFlattenable = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  module.exports = isFlattenable;
});

// node_modules/archiver-utils/node_modules/lodash/_baseFlatten.js
var require__baseFlatten = __commonJS((exports, module) => {
  var arrayPush = require__arrayPush();
  var isFlattenable = require__isFlattenable();
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  module.exports = baseFlatten;
});

// node_modules/archiver-utils/node_modules/lodash/flatten.js
var require_flatten = __commonJS((exports, module) => {
  var baseFlatten = require__baseFlatten();
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }
  module.exports = flatten;
});

// node_modules/archiver-utils/node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/archiver-utils/node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  module.exports = hashClear;
});

// node_modules/archiver-utils/node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = hashDelete;
});

// node_modules/archiver-utils/node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  module.exports = hashGet;
});

// node_modules/archiver-utils/node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  module.exports = hashHas;
});

// node_modules/archiver-utils/node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  module.exports = hashSet;
});

// node_modules/archiver-utils/node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/archiver-utils/node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  module.exports = listCacheClear;
});

// node_modules/archiver-utils/node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var eq = require_eq();
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  module.exports = assocIndexOf;
});

// node_modules/archiver-utils/node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  module.exports = listCacheDelete;
});

// node_modules/archiver-utils/node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  module.exports = listCacheGet;
});

// node_modules/archiver-utils/node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  module.exports = listCacheHas;
});

// node_modules/archiver-utils/node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  module.exports = listCacheSet;
});

// node_modules/archiver-utils/node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/archiver-utils/node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/archiver-utils/node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  module.exports = mapCacheClear;
});

// node_modules/archiver-utils/node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  module.exports = isKeyable;
});

// node_modules/archiver-utils/node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var isKeyable = require__isKeyable();
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  module.exports = getMapData;
});

// node_modules/archiver-utils/node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = mapCacheDelete;
});

// node_modules/archiver-utils/node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  module.exports = mapCacheGet;
});

// node_modules/archiver-utils/node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  module.exports = mapCacheHas;
});

// node_modules/archiver-utils/node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  module.exports = mapCacheSet;
});

// node_modules/archiver-utils/node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/archiver-utils/node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  module.exports = setCacheAdd;
});

// node_modules/archiver-utils/node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  module.exports = setCacheHas;
});

// node_modules/archiver-utils/node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/archiver-utils/node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  module.exports = baseFindIndex;
});

// node_modules/archiver-utils/node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  function baseIsNaN(value) {
    return value !== value;
  }
  module.exports = baseIsNaN;
});

// node_modules/archiver-utils/node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  module.exports = strictIndexOf;
});

// node_modules/archiver-utils/node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  module.exports = baseIndexOf;
});

// node_modules/archiver-utils/node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var baseIndexOf = require__baseIndexOf();
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  module.exports = arrayIncludes;
});

// node_modules/archiver-utils/node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  module.exports = arrayIncludesWith;
});

// node_modules/archiver-utils/node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  module.exports = arrayMap;
});

// node_modules/archiver-utils/node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  module.exports = cacheHas;
});

// node_modules/archiver-utils/node_modules/lodash/_baseDifference.js
var require__baseDifference = __commonJS((exports, module) => {
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var arrayMap = require__arrayMap();
  var baseUnary = require__baseUnary();
  var cacheHas = require__cacheHas();
  var LARGE_ARRAY_SIZE = 200;
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee == null ? value : iteratee(value);
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  module.exports = baseDifference;
});

// node_modules/archiver-utils/node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS((exports, module) => {
  var isArrayLike = require_isArrayLike();
  var isObjectLike = require_isObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  module.exports = isArrayLikeObject;
});

// node_modules/archiver-utils/node_modules/lodash/difference.js
var require_difference = __commonJS((exports, module) => {
  var baseDifference = require__baseDifference();
  var baseFlatten = require__baseFlatten();
  var baseRest = require__baseRest();
  var isArrayLikeObject = require_isArrayLikeObject();
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });
  module.exports = difference;
});

// node_modules/archiver-utils/node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/archiver-utils/node_modules/lodash/noop.js
var require_noop = __commonJS((exports, module) => {
  function noop() {}
  module.exports = noop;
});

// node_modules/archiver-utils/node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  module.exports = setToArray;
});

// node_modules/archiver-utils/node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set();
  var noop = require_noop();
  var setToArray = require__setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// node_modules/archiver-utils/node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var cacheHas = require__cacheHas();
  var createSet = require__createSet();
  var setToArray = require__setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  module.exports = baseUniq;
});

// node_modules/archiver-utils/node_modules/lodash/union.js
var require_union = __commonJS((exports, module) => {
  var baseFlatten = require__baseFlatten();
  var baseRest = require__baseRest();
  var baseUniq = require__baseUniq();
  var isArrayLikeObject = require_isArrayLikeObject();
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  module.exports = union;
});

// node_modules/archiver-utils/node_modules/lodash/_overArg.js
var require__overArg = __commonJS((exports, module) => {
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  module.exports = overArg;
});

// node_modules/archiver-utils/node_modules/lodash/_getPrototype.js
var require__getPrototype = __commonJS((exports, module) => {
  var overArg = require__overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
});

// node_modules/archiver-utils/node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var getPrototype = require__getPrototype();
  var isObjectLike = require_isObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertValidPattern = undefined;
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  exports.assertValidPattern = assertValidPattern;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseClass = undefined;
  var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
    "[:alpha:]": ["\\p{L}\\p{Nl}", true],
    "[:ascii:]": ["\\x" + "00-\\x" + "7f", false],
    "[:blank:]": ["\\p{Zs}\\t", true],
    "[:cntrl:]": ["\\p{Cc}", true],
    "[:digit:]": ["\\p{Nd}", true],
    "[:graph:]": ["\\p{Z}\\p{C}", true, true],
    "[:lower:]": ["\\p{Ll}", true],
    "[:print:]": ["\\p{C}", true],
    "[:punct:]": ["\\p{P}", true],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
    "[:upper:]": ["\\p{Lu}", true],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
    "[:xdigit:]": ["A-Fa-f0-9", false]
  };
  var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
  var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var rangesToString = (ranges) => ranges.join("");
  var parseClass = (glob, position) => {
    const pos = position;
    if (glob.charAt(pos) !== "[") {
      throw new Error("not in a brace expression");
    }
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE:
      while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
    if (endPos < i) {
      return ["", false, 0, false];
    }
    if (!ranges.length && !negs.length) {
      return ["$.", false, glob.length - pos, true];
    }
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
    return [comb, uflag, endPos - pos, true];
  };
  exports.parseClass = parseClass;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unescape = undefined;
  var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  };
  exports.unescape = unescape;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AST = undefined;
  var brace_expressions_js_1 = require_brace_expressions();
  var unescape_js_1 = require_unescape();
  var types = new Set(["!", "?", "+", "*", "@"]);
  var isExtglobType = (c) => types.has(c);
  var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
  var startNoDot = "(?!\\.)";
  var addPatternStart = new Set(["[", "."]);
  var justDots = new Set(["..", "."]);
  var reSpecials = new Set("().*{}+?[]^$\\!");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var qmark = "[^/]";
  var star = qmark + "*?";
  var starNoEmpty = qmark + "+?";

  class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    #emptyExt = false;
    constructor(type, parent, options = {}) {
      this.type = type;
      if (type)
        this.#hasMagic = true;
      this.#parent = parent;
      this.#root = this.#parent ? this.#parent.#root : this;
      this.#options = this.#root === this ? options : this.#root.#options;
      this.#negs = this.#root === this ? [] : this.#root.#negs;
      if (type === "!" && !this.#root.#filledNegs)
        this.#negs.push(this);
      this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
      if (this.#hasMagic !== undefined)
        return this.#hasMagic;
      for (const p of this.#parts) {
        if (typeof p === "string")
          continue;
        if (p.type || p.hasMagic)
          return this.#hasMagic = true;
      }
      return this.#hasMagic;
    }
    toString() {
      if (this.#toString !== undefined)
        return this.#toString;
      if (!this.type) {
        return this.#toString = this.#parts.map((p) => String(p)).join("");
      } else {
        return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
      }
    }
    #fillNegs() {
      if (this !== this.#root)
        throw new Error("should only call on root");
      if (this.#filledNegs)
        return this;
      this.toString();
      this.#filledNegs = true;
      let n;
      while (n = this.#negs.pop()) {
        if (n.type !== "!")
          continue;
        let p = n;
        let pp = p.#parent;
        while (pp) {
          for (let i = p.#parentIndex + 1;!pp.type && i < pp.#parts.length; i++) {
            for (const part of n.#parts) {
              if (typeof part === "string") {
                throw new Error("string part in extglob AST??");
              }
              part.copyIn(pp.#parts[i]);
            }
          }
          p = pp;
          pp = p.#parent;
        }
      }
      return this;
    }
    push(...parts) {
      for (const p of parts) {
        if (p === "")
          continue;
        if (typeof p !== "string" && !(p instanceof AST && p.#parent === this)) {
          throw new Error("invalid part: " + p);
        }
        this.#parts.push(p);
      }
    }
    toJSON() {
      const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
      if (this.isStart() && !this.type)
        ret.unshift([]);
      if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
        ret.push({});
      }
      return ret;
    }
    isStart() {
      if (this.#root === this)
        return true;
      if (!this.#parent?.isStart())
        return false;
      if (this.#parentIndex === 0)
        return true;
      const p = this.#parent;
      for (let i = 0;i < this.#parentIndex; i++) {
        const pp = p.#parts[i];
        if (!(pp instanceof AST && pp.type === "!")) {
          return false;
        }
      }
      return true;
    }
    isEnd() {
      if (this.#root === this)
        return true;
      if (this.#parent?.type === "!")
        return true;
      if (!this.#parent?.isEnd())
        return false;
      if (!this.type)
        return this.#parent?.isEnd();
      const pl = this.#parent ? this.#parent.#parts.length : 0;
      return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
      if (typeof part === "string")
        this.push(part);
      else
        this.push(part.clone(this));
    }
    clone(parent) {
      const c = new AST(this.type, parent);
      for (const p of this.#parts) {
        c.copyIn(p);
      }
      return c;
    }
    static #parseAST(str, ast, pos, opt) {
      let escaping = false;
      let inBrace = false;
      let braceStart = -1;
      let braceNeg = false;
      if (ast.type === null) {
        let i2 = pos;
        let acc2 = "";
        while (i2 < str.length) {
          const c = str.charAt(i2++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc2 += c;
            continue;
          }
          if (inBrace) {
            if (i2 === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc2 += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i2;
            braceNeg = false;
            acc2 += c;
            continue;
          }
          if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
            ast.push(acc2);
            acc2 = "";
            const ext = new AST(c, ast);
            i2 = AST.#parseAST(str, ext, i2, opt);
            ast.push(ext);
            continue;
          }
          acc2 += c;
        }
        ast.push(acc2);
        return i2;
      }
      let i = pos + 1;
      let part = new AST(null, ast);
      const parts = [];
      let acc = "";
      while (i < str.length) {
        const c = str.charAt(i++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc += c;
          continue;
        }
        if (inBrace) {
          if (i === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i;
          braceNeg = false;
          acc += c;
          continue;
        }
        if (isExtglobType(c) && str.charAt(i) === "(") {
          part.push(acc);
          acc = "";
          const ext = new AST(c, part);
          part.push(ext);
          i = AST.#parseAST(str, ext, i, opt);
          continue;
        }
        if (c === "|") {
          part.push(acc);
          acc = "";
          parts.push(part);
          part = new AST(null, ast);
          continue;
        }
        if (c === ")") {
          if (acc === "" && ast.#parts.length === 0) {
            ast.#emptyExt = true;
          }
          part.push(acc);
          acc = "";
          ast.push(...parts, part);
          return i;
        }
        acc += c;
      }
      ast.type = null;
      ast.#hasMagic = undefined;
      ast.#parts = [str.substring(pos - 1)];
      return i;
    }
    static fromGlob(pattern, options = {}) {
      const ast = new AST(null, undefined, options);
      AST.#parseAST(pattern, ast, 0, options);
      return ast;
    }
    toMMPattern() {
      if (this !== this.#root)
        return this.#root.toMMPattern();
      const glob = this.toString();
      const [re, body, hasMagic, uflag] = this.toRegExpSource();
      const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
      if (!anyMagic) {
        return body;
      }
      const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob
      });
    }
    get options() {
      return this.#options;
    }
    toRegExpSource(allowDot) {
      const dot = allowDot ?? !!this.#options.dot;
      if (this.#root === this)
        this.#fillNegs();
      if (!this.type) {
        const noEmpty = this.isStart() && this.isEnd();
        const src = this.#parts.map((p) => {
          const [re, _2, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
          this.#hasMagic = this.#hasMagic || hasMagic;
          this.#uflag = this.#uflag || uflag;
          return re;
        }).join("");
        let start2 = "";
        if (this.isStart()) {
          if (typeof this.#parts[0] === "string") {
            const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
            if (!dotTravAllowed) {
              const aps = addPatternStart;
              const needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4));
              const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
        }
        let end = "";
        if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
          end = "(?:$|\\/)";
        }
        const final2 = start2 + src + end;
        return [
          final2,
          (0, unescape_js_1.unescape)(src),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      const repeated = this.type === "*" || this.type === "+";
      const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
      let body = this.#partsToRegExp(dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        const s = this.toString();
        this.#parts = [s];
        this.type = null;
        this.#hasMagic = undefined;
        return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
      if (bodyDotAllowed === body) {
        bodyDotAllowed = "";
      }
      if (bodyDotAllowed) {
        body = `(?:${body})(?:${bodyDotAllowed})*?`;
      }
      let final = "";
      if (this.type === "!" && this.#emptyExt) {
        final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
      } else {
        const close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
        final = start + body + close;
      }
      return [
        final,
        (0, unescape_js_1.unescape)(body),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    #partsToRegExp(dot) {
      return this.#parts.map((p) => {
        if (typeof p === "string") {
          throw new Error("string type in extglob ast??");
        }
        const [re, _2, _hasMagic, uflag] = p.toRegExpSource(dot);
        this.#uflag = this.#uflag || uflag;
        return re;
      }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
      let escaping = false;
      let re = "";
      let uflag = false;
      for (let i = 0;i < glob.length; i++) {
        const c = glob.charAt(i);
        if (escaping) {
          escaping = false;
          re += (reSpecials.has(c) ? "\\" : "") + c;
          continue;
        }
        if (c === "\\") {
          if (i === glob.length - 1) {
            re += "\\\\";
          } else {
            escaping = true;
          }
          continue;
        }
        if (c === "[") {
          const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
          if (consumed) {
            re += src;
            uflag = uflag || needUflag;
            i += consumed - 1;
            hasMagic = hasMagic || magic;
            continue;
          }
        }
        if (c === "*") {
          if (noEmpty && glob === "*")
            re += starNoEmpty;
          else
            re += star;
          hasMagic = true;
          continue;
        }
        if (c === "?") {
          re += qmark;
          hasMagic = true;
          continue;
        }
        re += regExpEscape(c);
      }
      return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
  }
  exports.AST = AST;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escape = undefined;
  var escape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
  };
  exports.escape = escape;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/index.js
var require_commonjs16 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = undefined;
  var brace_expansion_1 = __importDefault(require_brace_expansion());
  var assert_valid_pattern_js_1 = require_assert_valid_pattern();
  var ast_js_1 = require_ast();
  var escape_js_1 = require_escape();
  var unescape_js_1 = require_unescape();
  var minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  exports.minimatch = minimatch;
  var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
  var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
  var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
  var starDotExtTestNocase = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
  };
  var starDotExtTestNocaseDot = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext2);
  };
  var starDotStarRE = /^\*+\.\*+$/;
  var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
  var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
  var dotStarRE = /^\.\*+$/;
  var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
  var starRE = /^\*+$/;
  var starTest = (f) => f.length !== 0 && !f.startsWith(".");
  var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
  var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
  var qmarksTestNocase = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  };
  var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  };
  var qmarksTestDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  };
  var qmarksTest = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  };
  var qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith(".");
  };
  var qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== "." && f !== "..";
  };
  var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
  var path = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  exports.sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
  exports.minimatch.sep = exports.sep;
  exports.GLOBSTAR = Symbol("globstar **");
  exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
  exports.filter = filter;
  exports.minimatch.filter = exports.filter;
  var ext = (a, b = {}) => Object.assign({}, a, b);
  var defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
      Minimatch: class Minimatch2 extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class AST extends orig.AST {
        constructor(type, parent, options = {}) {
          super(type, parent, ext(def, options));
        }
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: (options) => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR: exports.GLOBSTAR
    });
  };
  exports.defaults = defaults;
  exports.minimatch.defaults = exports.defaults;
  var braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
  };
  exports.braceExpand = braceExpand;
  exports.minimatch.braceExpand = exports.braceExpand;
  var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
  exports.makeRe = makeRe;
  exports.minimatch.makeRe = exports.makeRe;
  var match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  exports.match = match;
  exports.minimatch.match = exports.match;
  var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

  class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      options = options || {};
      this.options = options;
      this.pattern = pattern;
      this.platform = options.platform || defaultPlatform;
      this.isWindows = this.platform === "win32";
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
      this.regexp = null;
      this.negate = false;
      this.nonegate = !!options.nonegate;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.nocase = !!this.options.nocase;
      this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
      this.globSet = [];
      this.globParts = [];
      this.set = [];
      this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) {
        return true;
      }
      for (const pattern of this.set) {
        for (const part of pattern) {
          if (typeof part !== "string")
            return true;
        }
      }
      return false;
    }
    debug(..._2) {}
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      this.globSet = [...new Set(this.braceExpand())];
      if (options.debug) {
        this.debug = (...args) => console.error(...args);
      }
      this.debug(this.pattern, this.globSet);
      const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts);
      this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _2, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
          const isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) {
            return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
          } else if (isDrive) {
            return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
          }
        }
        return s.map((ss) => this.parse(ss));
      });
      this.debug(this.pattern, set);
      this.set = set.filter((s) => s.indexOf(false) === -1);
      if (this.isWindows) {
        for (let i = 0;i < this.set.length; i++) {
          const p = this.set[i];
          if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
            p[2] = "?";
          }
        }
      }
      this.debug(this.pattern, this.set);
    }
    preprocess(globParts) {
      if (this.options.noglobstar) {
        for (let i = 0;i < globParts.length; i++) {
          for (let j = 0;j < globParts[i].length; j++) {
            if (globParts[i][j] === "**") {
              globParts[i][j] = "*";
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        globParts = this.firstPhasePreProcess(globParts);
        globParts = this.secondPhasePreProcess(globParts);
      } else if (optimizationLevel >= 1) {
        globParts = this.levelOneOptimize(globParts);
      } else {
        globParts = this.adjascentGlobstarOptimize(globParts);
      }
      return globParts;
    }
    adjascentGlobstarOptimize(globParts) {
      return globParts.map((parts) => {
        let gs = -1;
        while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
          let i = gs;
          while (parts[i + 1] === "**") {
            i++;
          }
          if (i !== gs) {
            parts.splice(gs, i - gs);
          }
        }
        return parts;
      });
    }
    levelOneOptimize(globParts) {
      return globParts.map((parts) => {
        parts = parts.reduce((set, part) => {
          const prev = set[set.length - 1];
          if (part === "**" && prev === "**") {
            return set;
          }
          if (part === "..") {
            if (prev && prev !== ".." && prev !== "." && prev !== "**") {
              set.pop();
              return set;
            }
          }
          set.push(part);
          return set;
        }, []);
        return parts.length === 0 ? [""] : parts;
      });
    }
    levelTwoFileOptimize(parts) {
      if (!Array.isArray(parts)) {
        parts = this.slashSplit(parts);
      }
      let didSomething = false;
      do {
        didSomething = false;
        if (!this.preserveMultipleSlashes) {
          for (let i = 1;i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            parts.splice(dd - 1, 2);
            dd -= 2;
          }
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    firstPhasePreProcess(globParts) {
      let didSomething = false;
      do {
        didSomething = false;
        for (let parts of globParts) {
          let gs = -1;
          while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
            let gss = gs;
            while (parts[gss + 1] === "**") {
              gss++;
            }
            if (gss > gs) {
              parts.splice(gs + 1, gss - gs);
            }
            let next = parts[gs + 1];
            const p = parts[gs + 2];
            const p2 = parts[gs + 3];
            if (next !== "..")
              continue;
            if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
              continue;
            }
            didSomething = true;
            parts.splice(gs, 1);
            const other = parts.slice(0);
            other[gs] = "**";
            globParts.push(other);
            gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1;i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              const needDot = dd === 1 && parts[dd + 1] === "**";
              const splin = needDot ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin);
              if (parts.length === 0)
                parts.push("");
              dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    secondPhasePreProcess(globParts) {
      for (let i = 0;i < globParts.length - 1; i++) {
        for (let j = i + 1;j < globParts.length; j++) {
          const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
          if (matched) {
            globParts[i] = [];
            globParts[j] = matched;
            break;
          }
        }
      }
      return globParts.filter((gs) => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
      let ai = 0;
      let bi = 0;
      let result = [];
      let which = "";
      while (ai < a.length && bi < b.length) {
        if (a[ai] === b[bi]) {
          result.push(which === "b" ? b[bi] : a[ai]);
          ai++;
          bi++;
        } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
          result.push(a[ai]);
          ai++;
        } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
          result.push(b[bi]);
          bi++;
        } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
          if (which === "b")
            return false;
          which = "a";
          result.push(a[ai]);
          ai++;
          bi++;
        } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
          if (which === "a")
            return false;
          which = "b";
          result.push(b[bi]);
          ai++;
          bi++;
        } else {
          return false;
        }
      }
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    matchOne(file, pattern, partial = false) {
      const options = this.options;
      if (this.isWindows) {
        const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
        const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
        const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
        const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
        const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
        const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
        if (typeof fdi === "number" && typeof pdi === "number") {
          const [fd, pd] = [file[fdi], pattern[pdi]];
          if (fd.toLowerCase() === pd.toLowerCase()) {
            pattern[pdi] = fd;
            if (pdi > fdi) {
              pattern = pattern.slice(pdi);
            } else if (fdi > pdi) {
              file = file.slice(fdi);
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        file = this.levelTwoFileOptimize(file);
      }
      this.debug("matchOne", this, { file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) {
          return false;
        }
        if (p === exports.GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (;fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
            if (fr === fl) {
              return true;
            }
          }
          return false;
        }
        let hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = p.test(f);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      } else {
        throw new Error("wtf?");
      }
    }
    braceExpand() {
      return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      const options = this.options;
      if (pattern === "**")
        return exports.GLOBSTAR;
      if (pattern === "")
        return "";
      let m;
      let fastTest = null;
      if (m = pattern.match(starRE)) {
        fastTest = options.dot ? starTestDot : starTest;
      } else if (m = pattern.match(starDotExtRE)) {
        fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
      } else if (m = pattern.match(qmarksRE)) {
        fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
      } else if (m = pattern.match(starDotStarRE)) {
        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
      } else if (m = pattern.match(dotStarRE)) {
        fastTest = dotStarTest;
      }
      const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
      if (fastTest && typeof re === "object") {
        Reflect.defineProperty(re, "test", { value: fastTest });
      }
      return re;
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      const flags = new Set(options.nocase ? ["i"] : []);
      let re = set.map((pattern) => {
        const pp = pattern.map((p) => {
          if (p instanceof RegExp) {
            for (const f of p.flags.split(""))
              flags.add(f);
          }
          return typeof p === "string" ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;
        });
        pp.forEach((p, i) => {
          const next = pp[i + 1];
          const prev = pp[i - 1];
          if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
            return;
          }
          if (prev === undefined) {
            if (next !== undefined && next !== exports.GLOBSTAR) {
              pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
            } else {
              pp[i] = twoStar;
            }
          } else if (next === undefined) {
            pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
          } else if (next !== exports.GLOBSTAR) {
            pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
            pp[i + 1] = exports.GLOBSTAR;
          }
        });
        return pp.filter((p) => p !== exports.GLOBSTAR).join("/");
      }).join("|");
      const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$";
      if (this.negate)
        re = "^(?!" + re + ").+$";
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(p) {
      if (this.preserveMultipleSlashes) {
        return p.split("/");
      } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
        return ["", ...p.split(/\/+/)];
      } else {
        return p.split(/\/+/);
      }
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment) {
        return false;
      }
      if (this.empty) {
        return f === "";
      }
      if (f === "/" && partial) {
        return true;
      }
      const options = this.options;
      if (this.isWindows) {
        f = f.split("\\").join("/");
      }
      const ff = this.slashSplit(f);
      this.debug(this.pattern, "split", ff);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename) {
        for (let i = ff.length - 2;!filename && i >= 0; i--) {
          filename = ff[i];
        }
      }
      for (let i = 0;i < set.length; i++) {
        const pattern = set[i];
        let file = ff;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) {
            return true;
          }
          return !this.negate;
        }
      }
      if (options.flipNegate) {
        return false;
      }
      return this.negate;
    }
    static defaults(def) {
      return exports.minimatch.defaults(def).Minimatch;
    }
  }
  exports.Minimatch = Minimatch;
  var ast_js_2 = require_ast();
  Object.defineProperty(exports, "AST", { enumerable: true, get: function() {
    return ast_js_2.AST;
  } });
  var escape_js_2 = require_escape();
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  var unescape_js_2 = require_unescape();
  Object.defineProperty(exports, "unescape", { enumerable: true, get: function() {
    return unescape_js_2.unescape;
  } });
  exports.minimatch.AST = ast_js_1.AST;
  exports.minimatch.Minimatch = Minimatch;
  exports.minimatch.escape = escape_js_1.escape;
  exports.minimatch.unescape = unescape_js_1.unescape;
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LRUCache = undefined;
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var warned = new Set;
  var PROCESS = typeof process === "object" && !!process ? process : {};
  var emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
  };
  var AC = globalThis.AbortController;
  var AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal2 {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_2, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController2 {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS;
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in " + "node 14, load an AbortController polyfill from the " + "`node-abort-controller` package. A minimal polyfill is " + "provided for use by LRUCache.fetch(), but it should not be " + "relied upon in other contexts (eg, passing it to other APIs that " + "use AbortController/AbortSignal might have undesirable effects). " + "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  var shouldWarn = (code) => !warned.has(code);
  var TYPE = Symbol("type");
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

  class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  }

  class Stack {
    heap;
    length;
    static #constructing = false;
    static create(max) {
      const HeapCls = getUintArray(max);
      if (!HeapCls)
        return [];
      Stack.#constructing = true;
      const s = new Stack(max, HeapCls);
      Stack.#constructing = false;
      return s;
    }
    constructor(max, HeapCls) {
      if (!Stack.#constructing) {
        throw new TypeError("instantiate Stack using Stack.create(n)");
      }
      this.heap = new HeapCls(max);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  }

  class LRUCache {
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    ttl;
    ttlResolution;
    ttlAutopurge;
    updateAgeOnGet;
    updateAgeOnHas;
    allowStale;
    noDisposeOnSet;
    noUpdateTTL;
    maxEntrySize;
    sizeCalculation;
    noDeleteOnFetchRejection;
    noDeleteOnStaleGet;
    allowStaleOnFetchAbort;
    allowStaleOnFetchRejection;
    ignoreFetchAbort;
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    static unsafeExposeInternals(c) {
      return {
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options) => c.#indexes(options),
        rindexes: (options) => c.#rindexes(options),
        isStale: (index) => c.#isStale(index)
      };
    }
    get max() {
      return this.#max;
    }
    get maxSize() {
      return this.#maxSize;
    }
    get calculatedSize() {
      return this.#calculatedSize;
    }
    get size() {
      return this.#size;
    }
    get fetchMethod() {
      return this.#fetchMethod;
    }
    get memoMethod() {
      return this.#memoMethod;
    }
    get dispose() {
      return this.#dispose;
    }
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options) {
      const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.#max = max;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (memoMethod !== undefined && typeof memoMethod !== "function") {
        throw new TypeError("memoMethod must be a function if defined");
      }
      this.#memoMethod = memoMethod;
      if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = new Map;
      this.#keyList = new Array(max).fill(undefined);
      this.#valList = new Array(max).fill(undefined);
      this.#next = new UintArray(max);
      this.#prev = new UintArray(max);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = undefined;
        this.#disposed = undefined;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.#keyMap.get(key);
        if (index === undefined) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      };
    }
    #updateItemAge = () => {};
    #statusTTL = () => {};
    #setItemTTL = () => {};
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation " + "or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {};
    #addItemSize = (_i, _s, _st) => {};
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.toStringTag] = "LRUCache";
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], "expire");
          deleted = true;
        }
      }
      return deleted;
    }
    info(key) {
      const i = this.#keyMap.get(key);
      if (i === undefined)
        return;
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        return;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i];
        const start = this.#starts[i];
        if (ttl && start) {
          const remain = ttl - (perf.now() - start);
          entry.ttl = remain;
          entry.start = Date.now();
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      return entry;
    }
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined || key === undefined)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    set(k, v, setOptions = {}) {
      if (v === undefined) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.#delete(k, "set");
        return this;
      }
      let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
      if (index === undefined) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: s } = oldVal;
            if (s !== undefined && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s, k, "set"]);
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== undefined)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== undefined) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (free) {
        this.#keyList[head] = undefined;
        this.#valList[head] = undefined;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index === undefined || !allowStale && this.#isStale(index)) {
        return;
      }
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
      const v = index === undefined ? undefined : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (this.#valList[index] === p) {
          if (v2 === undefined) {
            if (bf2.__staleWhileFetching) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.#delete(k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === undefined;
          if (del) {
            this.#delete(k, "fetch");
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== undefined) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(undefined);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: undefined
      });
      if (index === undefined) {
        this.set(k, bf, { ...fetchOpts.options, status: undefined });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === undefined) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options, context);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== undefined;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options, context);
        const hasStale = p.__staleWhileFetching !== undefined;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions);
      if (v === undefined)
        throw new Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod;
      if (!memoMethod) {
        throw new Error("no memoMethod provided to constructor");
      }
      const { context, forceRefresh, ...options } = memoOptions;
      const v = this.get(k, options);
      if (!forceRefresh && v !== undefined)
        return v;
      const vv = memoMethod(k, v, {
        options,
        context
      });
      this.set(k, vv, options);
      return vv;
    }
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, "expire");
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : undefined;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== undefined) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    delete(k) {
      return this.#delete(k, "delete");
    }
    #delete(k, reason) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
          deleted = true;
          if (this.#size === 1) {
            this.#clear(reason);
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = undefined;
            this.#valList[index] = undefined;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              const pi = this.#prev[index];
              this.#next[pi] = this.#next[index];
              const ni = this.#next[index];
              this.#prev[ni] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    clear() {
      return this.#clear("delete");
    }
    #clear(reason) {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason);
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(undefined);
      this.#keyList.fill(undefined);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  exports.LRUCache = LRUCache;
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs18 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = undefined;
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var node_events_1 = __require("node:events");
  var node_stream_1 = __importDefault(__require("node:stream"));
  var node_string_decoder_1 = __require("node:string_decoder");
  var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));
  exports.isStream = isStream;
  var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && s.pipe !== node_stream_1.default.Writable.prototype.pipe;
  exports.isReadable = isReadable;
  var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
  exports.isWritable = isWritable;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var DATALISTENERS = Symbol("dataListeners");
  var DISCARDED = Symbol("discarded");
  var defer = (fn) => Promise.resolve().then(fn);
  var nodefer = (fn) => fn();
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      this.dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors(_er) {}
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }
  var isObjectModeOptions = (o) => !!o.objectMode;
  var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";

  class Minipass extends node_events_1.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    writable = true;
    readable = true;
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions(options)) {
        this[OBJECTMODE] = true;
        this[ENCODING] = null;
      } else if (isEncodingOptions(options)) {
        this[ENCODING] = options.encoding;
        this[OBJECTMODE] = false;
      } else {
        this[OBJECTMODE] = false;
        this[ENCODING] = null;
      }
      this[ASYNC] = !!options.async;
      this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL] = signal;
        if (signal.aborted) {
          this[ABORT]();
        } else {
          signal.addEventListener("abort", () => this[ABORT]());
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL]?.reason);
      this.destroy(this[SIGNAL]?.reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_2) {}
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : nodefer;
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE]) {
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING]) {
        chunk = this[DECODER].write(chunk);
      }
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      this[DISCARDED] = false;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ];
      }
      const ret = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (this[OBJECTMODE])
        this[BUFFERSHIFT]();
      else {
        const c = chunk;
        if (n === c.length || n === null)
          this[BUFFERSHIFT]();
        else if (typeof c === "string") {
          this[BUFFER][0] = c.slice(n);
          chunk = c.slice(0, n);
          this[BUFFERLENGTH] -= n;
        } else {
          this[BUFFER][0] = c.subarray(n);
          chunk = c.subarray(0, n);
          this[BUFFERLENGTH] -= n;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== undefined)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this[FLOWING] || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      if (!this[DATALISTENERS] && !this[PIPES].length) {
        this[DISCARDED] = true;
      }
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
      this[DISCARDED] = false;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this[FLOWING];
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return dest;
      this[DISCARDED] = false;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES].length === 1) {
          if (this[FLOWING] && this[DATALISTENERS] === 0) {
            this[FLOWING] = false;
          }
          this[PIPES] = [];
        } else
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    on(ev, handler) {
      const ret = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED] = false;
        this[DATALISTENERS]++;
        if (!this[PIPES].length && !this[FLOWING]) {
          this[RESUME]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
        super.emit("readable");
      } else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        const h = handler;
        if (this[ASYNC])
          defer(() => h.call(this, this[EMITTED_ERROR]));
        else
          h.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    off(ev, handler) {
      const ret = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS] = this.listeners("data").length;
        if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    removeAllListeners(ev) {
      const ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === undefined) {
        this[DATALISTENERS] = 0;
        if (!this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return false;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, ...args);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = this[DISCARDED] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return false;
      this[EMITTED_END] = true;
      this.readable = false;
      return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      await p;
      return buf;
    }
    async concat() {
      if (this[OBJECTMODE]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    async promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [Symbol.asyncIterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: undefined, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED, ondestroy);
          stop();
          resolve({ done: true, value: undefined });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    [Symbol.iterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR, stop);
        this.off(DESTROYED, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: undefined };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[DISCARDED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static get isStream() {
      return exports.isStream;
    }
  }
  exports.Minipass = Minipass;
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs19 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = undefined;
  var lru_cache_1 = require_commonjs17();
  var node_path_1 = __require("node:path");
  var node_url_1 = __require("node:url");
  var fs_1 = __require("fs");
  var actualFS = __importStar(__require("node:fs"));
  var realpathSync = fs_1.realpathSync.native;
  var promises_1 = __require("node:fs/promises");
  var minipass_1 = require_commonjs18();
  var defaultFS = {
    lstatSync: fs_1.lstatSync,
    readdir: fs_1.readdir,
    readdirSync: fs_1.readdirSync,
    readlinkSync: fs_1.readlinkSync,
    realpathSync,
    promises: {
      lstat: promises_1.lstat,
      readdir: promises_1.readdir,
      readlink: promises_1.readlink,
      realpath: promises_1.realpath
    }
  };
  var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
    ...defaultFS,
    ...fsOption,
    promises: {
      ...defaultFS.promises,
      ...fsOption.promises || {}
    }
  };
  var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
  var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
  var eitherSep = /[\\\/]/;
  var UNKNOWN = 0;
  var IFIFO = 1;
  var IFCHR = 2;
  var IFDIR = 4;
  var IFBLK = 6;
  var IFREG = 8;
  var IFLNK = 10;
  var IFSOCK = 12;
  var IFMT = 15;
  var IFMT_UNKNOWN = ~IFMT;
  var READDIR_CALLED = 16;
  var LSTAT_CALLED = 32;
  var ENOTDIR = 64;
  var ENOENT = 128;
  var ENOREADLINK = 256;
  var ENOREALPATH = 512;
  var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
  var TYPEMASK = 1023;
  var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
  var normalizeCache = new Map;
  var normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
      return c;
    const n = s.normalize("NFKD");
    normalizeCache.set(s, n);
    return n;
  };
  var normalizeNocaseCache = new Map;
  var normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
      return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
  };

  class ResolveCache extends lru_cache_1.LRUCache {
    constructor() {
      super({ max: 256 });
    }
  }
  exports.ResolveCache = ResolveCache;

  class ChildrenCache extends lru_cache_1.LRUCache {
    constructor(maxSize = 16 * 1024) {
      super({
        maxSize,
        sizeCalculation: (a) => a.length + 1
      });
    }
  }
  exports.ChildrenCache = ChildrenCache;
  var setAsCwd = Symbol("PathScurry setAsCwd");

  class PathBase {
    name;
    root;
    roots;
    parent;
    nocase;
    isCWD = false;
    #fs;
    #dev;
    get dev() {
      return this.#dev;
    }
    #mode;
    get mode() {
      return this.#mode;
    }
    #nlink;
    get nlink() {
      return this.#nlink;
    }
    #uid;
    get uid() {
      return this.#uid;
    }
    #gid;
    get gid() {
      return this.#gid;
    }
    #rdev;
    get rdev() {
      return this.#rdev;
    }
    #blksize;
    get blksize() {
      return this.#blksize;
    }
    #ino;
    get ino() {
      return this.#ino;
    }
    #size;
    get size() {
      return this.#size;
    }
    #blocks;
    get blocks() {
      return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
      return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
      return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
      return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
      return this.#birthtimeMs;
    }
    #atime;
    get atime() {
      return this.#atime;
    }
    #mtime;
    get mtime() {
      return this.#mtime;
    }
    #ctime;
    get ctime() {
      return this.#ctime;
    }
    #birthtime;
    get birthtime() {
      return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    get parentPath() {
      return (this.parent || this).fullpath();
    }
    get path() {
      return this.parentPath;
    }
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      this.name = name;
      this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
      this.#type = type & TYPEMASK;
      this.nocase = nocase;
      this.roots = roots;
      this.root = root || this;
      this.#children = children;
      this.#fullpath = opts.fullpath;
      this.#relative = opts.relative;
      this.#relativePosix = opts.relativePosix;
      this.parent = opts.parent;
      if (this.parent) {
        this.#fs = this.parent.#fs;
      } else {
        this.#fs = fsFromOption(opts.fs);
      }
    }
    depth() {
      if (this.#depth !== undefined)
        return this.#depth;
      if (!this.parent)
        return this.#depth = 0;
      return this.#depth = this.parent.depth() + 1;
    }
    childrenCache() {
      return this.#children;
    }
    resolve(path) {
      if (!path) {
        return this;
      }
      const rootPath = this.getRootString(path);
      const dir = path.substring(rootPath.length);
      const dirParts = dir.split(this.splitSep);
      const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
      return result;
    }
    #resolveParts(dirParts) {
      let p = this;
      for (const part of dirParts) {
        p = p.child(part);
      }
      return p;
    }
    children() {
      const cached = this.#children.get(this);
      if (cached) {
        return cached;
      }
      const children = Object.assign([], { provisional: 0 });
      this.#children.set(this, children);
      this.#type &= ~READDIR_CALLED;
      return children;
    }
    child(pathPart, opts) {
      if (pathPart === "" || pathPart === ".") {
        return this;
      }
      if (pathPart === "..") {
        return this.parent || this;
      }
      const children = this.children();
      const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
      for (const p of children) {
        if (p.#matchName === name) {
          return p;
        }
      }
      const s = this.parent ? this.sep : "";
      const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
      const pchild = this.newChild(pathPart, UNKNOWN, {
        ...opts,
        parent: this,
        fullpath
      });
      if (!this.canReaddir()) {
        pchild.#type |= ENOENT;
      }
      children.push(pchild);
      return pchild;
    }
    relative() {
      if (this.isCWD)
        return "";
      if (this.#relative !== undefined) {
        return this.#relative;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relative = this.name;
      }
      const pv = p.relative();
      return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    relativePosix() {
      if (this.sep === "/")
        return this.relative();
      if (this.isCWD)
        return "";
      if (this.#relativePosix !== undefined)
        return this.#relativePosix;
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relativePosix = this.fullpathPosix();
      }
      const pv = p.relativePosix();
      return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    fullpath() {
      if (this.#fullpath !== undefined) {
        return this.#fullpath;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#fullpath = this.name;
      }
      const pv = p.fullpath();
      const fp = pv + (!p.parent ? "" : this.sep) + name;
      return this.#fullpath = fp;
    }
    fullpathPosix() {
      if (this.#fullpathPosix !== undefined)
        return this.#fullpathPosix;
      if (this.sep === "/")
        return this.#fullpathPosix = this.fullpath();
      if (!this.parent) {
        const p2 = this.fullpath().replace(/\\/g, "/");
        if (/^[a-z]:\//i.test(p2)) {
          return this.#fullpathPosix = `//?/${p2}`;
        } else {
          return this.#fullpathPosix = p2;
        }
      }
      const p = this.parent;
      const pfpp = p.fullpathPosix();
      const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
      return this.#fullpathPosix = fpp;
    }
    isUnknown() {
      return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
      return this[`is${type}`]();
    }
    getType() {
      return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : this.isSocket() ? "Socket" : "Unknown";
    }
    isFile() {
      return (this.#type & IFMT) === IFREG;
    }
    isDirectory() {
      return (this.#type & IFMT) === IFDIR;
    }
    isCharacterDevice() {
      return (this.#type & IFMT) === IFCHR;
    }
    isBlockDevice() {
      return (this.#type & IFMT) === IFBLK;
    }
    isFIFO() {
      return (this.#type & IFMT) === IFIFO;
    }
    isSocket() {
      return (this.#type & IFMT) === IFSOCK;
    }
    isSymbolicLink() {
      return (this.#type & IFLNK) === IFLNK;
    }
    lstatCached() {
      return this.#type & LSTAT_CALLED ? this : undefined;
    }
    readlinkCached() {
      return this.#linkTarget;
    }
    realpathCached() {
      return this.#realpath;
    }
    readdirCached() {
      const children = this.children();
      return children.slice(0, children.provisional);
    }
    canReadlink() {
      if (this.#linkTarget)
        return true;
      if (!this.parent)
        return false;
      const ifmt = this.#type & IFMT;
      return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    calledReaddir() {
      return !!(this.#type & READDIR_CALLED);
    }
    isENOENT() {
      return !!(this.#type & ENOENT);
    }
    isNamed(n) {
      return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    async readlink() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return;
      }
      if (!this.parent) {
        return;
      }
      try {
        const read = await this.#fs.promises.readlink(this.fullpath());
        const linkTarget = (await this.parent.realpath())?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
    }
    readlinkSync() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return;
      }
      if (!this.parent) {
        return;
      }
      try {
        const read = this.#fs.readlinkSync(this.fullpath());
        const linkTarget = this.parent.realpathSync()?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
    }
    #readdirSuccess(children) {
      this.#type |= READDIR_CALLED;
      for (let p = children.provisional;p < children.length; p++) {
        const c = children[p];
        if (c)
          c.#markENOENT();
      }
    }
    #markENOENT() {
      if (this.#type & ENOENT)
        return;
      this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
      this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
      const children = this.children();
      children.provisional = 0;
      for (const p of children) {
        p.#markENOENT();
      }
    }
    #markENOREALPATH() {
      this.#type |= ENOREALPATH;
      this.#markENOTDIR();
    }
    #markENOTDIR() {
      if (this.#type & ENOTDIR)
        return;
      let t = this.#type;
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      this.#type = t | ENOTDIR;
      this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
      if (code === "ENOTDIR" || code === "EPERM") {
        this.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      } else {
        this.children().provisional = 0;
      }
    }
    #lstatFail(code = "") {
      if (code === "ENOTDIR") {
        const p = this.parent;
        p.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      }
    }
    #readlinkFail(code = "") {
      let ter = this.#type;
      ter |= ENOREADLINK;
      if (code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN") {
        ter &= IFMT_UNKNOWN;
      }
      this.#type = ter;
      if (code === "ENOTDIR" && this.parent) {
        this.parent.#markENOTDIR();
      }
    }
    #readdirAddChild(e, c) {
      return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
      const type = entToType(e);
      const child = this.newChild(e.name, type, { parent: this });
      const ifmt = child.#type & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
        child.#type |= ENOTDIR;
      }
      c.unshift(child);
      c.provisional++;
      return child;
    }
    #readdirMaybePromoteChild(e, c) {
      for (let p = c.provisional;p < c.length; p++) {
        const pchild = c[p];
        const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
        if (name !== pchild.#matchName) {
          continue;
        }
        return this.#readdirPromoteChild(e, pchild, p, c);
      }
    }
    #readdirPromoteChild(e, p, index, c) {
      const v = p.name;
      p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
      if (v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      c.provisional++;
      return p;
    }
    async lstat() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    lstatSync() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(this.#fs.lstatSync(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    #applyStat(st) {
      const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      this.#atime = atime;
      this.#atimeMs = atimeMs;
      this.#birthtime = birthtime;
      this.#birthtimeMs = birthtimeMs;
      this.#blksize = blksize;
      this.#blocks = blocks;
      this.#ctime = ctime;
      this.#ctimeMs = ctimeMs;
      this.#dev = dev;
      this.#gid = gid;
      this.#ino = ino;
      this.#mode = mode;
      this.#mtime = mtime;
      this.#mtimeMs = mtimeMs;
      this.#nlink = nlink;
      this.#rdev = rdev;
      this.#size = size;
      this.#uid = uid;
      const ifmt = entToType(st);
      this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
      if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
        this.#type |= ENOTDIR;
      }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
      this.#readdirCBInFlight = false;
      const cbs = this.#onReaddirCB.slice();
      this.#onReaddirCB.length = 0;
      cbs.forEach((cb) => cb(null, children));
    }
    readdirCB(cb, allowZalgo = false) {
      if (!this.canReaddir()) {
        if (allowZalgo)
          cb(null, []);
        else
          queueMicrotask(() => cb(null, []));
        return;
      }
      const children = this.children();
      if (this.calledReaddir()) {
        const c = children.slice(0, children.provisional);
        if (allowZalgo)
          cb(null, c);
        else
          queueMicrotask(() => cb(null, c));
        return;
      }
      this.#onReaddirCB.push(cb);
      if (this.#readdirCBInFlight) {
        return;
      }
      this.#readdirCBInFlight = true;
      const fullpath = this.fullpath();
      this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
        if (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        } else {
          for (const e of entries) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        }
        this.#callOnReaddirCB(children.slice(0, children.provisional));
        return;
      });
    }
    #asyncReaddirInFlight;
    async readdir() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      if (this.#asyncReaddirInFlight) {
        await this.#asyncReaddirInFlight;
      } else {
        let resolve = () => {};
        this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
        try {
          for (const e of await this.#fs.promises.readdir(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        this.#asyncReaddirInFlight = undefined;
        resolve();
      }
      return children.slice(0, children.provisional);
    }
    readdirSync() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      try {
        for (const e of this.#fs.readdirSync(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      return children.slice(0, children.provisional);
    }
    canReaddir() {
      if (this.#type & ENOCHILD)
        return false;
      const ifmt = IFMT & this.#type;
      if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
        return false;
      }
      return true;
    }
    shouldWalk(dirs, walkFilter) {
      return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    async realpath() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return;
      try {
        const rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_2) {
        this.#markENOREALPATH();
      }
    }
    realpathSync() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return;
      try {
        const rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_2) {
        this.#markENOREALPATH();
      }
    }
    [setAsCwd](oldCwd) {
      if (oldCwd === this)
        return;
      oldCwd.isCWD = false;
      this.isCWD = true;
      const changed = new Set([]);
      let rp = [];
      let p = this;
      while (p && p.parent) {
        changed.add(p);
        p.#relative = rp.join(this.sep);
        p.#relativePosix = rp.join("/");
        p = p.parent;
        rp.push("..");
      }
      p = oldCwd;
      while (p && p.parent && !changed.has(p)) {
        p.#relative = undefined;
        p.#relativePosix = undefined;
        p = p.parent;
      }
    }
  }
  exports.PathBase = PathBase;

  class PathWin32 extends PathBase {
    sep = "\\";
    splitSep = eitherSep;
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type, root, roots, nocase, children, opts);
    }
    newChild(name, type = UNKNOWN, opts = {}) {
      return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    getRootString(path) {
      return node_path_1.win32.parse(path).root;
    }
    getRoot(rootPath) {
      rootPath = uncToDrive(rootPath.toUpperCase());
      if (rootPath === this.root.name) {
        return this.root;
      }
      for (const [compare, root] of Object.entries(this.roots)) {
        if (this.sameRoot(rootPath, compare)) {
          return this.roots[rootPath] = root;
        }
      }
      return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    sameRoot(rootPath, compare = this.root.name) {
      rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
      return rootPath === compare;
    }
  }
  exports.PathWin32 = PathWin32;

  class PathPosix extends PathBase {
    splitSep = "/";
    sep = "/";
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type, root, roots, nocase, children, opts);
    }
    getRootString(path) {
      return path.startsWith("/") ? "/" : "";
    }
    getRoot(_rootPath) {
      return this.root;
    }
    newChild(name, type = UNKNOWN, opts = {}) {
      return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
  }
  exports.PathPosix = PathPosix;

  class PathScurryBase {
    root;
    rootPath;
    roots;
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    nocase;
    #fs;
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}) {
      this.#fs = fsFromOption(fs);
      if (cwd instanceof URL || cwd.startsWith("file://")) {
        cwd = (0, node_url_1.fileURLToPath)(cwd);
      }
      const cwdPath = pathImpl.resolve(cwd);
      this.roots = Object.create(null);
      this.rootPath = this.parseRootPath(cwdPath);
      this.#resolveCache = new ResolveCache;
      this.#resolvePosixCache = new ResolveCache;
      this.#children = new ChildrenCache(childrenCacheSize);
      const split = cwdPath.substring(this.rootPath.length).split(sep);
      if (split.length === 1 && !split[0]) {
        split.pop();
      }
      if (nocase === undefined) {
        throw new TypeError("must provide nocase setting to PathScurryBase ctor");
      }
      this.nocase = nocase;
      this.root = this.newRoot(this.#fs);
      this.roots[this.rootPath] = this.root;
      let prev = this.root;
      let len = split.length - 1;
      const joinSep = pathImpl.sep;
      let abs = this.rootPath;
      let sawFirst = false;
      for (const part of split) {
        const l = len--;
        prev = prev.child(part, {
          relative: new Array(l).fill("..").join(joinSep),
          relativePosix: new Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        });
        sawFirst = true;
      }
      this.cwd = prev;
    }
    depth(path = this.cwd) {
      if (typeof path === "string") {
        path = this.cwd.resolve(path);
      }
      return path.depth();
    }
    childrenCache() {
      return this.#children;
    }
    resolve(...paths) {
      let r = "";
      for (let i = paths.length - 1;i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolveCache.get(r);
      if (cached !== undefined) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpath();
      this.#resolveCache.set(r, result);
      return result;
    }
    resolvePosix(...paths) {
      let r = "";
      for (let i = paths.length - 1;i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolvePosixCache.get(r);
      if (cached !== undefined) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpathPosix();
      this.#resolvePosixCache.set(r, result);
      return result;
    }
    relative(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relative();
    }
    relativePosix(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relativePosix();
    }
    basename(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.name;
    }
    dirname(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else {
        const p = await entry.readdir();
        return withFileTypes ? p : p.map((e) => e.name);
      }
    }
    readdirSync(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else if (withFileTypes) {
        return entry.readdirSync();
      } else {
        return entry.readdirSync().map((e) => e.name);
      }
    }
    async lstat(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstat();
    }
    lstatSync(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.readlink();
      return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.readlinkSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.realpath();
      return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.realpathSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
      const results = [];
      if (!filter || filter(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = new Set;
      const walk = (dir, cb) => {
        dirs.add(dir);
        dir.readdirCB((er, entries) => {
          if (er) {
            return cb(er);
          }
          let len = entries.length;
          if (!len)
            return cb();
          const next = () => {
            if (--len === 0) {
              cb();
            }
          };
          for (const e of entries) {
            if (!filter || filter(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            if (follow && e.isSymbolicLink()) {
              e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
            } else {
              if (e.shouldWalk(dirs, walkFilter)) {
                walk(e, next);
              } else {
                next();
              }
            }
          }
        }, true);
      };
      const start = entry;
      return new Promise((res, rej) => {
        walk(start, (er) => {
          if (er)
            return rej(er);
          res(results);
        });
      });
    }
    walkSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
      const results = [];
      if (!filter || filter(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter || filter(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
      return results;
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        options = entry;
        entry = this.cwd;
      }
      return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
      if (!filter || filter(entry)) {
        yield withFileTypes ? entry : entry.fullpath();
      }
      const dirs = new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter || filter(e)) {
            yield withFileTypes ? e : e.fullpath();
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
    }
    stream(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
      const results = new minipass_1.Minipass({ objectMode: true });
      if (!filter || filter(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = new Set;
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const onReaddir = (er, entries, didRealpaths = false) => {
            if (er)
              return results.emit("error", er);
            if (follow && !didRealpaths) {
              const promises = [];
              for (const e of entries) {
                if (e.isSymbolicLink()) {
                  promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                }
              }
              if (promises.length) {
                Promise.all(promises).then(() => onReaddir(null, entries, true));
                return;
              }
            }
            for (const e of entries) {
              if (e && (!filter || filter(e))) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              const r = e.realpathCached() || e;
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
            if (paused && !results.flowing) {
              results.once("drain", process2);
            } else if (!sync) {
              process2();
            }
          };
          let sync = true;
          dir.readdirCB(onReaddir, true);
          sync = false;
        }
      };
      process2();
      return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
      const results = new minipass_1.Minipass({ objectMode: true });
      const dirs = new Set;
      if (!filter || filter(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
        }
        if (paused && !results.flowing)
          results.once("drain", process2);
      };
      process2();
      return results;
    }
    chdir(path = this.cwd) {
      const oldCwd = this.cwd;
      this.cwd = typeof path === "string" ? this.cwd.resolve(path) : path;
      this.cwd[setAsCwd](oldCwd);
    }
  }
  exports.PathScurryBase = PathScurryBase;

  class PathScurryWin32 extends PathScurryBase {
    sep = "\\";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
      this.nocase = nocase;
      for (let p = this.cwd;p; p = p.parent) {
        p.nocase = this.nocase;
      }
    }
    parseRootPath(dir) {
      return node_path_1.win32.parse(dir).root.toUpperCase();
    }
    newRoot(fs) {
      return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    isAbsolute(p) {
      return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
  }
  exports.PathScurryWin32 = PathScurryWin32;

  class PathScurryPosix extends PathScurryBase {
    sep = "/";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = false } = opts;
      super(cwd, node_path_1.posix, "/", { ...opts, nocase });
      this.nocase = nocase;
    }
    parseRootPath(_dir) {
      return "/";
    }
    newRoot(fs) {
      return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    isAbsolute(p) {
      return p.startsWith("/");
    }
  }
  exports.PathScurryPosix = PathScurryPosix;

  class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, { ...opts, nocase });
    }
  }
  exports.PathScurryDarwin = PathScurryDarwin;
  exports.Path = process.platform === "win32" ? PathWin32 : PathPosix;
  exports.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
});

// node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pattern = undefined;
  var minimatch_1 = require_commonjs16();
  var isPatternList = (pl) => pl.length >= 1;
  var isGlobList = (gl) => gl.length >= 1;

  class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
      if (!isPatternList(patternList)) {
        throw new TypeError("empty pattern list");
      }
      if (!isGlobList(globList)) {
        throw new TypeError("empty glob list");
      }
      if (globList.length !== patternList.length) {
        throw new TypeError("mismatched pattern list and glob list lengths");
      }
      this.length = patternList.length;
      if (index < 0 || index >= this.length) {
        throw new TypeError("index out of range");
      }
      this.#patternList = patternList;
      this.#globList = globList;
      this.#index = index;
      this.#platform = platform;
      if (this.#index === 0) {
        if (this.isUNC()) {
          const [p0, p1, p2, p3, ...prest] = this.#patternList;
          const [g0, g1, g2, g3, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = [p0, p1, p2, p3, ""].join("/");
          const g = [g0, g1, g2, g3, ""].join("/");
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        } else if (this.isDrive() || this.isAbsolute()) {
          const [p1, ...prest] = this.#patternList;
          const [g1, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = p1 + "/";
          const g = g1 + "/";
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        }
      }
    }
    pattern() {
      return this.#patternList[this.#index];
    }
    isString() {
      return typeof this.#patternList[this.#index] === "string";
    }
    isGlobstar() {
      return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
    }
    isRegExp() {
      return this.#patternList[this.#index] instanceof RegExp;
    }
    globString() {
      return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    hasMore() {
      return this.length > this.#index + 1;
    }
    rest() {
      if (this.#rest !== undefined)
        return this.#rest;
      if (!this.hasMore())
        return this.#rest = null;
      this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
      this.#rest.#isAbsolute = this.#isAbsolute;
      this.#rest.#isUNC = this.#isUNC;
      this.#rest.#isDrive = this.#isDrive;
      return this.#rest;
    }
    isUNC() {
      const pl = this.#patternList;
      return this.#isUNC !== undefined ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    isDrive() {
      const pl = this.#patternList;
      return this.#isDrive !== undefined ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    isAbsolute() {
      const pl = this.#patternList;
      return this.#isAbsolute !== undefined ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    root() {
      const p = this.#patternList[0];
      return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    checkFollowGlobstar() {
      return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    markFollowGlobstar() {
      if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
        return false;
      this.#followGlobstar = false;
      return true;
    }
  }
  exports.Pattern = Pattern;
});

// node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ignore = undefined;
  var minimatch_1 = require_commonjs16();
  var pattern_js_1 = require_pattern();
  var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

  class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
      this.relative = [];
      this.absolute = [];
      this.relativeChildren = [];
      this.absoluteChildren = [];
      this.platform = platform;
      this.mmopts = {
        dot: true,
        nobrace,
        nocase,
        noext,
        noglobstar,
        optimizationLevel: 2,
        platform,
        nocomment: true,
        nonegate: true
      };
      for (const ign of ignored)
        this.add(ign);
    }
    add(ign) {
      const mm = new minimatch_1.Minimatch(ign, this.mmopts);
      for (let i = 0;i < mm.set.length; i++) {
        const parsed = mm.set[i];
        const globParts = mm.globParts[i];
        if (!parsed || !globParts) {
          throw new Error("invalid pattern object");
        }
        while (parsed[0] === "." && globParts[0] === ".") {
          parsed.shift();
          globParts.shift();
        }
        const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
        const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
        const children = globParts[globParts.length - 1] === "**";
        const absolute = p.isAbsolute();
        if (absolute)
          this.absolute.push(m);
        else
          this.relative.push(m);
        if (children) {
          if (absolute)
            this.absoluteChildren.push(m);
          else
            this.relativeChildren.push(m);
        }
      }
    }
    ignored(p) {
      const fullpath = p.fullpath();
      const fullpaths = `${fullpath}/`;
      const relative = p.relative() || ".";
      const relatives = `${relative}/`;
      for (const m of this.relative) {
        if (m.match(relative) || m.match(relatives))
          return true;
      }
      for (const m of this.absolute) {
        if (m.match(fullpath) || m.match(fullpaths))
          return true;
      }
      return false;
    }
    childrenIgnored(p) {
      const fullpath = p.fullpath() + "/";
      const relative = (p.relative() || ".") + "/";
      for (const m of this.relativeChildren) {
        if (m.match(relative))
          return true;
      }
      for (const m of this.absoluteChildren) {
        if (m.match(fullpath))
          return true;
      }
      return false;
    }
  }
  exports.Ignore = Ignore;
});

// node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = undefined;
  var minimatch_1 = require_commonjs16();

  class HasWalkedCache {
    store;
    constructor(store = new Map) {
      this.store = store;
    }
    copy() {
      return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
      return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
      const fullpath = target.fullpath();
      const cached = this.store.get(fullpath);
      if (cached)
        cached.add(pattern.globString());
      else
        this.store.set(fullpath, new Set([pattern.globString()]));
    }
  }
  exports.HasWalkedCache = HasWalkedCache;

  class MatchRecord {
    store = new Map;
    add(target, absolute, ifDir) {
      const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
      const current = this.store.get(target);
      this.store.set(target, current === undefined ? n : n & current);
    }
    entries() {
      return [...this.store.entries()].map(([path, n]) => [
        path,
        !!(n & 2),
        !!(n & 1)
      ]);
    }
  }
  exports.MatchRecord = MatchRecord;

  class SubWalks {
    store = new Map;
    add(target, pattern) {
      if (!target.canReaddir()) {
        return;
      }
      const subs = this.store.get(target);
      if (subs) {
        if (!subs.find((p) => p.globString() === pattern.globString())) {
          subs.push(pattern);
        }
      } else
        this.store.set(target, [pattern]);
    }
    get(target) {
      const subs = this.store.get(target);
      if (!subs) {
        throw new Error("attempting to walk unknown path");
      }
      return subs;
    }
    entries() {
      return this.keys().map((k) => [k, this.store.get(k)]);
    }
    keys() {
      return [...this.store.keys()].filter((t) => t.canReaddir());
    }
  }
  exports.SubWalks = SubWalks;

  class Processor {
    hasWalkedCache;
    matches = new MatchRecord;
    subwalks = new SubWalks;
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
      this.opts = opts;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache;
    }
    processPatterns(target, patterns) {
      this.patterns = patterns;
      const processingSet = patterns.map((p) => [target, p]);
      for (let [t, pattern] of processingSet) {
        this.hasWalkedCache.storeWalked(t, pattern);
        const root = pattern.root();
        const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
        if (root) {
          t = t.resolve(root === "/" && this.opts.root !== undefined ? this.opts.root : root);
          const rest2 = pattern.rest();
          if (!rest2) {
            this.matches.add(t, true, false);
            continue;
          } else {
            pattern = rest2;
          }
        }
        if (t.isENOENT())
          continue;
        let p;
        let rest;
        let changed = false;
        while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
          const c = t.resolve(p);
          t = c;
          pattern = rest;
          changed = true;
        }
        p = pattern.pattern();
        rest = pattern.rest();
        if (changed) {
          if (this.hasWalkedCache.hasWalked(t, pattern))
            continue;
          this.hasWalkedCache.storeWalked(t, pattern);
        }
        if (typeof p === "string") {
          const ifDir = p === ".." || p === "" || p === ".";
          this.matches.add(t.resolve(p), absolute, ifDir);
          continue;
        } else if (p === minimatch_1.GLOBSTAR) {
          if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
            this.subwalks.add(t, pattern);
          }
          const rp = rest?.pattern();
          const rrest = rest?.rest();
          if (!rest || (rp === "" || rp === ".") && !rrest) {
            this.matches.add(t, absolute, rp === "" || rp === ".");
          } else {
            if (rp === "..") {
              const tp = t.parent || t;
              if (!rrest)
                this.matches.add(tp, absolute, true);
              else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                this.subwalks.add(tp, rrest);
              }
            }
          }
        } else if (p instanceof RegExp) {
          this.subwalks.add(t, pattern);
        }
      }
      return this;
    }
    subwalkTargets() {
      return this.subwalks.keys();
    }
    child() {
      return new Processor(this.opts, this.hasWalkedCache);
    }
    filterEntries(parent, entries) {
      const patterns = this.subwalks.get(parent);
      const results = this.child();
      for (const e of entries) {
        for (const pattern of patterns) {
          const absolute = pattern.isAbsolute();
          const p = pattern.pattern();
          const rest = pattern.rest();
          if (p === minimatch_1.GLOBSTAR) {
            results.testGlobstar(e, pattern, rest, absolute);
          } else if (p instanceof RegExp) {
            results.testRegExp(e, p, rest, absolute);
          } else {
            results.testString(e, p, rest, absolute);
          }
        }
      }
      return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
      if (this.dot || !e.name.startsWith(".")) {
        if (!pattern.hasMore()) {
          this.matches.add(e, absolute, false);
        }
        if (e.canReaddir()) {
          if (this.follow || !e.isSymbolicLink()) {
            this.subwalks.add(e, pattern);
          } else if (e.isSymbolicLink()) {
            if (rest && pattern.checkFollowGlobstar()) {
              this.subwalks.add(e, rest);
            } else if (pattern.markFollowGlobstar()) {
              this.subwalks.add(e, pattern);
            }
          }
        }
      }
      if (rest) {
        const rp = rest.pattern();
        if (typeof rp === "string" && rp !== ".." && rp !== "" && rp !== ".") {
          this.testString(e, rp, rest.rest(), absolute);
        } else if (rp === "..") {
          const ep = e.parent || e;
          this.subwalks.add(ep, rest);
        } else if (rp instanceof RegExp) {
          this.testRegExp(e, rp, rest.rest(), absolute);
        }
      }
    }
    testRegExp(e, p, rest, absolute) {
      if (!p.test(e.name))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
    testString(e, p, rest, absolute) {
      if (!e.isNamed(p))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
  }
  exports.Processor = Processor;
});

// node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GlobStream = exports.GlobWalker = exports.GlobUtil = undefined;
  var minipass_1 = require_commonjs18();
  var ignore_js_1 = require_ignore();
  var processor_js_1 = require_processor();
  var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;

  class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set;
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
      this.patterns = patterns;
      this.path = path;
      this.opts = opts;
      this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
      this.includeChildMatches = opts.includeChildMatches !== false;
      if (opts.ignore || !this.includeChildMatches) {
        this.#ignore = makeIgnore(opts.ignore ?? [], opts);
        if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
          const m = "cannot ignore child matches, ignore lacks add() method.";
          throw new Error(m);
        }
      }
      this.maxDepth = opts.maxDepth || Infinity;
      if (opts.signal) {
        this.signal = opts.signal;
        this.signal.addEventListener("abort", () => {
          this.#onResume.length = 0;
        });
      }
    }
    #ignored(path) {
      return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
      return !!this.#ignore?.childrenIgnored?.(path);
    }
    pause() {
      this.paused = true;
    }
    resume() {
      if (this.signal?.aborted)
        return;
      this.paused = false;
      let fn = undefined;
      while (!this.paused && (fn = this.#onResume.shift())) {
        fn();
      }
    }
    onResume(fn) {
      if (this.signal?.aborted)
        return;
      if (!this.paused) {
        fn();
      } else {
        this.#onResume.push(fn);
      }
    }
    async matchCheck(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || await e.realpath();
        if (!rpc)
          return;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? await e.lstat() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = await s.realpath();
        if (target && (target.isUnknown() || this.opts.stat)) {
          await target.lstat();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
      return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : undefined;
    }
    matchCheckSync(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || e.realpathSync();
        if (!rpc)
          return;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? e.lstatSync() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = s.realpathSync();
        if (target && (target?.isUnknown() || this.opts.stat)) {
          target.lstatSync();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
      if (this.#ignored(e))
        return;
      if (!this.includeChildMatches && this.#ignore?.add) {
        const ign = `${e.relativePosix()}/**`;
        this.#ignore.add(ign);
      }
      const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
      this.seen.add(e);
      const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
      if (this.opts.withFileTypes) {
        this.matchEmit(e);
      } else if (abs) {
        const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
        this.matchEmit(abs2 + mark);
      } else {
        const rel = this.opts.posix ? e.relativePosix() : e.relative();
        const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
        this.matchEmit(!rel ? "." + mark : pre + rel + mark);
      }
    }
    async match(e, absolute, ifDir) {
      const p = await this.matchCheck(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
      const p = this.matchCheckSync(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const childrenCached = t.readdirCached();
        if (t.calledReaddir())
          this.walkCB3(t, childrenCached, processor, next);
        else {
          t.readdirCB((_2, entries) => this.walkCB3(t, entries, processor, next), true);
        }
      }
      next();
    }
    walkCB3(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2(target2, patterns, processor.child(), next);
      }
      next();
    }
    walkCBSync(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const children = t.readdirSync();
        this.walkCB3Sync(t, children, processor, next);
      }
      next();
    }
    walkCB3Sync(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2Sync(target2, patterns, processor.child(), next);
      }
      next();
    }
  }
  exports.GlobUtil = GlobUtil;

  class GlobWalker extends GlobUtil {
    matches = new Set;
    constructor(patterns, path, opts) {
      super(patterns, path, opts);
    }
    matchEmit(e) {
      this.matches.add(e);
    }
    async walk() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        await this.path.lstat();
      }
      await new Promise((res, rej) => {
        this.walkCB(this.path, this.patterns, () => {
          if (this.signal?.aborted) {
            rej(this.signal.reason);
          } else {
            res(this.matches);
          }
        });
      });
      return this.matches;
    }
    walkSync() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => {
        if (this.signal?.aborted)
          throw this.signal.reason;
      });
      return this.matches;
    }
  }
  exports.GlobWalker = GlobWalker;

  class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path, opts) {
      super(patterns, path, opts);
      this.results = new minipass_1.Minipass({
        signal: this.signal,
        objectMode: true
      });
      this.results.on("drain", () => this.resume());
      this.results.on("resume", () => this.resume());
    }
    matchEmit(e) {
      this.results.write(e);
      if (!this.results.flowing)
        this.pause();
    }
    stream() {
      const target = this.path;
      if (target.isUnknown()) {
        target.lstat().then(() => {
          this.walkCB(target, this.patterns, () => this.results.end());
        });
      } else {
        this.walkCB(target, this.patterns, () => this.results.end());
      }
      return this.results;
    }
    streamSync() {
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => this.results.end());
      return this.results;
    }
  }
  exports.GlobStream = GlobStream;
});

// node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Glob = undefined;
  var minimatch_1 = require_commonjs16();
  var node_url_1 = __require("node:url");
  var path_scurry_1 = require_commonjs19();
  var pattern_js_1 = require_pattern();
  var walker_js_1 = require_walker();
  var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

  class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    opts;
    patterns;
    constructor(pattern, opts) {
      if (!opts)
        throw new TypeError("glob options required");
      this.withFileTypes = !!opts.withFileTypes;
      this.signal = opts.signal;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.dotRelative = !!opts.dotRelative;
      this.nodir = !!opts.nodir;
      this.mark = !!opts.mark;
      if (!opts.cwd) {
        this.cwd = "";
      } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
        opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
      }
      this.cwd = opts.cwd || "";
      this.root = opts.root;
      this.magicalBraces = !!opts.magicalBraces;
      this.nobrace = !!opts.nobrace;
      this.noext = !!opts.noext;
      this.realpath = !!opts.realpath;
      this.absolute = opts.absolute;
      this.includeChildMatches = opts.includeChildMatches !== false;
      this.noglobstar = !!opts.noglobstar;
      this.matchBase = !!opts.matchBase;
      this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
      this.stat = !!opts.stat;
      this.ignore = opts.ignore;
      if (this.withFileTypes && this.absolute !== undefined) {
        throw new Error("cannot set absolute and withFileTypes:true");
      }
      if (typeof pattern === "string") {
        pattern = [pattern];
      }
      this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        pattern = pattern.map((p) => p.replace(/\\/g, "/"));
      }
      if (this.matchBase) {
        if (opts.noglobstar) {
          throw new TypeError("base matching requires globstar");
        }
        pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
      }
      this.pattern = pattern;
      this.platform = opts.platform || defaultPlatform;
      this.opts = { ...opts, platform: this.platform };
      if (opts.scurry) {
        this.scurry = opts.scurry;
        if (opts.nocase !== undefined && opts.nocase !== opts.scurry.nocase) {
          throw new Error("nocase option contradicts provided scurry option");
        }
      } else {
        const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
        this.scurry = new Scurry(this.cwd, {
          nocase: opts.nocase,
          fs: opts.fs
        });
      }
      this.nocase = this.scurry.nocase;
      const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
      const mmo = {
        ...opts,
        dot: this.dot,
        matchBase: this.matchBase,
        nobrace: this.nobrace,
        nocase: this.nocase,
        nocaseMagicOnly,
        nocomment: true,
        noext: this.noext,
        nonegate: true,
        optimizationLevel: 2,
        platform: this.platform,
        windowsPathsNoEscape: this.windowsPathsNoEscape,
        debug: !!this.opts.debug
      };
      const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
      const [matchSet, globParts] = mms.reduce((set, m) => {
        set[0].push(...m.set);
        set[1].push(...m.globParts);
        return set;
      }, [[], []]);
      this.patterns = matchSet.map((set, i) => {
        const g = globParts[i];
        if (!g)
          throw new Error("invalid pattern object");
        return new pattern_js_1.Pattern(set, g, 0, this.platform);
      });
    }
    async walk() {
      return [
        ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walk()
      ];
    }
    walkSync() {
      return [
        ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walkSync()
      ];
    }
    stream() {
      return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).stream();
    }
    streamSync() {
      return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).streamSync();
    }
    iterateSync() {
      return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    iterate() {
      return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
  }
  exports.Glob = Glob;
});

// node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMagic = undefined;
  var minimatch_1 = require_commonjs16();
  var hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
      pattern = [pattern];
    }
    for (const p of pattern) {
      if (new minimatch_1.Minimatch(p, options).hasMagic())
        return true;
    }
    return false;
  };
  exports.hasMagic = hasMagic;
});

// node_modules/glob/dist/commonjs/index.js
var require_commonjs20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = undefined;
  exports.globStreamSync = globStreamSync;
  exports.globStream = globStream;
  exports.globSync = globSync;
  exports.globIterateSync = globIterateSync;
  exports.globIterate = globIterate;
  var minimatch_1 = require_commonjs16();
  var glob_js_1 = require_glob();
  var has_magic_js_1 = require_has_magic();
  var minimatch_2 = require_commonjs16();
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return minimatch_2.escape;
  } });
  Object.defineProperty(exports, "unescape", { enumerable: true, get: function() {
    return minimatch_2.unescape;
  } });
  var glob_js_2 = require_glob();
  Object.defineProperty(exports, "Glob", { enumerable: true, get: function() {
    return glob_js_2.Glob;
  } });
  var has_magic_js_2 = require_has_magic();
  Object.defineProperty(exports, "hasMagic", { enumerable: true, get: function() {
    return has_magic_js_2.hasMagic;
  } });
  var ignore_js_1 = require_ignore();
  Object.defineProperty(exports, "Ignore", { enumerable: true, get: function() {
    return ignore_js_1.Ignore;
  } });
  function globStreamSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).streamSync();
  }
  function globStream(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).stream();
  }
  function globSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walkSync();
  }
  async function glob_(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walk();
  }
  function globIterateSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterateSync();
  }
  function globIterate(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterate();
  }
  exports.streamSync = globStreamSync;
  exports.stream = Object.assign(globStream, { sync: globStreamSync });
  exports.iterateSync = globIterateSync;
  exports.iterate = Object.assign(globIterate, {
    sync: globIterateSync
  });
  exports.sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
  });
  exports.glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync: exports.sync,
    globStream,
    stream: exports.stream,
    globStreamSync,
    streamSync: exports.streamSync,
    globIterate,
    iterate: exports.iterate,
    globIterateSync,
    iterateSync: exports.iterateSync,
    Glob: glob_js_1.Glob,
    hasMagic: has_magic_js_1.hasMagic,
    escape: minimatch_1.escape,
    unescape: minimatch_1.unescape
  });
  exports.glob.glob = exports.glob;
});

// node_modules/archiver-utils/file.js
var require_file3 = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var flatten = require_flatten();
  var difference = require_difference();
  var union = require_union();
  var isPlainObject = require_isPlainObject();
  var glob = require_commonjs20();
  var file = module.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file.exists = function() {
    var filepath = path.join.apply(path, arguments);
    return fs.existsSync(filepath);
  };
  file.expand = function(...args) {
    var options = isPlainObject(args[0]) ? args.shift() : {};
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file.expand(options, patterns).forEach(function(src) {
      var destPath = src;
      if (options.flatten) {
        destPath = path.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src = path.join(options.cwd, src);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src = src.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src);
      } else {
        files.push({
          src: [src],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj) {
      var prop;
      if ("src" in obj || "dest" in obj) {
        files.push(obj);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj) {
      if (!("src" in obj) || !obj.src) {
        return;
      }
      if (Array.isArray(obj.src)) {
        obj.src = flatten(obj.src);
      } else {
        obj.src = [obj.src];
      }
    }).map(function(obj) {
      var expandOptions = Object.assign({}, obj);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj.expand) {
        return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj);
          result2.orig = Object.assign({}, obj);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj);
      result.orig = Object.assign({}, obj);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src;
            if (!("result" in fn)) {
              src = obj.src;
              src = Array.isArray(src) ? flatten(src) : [src];
              fn.result = file.expand(expandOptions, src);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
});

// node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var isStream = require_is_stream();
  var lazystream = require_lazystream();
  var normalizePath = require_normalize_path();
  var defaults = require_defaults();
  var Stream = __require("stream").Stream;
  var PassThrough = require_ours().PassThrough;
  var utils = module.exports = {};
  utils.file = require_file3();
  utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = Buffer.alloc(size);
      var offset = 0;
      collection.forEach(function(data) {
        data.copy(buf, offset);
        offset += data.length;
      });
      callback(null, buf);
    });
  };
  utils.dateify = function(dateish) {
    dateish = dateish || new Date;
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = new Date;
    }
    return dateish;
  };
  utils.defaults = function(object, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults(...args);
  };
  utils.isStream = function(source) {
    return isStream(source);
  };
  utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
      return fs.createReadStream(filepath);
    });
  };
  utils.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (utils.isStream(source)) {
      return source.pipe(new PassThrough);
    }
    return source;
  };
  utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
  };
  utils.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs.readdir(dirpath, function(err, list) {
      var i = 0;
      var file;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file = list[i++];
        if (!file) {
          return callback(null, results);
        }
        filepath = path.join(dirpath, file);
        fs.stat(filepath, function(err2, stats) {
          results.push({
            path: filepath,
            relative: path.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils.walkdir(filepath, base, function(err3, res) {
              if (err3) {
                return callback(err3);
              }
              res.forEach(function(dirEntry) {
                results.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
});

// node_modules/archiver/lib/error.js
var require_error3 = __commonJS((exports, module) => {
  var util = __require("util");
  var ERROR_CODES = {
    ABORTED: "archive was aborted",
    DIRECTORYDIRPATHREQUIRED: "diretory dirpath argument must be a non-empty string value",
    DIRECTORYFUNCTIONINVALIDDATA: "invalid data returned by directory custom data function",
    ENTRYNAMEREQUIRED: "entry name must be a non-empty string value",
    FILEFILEPATHREQUIRED: "file filepath argument must be a non-empty string value",
    FINALIZING: "archive already finalizing",
    QUEUECLOSED: "queue closed",
    NOENDMETHOD: "no suitable finalize/end method defined by module",
    DIRECTORYNOTSUPPORTED: "support for directory entries not defined by module",
    FORMATSET: "archive format already set",
    INPUTSTEAMBUFFERREQUIRED: "input source must be valid Stream or Buffer instance",
    MODULESET: "module already set",
    SYMLINKNOTSUPPORTED: "support for symlink entries not defined by module",
    SYMLINKFILEPATHREQUIRED: "symlink filepath argument must be a non-empty string value",
    SYMLINKTARGETREQUIRED: "symlink target argument must be a non-empty string value",
    ENTRYNOTSUPPORTED: "entry not supported"
  };
  function ArchiverError(code, data) {
    Error.captureStackTrace(this, this.constructor);
    this.message = ERROR_CODES[code] || code;
    this.code = code;
    this.data = data;
  }
  util.inherits(ArchiverError, Error);
  exports = module.exports = ArchiverError;
});

// node_modules/archiver/lib/core.js
var require_core2 = __commonJS((exports, module) => {
  var fs = __require("fs");
  var glob = require_readdir_glob();
  var async = require_async();
  var path = __require("path");
  var util = require_archiver_utils();
  var inherits = __require("util").inherits;
  var ArchiverError = require_error3();
  var Transform = require_ours().Transform;
  var win32 = process.platform === "win32";
  var Archiver = function(format, options) {
    if (!(this instanceof Archiver)) {
      return new Archiver(format, options);
    }
    if (typeof format !== "string") {
      options = format;
      format = "zip";
    }
    options = this.options = util.defaults(options, {
      highWaterMark: 1024 * 1024,
      statConcurrency: 4
    });
    Transform.call(this, options);
    this._format = false;
    this._module = false;
    this._pending = 0;
    this._pointer = 0;
    this._entriesCount = 0;
    this._entriesProcessedCount = 0;
    this._fsEntriesTotalBytes = 0;
    this._fsEntriesProcessedBytes = 0;
    this._queue = async.queue(this._onQueueTask.bind(this), 1);
    this._queue.drain(this._onQueueDrain.bind(this));
    this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
    this._statQueue.drain(this._onQueueDrain.bind(this));
    this._state = {
      aborted: false,
      finalize: false,
      finalizing: false,
      finalized: false,
      modulePiped: false
    };
    this._streams = [];
  };
  inherits(Archiver, Transform);
  Archiver.prototype._abort = function() {
    this._state.aborted = true;
    this._queue.kill();
    this._statQueue.kill();
    if (this._queue.idle()) {
      this._shutdown();
    }
  };
  Archiver.prototype._append = function(filepath, data) {
    data = data || {};
    var task = {
      source: null,
      filepath
    };
    if (!data.name) {
      data.name = filepath;
    }
    data.sourcePath = filepath;
    task.data = data;
    this._entriesCount++;
    if (data.stats && data.stats instanceof fs.Stats) {
      task = this._updateQueueTaskWithStats(task, data.stats);
      if (task) {
        if (data.stats.size) {
          this._fsEntriesTotalBytes += data.stats.size;
        }
        this._queue.push(task);
      }
    } else {
      this._statQueue.push(task);
    }
  };
  Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    this._state.finalizing = true;
    this._moduleFinalize();
    this._state.finalizing = false;
    this._state.finalized = true;
  };
  Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return false;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
      return true;
    }
    return false;
  };
  Archiver.prototype._moduleAppend = function(source, data, callback) {
    if (this._state.aborted) {
      callback();
      return;
    }
    this._module.append(source, data, function(err) {
      this._task = null;
      if (this._state.aborted) {
        this._shutdown();
        return;
      }
      if (err) {
        this.emit("error", err);
        setImmediate(callback);
        return;
      }
      this.emit("entry", data);
      this._entriesProcessedCount++;
      if (data.stats && data.stats.size) {
        this._fsEntriesProcessedBytes += data.stats.size;
      }
      this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      });
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function") {
      this._module.finalize();
    } else if (typeof this._module.end === "function") {
      this._module.end();
    } else {
      this.emit("error", new ArchiverError("NOENDMETHOD"));
    }
  };
  Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this));
    this._module.pipe(this);
    this._state.modulePiped = true;
  };
  Archiver.prototype._moduleSupports = function(key) {
    if (!this._module.supports || !this._module.supports[key]) {
      return false;
    }
    return this._module.supports[key];
  };
  Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this);
    this._state.modulePiped = false;
  };
  Archiver.prototype._normalizeEntryData = function(data, stats) {
    data = util.defaults(data, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: false
    });
    if (stats && data.stats === false) {
      data.stats = stats;
    }
    var isDir = data.type === "directory";
    if (data.name) {
      if (typeof data.prefix === "string" && data.prefix !== "") {
        data.name = data.prefix + "/" + data.name;
        data.prefix = null;
      }
      data.name = util.sanitizePath(data.name);
      if (data.type !== "symlink" && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (typeof data.mode === "number") {
      if (win32) {
        data.mode &= 511;
      } else {
        data.mode &= 4095;
      }
    } else if (data.stats && data.mode === null) {
      if (win32) {
        data.mode = data.stats.mode & 511;
      } else {
        data.mode = data.stats.mode & 4095;
      }
      if (win32 && isDir) {
        data.mode = 493;
      }
    } else if (data.mode === null) {
      data.mode = isDir ? 493 : 420;
    }
    if (data.stats && data.date === null) {
      data.date = data.stats.mtime;
    } else {
      data.date = util.dateify(data.date);
    }
    return data;
  };
  Archiver.prototype._onModuleError = function(err) {
    this.emit("error", err);
  };
  Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
  };
  Archiver.prototype._onQueueTask = function(task, callback) {
    var fullCallback = () => {
      if (task.data.callback) {
        task.data.callback();
      }
      callback();
    };
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      fullCallback();
      return;
    }
    this._task = task;
    this._moduleAppend(task.source, task.data, fullCallback);
  };
  Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    fs.lstat(task.filepath, function(err, stats) {
      if (this._state.aborted) {
        setImmediate(callback);
        return;
      }
      if (err) {
        this._entriesCount--;
        this.emit("warning", err);
        setImmediate(callback);
        return;
      }
      task = this._updateQueueTaskWithStats(task, stats);
      if (task) {
        if (stats.size) {
          this._fsEntriesTotalBytes += stats.size;
        }
        this._queue.push(task);
      }
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._shutdown = function() {
    this._moduleUnpipe();
    this.end();
  };
  Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk) {
      this._pointer += chunk.length;
    }
    callback(null, chunk);
  };
  Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile()) {
      task.data.type = "file";
      task.data.sourceType = "stream";
      task.source = util.lazyReadStream(task.filepath);
    } else if (stats.isDirectory() && this._moduleSupports("directory")) {
      task.data.name = util.trailingSlashIt(task.data.name);
      task.data.type = "directory";
      task.data.sourcePath = util.trailingSlashIt(task.filepath);
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
      var linkPath = fs.readlinkSync(task.filepath);
      var dirName = path.dirname(task.filepath);
      task.data.type = "symlink";
      task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else {
      if (stats.isDirectory()) {
        this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
      } else if (stats.isSymbolicLink()) {
        this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
      } else {
        this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
      }
      return null;
    }
    task.data = this._normalizeEntryData(task.data, stats);
    return task;
  };
  Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized) {
      return this;
    }
    this._abort();
    return this;
  };
  Archiver.prototype.append = function(source, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    data = this._normalizeEntryData(data);
    if (typeof data.name !== "string" || data.name.length === 0) {
      this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
      return this;
    }
    if (data.type === "directory" && !this._moduleSupports("directory")) {
      this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
      return this;
    }
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      data.sourceType = "buffer";
    } else if (util.isStream(source)) {
      data.sourceType = "stream";
    } else {
      this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
      return this;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source
    });
    return this;
  };
  Archiver.prototype.directory = function(dirpath, destpath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof dirpath !== "string" || dirpath.length === 0) {
      this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
      return this;
    }
    this._pending++;
    if (destpath === false) {
      destpath = "";
    } else if (typeof destpath !== "string") {
      destpath = dirpath;
    }
    var dataFunction = false;
    if (typeof data === "function") {
      dataFunction = data;
      data = {};
    } else if (typeof data !== "object") {
      data = {};
    }
    var globOptions = {
      stat: true,
      dot: true
    };
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var ignoreMatch = false;
      var entryData = Object.assign({}, data);
      entryData.name = match.relative;
      entryData.prefix = destpath;
      entryData.stats = match.stat;
      entryData.callback = globber.resume.bind(globber);
      try {
        if (dataFunction) {
          entryData = dataFunction(entryData);
          if (entryData === false) {
            ignoreMatch = true;
          } else if (typeof entryData !== "object") {
            throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
          }
        }
      } catch (e) {
        this.emit("error", e);
        return;
      }
      if (ignoreMatch) {
        globber.resume();
        return;
      }
      this._append(match.absolute, entryData);
    }
    var globber = glob(dirpath, globOptions);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.file = function(filepath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
      return this;
    }
    this._append(filepath, data);
    return this;
  };
  Archiver.prototype.glob = function(pattern, options, data) {
    this._pending++;
    options = util.defaults(options, {
      stat: true,
      pattern
    });
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var entryData = Object.assign({}, data);
      entryData.callback = globber.resume.bind(globber);
      entryData.stats = match.stat;
      entryData.name = match.relative;
      this._append(match.absolute, entryData);
    }
    var globber = glob(options.cwd || ".", options);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
      var abortedError = new ArchiverError("ABORTED");
      this.emit("error", abortedError);
      return Promise.reject(abortedError);
    }
    if (this._state.finalize) {
      var finalizingError = new ArchiverError("FINALIZING");
      this.emit("error", finalizingError);
      return Promise.reject(finalizingError);
    }
    this._state.finalize = true;
    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
    var self2 = this;
    return new Promise(function(resolve, reject) {
      var errored;
      self2._module.on("end", function() {
        if (!errored) {
          resolve();
        }
      });
      self2._module.on("error", function(err) {
        errored = true;
        reject(err);
      });
    });
  };
  Archiver.prototype.setFormat = function(format) {
    if (this._format) {
      this.emit("error", new ArchiverError("FORMATSET"));
      return this;
    }
    this._format = format;
    return this;
  };
  Archiver.prototype.setModule = function(module2) {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.module) {
      this.emit("error", new ArchiverError("MODULESET"));
      return this;
    }
    this._module = module2;
    this._modulePipe();
    return this;
  };
  Archiver.prototype.symlink = function(filepath, target, mode) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
      return this;
    }
    if (typeof target !== "string" || target.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
      return this;
    }
    if (!this._moduleSupports("symlink")) {
      this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
      return this;
    }
    var data = {};
    data.type = "symlink";
    data.name = filepath.replace(/\\/g, "/");
    data.linkname = target.replace(/\\/g, "/");
    data.sourceType = "buffer";
    if (typeof mode === "number") {
      data.mode = mode;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source: Buffer.concat([])
    });
    return this;
  };
  Archiver.prototype.pointer = function() {
    return this._pointer;
  };
  Archiver.prototype.use = function(plugin) {
    this._streams.push(plugin);
    return this;
  };
  module.exports = Archiver;
});

// node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS((exports, module) => {
  var ArchiveEntry = module.exports = function() {};
  ArchiveEntry.prototype.getName = function() {};
  ArchiveEntry.prototype.getSize = function() {};
  ArchiveEntry.prototype.getLastModifiedDate = function() {};
  ArchiveEntry.prototype.isDirectory = function() {};
});

// node_modules/compress-commons/lib/archivers/zip/util.js
var require_util13 = __commonJS((exports, module) => {
  var util = module.exports = {};
  util.dateToDos = function(d, forceLocalTime) {
    forceLocalTime = forceLocalTime || false;
    var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
    if (year < 1980) {
      return 2162688;
    } else if (year >= 2044) {
      return 2141175677;
    }
    var val = {
      year,
      month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
      date: forceLocalTime ? d.getDate() : d.getUTCDate(),
      hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
      minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
      seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
  };
  util.dosToDate = function(dos) {
    return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
  };
  util.fromDosTime = function(buf) {
    return util.dosToDate(buf.readUInt32LE(0));
  };
  util.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(v % 4294967296, 0);
    buf.writeUInt32LE(v / 4294967296 | 0, 4);
    return buf;
  };
  util.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16LE((v & 65535) >>> 0, 0);
    return buf;
  };
  util.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
  };
  util.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
    return buf;
  };
  util.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
  };
  util.toDosTime = function(d) {
    return util.getLongBytes(util.dateToDos(d));
  };
});

// node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS((exports, module) => {
  var zipUtil = require_util13();
  var DATA_DESCRIPTOR_FLAG = 1 << 3;
  var ENCRYPTION_FLAG = 1 << 0;
  var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
  var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
  var STRONG_ENCRYPTION_FLAG = 1 << 6;
  var UFT8_NAMES_FLAG = 1 << 11;
  var GeneralPurposeBit = module.exports = function() {
    if (!(this instanceof GeneralPurposeBit)) {
      return new GeneralPurposeBit;
    }
    this.descriptor = false;
    this.encryption = false;
    this.utf8 = false;
    this.numberOfShannonFanoTrees = 0;
    this.strongEncryption = false;
    this.slidingDictionarySize = 0;
    return this;
  };
  GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
  };
  GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset);
    var gbp = new GeneralPurposeBit;
    gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
    gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
    gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
    gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
    gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
    gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
    return gbp;
  };
  GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
  };
  GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  };
  GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
  };
  GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  };
  GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
  };
  GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  };
  GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
  };
  GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
  };
  GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
  };
  GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  };
  GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
  };
  GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  };
});

// node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS((exports, module) => {
  module.exports = {
    PERM_MASK: 4095,
    FILE_TYPE_FLAG: 61440,
    LINK_FLAG: 40960,
    FILE_FLAG: 32768,
    DIR_FLAG: 16384,
    DEFAULT_LINK_PERM: 511,
    DEFAULT_DIR_PERM: 493,
    DEFAULT_FILE_PERM: 420
  };
});

// node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants11 = __commonJS((exports, module) => {
  module.exports = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    DEFAULT_DIR_MODE: 16877,
    EXT_FILE_ATTR_DIR: 1106051088,
    EXT_FILE_ATTR_FILE: 2175008800,
    S_IFMT: 61440,
    S_IFIFO: 4096,
    S_IFCHR: 8192,
    S_IFDIR: 16384,
    S_IFBLK: 24576,
    S_IFREG: 32768,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    S_DOS_A: 32,
    S_DOS_D: 16,
    S_DOS_V: 8,
    S_DOS_S: 4,
    S_DOS_H: 2,
    S_DOS_R: 1
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var normalizePath = require_normalize_path();
  var ArchiveEntry = require_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var UnixStat = require_unix_stat();
  var constants = require_constants11();
  var zipUtil = require_util13();
  var ZipArchiveEntry = module.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry)) {
      return new ZipArchiveEntry(name);
    }
    ArchiveEntry.call(this);
    this.platform = constants.PLATFORM_FAT;
    this.method = -1;
    this.name = null;
    this.size = 0;
    this.csize = 0;
    this.gpb = new GeneralPurposeBit;
    this.crc = 0;
    this.time = -1;
    this.minver = constants.MIN_VERSION_INITIAL;
    this.mode = -1;
    this.extra = null;
    this.exattr = 0;
    this.inattr = 0;
    this.comment = null;
    if (name) {
      this.setName(name);
    }
  };
  inherits(ZipArchiveEntry, ArchiveEntry);
  ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  };
  ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
  };
  ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
  };
  ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
  };
  ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants.EMPTY;
  };
  ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  };
  ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
  };
  ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
  };
  ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
  };
  ZipArchiveEntry.prototype.getName = function() {
    return this.name;
  };
  ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
  };
  ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
  };
  ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
  };
  ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  };
  ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
  };
  ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  };
  ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.comment = comment;
  };
  ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry compressed size");
    }
    this.csize = size;
  };
  ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0) {
      throw new Error("invalid entry crc32");
    }
    this.crc = crc;
  };
  ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
  };
  ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
  };
  ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit)) {
      throw new Error("invalid entry GeneralPurposeBit");
    }
    this.gpb = gpb;
  };
  ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
  };
  ZipArchiveEntry.prototype.setMethod = function(method) {
    if (method < 0) {
      throw new Error("invalid entry compression method");
    }
    this.method = method;
  };
  ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
    name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    if (prependSlash) {
      name = `/${name}`;
    }
    if (Buffer.byteLength(name) !== name.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.name = name;
  };
  ZipArchiveEntry.prototype.setPlatform = function(platform) {
    this.platform = platform;
  };
  ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry size");
    }
    this.size = size;
  };
  ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date)) {
      throw new Error("invalid entry time");
    }
    this.time = zipUtil.dateToDos(time, forceLocalTime);
  };
  ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
    this.setExternalAttributes(extattr);
    this.mode = mode & constants.MODE_MASK;
    this.platform = constants.PLATFORM_UNIX;
  };
  ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
  };
  ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  };
  ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
  };
  ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
  };
});

// node_modules/compress-commons/lib/util/index.js
var require_util14 = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var PassThrough = require_ours().PassThrough;
  var isStream = require_is_stream();
  var util = module.exports = {};
  util.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (isStream(source) && !source._readableState) {
      var normalized = new PassThrough;
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
});

// node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var isStream = require_is_stream();
  var Transform = require_ours().Transform;
  var ArchiveEntry = require_archive_entry();
  var util = require_util14();
  var ArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream)) {
      return new ArchiveOutputStream(options);
    }
    Transform.call(this, options);
    this.offset = 0;
    this._archive = {
      finish: false,
      finished: false,
      processing: false
    };
  };
  inherits(ArchiveOutputStream, Transform);
  ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {};
  ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {};
  ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err) {
      this.emit("error", err);
    }
  };
  ArchiveOutputStream.prototype._finish = function(ae) {};
  ArchiveOutputStream.prototype._normalizeEntry = function(ae) {};
  ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    source = source || null;
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    if (!(ae instanceof ArchiveEntry)) {
      callback(new Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      callback(new Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      callback(new Error("already processing an entry"));
      return;
    }
    this._archive.processing = true;
    this._normalizeEntry(ae);
    this._entry = ae;
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      this._appendBuffer(ae, source, callback);
    } else if (isStream(source)) {
      this._appendStream(ae, source, callback);
    } else {
      this._archive.processing = false;
      callback(new Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  };
  ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = true;
      return;
    }
    this._finish();
  };
  ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
  };
  ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk) {
      this.offset += chunk.length;
    }
    return Transform.prototype.write.call(this, chunk, cb);
  };
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS((exports) => {
  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
  var CRC32;
  (function(factory) {
    if (typeof DO_NOT_EXPORT_CRC === "undefined") {
      if (typeof exports === "object") {
        factory(exports);
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          var module2 = {};
          factory(module2);
          return module2;
        });
      } else {
        factory(CRC32 = {});
      }
    } else {
      factory(CRC32 = {});
    }
  })(function(CRC322) {
    CRC322.version = "1.2.2";
    function signed_crc_table() {
      var c = 0, table = new Array(256);
      for (var n = 0;n != 256; ++n) {
        c = n;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0;n != 256; ++n)
        table[n] = T[n];
      for (n = 0;n != 256; ++n) {
        v = T[n];
        for (c = 256 + n;c < 4096; c += 256)
          v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1;n != 16; ++n)
        out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length;i < L; )
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (;i < L; )
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L)
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0;i < L; ) {
        c = str.charCodeAt(i++);
        if (c < 128) {
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        } else if (c < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC322.table = T0;
    CRC322.bstr = crc32_bstr;
    CRC322.buf = crc32_buf;
    CRC322.str = crc32_str;
  });
});

// node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS((exports, module) => {
  var { Transform } = require_ours();
  var crc32 = require_crc32();

  class CRC32Stream extends Transform {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      callback(null, chunk);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  }
  module.exports = CRC32Stream;
});

// node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS((exports, module) => {
  var { DeflateRaw } = __require("zlib");
  var crc32 = require_crc32();

  class DeflateCRC32Stream extends DeflateRaw {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
      this.compressedSize = 0;
    }
    push(chunk, encoding) {
      if (chunk) {
        this.compressedSize += chunk.length;
      }
      return super.push(chunk, encoding);
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      super._transform(chunk, encoding, callback);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(compressed = false) {
      if (compressed) {
        return this.compressedSize;
      } else {
        return this.rawSize;
      }
    }
  }
  module.exports = DeflateCRC32Stream;
});

// node_modules/crc32-stream/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  module.exports = {
    CRC32Stream: require_crc32_stream(),
    DeflateCRC32Stream: require_deflate_crc32_stream()
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var crc32 = require_crc32();
  var { CRC32Stream } = require_lib2();
  var { DeflateCRC32Stream } = require_lib2();
  var ArchiveOutputStream = require_archive_output_stream();
  var ZipArchiveEntry = require_zip_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var constants = require_constants11();
  var util = require_util14();
  var zipUtil = require_util13();
  var ZipArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream)) {
      return new ZipArchiveOutputStream(options);
    }
    options = this.options = this._defaults(options);
    ArchiveOutputStream.call(this, options);
    this._entry = null;
    this._entries = [];
    this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: false,
      finished: false,
      processing: false,
      forceZip64: options.forceZip64,
      forceLocalTime: options.forceLocalTime
    };
  };
  inherits(ZipArchiveOutputStream, ArchiveOutputStream);
  ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    this._entries.push(ae);
    if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
      this._writeDataDescriptor(ae);
    }
    this._archive.processing = false;
    this._entry = null;
    if (this._archive.finish && !this._archive.finished) {
      this._finish();
    }
  };
  ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0) {
      ae.setMethod(constants.METHOD_STORED);
    }
    var method = ae.getMethod();
    if (method === constants.METHOD_STORED) {
      ae.setSize(source.length);
      ae.setCompressedSize(source.length);
      ae.setCrc(crc32.buf(source) >>> 0);
    }
    this._writeLocalFileHeader(ae);
    if (method === constants.METHOD_STORED) {
      this.write(source);
      this._afterAppend(ae);
      callback(null, ae);
      return;
    } else if (method === constants.METHOD_DEFLATED) {
      this._smartStream(ae, callback).end(source);
      return;
    } else {
      callback(new Error("compression method " + method + " not implemented"));
      return;
    }
  };
  ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
      smart.emit("error", err);
      smart.end();
    });
    source.pipe(smart);
  };
  ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object") {
      o = {};
    }
    if (typeof o.zlib !== "object") {
      o.zlib = {};
    }
    if (typeof o.zlib.level !== "number") {
      o.zlib.level = constants.ZLIB_BEST_SPEED;
    }
    o.forceZip64 = !!o.forceZip64;
    o.forceLocalTime = !!o.forceLocalTime;
    return o;
  };
  ZipArchiveOutputStream.prototype._finish = function() {
    this._archive.centralOffset = this.offset;
    this._entries.forEach(function(ae) {
      this._writeCentralFileHeader(ae);
    }.bind(this));
    this._archive.centralLength = this.offset - this._archive.centralOffset;
    if (this.isZip64()) {
      this._writeCentralDirectoryZip64();
    }
    this._writeCentralDirectoryEnd();
    this._archive.processing = false;
    this._archive.finish = true;
    this._archive.finished = true;
    this.end();
  };
  ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1) {
      ae.setMethod(constants.METHOD_DEFLATED);
    }
    if (ae.getMethod() === constants.METHOD_DEFLATED) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    }
    if (ae.getTime() === -1) {
      ae.setTime(new Date, this._archive.forceLocalTime);
    }
    ae._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  };
  ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
    var process2 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream;
    var error = null;
    function handleStuff() {
      var digest = process2.digest().readUInt32BE(0);
      ae.setCrc(digest);
      ae.setSize(process2.size());
      ae.setCompressedSize(process2.size(true));
      this._afterAppend(ae);
      callback(error, ae);
    }
    process2.once("end", handleStuff.bind(this));
    process2.once("error", function(err) {
      error = err;
    });
    process2.pipe(this, { end: false });
    return process2;
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length;
    var size = this._archive.centralLength;
    var offset = this._archive.centralOffset;
    if (this.isZip64()) {
      records = constants.ZIP64_MAGIC_SHORT;
      size = constants.ZIP64_MAGIC;
      offset = constants.ZIP64_MAGIC;
    }
    this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
    this.write(constants.SHORT_ZERO);
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getLongBytes(size));
    this.write(zipUtil.getLongBytes(offset));
    var comment = this.getComment();
    var commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength));
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
    this.write(zipUtil.getEightBytes(44));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(constants.LONG_ZERO);
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._archive.centralLength));
    this.write(zipUtil.getEightBytes(this._archive.centralOffset));
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
    this.write(zipUtil.getLongBytes(1));
  };
  ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var fileOffset = ae._offsets.file;
    var size = ae.getSize();
    var compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || fileOffset > constants.ZIP64_MAGIC) {
      size = constants.ZIP64_MAGIC;
      compressedSize = constants.ZIP64_MAGIC;
      fileOffset = constants.ZIP64_MAGIC;
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      var extraBuf = Buffer.concat([
        zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
        zipUtil.getShortBytes(24),
        zipUtil.getEightBytes(ae.getSize()),
        zipUtil.getEightBytes(ae.getCompressedSize()),
        zipUtil.getEightBytes(ae._offsets.file)
      ], 28);
      ae.setExtra(extraBuf);
    }
    this.write(zipUtil.getLongBytes(constants.SIG_CFH));
    this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    this.write(zipUtil.getLongBytes(compressedSize));
    this.write(zipUtil.getLongBytes(size));
    var name = ae.getName();
    var comment = ae.getComment();
    var extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
      comment = Buffer.from(comment);
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(zipUtil.getShortBytes(comment.length));
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
    this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
    this.write(zipUtil.getLongBytes(fileOffset));
    this.write(name);
    this.write(extra);
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    this.write(zipUtil.getLongBytes(constants.SIG_DD));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    if (ae.isZip64()) {
      this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
      this.write(zipUtil.getEightBytes(ae.getSize()));
    } else {
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
  };
  ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var name = ae.getName();
    var extra = ae.getLocalFileDataExtra();
    if (ae.isZip64()) {
      gpb.useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
    }
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
    }
    ae._offsets.file = this.offset;
    this.write(zipUtil.getLongBytes(constants.SIG_LFH));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    ae._offsets.data = this.offset;
    if (gpb.usesDataDescriptor()) {
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
    } else {
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(name);
    this.write(extra);
    ae._offsets.contents = this.offset;
  };
  ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
  };
  ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
  };
  ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
  };
});

// node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS((exports, module) => {
  module.exports = {
    ArchiveEntry: require_archive_entry(),
    ZipArchiveEntry: require_zip_archive_entry(),
    ArchiveOutputStream: require_archive_output_stream(),
    ZipArchiveOutputStream: require_zip_archive_output_stream()
  };
});

// node_modules/zip-stream/index.js
var require_zip_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
  var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
  var util = require_archiver_utils();
  var ZipStream = module.exports = function(options) {
    if (!(this instanceof ZipStream)) {
      return new ZipStream(options);
    }
    options = this.options = options || {};
    options.zlib = options.zlib || {};
    ZipArchiveOutputStream.call(this, options);
    if (typeof options.level === "number" && options.level >= 0) {
      options.zlib.level = options.level;
      delete options.level;
    }
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
      options.store = true;
    }
    options.namePrependSlash = options.namePrependSlash || false;
    if (options.comment && options.comment.length > 0) {
      this.setComment(options.comment);
    }
  };
  inherits(ZipStream, ZipArchiveOutputStream);
  ZipStream.prototype._normalizeFileData = function(data) {
    data = util.defaults(data, {
      type: "file",
      name: null,
      namePrependSlash: this.options.namePrependSlash,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var isDir = data.type === "directory";
    var isSymlink = data.type === "symlink";
    if (data.name) {
      data.name = util.sanitizePath(data.name);
      if (!isSymlink && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (isDir || isSymlink) {
      data.store = true;
    }
    data.date = util.dateify(data.date);
    return data;
  };
  ZipStream.prototype.entry = function(source, data, callback) {
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    data = this._normalizeFileData(data);
    if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
      callback(new Error(data.type + " entries not currently supported"));
      return;
    }
    if (typeof data.name !== "string" || data.name.length === 0) {
      callback(new Error("entry name must be a non-empty string value"));
      return;
    }
    if (data.type === "symlink" && typeof data.linkname !== "string") {
      callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var entry = new ZipArchiveEntry(data.name);
    entry.setTime(data.date, this.options.forceLocalTime);
    if (data.namePrependSlash) {
      entry.setName(data.name, true);
    }
    if (data.store) {
      entry.setMethod(0);
    }
    if (data.comment.length > 0) {
      entry.setComment(data.comment);
    }
    if (data.type === "symlink" && typeof data.mode !== "number") {
      data.mode = 40960;
    }
    if (typeof data.mode === "number") {
      if (data.type === "symlink") {
        data.mode |= 40960;
      }
      entry.setUnixMode(data.mode);
    }
    if (data.type === "symlink" && typeof data.linkname === "string") {
      source = Buffer.from(data.linkname);
    }
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
  };
  ZipStream.prototype.finalize = function() {
    this.finish();
  };
});

// node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS((exports, module) => {
  var engine = require_zip_stream();
  var util = require_archiver_utils();
  var Zip = function(options) {
    if (!(this instanceof Zip)) {
      return new Zip(options);
    }
    options = this.options = util.defaults(options, {
      comment: "",
      forceUTC: false,
      namePrependSlash: false,
      store: false
    });
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = new engine(options);
  };
  Zip.prototype.append = function(source, data, callback) {
    this.engine.entry(source, data, callback);
  };
  Zip.prototype.finalize = function() {
    this.engine.finalize();
  };
  Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  };
  Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  };
  module.exports = Zip;
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS((exports, module) => {
  module.exports = class FixedFIFO {
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
        throw new Error("Max size for a FixedFIFO should be a power of two");
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    clear() {
      this.top = this.btm = 0;
      this.next = null;
      this.buffer.fill(undefined);
    }
    push(data) {
      if (this.buffer[this.top] !== undefined)
        return false;
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last = this.buffer[this.btm];
      if (last === undefined)
        return;
      this.buffer[this.btm] = undefined;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
    peek() {
      return this.buffer[this.btm];
    }
    isEmpty() {
      return this.buffer[this.btm] === undefined;
    }
  };
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS((exports, module) => {
  var FixedFIFO = require_fixed_size();
  module.exports = class FastFIFO {
    constructor(hwm) {
      this.hwm = hwm || 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.length = 0;
    }
    clear() {
      this.head = this.tail;
      this.head.clear();
      this.length = 0;
    }
    push(val) {
      this.length++;
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      if (this.length !== 0)
        this.length--;
      const val = this.tail.shift();
      if (val === undefined && this.tail.next) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        return this.tail.shift();
      }
      return val;
    }
    peek() {
      const val = this.tail.peek();
      if (val === undefined && this.tail.next)
        return this.tail.next.peek();
      return val;
    }
    isEmpty() {
      return this.length === 0;
    }
  };
});

// node_modules/b4a/index.js
var require_b4a = __commonJS((exports, module) => {
  function isBuffer(value) {
    return Buffer.isBuffer(value) || value instanceof Uint8Array;
  }
  function isEncoding(encoding) {
    return Buffer.isEncoding(encoding);
  }
  function alloc(size, fill2, encoding) {
    return Buffer.alloc(size, fill2, encoding);
  }
  function allocUnsafe(size) {
    return Buffer.allocUnsafe(size);
  }
  function allocUnsafeSlow(size) {
    return Buffer.allocUnsafeSlow(size);
  }
  function byteLength(string, encoding) {
    return Buffer.byteLength(string, encoding);
  }
  function compare(a, b) {
    return Buffer.compare(a, b);
  }
  function concat(buffers, totalLength) {
    return Buffer.concat(buffers, totalLength);
  }
  function copy(source, target, targetStart, start, end) {
    return toBuffer(source).copy(target, targetStart, start, end);
  }
  function equals(a, b) {
    return toBuffer(a).equals(b);
  }
  function fill(buffer, value, offset, end, encoding) {
    return toBuffer(buffer).fill(value, offset, end, encoding);
  }
  function from(value, encodingOrOffset, length) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  function includes(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).includes(value, byteOffset, encoding);
  }
  function indexOf(buffer, value, byfeOffset, encoding) {
    return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
  }
  function lastIndexOf(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
  }
  function swap16(buffer) {
    return toBuffer(buffer).swap16();
  }
  function swap32(buffer) {
    return toBuffer(buffer).swap32();
  }
  function swap64(buffer) {
    return toBuffer(buffer).swap64();
  }
  function toBuffer(buffer) {
    if (Buffer.isBuffer(buffer))
      return buffer;
    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function toString(buffer, encoding, start, end) {
    return toBuffer(buffer).toString(encoding, start, end);
  }
  function write(buffer, string, offset, length, encoding) {
    return toBuffer(buffer).write(string, offset, length, encoding);
  }
  function readDoubleBE(buffer, offset) {
    return toBuffer(buffer).readDoubleBE(offset);
  }
  function readDoubleLE(buffer, offset) {
    return toBuffer(buffer).readDoubleLE(offset);
  }
  function readFloatBE(buffer, offset) {
    return toBuffer(buffer).readFloatBE(offset);
  }
  function readFloatLE(buffer, offset) {
    return toBuffer(buffer).readFloatLE(offset);
  }
  function readInt32BE(buffer, offset) {
    return toBuffer(buffer).readInt32BE(offset);
  }
  function readInt32LE(buffer, offset) {
    return toBuffer(buffer).readInt32LE(offset);
  }
  function readUInt32BE(buffer, offset) {
    return toBuffer(buffer).readUInt32BE(offset);
  }
  function readUInt32LE(buffer, offset) {
    return toBuffer(buffer).readUInt32LE(offset);
  }
  function writeDoubleBE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleBE(value, offset);
  }
  function writeDoubleLE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleLE(value, offset);
  }
  function writeFloatBE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatBE(value, offset);
  }
  function writeFloatLE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatLE(value, offset);
  }
  function writeInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32BE(value, offset);
  }
  function writeInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32LE(value, offset);
  }
  function writeUInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32BE(value, offset);
  }
  function writeUInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32LE(value, offset);
  }
  module.exports = {
    isBuffer,
    isEncoding,
    alloc,
    allocUnsafe,
    allocUnsafeSlow,
    byteLength,
    compare,
    concat,
    copy,
    equals,
    fill,
    from,
    includes,
    indexOf,
    lastIndexOf,
    swap16,
    swap32,
    swap64,
    toBuffer,
    toString,
    write,
    readDoubleBE,
    readDoubleLE,
    readFloatBE,
    readFloatLE,
    readInt32BE,
    readInt32LE,
    readUInt32BE,
    readUInt32LE,
    writeDoubleBE,
    writeDoubleLE,
    writeFloatBE,
    writeFloatLE,
    writeInt32BE,
    writeInt32LE,
    writeUInt32BE,
    writeUInt32LE
  };
});

// node_modules/text-decoder/lib/pass-through-decoder.js
var require_pass_through_decoder = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class PassThroughDecoder {
    constructor(encoding) {
      this.encoding = encoding;
    }
    get remaining() {
      return 0;
    }
    decode(tail) {
      return b4a.toString(tail, this.encoding);
    }
    flush() {
      return "";
    }
  };
});

// node_modules/text-decoder/lib/utf8-decoder.js
var require_utf8_decoder = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class UTF8Decoder {
    constructor() {
      this.codePoint = 0;
      this.bytesSeen = 0;
      this.bytesNeeded = 0;
      this.lowerBoundary = 128;
      this.upperBoundary = 191;
    }
    get remaining() {
      return this.bytesSeen;
    }
    decode(data) {
      if (this.bytesNeeded === 0) {
        let isBoundary = true;
        for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength;i < n && isBoundary; i++) {
          isBoundary = data[i] <= 127;
        }
        if (isBoundary)
          return b4a.toString(data, "utf8");
      }
      let result = "";
      for (let i = 0, n = data.byteLength;i < n; i++) {
        const byte = data[i];
        if (this.bytesNeeded === 0) {
          if (byte <= 127) {
            result += String.fromCharCode(byte);
          } else {
            this.bytesSeen = 1;
            if (byte >= 194 && byte <= 223) {
              this.bytesNeeded = 2;
              this.codePoint = byte & 31;
            } else if (byte >= 224 && byte <= 239) {
              if (byte === 224)
                this.lowerBoundary = 160;
              else if (byte === 237)
                this.upperBoundary = 159;
              this.bytesNeeded = 3;
              this.codePoint = byte & 15;
            } else if (byte >= 240 && byte <= 244) {
              if (byte === 240)
                this.lowerBoundary = 144;
              if (byte === 244)
                this.upperBoundary = 143;
              this.bytesNeeded = 4;
              this.codePoint = byte & 7;
            } else {
              result += "";
            }
          }
          continue;
        }
        if (byte < this.lowerBoundary || byte > this.upperBoundary) {
          this.codePoint = 0;
          this.bytesNeeded = 0;
          this.bytesSeen = 0;
          this.lowerBoundary = 128;
          this.upperBoundary = 191;
          result += "";
          continue;
        }
        this.lowerBoundary = 128;
        this.upperBoundary = 191;
        this.codePoint = this.codePoint << 6 | byte & 63;
        this.bytesSeen++;
        if (this.bytesSeen !== this.bytesNeeded)
          continue;
        result += String.fromCodePoint(this.codePoint);
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
      }
      return result;
    }
    flush() {
      const result = this.bytesNeeded > 0 ? "" : "";
      this.codePoint = 0;
      this.bytesNeeded = 0;
      this.bytesSeen = 0;
      this.lowerBoundary = 128;
      this.upperBoundary = 191;
      return result;
    }
  };
});

// node_modules/text-decoder/index.js
var require_text_decoder = __commonJS((exports, module) => {
  var PassThroughDecoder = require_pass_through_decoder();
  var UTF8Decoder = require_utf8_decoder();
  module.exports = class TextDecoder2 {
    constructor(encoding = "utf8") {
      this.encoding = normalizeEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.decoder = new UTF8Decoder;
          break;
        case "utf16le":
        case "base64":
          throw new Error("Unsupported encoding: " + this.encoding);
        default:
          this.decoder = new PassThroughDecoder(this.encoding);
      }
    }
    get remaining() {
      return this.decoder.remaining;
    }
    push(data) {
      if (typeof data === "string")
        return data;
      return this.decoder.decode(data);
    }
    write(data) {
      return this.push(data);
    }
    end(data) {
      let result = "";
      if (data)
        result = this.push(data);
      result += this.decoder.flush();
      return result;
    }
  };
  function normalizeEncoding(encoding) {
    encoding = encoding.toLowerCase();
    switch (encoding) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return encoding;
      default:
        throw new Error("Unknown encoding: " + encoding);
    }
  }
});

// node_modules/streamx/index.js
var require_streamx = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var STREAM_DESTROYED = new Error("Stream was destroyed");
  var PREMATURE_CLOSE = new Error("Premature close");
  var FIFO = require_fast_fifo();
  var TextDecoder2 = require_text_decoder();
  var qmt = typeof queueMicrotask === "undefined" ? (fn) => global.process.nextTick(fn) : queueMicrotask;
  var MAX = (1 << 29) - 1;
  var OPENING = 1;
  var PREDESTROYING = 2;
  var DESTROYING = 4;
  var DESTROYED = 8;
  var NOT_OPENING = MAX ^ OPENING;
  var NOT_PREDESTROYING = MAX ^ PREDESTROYING;
  var READ_ACTIVE = 1 << 4;
  var READ_UPDATING = 2 << 4;
  var READ_PRIMARY = 4 << 4;
  var READ_QUEUED = 8 << 4;
  var READ_RESUMED = 16 << 4;
  var READ_PIPE_DRAINED = 32 << 4;
  var READ_ENDING = 64 << 4;
  var READ_EMIT_DATA = 128 << 4;
  var READ_EMIT_READABLE = 256 << 4;
  var READ_EMITTED_READABLE = 512 << 4;
  var READ_DONE = 1024 << 4;
  var READ_NEXT_TICK = 2048 << 4;
  var READ_NEEDS_PUSH = 4096 << 4;
  var READ_READ_AHEAD = 8192 << 4;
  var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
  var READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
  var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
  var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
  var READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
  var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
  var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
  var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
  var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
  var READ_PAUSED = MAX ^ READ_RESUMED;
  var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
  var READ_NOT_ENDING = MAX ^ READ_ENDING;
  var READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
  var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
  var READ_NOT_UPDATING = MAX ^ READ_UPDATING;
  var READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
  var READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
  var WRITE_ACTIVE = 1 << 18;
  var WRITE_UPDATING = 2 << 18;
  var WRITE_PRIMARY = 4 << 18;
  var WRITE_QUEUED = 8 << 18;
  var WRITE_UNDRAINED = 16 << 18;
  var WRITE_DONE = 32 << 18;
  var WRITE_EMIT_DRAIN = 64 << 18;
  var WRITE_NEXT_TICK = 128 << 18;
  var WRITE_WRITING = 256 << 18;
  var WRITE_FINISHING = 512 << 18;
  var WRITE_CORKED = 1024 << 18;
  var WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
  var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
  var WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
  var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
  var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
  var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
  var WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
  var WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
  var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
  var NOT_ACTIVE = MAX ^ ACTIVE;
  var DONE = READ_DONE | WRITE_DONE;
  var DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
  var OPEN_STATUS = DESTROY_STATUS | OPENING;
  var AUTO_DESTROY = DESTROY_STATUS | DONE;
  var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
  var ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
  var TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
  var IS_OPENING = OPEN_STATUS | TICKING;
  var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
  var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
  var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
  var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
  var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
  var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
  var READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
  var READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
  var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
  var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
  var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
  var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
  var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
  var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
  var WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
  var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
  var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
  var WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
  var WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
  var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");

  class WritableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
      this.stream = stream;
      this.queue = new FIFO;
      this.highWaterMark = highWaterMark;
      this.buffered = 0;
      this.error = null;
      this.pipeline = null;
      this.drains = null;
      this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
      this.map = mapWritable || map;
      this.afterWrite = afterWrite.bind(this);
      this.afterUpdateNextTick = updateWriteNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & WRITE_DONE) !== 0;
    }
    push(data) {
      if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0)
        return false;
      if (this.map !== null)
        data = this.map(data);
      this.buffered += this.byteLength(data);
      this.queue.push(data);
      if (this.buffered < this.highWaterMark) {
        this.stream._duplexState |= WRITE_QUEUED;
        return true;
      }
      this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
      return false;
    }
    shift() {
      const data = this.queue.shift();
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0)
        this.stream._duplexState &= WRITE_NOT_QUEUED;
      return data;
    }
    end(data) {
      if (typeof data === "function")
        this.stream.once("finish", data);
      else if (data !== undefined && data !== null)
        this.push(data);
      this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
    }
    autoBatch(data, cb) {
      const buffer = [];
      const stream = this.stream;
      buffer.push(data);
      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
        buffer.push(stream._writableState.shift());
      }
      if ((stream._duplexState & OPEN_STATUS) !== 0)
        return cb(null);
      stream._writev(buffer, cb);
    }
    update() {
      const stream = this.stream;
      stream._duplexState |= WRITE_UPDATING;
      do {
        while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
          const data = this.shift();
          stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
          stream._write(data, this.afterWrite);
        }
        if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === true);
      stream._duplexState &= WRITE_NOT_UPDATING;
    }
    updateNonPrimary() {
      const stream = this.stream;
      if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
        stream._duplexState = stream._duplexState | WRITE_ACTIVE;
        stream._final(afterFinal.bind(this));
        return;
      }
      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;
          stream._destroy(afterDestroy.bind(this));
        }
        return;
      }
      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
        stream._open(afterOpen.bind(this));
      }
    }
    continueUpdate() {
      if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0)
        return false;
      this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
      return true;
    }
    updateCallback() {
      if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTick() {
      if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0)
        return;
      this.stream._duplexState |= WRITE_NEXT_TICK;
      if ((this.stream._duplexState & WRITE_UPDATING) === 0)
        qmt(this.afterUpdateNextTick);
    }
  }

  class ReadableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
      this.stream = stream;
      this.queue = new FIFO;
      this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
      this.buffered = 0;
      this.readAhead = highWaterMark > 0;
      this.error = null;
      this.pipeline = null;
      this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
      this.map = mapReadable || map;
      this.pipeTo = null;
      this.afterRead = afterRead.bind(this);
      this.afterUpdateNextTick = updateReadNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & READ_DONE) !== 0;
    }
    pipe(pipeTo, cb) {
      if (this.pipeTo !== null)
        throw new Error("Can only pipe to one destination");
      if (typeof cb !== "function")
        cb = null;
      this.stream._duplexState |= READ_PIPE_DRAINED;
      this.pipeTo = pipeTo;
      this.pipeline = new Pipeline(this.stream, pipeTo, cb);
      if (cb)
        this.stream.on("error", noop);
      if (isStreamx(pipeTo)) {
        pipeTo._writableState.pipeline = this.pipeline;
        if (cb)
          pipeTo.on("error", noop);
        pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      } else {
        const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
        const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
        pipeTo.on("error", onerror);
        pipeTo.on("close", onclose);
        pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      }
      pipeTo.on("drain", afterDrain.bind(this));
      this.stream.emit("piping", pipeTo);
      pipeTo.emit("pipe", this.stream);
    }
    push(data) {
      const stream = this.stream;
      if (data === null) {
        this.highWaterMark = 0;
        stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
        return false;
      }
      if (this.map !== null) {
        data = this.map(data);
        if (data === null) {
          stream._duplexState &= READ_PUSHED;
          return this.buffered < this.highWaterMark;
        }
      }
      this.buffered += this.byteLength(data);
      this.queue.push(data);
      stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
      return this.buffered < this.highWaterMark;
    }
    shift() {
      const data = this.queue.shift();
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0)
        this.stream._duplexState &= READ_NOT_QUEUED;
      return data;
    }
    unshift(data) {
      const pending = [this.map !== null ? this.map(data) : data];
      while (this.buffered > 0)
        pending.push(this.shift());
      for (let i = 0;i < pending.length - 1; i++) {
        const data2 = pending[i];
        this.buffered += this.byteLength(data2);
        this.queue.push(data2);
      }
      this.push(pending[pending.length - 1]);
    }
    read() {
      const stream = this.stream;
      if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false)
          stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0)
          stream.emit("data", data);
        return data;
      }
      if (this.readAhead === false) {
        stream._duplexState |= READ_READ_AHEAD;
        this.updateNextTick();
      }
      return null;
    }
    drain() {
      const stream = this.stream;
      while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false)
          stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0)
          stream.emit("data", data);
      }
    }
    update() {
      const stream = this.stream;
      stream._duplexState |= READ_UPDATING;
      do {
        this.drain();
        while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
          stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
          stream._read(this.afterRead);
          this.drain();
        }
        if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
          stream._duplexState |= READ_EMITTED_READABLE;
          stream.emit("readable");
        }
        if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === true);
      stream._duplexState &= READ_NOT_UPDATING;
    }
    updateNonPrimary() {
      const stream = this.stream;
      if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
        stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
        stream.emit("end");
        if ((stream._duplexState & AUTO_DESTROY) === DONE)
          stream._duplexState |= DESTROYING;
        if (this.pipeTo !== null)
          this.pipeTo.end();
      }
      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;
          stream._destroy(afterDestroy.bind(this));
        }
        return;
      }
      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
        stream._open(afterOpen.bind(this));
      }
    }
    continueUpdate() {
      if ((this.stream._duplexState & READ_NEXT_TICK) === 0)
        return false;
      this.stream._duplexState &= READ_NOT_NEXT_TICK;
      return true;
    }
    updateCallback() {
      if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTickIfOpen() {
      if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0)
        return;
      this.stream._duplexState |= READ_NEXT_TICK;
      if ((this.stream._duplexState & READ_UPDATING) === 0)
        qmt(this.afterUpdateNextTick);
    }
    updateNextTick() {
      if ((this.stream._duplexState & READ_NEXT_TICK) !== 0)
        return;
      this.stream._duplexState |= READ_NEXT_TICK;
      if ((this.stream._duplexState & READ_UPDATING) === 0)
        qmt(this.afterUpdateNextTick);
    }
  }

  class TransformState {
    constructor(stream) {
      this.data = null;
      this.afterTransform = afterTransform.bind(stream);
      this.afterFinal = null;
    }
  }

  class Pipeline {
    constructor(src, dst, cb) {
      this.from = src;
      this.to = dst;
      this.afterPipe = cb;
      this.error = null;
      this.pipeToFinished = false;
    }
    finished() {
      this.pipeToFinished = true;
    }
    done(stream, err) {
      if (err)
        this.error = err;
      if (stream === this.to) {
        this.to = null;
        if (this.from !== null) {
          if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
            this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
          }
          return;
        }
      }
      if (stream === this.from) {
        this.from = null;
        if (this.to !== null) {
          if ((stream._duplexState & READ_DONE) === 0) {
            this.to.destroy(this.error || new Error("Readable stream closed before ending"));
          }
          return;
        }
      }
      if (this.afterPipe !== null)
        this.afterPipe(this.error);
      this.to = this.from = this.afterPipe = null;
    }
  }
  function afterDrain() {
    this.stream._duplexState |= READ_PIPE_DRAINED;
    this.updateCallback();
  }
  function afterFinal(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & DESTROY_STATUS) === 0) {
      stream._duplexState |= WRITE_DONE;
      stream.emit("finish");
    }
    if ((stream._duplexState & AUTO_DESTROY) === DONE) {
      stream._duplexState |= DESTROYING;
    }
    stream._duplexState &= WRITE_NOT_FINISHING;
    if ((stream._duplexState & WRITE_UPDATING) === 0)
      this.update();
    else
      this.updateNextTick();
  }
  function afterDestroy(err) {
    const stream = this.stream;
    if (!err && this.error !== STREAM_DESTROYED)
      err = this.error;
    if (err)
      stream.emit("error", err);
    stream._duplexState |= DESTROYED;
    stream.emit("close");
    const rs = stream._readableState;
    const ws = stream._writableState;
    if (rs !== null && rs.pipeline !== null)
      rs.pipeline.done(stream, err);
    if (ws !== null) {
      while (ws.drains !== null && ws.drains.length > 0)
        ws.drains.shift().resolve(false);
      if (ws.pipeline !== null)
        ws.pipeline.done(stream, err);
    }
  }
  function afterWrite(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    stream._duplexState &= WRITE_NOT_ACTIVE;
    if (this.drains !== null)
      tickDrains(this.drains);
    if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
      stream._duplexState &= WRITE_DRAINED;
      if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
        stream.emit("drain");
      }
    }
    this.updateCallback();
  }
  function afterRead(err) {
    if (err)
      this.stream.destroy(err);
    this.stream._duplexState &= READ_NOT_ACTIVE;
    if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0)
      this.stream._duplexState &= READ_NO_READ_AHEAD;
    this.updateCallback();
  }
  function updateReadNT() {
    if ((this.stream._duplexState & READ_UPDATING) === 0) {
      this.stream._duplexState &= READ_NOT_NEXT_TICK;
      this.update();
    }
  }
  function updateWriteNT() {
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
      this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
      this.update();
    }
  }
  function tickDrains(drains) {
    for (let i = 0;i < drains.length; i++) {
      if (--drains[i].writes === 0) {
        drains.shift().resolve(true);
        i--;
      }
    }
  }
  function afterOpen(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & DESTROYING) === 0) {
      if ((stream._duplexState & READ_PRIMARY_STATUS) === 0)
        stream._duplexState |= READ_PRIMARY;
      if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0)
        stream._duplexState |= WRITE_PRIMARY;
      stream.emit("open");
    }
    stream._duplexState &= NOT_ACTIVE;
    if (stream._writableState !== null) {
      stream._writableState.updateCallback();
    }
    if (stream._readableState !== null) {
      stream._readableState.updateCallback();
    }
  }
  function afterTransform(err, data) {
    if (data !== undefined && data !== null)
      this.push(data);
    this._writableState.afterWrite(err);
  }
  function newListener(name) {
    if (this._readableState !== null) {
      if (name === "data") {
        this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
      }
      if (name === "readable") {
        this._duplexState |= READ_EMIT_READABLE;
        this._readableState.updateNextTick();
      }
    }
    if (this._writableState !== null) {
      if (name === "drain") {
        this._duplexState |= WRITE_EMIT_DRAIN;
        this._writableState.updateNextTick();
      }
    }
  }

  class Stream extends EventEmitter {
    constructor(opts) {
      super();
      this._duplexState = 0;
      this._readableState = null;
      this._writableState = null;
      if (opts) {
        if (opts.open)
          this._open = opts.open;
        if (opts.destroy)
          this._destroy = opts.destroy;
        if (opts.predestroy)
          this._predestroy = opts.predestroy;
        if (opts.signal) {
          opts.signal.addEventListener("abort", abort.bind(this));
        }
      }
      this.on("newListener", newListener);
    }
    _open(cb) {
      cb(null);
    }
    _destroy(cb) {
      cb(null);
    }
    _predestroy() {}
    get readable() {
      return this._readableState !== null ? true : undefined;
    }
    get writable() {
      return this._writableState !== null ? true : undefined;
    }
    get destroyed() {
      return (this._duplexState & DESTROYED) !== 0;
    }
    get destroying() {
      return (this._duplexState & DESTROY_STATUS) !== 0;
    }
    destroy(err) {
      if ((this._duplexState & DESTROY_STATUS) === 0) {
        if (!err)
          err = STREAM_DESTROYED;
        this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
        if (this._readableState !== null) {
          this._readableState.highWaterMark = 0;
          this._readableState.error = err;
        }
        if (this._writableState !== null) {
          this._writableState.highWaterMark = 0;
          this._writableState.error = err;
        }
        this._duplexState |= PREDESTROYING;
        this._predestroy();
        this._duplexState &= NOT_PREDESTROYING;
        if (this._readableState !== null)
          this._readableState.updateNextTick();
        if (this._writableState !== null)
          this._writableState.updateNextTick();
      }
    }
  }

  class Readable extends Stream {
    constructor(opts) {
      super(opts);
      this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
      this._readableState = new ReadableState(this, opts);
      if (opts) {
        if (this._readableState.readAhead === false)
          this._duplexState &= READ_NO_READ_AHEAD;
        if (opts.read)
          this._read = opts.read;
        if (opts.eagerOpen)
          this._readableState.updateNextTick();
        if (opts.encoding)
          this.setEncoding(opts.encoding);
      }
    }
    setEncoding(encoding) {
      const dec = new TextDecoder2(encoding);
      const map = this._readableState.map || echo;
      this._readableState.map = mapOrSkip;
      return this;
      function mapOrSkip(data) {
        const next = dec.push(data);
        return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
      }
    }
    _read(cb) {
      cb(null);
    }
    pipe(dest, cb) {
      this._readableState.updateNextTick();
      this._readableState.pipe(dest, cb);
      return dest;
    }
    read() {
      this._readableState.updateNextTick();
      return this._readableState.read();
    }
    push(data) {
      this._readableState.updateNextTickIfOpen();
      return this._readableState.push(data);
    }
    unshift(data) {
      this._readableState.updateNextTickIfOpen();
      return this._readableState.unshift(data);
    }
    resume() {
      this._duplexState |= READ_RESUMED_READ_AHEAD;
      this._readableState.updateNextTick();
      return this;
    }
    pause() {
      this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
      return this;
    }
    static _fromAsyncIterator(ite, opts) {
      let destroy;
      const rs = new Readable({
        ...opts,
        read(cb) {
          ite.next().then(push).then(cb.bind(null, null)).catch(cb);
        },
        predestroy() {
          destroy = ite.return();
        },
        destroy(cb) {
          if (!destroy)
            return cb(null);
          destroy.then(cb.bind(null, null)).catch(cb);
        }
      });
      return rs;
      function push(data) {
        if (data.done)
          rs.push(null);
        else
          rs.push(data.value);
      }
    }
    static from(data, opts) {
      if (isReadStreamx(data))
        return data;
      if (data[asyncIterator])
        return this._fromAsyncIterator(data[asyncIterator](), opts);
      if (!Array.isArray(data))
        data = data === undefined ? [] : [data];
      let i = 0;
      return new Readable({
        ...opts,
        read(cb) {
          this.push(i === data.length ? null : data[i++]);
          cb(null);
        }
      });
    }
    static isBackpressured(rs) {
      return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
    }
    static isPaused(rs) {
      return (rs._duplexState & READ_RESUMED) === 0;
    }
    [asyncIterator]() {
      const stream = this;
      let error = null;
      let promiseResolve = null;
      let promiseReject = null;
      this.on("error", (err) => {
        error = err;
      });
      this.on("readable", onreadable);
      this.on("close", onclose);
      return {
        [asyncIterator]() {
          return this;
        },
        next() {
          return new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
            const data = stream.read();
            if (data !== null)
              ondata(data);
            else if ((stream._duplexState & DESTROYED) !== 0)
              ondata(null);
          });
        },
        return() {
          return destroy(null);
        },
        throw(err) {
          return destroy(err);
        }
      };
      function onreadable() {
        if (promiseResolve !== null)
          ondata(stream.read());
      }
      function onclose() {
        if (promiseResolve !== null)
          ondata(null);
      }
      function ondata(data) {
        if (promiseReject === null)
          return;
        if (error)
          promiseReject(error);
        else if (data === null && (stream._duplexState & READ_DONE) === 0)
          promiseReject(STREAM_DESTROYED);
        else
          promiseResolve({ value: data, done: data === null });
        promiseReject = promiseResolve = null;
      }
      function destroy(err) {
        stream.destroy(err);
        return new Promise((resolve, reject) => {
          if (stream._duplexState & DESTROYED)
            return resolve({ value: undefined, done: true });
          stream.once("close", function() {
            if (err)
              reject(err);
            else
              resolve({ value: undefined, done: true });
          });
        });
      }
    }
  }

  class Writable extends Stream {
    constructor(opts) {
      super(opts);
      this._duplexState |= OPENING | READ_DONE;
      this._writableState = new WritableState(this, opts);
      if (opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
        if (opts.eagerOpen)
          this._writableState.updateNextTick();
      }
    }
    cork() {
      this._duplexState |= WRITE_CORKED;
    }
    uncork() {
      this._duplexState &= WRITE_NOT_CORKED;
      this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    static isBackpressured(ws) {
      return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
    }
    static drained(ws) {
      if (ws.destroyed)
        return Promise.resolve(false);
      const state = ws._writableState;
      const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
      const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
      if (writes === 0)
        return Promise.resolve(true);
      if (state.drains === null)
        state.drains = [];
      return new Promise((resolve) => {
        state.drains.push({ writes, resolve });
      });
    }
    write(data) {
      this._writableState.updateNextTick();
      return this._writableState.push(data);
    }
    end(data) {
      this._writableState.updateNextTick();
      this._writableState.end(data);
      return this;
    }
  }

  class Duplex extends Readable {
    constructor(opts) {
      super(opts);
      this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
      this._writableState = new WritableState(this, opts);
      if (opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
      }
    }
    cork() {
      this._duplexState |= WRITE_CORKED;
    }
    uncork() {
      this._duplexState &= WRITE_NOT_CORKED;
      this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    write(data) {
      this._writableState.updateNextTick();
      return this._writableState.push(data);
    }
    end(data) {
      this._writableState.updateNextTick();
      this._writableState.end(data);
      return this;
    }
  }

  class Transform extends Duplex {
    constructor(opts) {
      super(opts);
      this._transformState = new TransformState(this);
      if (opts) {
        if (opts.transform)
          this._transform = opts.transform;
        if (opts.flush)
          this._flush = opts.flush;
      }
    }
    _write(data, cb) {
      if (this._readableState.buffered >= this._readableState.highWaterMark) {
        this._transformState.data = data;
      } else {
        this._transform(data, this._transformState.afterTransform);
      }
    }
    _read(cb) {
      if (this._transformState.data !== null) {
        const data = this._transformState.data;
        this._transformState.data = null;
        cb(null);
        this._transform(data, this._transformState.afterTransform);
      } else {
        cb(null);
      }
    }
    destroy(err) {
      super.destroy(err);
      if (this._transformState.data !== null) {
        this._transformState.data = null;
        this._transformState.afterTransform();
      }
    }
    _transform(data, cb) {
      cb(null, data);
    }
    _flush(cb) {
      cb(null);
    }
    _final(cb) {
      this._transformState.afterFinal = cb;
      this._flush(transformAfterFlush.bind(this));
    }
  }

  class PassThrough extends Transform {
  }
  function transformAfterFlush(err, data) {
    const cb = this._transformState.afterFinal;
    if (err)
      return cb(err);
    if (data !== null && data !== undefined)
      this.push(data);
    this.push(null);
    cb(null);
  }
  function pipelinePromise(...streams) {
    return new Promise((resolve, reject) => {
      return pipeline(...streams, (err) => {
        if (err)
          return reject(err);
        resolve();
      });
    });
  }
  function pipeline(stream, ...streams) {
    const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
    const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
    if (all.length < 2)
      throw new Error("Pipeline requires at least 2 streams");
    let src = all[0];
    let dest = null;
    let error = null;
    for (let i = 1;i < all.length; i++) {
      dest = all[i];
      if (isStreamx(src)) {
        src.pipe(dest, onerror);
      } else {
        errorHandle(src, true, i > 1, onerror);
        src.pipe(dest);
      }
      src = dest;
    }
    if (done) {
      let fin = false;
      const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
      dest.on("error", (err) => {
        if (error === null)
          error = err;
      });
      dest.on("finish", () => {
        fin = true;
        if (!autoDestroy)
          done(error);
      });
      if (autoDestroy) {
        dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
      }
    }
    return dest;
    function errorHandle(s, rd, wr, onerror2) {
      s.on("error", onerror2);
      s.on("close", onclose);
      function onclose() {
        if (rd && s._readableState && !s._readableState.ended)
          return onerror2(PREMATURE_CLOSE);
        if (wr && s._writableState && !s._writableState.ended)
          return onerror2(PREMATURE_CLOSE);
      }
    }
    function onerror(err) {
      if (!err || error)
        return;
      error = err;
      for (const s of all) {
        s.destroy(err);
      }
    }
  }
  function echo(s) {
    return s;
  }
  function isStream(stream) {
    return !!stream._readableState || !!stream._writableState;
  }
  function isStreamx(stream) {
    return typeof stream._duplexState === "number" && isStream(stream);
  }
  function isEnded(stream) {
    return !!stream._readableState && stream._readableState.ended;
  }
  function isFinished(stream) {
    return !!stream._writableState && stream._writableState.ended;
  }
  function getStreamError(stream, opts = {}) {
    const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
    return !opts.all && err === STREAM_DESTROYED ? null : err;
  }
  function isReadStreamx(stream) {
    return isStreamx(stream) && stream.readable;
  }
  function isDisturbed(stream) {
    return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
  }
  function isTypedArray(data) {
    return typeof data === "object" && data !== null && typeof data.byteLength === "number";
  }
  function defaultByteLength(data) {
    return isTypedArray(data) ? data.byteLength : 1024;
  }
  function noop() {}
  function abort() {
    this.destroy(new Error("Stream aborted."));
  }
  function isWritev(s) {
    return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
  }
  module.exports = {
    pipeline,
    pipelinePromise,
    isStream,
    isStreamx,
    isEnded,
    isFinished,
    isDisturbed,
    getStreamError,
    Stream,
    Writable,
    Readable,
    Duplex,
    Transform,
    PassThrough
  };
});

// node_modules/tar-stream/headers.js
var require_headers2 = __commonJS((exports) => {
  var b4a = require_b4a();
  var ZEROS = "0000000000000000000";
  var SEVENS = "7777777777777777777";
  var ZERO_OFFSET = 48;
  var USTAR_MAGIC = b4a.from([117, 115, 116, 97, 114, 0]);
  var USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET]);
  var GNU_MAGIC = b4a.from([117, 115, 116, 97, 114, 32]);
  var GNU_VER = b4a.from([32, 0]);
  var MASK = 4095;
  var MAGIC_OFFSET = 257;
  var VERSION_OFFSET = 263;
  exports.decodeLongPath = function decodeLongPath(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
  };
  exports.encodePax = function encodePax(opts) {
    let result = "";
    if (opts.name)
      result += addLength(" path=" + opts.name + `
`);
    if (opts.linkname)
      result += addLength(" linkpath=" + opts.linkname + `
`);
    const pax = opts.pax;
    if (pax) {
      for (const key in pax) {
        result += addLength(" " + key + "=" + pax[key] + `
`);
      }
    }
    return b4a.from(result);
  };
  exports.decodePax = function decodePax(buf) {
    const result = {};
    while (buf.length) {
      let i = 0;
      while (i < buf.length && buf[i] !== 32)
        i++;
      const len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
      if (!len)
        return result;
      const b = b4a.toString(buf.subarray(i + 1, len - 1));
      const keyIndex = b.indexOf("=");
      if (keyIndex === -1)
        return result;
      result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
      buf = buf.subarray(len);
    }
    return result;
  };
  exports.encode = function encode(opts) {
    const buf = b4a.alloc(512);
    let name = opts.name;
    let prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/")
      name += "/";
    if (b4a.byteLength(name) !== name.length)
      return null;
    while (b4a.byteLength(name) > 100) {
      const i = name.indexOf("/");
      if (i === -1)
        return null;
      prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }
    if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155)
      return null;
    if (opts.linkname && b4a.byteLength(opts.linkname) > 100)
      return null;
    b4a.write(buf, name);
    b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100);
    b4a.write(buf, encodeOct(opts.uid, 6), 108);
    b4a.write(buf, encodeOct(opts.gid, 6), 116);
    encodeSize(opts.size, buf, 124);
    b4a.write(buf, encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname)
      b4a.write(buf, opts.linkname, 157);
    b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
    b4a.copy(USTAR_VER, buf, VERSION_OFFSET);
    if (opts.uname)
      b4a.write(buf, opts.uname, 265);
    if (opts.gname)
      b4a.write(buf, opts.gname, 297);
    b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
    b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337);
    if (prefix)
      b4a.write(buf, prefix, 345);
    b4a.write(buf, encodeOct(cksum(buf), 6), 148);
    return buf;
  };
  exports.decode = function decode(buf, filenameEncoding, allowUnknownFormat) {
    let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    let name = decodeStr(buf, 0, 100, filenameEncoding);
    const mode = decodeOct(buf, 100, 8);
    const uid = decodeOct(buf, 108, 8);
    const gid = decodeOct(buf, 116, 8);
    const size = decodeOct(buf, 124, 12);
    const mtime = decodeOct(buf, 136, 12);
    const type = toType(typeflag);
    const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    const uname = decodeStr(buf, 265, 32);
    const gname = decodeStr(buf, 297, 32);
    const devmajor = decodeOct(buf, 329, 8);
    const devminor = decodeOct(buf, 337, 8);
    const c = cksum(buf);
    if (c === 8 * 32)
      return null;
    if (c !== decodeOct(buf, 148, 8))
      throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (isUSTAR(buf)) {
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (isGNU(buf)) {} else {
      if (!allowUnknownFormat) {
        throw new Error("Invalid tar header: unknown format.");
      }
    }
    if (typeflag === 0 && name && name[name.length - 1] === "/")
      typeflag = 5;
    return {
      name,
      mode,
      uid,
      gid,
      size,
      mtime: new Date(1000 * mtime),
      type,
      linkname,
      uname,
      gname,
      devmajor,
      devminor,
      pax: null
    };
  };
  function isUSTAR(buf) {
    return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
  }
  function isGNU(buf) {
    return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
  }
  function clamp(index, len, defaultValue) {
    if (typeof index !== "number")
      return defaultValue;
    index = ~~index;
    if (index >= len)
      return len;
    if (index >= 0)
      return index;
    index += len;
    if (index >= 0)
      return index;
    return 0;
  }
  function toType(flag) {
    switch (flag) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  }
  function toTypeflag(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  }
  function indexOf(block, num, offset, end) {
    for (;offset < end; offset++) {
      if (block[offset] === num)
        return offset;
    }
    return end;
  }
  function cksum(block) {
    let sum = 8 * 32;
    for (let i = 0;i < 148; i++)
      sum += block[i];
    for (let j = 156;j < 512; j++)
      sum += block[j];
    return sum;
  }
  function encodeOct(val, n) {
    val = val.toString(8);
    if (val.length > n)
      return SEVENS.slice(0, n) + " ";
    return ZEROS.slice(0, n - val.length) + val + " ";
  }
  function encodeSizeBin(num, buf, off) {
    buf[off] = 128;
    for (let i = 11;i > 0; i--) {
      buf[off + i] = num & 255;
      num = Math.floor(num / 256);
    }
  }
  function encodeSize(num, buf, off) {
    if (num.toString(8).length > 11) {
      encodeSizeBin(num, buf, off);
    } else {
      b4a.write(buf, encodeOct(num, 11), off);
    }
  }
  function parse256(buf) {
    let positive;
    if (buf[0] === 128)
      positive = true;
    else if (buf[0] === 255)
      positive = false;
    else
      return null;
    const tuple = [];
    let i;
    for (i = buf.length - 1;i > 0; i--) {
      const byte = buf[i];
      if (positive)
        tuple.push(byte);
      else
        tuple.push(255 - byte);
    }
    let sum = 0;
    const l = tuple.length;
    for (i = 0;i < l; i++) {
      sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
  }
  function decodeOct(val, offset, length) {
    val = val.subarray(offset, offset + length);
    offset = 0;
    if (val[offset] & 128) {
      return parse256(val);
    } else {
      while (offset < val.length && val[offset] === 32)
        offset++;
      const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
      while (offset < end && val[offset] === 0)
        offset++;
      if (end === offset)
        return 0;
      return parseInt(b4a.toString(val.subarray(offset, end)), 8);
    }
  }
  function decodeStr(val, offset, length, encoding) {
    return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
  }
  function addLength(str) {
    const len = b4a.byteLength(str);
    let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits))
      digits++;
    return len + digits + str;
  }
});

// node_modules/tar-stream/extract.js
var require_extract = __commonJS((exports, module) => {
  var { Writable, Readable, getStreamError } = require_streamx();
  var FIFO = require_fast_fifo();
  var b4a = require_b4a();
  var headers = require_headers2();
  var EMPTY = b4a.alloc(0);

  class BufferList {
    constructor() {
      this.buffered = 0;
      this.shifted = 0;
      this.queue = new FIFO;
      this._offset = 0;
    }
    push(buffer) {
      this.buffered += buffer.byteLength;
      this.queue.push(buffer);
    }
    shiftFirst(size) {
      return this._buffered === 0 ? null : this._next(size);
    }
    shift(size) {
      if (size > this.buffered)
        return null;
      if (size === 0)
        return EMPTY;
      let chunk = this._next(size);
      if (size === chunk.byteLength)
        return chunk;
      const chunks = [chunk];
      while ((size -= chunk.byteLength) > 0) {
        chunk = this._next(size);
        chunks.push(chunk);
      }
      return b4a.concat(chunks);
    }
    _next(size) {
      const buf = this.queue.peek();
      const rem = buf.byteLength - this._offset;
      if (size >= rem) {
        const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
        this.queue.shift();
        this._offset = 0;
        this.buffered -= rem;
        this.shifted += rem;
        return sub;
      }
      this.buffered -= size;
      this.shifted += size;
      return buf.subarray(this._offset, this._offset += size);
    }
  }

  class Source extends Readable {
    constructor(self2, header, offset) {
      super();
      this.header = header;
      this.offset = offset;
      this._parent = self2;
    }
    _read(cb) {
      if (this.header.size === 0) {
        this.push(null);
      }
      if (this._parent._stream === this) {
        this._parent._update();
      }
      cb(null);
    }
    _predestroy() {
      this._parent.destroy(getStreamError(this));
    }
    _detach() {
      if (this._parent._stream === this) {
        this._parent._stream = null;
        this._parent._missing = overflow(this.header.size);
        this._parent._update();
      }
    }
    _destroy(cb) {
      this._detach();
      cb(null);
    }
  }

  class Extract extends Writable {
    constructor(opts) {
      super(opts);
      if (!opts)
        opts = {};
      this._buffer = new BufferList;
      this._offset = 0;
      this._header = null;
      this._stream = null;
      this._missing = 0;
      this._longHeader = false;
      this._callback = noop;
      this._locked = false;
      this._finished = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      this._filenameEncoding = opts.filenameEncoding || "utf-8";
      this._allowUnknownFormat = !!opts.allowUnknownFormat;
      this._unlockBound = this._unlock.bind(this);
    }
    _unlock(err) {
      this._locked = false;
      if (err) {
        this.destroy(err);
        this._continueWrite(err);
        return;
      }
      this._update();
    }
    _consumeHeader() {
      if (this._locked)
        return false;
      this._offset = this._buffer.shifted;
      try {
        this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
      } catch (err) {
        this._continueWrite(err);
        return false;
      }
      if (!this._header)
        return true;
      switch (this._header.type) {
        case "gnu-long-path":
        case "gnu-long-link-path":
        case "pax-global-header":
        case "pax-header":
          this._longHeader = true;
          this._missing = this._header.size;
          return true;
      }
      this._locked = true;
      this._applyLongHeaders();
      if (this._header.size === 0 || this._header.type === "directory") {
        this.emit("entry", this._header, this._createStream(), this._unlockBound);
        return true;
      }
      this._stream = this._createStream();
      this._missing = this._header.size;
      this.emit("entry", this._header, this._stream, this._unlockBound);
      return true;
    }
    _applyLongHeaders() {
      if (this._gnuLongPath) {
        this._header.name = this._gnuLongPath;
        this._gnuLongPath = null;
      }
      if (this._gnuLongLinkPath) {
        this._header.linkname = this._gnuLongLinkPath;
        this._gnuLongLinkPath = null;
      }
      if (this._pax) {
        if (this._pax.path)
          this._header.name = this._pax.path;
        if (this._pax.linkpath)
          this._header.linkname = this._pax.linkpath;
        if (this._pax.size)
          this._header.size = parseInt(this._pax.size, 10);
        this._header.pax = this._pax;
        this._pax = null;
      }
    }
    _decodeLongHeader(buf) {
      switch (this._header.type) {
        case "gnu-long-path":
          this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
          break;
        case "gnu-long-link-path":
          this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
          break;
        case "pax-global-header":
          this._paxGlobal = headers.decodePax(buf);
          break;
        case "pax-header":
          this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
          break;
      }
    }
    _consumeLongHeader() {
      this._longHeader = false;
      this._missing = overflow(this._header.size);
      const buf = this._buffer.shift(this._header.size);
      try {
        this._decodeLongHeader(buf);
      } catch (err) {
        this._continueWrite(err);
        return false;
      }
      return true;
    }
    _consumeStream() {
      const buf = this._buffer.shiftFirst(this._missing);
      if (buf === null)
        return false;
      this._missing -= buf.byteLength;
      const drained = this._stream.push(buf);
      if (this._missing === 0) {
        this._stream.push(null);
        if (drained)
          this._stream._detach();
        return drained && this._locked === false;
      }
      return drained;
    }
    _createStream() {
      return new Source(this, this._header, this._offset);
    }
    _update() {
      while (this._buffer.buffered > 0 && !this.destroying) {
        if (this._missing > 0) {
          if (this._stream !== null) {
            if (this._consumeStream() === false)
              return;
            continue;
          }
          if (this._longHeader === true) {
            if (this._missing > this._buffer.buffered)
              break;
            if (this._consumeLongHeader() === false)
              return false;
            continue;
          }
          const ignore = this._buffer.shiftFirst(this._missing);
          if (ignore !== null)
            this._missing -= ignore.byteLength;
          continue;
        }
        if (this._buffer.buffered < 512)
          break;
        if (this._stream !== null || this._consumeHeader() === false)
          return;
      }
      this._continueWrite(null);
    }
    _continueWrite(err) {
      const cb = this._callback;
      this._callback = noop;
      cb(err);
    }
    _write(data, cb) {
      this._callback = cb;
      this._buffer.push(data);
      this._update();
    }
    _final(cb) {
      this._finished = this._missing === 0 && this._buffer.buffered === 0;
      cb(this._finished ? null : new Error("Unexpected end of data"));
    }
    _predestroy() {
      this._continueWrite(null);
    }
    _destroy(cb) {
      if (this._stream)
        this._stream.destroy(getStreamError(this));
      cb(null);
    }
    [Symbol.asyncIterator]() {
      let error = null;
      let promiseResolve = null;
      let promiseReject = null;
      let entryStream = null;
      let entryCallback = null;
      const extract = this;
      this.on("entry", onentry);
      this.on("error", (err) => {
        error = err;
      });
      this.on("close", onclose);
      return {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          return new Promise(onnext);
        },
        return() {
          return destroy(null);
        },
        throw(err) {
          return destroy(err);
        }
      };
      function consumeCallback(err) {
        if (!entryCallback)
          return;
        const cb = entryCallback;
        entryCallback = null;
        cb(err);
      }
      function onnext(resolve, reject) {
        if (error) {
          return reject(error);
        }
        if (entryStream) {
          resolve({ value: entryStream, done: false });
          entryStream = null;
          return;
        }
        promiseResolve = resolve;
        promiseReject = reject;
        consumeCallback(null);
        if (extract._finished && promiseResolve) {
          promiseResolve({ value: undefined, done: true });
          promiseResolve = promiseReject = null;
        }
      }
      function onentry(header, stream, callback) {
        entryCallback = callback;
        stream.on("error", noop);
        if (promiseResolve) {
          promiseResolve({ value: stream, done: false });
          promiseResolve = promiseReject = null;
        } else {
          entryStream = stream;
        }
      }
      function onclose() {
        consumeCallback(error);
        if (!promiseResolve)
          return;
        if (error)
          promiseReject(error);
        else
          promiseResolve({ value: undefined, done: true });
        promiseResolve = promiseReject = null;
      }
      function destroy(err) {
        extract.destroy(err);
        consumeCallback(err);
        return new Promise((resolve, reject) => {
          if (extract.destroyed)
            return resolve({ value: undefined, done: true });
          extract.once("close", function() {
            if (err)
              reject(err);
            else
              resolve({ value: undefined, done: true });
          });
        });
      }
    }
  }
  module.exports = function extract(opts) {
    return new Extract(opts);
  };
  function noop() {}
  function overflow(size) {
    size &= 511;
    return size && 512 - size;
  }
});

// node_modules/tar-stream/constants.js
var require_constants12 = __commonJS((exports, module) => {
  var constants = {
    S_IFMT: 61440,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960
  };
  try {
    module.exports = __require("fs").constants || constants;
  } catch {
    module.exports = constants;
  }
});

// node_modules/tar-stream/pack.js
var require_pack = __commonJS((exports, module) => {
  var { Readable, Writable, getStreamError } = require_streamx();
  var b4a = require_b4a();
  var constants = require_constants12();
  var headers = require_headers2();
  var DMODE = 493;
  var FMODE = 420;
  var END_OF_TAR = b4a.alloc(1024);

  class Sink extends Writable {
    constructor(pack, header, callback) {
      super({ mapWritable, eagerOpen: true });
      this.written = 0;
      this.header = header;
      this._callback = callback;
      this._linkname = null;
      this._isLinkname = header.type === "symlink" && !header.linkname;
      this._isVoid = header.type !== "file" && header.type !== "contiguous-file";
      this._finished = false;
      this._pack = pack;
      this._openCallback = null;
      if (this._pack._stream === null)
        this._pack._stream = this;
      else
        this._pack._pending.push(this);
    }
    _open(cb) {
      this._openCallback = cb;
      if (this._pack._stream === this)
        this._continueOpen();
    }
    _continuePack(err) {
      if (this._callback === null)
        return;
      const callback = this._callback;
      this._callback = null;
      callback(err);
    }
    _continueOpen() {
      if (this._pack._stream === null)
        this._pack._stream = this;
      const cb = this._openCallback;
      this._openCallback = null;
      if (cb === null)
        return;
      if (this._pack.destroying)
        return cb(new Error("pack stream destroyed"));
      if (this._pack._finalized)
        return cb(new Error("pack stream is already finalized"));
      this._pack._stream = this;
      if (!this._isLinkname) {
        this._pack._encode(this.header);
      }
      if (this._isVoid) {
        this._finish();
        this._continuePack(null);
      }
      cb(null);
    }
    _write(data, cb) {
      if (this._isLinkname) {
        this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;
        return cb(null);
      }
      if (this._isVoid) {
        if (data.byteLength > 0) {
          return cb(new Error("No body allowed for this entry"));
        }
        return cb();
      }
      this.written += data.byteLength;
      if (this._pack.push(data))
        return cb();
      this._pack._drain = cb;
    }
    _finish() {
      if (this._finished)
        return;
      this._finished = true;
      if (this._isLinkname) {
        this.header.linkname = this._linkname ? b4a.toString(this._linkname, "utf-8") : "";
        this._pack._encode(this.header);
      }
      overflow(this._pack, this.header.size);
      this._pack._done(this);
    }
    _final(cb) {
      if (this.written !== this.header.size) {
        return cb(new Error("Size mismatch"));
      }
      this._finish();
      cb(null);
    }
    _getError() {
      return getStreamError(this) || new Error("tar entry destroyed");
    }
    _predestroy() {
      this._pack.destroy(this._getError());
    }
    _destroy(cb) {
      this._pack._done(this);
      this._continuePack(this._finished ? null : this._getError());
      cb();
    }
  }

  class Pack extends Readable {
    constructor(opts) {
      super(opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._pending = [];
      this._stream = null;
    }
    entry(header, buffer, callback) {
      if (this._finalized || this.destroying)
        throw new Error("already finalized or destroyed");
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = new Date;
      if (typeof buffer === "string")
        buffer = b4a.from(buffer);
      const sink = new Sink(this, header, callback);
      if (b4a.isBuffer(buffer)) {
        header.size = buffer.byteLength;
        sink.write(buffer);
        sink.end();
        return sink;
      }
      if (sink._isVoid) {
        return sink;
      }
      return sink;
    }
    finalize() {
      if (this._stream || this._pending.length > 0) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    }
    _done(stream) {
      if (stream !== this._stream)
        return;
      this._stream = null;
      if (this._finalizing)
        this.finalize();
      if (this._pending.length)
        this._pending.shift()._continueOpen();
    }
    _encode(header) {
      if (!header.pax) {
        const buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    }
    _encodePax(header) {
      const paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      const newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.byteLength,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.byteLength);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    }
    _doDrain() {
      const drain = this._drain;
      this._drain = noop;
      drain();
    }
    _predestroy() {
      const err = getStreamError(this);
      if (this._stream)
        this._stream.destroy(err);
      while (this._pending.length) {
        const stream = this._pending.shift();
        stream.destroy(err);
        stream._continueOpen();
      }
      this._doDrain();
    }
    _read(cb) {
      this._doDrain();
      cb();
    }
  }
  module.exports = function pack(opts) {
    return new Pack(opts);
  };
  function modeToType(mode) {
    switch (mode & constants.S_IFMT) {
      case constants.S_IFBLK:
        return "block-device";
      case constants.S_IFCHR:
        return "character-device";
      case constants.S_IFDIR:
        return "directory";
      case constants.S_IFIFO:
        return "fifo";
      case constants.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  function noop() {}
  function overflow(self2, size) {
    size &= 511;
    if (size)
      self2.push(END_OF_TAR.subarray(0, 512 - size));
  }
  function mapWritable(buf) {
    return b4a.isBuffer(buf) ? buf : b4a.from(buf);
  }
});

// node_modules/tar-stream/index.js
var require_tar_stream = __commonJS((exports) => {
  exports.extract = require_extract();
  exports.pack = require_pack();
});

// node_modules/archiver/lib/plugins/tar.js
var require_tar = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var engine = require_tar_stream();
  var util = require_archiver_utils();
  var Tar = function(options) {
    if (!(this instanceof Tar)) {
      return new Tar(options);
    }
    options = this.options = util.defaults(options, {
      gzip: false
    });
    if (typeof options.gzipOptions !== "object") {
      options.gzipOptions = {};
    }
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = engine.pack(options);
    this.compressor = false;
    if (options.gzip) {
      this.compressor = zlib.createGzip(options.gzipOptions);
      this.compressor.on("error", this._onCompressorError.bind(this));
    }
  };
  Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
  };
  Tar.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.mtime = data.date;
    function append(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      self2.engine.entry(data, sourceBuffer, function(err2) {
        callback(err2, data);
      });
    }
    if (data.sourceType === "buffer") {
      append(null, source);
    } else if (data.sourceType === "stream" && data.stats) {
      data.size = data.stats.size;
      var entry = self2.engine.entry(data, function(err) {
        callback(err, data);
      });
      source.pipe(entry);
    } else if (data.sourceType === "stream") {
      util.collectStream(source, append);
    }
  };
  Tar.prototype.finalize = function() {
    this.engine.finalize();
  };
  Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Tar.prototype.pipe = function(destination, options) {
    if (this.compressor) {
      return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
    } else {
      return this.engine.pipe.apply(this.engine, arguments);
    }
  };
  Tar.prototype.unpipe = function() {
    if (this.compressor) {
      return this.compressor.unpipe.apply(this.compressor, arguments);
    } else {
      return this.engine.unpipe.apply(this.engine, arguments);
    }
  };
  module.exports = Tar;
});

// node_modules/buffer-crc32/dist/index.cjs
var require_dist4 = __commonJS((exports, module) => {
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var CRC_TABLE = new Int32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  function ensureBuffer(input) {
    if (Buffer.isBuffer(input)) {
      return input;
    }
    if (typeof input === "number") {
      return Buffer.alloc(input);
    } else if (typeof input === "string") {
      return Buffer.from(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    const tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    let crc = ~~previous ^ -1;
    for (var n = 0;n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  var bufferCrc32 = crc32;
  var index = /* @__PURE__ */ getDefaultExportFromCjs(bufferCrc32);
  module.exports = index;
});

// node_modules/archiver/lib/plugins/json.js
var require_json = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var Transform = require_ours().Transform;
  var crc32 = require_dist4();
  var util = require_archiver_utils();
  var Json = function(options) {
    if (!(this instanceof Json)) {
      return new Json(options);
    }
    options = this.options = util.defaults(options, {});
    Transform.call(this, options);
    this.supports = {
      directory: true,
      symlink: true
    };
    this.files = [];
  };
  inherits(Json, Transform);
  Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
  };
  Json.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.crc32 = 0;
    function onend(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      data.size = sourceBuffer.length || 0;
      data.crc32 = crc32.unsigned(sourceBuffer);
      self2.files.push(data);
      callback(null, data);
    }
    if (data.sourceType === "buffer") {
      onend(null, source);
    } else if (data.sourceType === "stream") {
      util.collectStream(source, onend);
    }
  };
  Json.prototype.finalize = function() {
    this._writeStringified();
    this.end();
  };
  module.exports = Json;
});

// node_modules/archiver/index.js
var require_archiver = __commonJS((exports, module) => {
  var Archiver = require_core2();
  var formats = {};
  var vending = function(format, options) {
    return vending.create(format, options);
  };
  vending.create = function(format, options) {
    if (formats[format]) {
      var instance = new Archiver(format, options);
      instance.setFormat(format);
      instance.setModule(new formats[format](options));
      return instance;
    } else {
      throw new Error("create(" + format + "): format not registered");
    }
  };
  vending.registerFormat = function(format, module2) {
    if (formats[format]) {
      throw new Error("register(" + format + "): format already registered");
    }
    if (typeof module2 !== "function") {
      throw new Error("register(" + format + "): format module invalid");
    }
    if (typeof module2.prototype.append !== "function" || typeof module2.prototype.finalize !== "function") {
      throw new Error("register(" + format + "): format module missing methods");
    }
    formats[format] = module2;
  };
  vending.isRegisteredFormat = function(format) {
    if (formats[format]) {
      return true;
    }
    return false;
  };
  vending.registerFormat("zip", require_zip());
  vending.registerFormat("tar", require_tar());
  vending.registerFormat("json", require_json());
  module.exports = vending;
});

// node_modules/@actions/artifact/lib/internal/upload/zip.js
var require_zip2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZipUploadStream = exports.DEFAULT_COMPRESSION_LEVEL = undefined;
  exports.createZipUploadStream = createZipUploadStream;
  var stream = __importStar(__require("stream"));
  var promises_1 = __require("fs/promises");
  var archiver = __importStar(require_archiver());
  var core = __importStar(require_core());
  var config_1 = require_config();
  exports.DEFAULT_COMPRESSION_LEVEL = 6;

  class ZipUploadStream extends stream.Transform {
    constructor(bufferSize) {
      super({
        highWaterMark: bufferSize
      });
    }
    _transform(chunk, enc, cb) {
      cb(null, chunk);
    }
  }
  exports.ZipUploadStream = ZipUploadStream;
  function createZipUploadStream(uploadSpecification_1) {
    return __awaiter(this, arguments, undefined, function* (uploadSpecification, compressionLevel = exports.DEFAULT_COMPRESSION_LEVEL) {
      core.debug(`Creating Artifact archive with compressionLevel: ${compressionLevel}`);
      const zip = archiver.create("zip", {
        highWaterMark: (0, config_1.getUploadChunkSize)(),
        zlib: { level: compressionLevel }
      });
      zip.on("error", zipErrorCallback);
      zip.on("warning", zipWarningCallback);
      zip.on("finish", zipFinishCallback);
      zip.on("end", zipEndCallback);
      for (const file of uploadSpecification) {
        if (file.sourcePath !== null) {
          let sourcePath = file.sourcePath;
          if (file.stats.isSymbolicLink()) {
            sourcePath = yield (0, promises_1.realpath)(file.sourcePath);
          }
          zip.file(sourcePath, {
            name: file.destinationPath
          });
        } else {
          zip.append("", { name: file.destinationPath });
        }
      }
      const bufferSize = (0, config_1.getUploadChunkSize)();
      const zipUploadStream = new ZipUploadStream(bufferSize);
      core.debug(`Zip write high watermark value ${zipUploadStream.writableHighWaterMark}`);
      core.debug(`Zip read high watermark value ${zipUploadStream.readableHighWaterMark}`);
      zip.pipe(zipUploadStream);
      zip.finalize();
      return zipUploadStream;
    });
  }
  var zipErrorCallback = (error) => {
    core.error("An error has occurred while creating the zip file for upload");
    core.info(error);
    throw new Error("An error has occurred during zip creation for the artifact");
  };
  var zipWarningCallback = (error) => {
    if (error.code === "ENOENT") {
      core.warning("ENOENT warning during artifact zip creation. No such file or directory");
      core.info(error);
    } else {
      core.warning(`A non-blocking warning has occurred during artifact zip creation: ${error.code}`);
      core.info(error);
    }
  };
  var zipFinishCallback = () => {
    core.debug("Zip stream for upload has finished.");
  };
  var zipEndCallback = () => {
    core.debug("Zip stream for upload has ended.");
  };
});

// node_modules/@actions/artifact/lib/internal/upload/upload-artifact.js
var require_upload_artifact = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uploadArtifact = uploadArtifact;
  var core = __importStar(require_core());
  var retention_1 = require_retention();
  var path_and_artifact_name_validation_1 = require_path_and_artifact_name_validation();
  var artifact_twirp_client_1 = require_artifact_twirp_client2();
  var upload_zip_specification_1 = require_upload_zip_specification();
  var util_1 = require_util9();
  var blob_upload_1 = require_blob_upload();
  var zip_1 = require_zip2();
  var generated_1 = require_generated();
  var errors_1 = require_errors2();
  function uploadArtifact(name, files, rootDirectory, options) {
    return __awaiter(this, undefined, undefined, function* () {
      (0, path_and_artifact_name_validation_1.validateArtifactName)(name);
      (0, upload_zip_specification_1.validateRootDirectory)(rootDirectory);
      const zipSpecification = (0, upload_zip_specification_1.getUploadZipSpecification)(files, rootDirectory);
      if (zipSpecification.length === 0) {
        throw new errors_1.FilesNotFoundError(zipSpecification.flatMap((s) => s.sourcePath ? [s.sourcePath] : []));
      }
      const backendIds = (0, util_1.getBackendIdsFromToken)();
      const artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
      const createArtifactReq = {
        workflowRunBackendId: backendIds.workflowRunBackendId,
        workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
        name,
        version: 4
      };
      const expiresAt = (0, retention_1.getExpiration)(options === null || options === undefined ? undefined : options.retentionDays);
      if (expiresAt) {
        createArtifactReq.expiresAt = expiresAt;
      }
      const createArtifactResp = yield artifactClient.CreateArtifact(createArtifactReq);
      if (!createArtifactResp.ok) {
        throw new errors_1.InvalidResponseError("CreateArtifact: response from backend was not ok");
      }
      const zipUploadStream = yield (0, zip_1.createZipUploadStream)(zipSpecification, options === null || options === undefined ? undefined : options.compressionLevel);
      const uploadResult = yield (0, blob_upload_1.uploadZipToBlobStorage)(createArtifactResp.signedUploadUrl, zipUploadStream);
      const finalizeArtifactReq = {
        workflowRunBackendId: backendIds.workflowRunBackendId,
        workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
        name,
        size: uploadResult.uploadSize ? uploadResult.uploadSize.toString() : "0"
      };
      if (uploadResult.sha256Hash) {
        finalizeArtifactReq.hash = generated_1.StringValue.create({
          value: `sha256:${uploadResult.sha256Hash}`
        });
      }
      core.info(`Finalizing artifact upload`);
      const finalizeArtifactResp = yield artifactClient.FinalizeArtifact(finalizeArtifactReq);
      if (!finalizeArtifactResp.ok) {
        throw new errors_1.InvalidResponseError("FinalizeArtifact: response from backend was not ok");
      }
      const artifactId = BigInt(finalizeArtifactResp.artifactId);
      core.info(`Artifact ${name}.zip successfully finalized. Artifact ID ${artifactId}`);
      return {
        size: uploadResult.uploadSize,
        digest: uploadResult.sha256Hash,
        id: Number(artifactId)
      };
    });
  }
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Context = undefined;
  var fs_1 = __require("fs");
  var os_1 = __require("os");

  class Context {
    constructor() {
      var _a, _b, _c;
      this.payload = {};
      if (process.env.GITHUB_EVENT_PATH) {
        if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
          this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
        } else {
          const path = process.env.GITHUB_EVENT_PATH;
          process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
        }
      }
      this.eventName = process.env.GITHUB_EVENT_NAME;
      this.sha = process.env.GITHUB_SHA;
      this.ref = process.env.GITHUB_REF;
      this.workflow = process.env.GITHUB_WORKFLOW;
      this.action = process.env.GITHUB_ACTION;
      this.actor = process.env.GITHUB_ACTOR;
      this.job = process.env.GITHUB_JOB;
      this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
      this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
      this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
      this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== undefined ? _a : `https://api.github.com`;
      this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== undefined ? _b : `https://github.com`;
      this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== undefined ? _c : `https://api.github.com/graphql`;
    }
    get issue() {
      const payload = this.payload;
      return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
      if (process.env.GITHUB_REPOSITORY) {
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
        return { owner, repo };
      }
      if (this.payload.repository) {
        return {
          owner: this.payload.repository.owner.login,
          repo: this.payload.repository.name
        };
      }
      throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
  }
  exports.Context = Context;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/lib/proxy.js
var require_proxy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkBypass = exports.getProxyUrl = undefined;
  function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl)) {
      return;
    }
    const proxyVar = (() => {
      if (usingSsl) {
        return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        return process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
    })();
    if (proxyVar) {
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    } else {
      return;
    }
  }
  exports.getProxyUrl = getProxyUrl;
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
      return true;
    }
    const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
        return true;
      }
    }
    return false;
  }
  exports.checkBypass = checkBypass;
  function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username);
      this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var pm = __importStar(require_proxy2());
  var tunnel = __importStar(require_tunnel());
  var undici_1 = require_undici();
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  exports.getProxyUrl = getProxyUrl;
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  var HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  var ExponentialBackoffCeiling = 10;
  var ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          });
          this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          const chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          });
          this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }
  exports.isHttps = isHttps;

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = userAgent;
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    getJson(requestUrl, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        const res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        const parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response;
        do {
          response = yield this.requestRaw(info, data);
          if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (const handler of this.handlers) {
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info, data);
            } else {
              return response;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            const parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (const header in headers) {
                if (header.toLowerCase() === "authorization") {
                  delete headers[header];
                }
              }
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers);
            response = yield this.requestRaw(info, data);
            redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
            return response;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    requestRaw(info, data) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err) {
              reject(err);
            } else if (!res) {
              reject(new Error("Unknown error"));
            } else {
              resolve(res);
            }
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers) {
          info.options.headers = {};
        }
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      function handleResult(err, res) {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      }
      const req = info.httpModule.request(info.options, (msg) => {
        const res = new HttpClientResponse(msg);
        handleResult(undefined, res);
      });
      let socket;
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 60000, () => {
        if (socket) {
          socket.end();
        }
        handleResult(new Error(`Request timeout: ${info.options.path}`));
      });
      req.on("error", function(err) {
        handleResult(err);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    getAgent(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (!useProxy) {
        return;
      }
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      const info = {};
      info.parsedUrl = requestUrl;
      const usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info.options = {};
      info.options.host = info.parsedUrl.hostname;
      info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
      info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
      info.options.method = method;
      info.options.headers = this._mergeHeaders(headers);
      if (this.userAgent != null) {
        info.options.headers["user-agent"] = this.userAgent;
      }
      info.options.agent = this._getAgent(info.parsedUrl);
      if (this.handlers) {
        for (const handler of this.handlers) {
          handler.prepareRequest(info.options);
        }
      }
      return info;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      }
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
      }
      return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
      let agent;
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent = this._proxyAgent;
      }
      if (!useProxy) {
        agent = this._agent;
      }
      if (agent) {
        return agent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (proxyUrl && proxyUrl.hostname) {
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        }
        agent = tunnelAgent(agentOptions);
        this._proxyAgent = agent;
      }
      if (!agent) {
        const options = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
        this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError) {
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive) {
        proxyAgent = this._proxyAgentDispatcher;
      }
      if (proxyAgent) {
        return proxyAgent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      }));
      this._proxyAgentDispatcher = proxyAgent;
      if (usingSsl && this._ignoreSslError) {
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: false
        });
      }
      return proxyAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, undefined, undefined, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
          const statusCode = res.message.statusCode || 0;
          const response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound) {
            resolve(response);
          }
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              const a = new Date(value);
              if (!isNaN(a.valueOf())) {
                return a;
              }
            }
            return value;
          }
          let obj;
          let contents;
          try {
            contents = yield res.readBody();
            if (contents && contents.length > 0) {
              if (options && options.deserializeDates) {
                obj = JSON.parse(contents, dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {}
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = `Failed request: (${statusCode})`;
            }
            const err = new HttpClientError(msg, statusCode);
            err.result = response.result;
            reject(err);
          } else {
            resolve(response);
          }
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/internal/utils.js
var require_utils6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = undefined;
  var httpClient = __importStar(require_lib3());
  var undici_1 = require_undici();
  function getAuthString(token, options) {
    if (!token && !options.auth) {
      throw new Error("Parameter token or opts.auth is required");
    } else if (token && options.auth) {
      throw new Error("Parameters token and opts.auth may not both be specified");
    }
    return typeof options.auth === "string" ? options.auth : `token ${token}`;
  }
  exports.getAuthString = getAuthString;
  function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient;
    return hc.getAgent(destinationUrl);
  }
  exports.getProxyAgent = getProxyAgent;
  function getProxyAgentDispatcher(destinationUrl) {
    const hc = new httpClient.HttpClient;
    return hc.getAgentDispatcher(destinationUrl);
  }
  exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
  function getProxyFetch(destinationUrl) {
    const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
    const proxyFetch = (url, opts) => __awaiter(this, undefined, undefined, function* () {
      return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
    });
    return proxyFetch;
  }
  exports.getProxyFetch = getProxyFetch;
  function getApiBaseUrl() {
    return process.env["GITHUB_API_URL"] || "https://api.github.com";
  }
  exports.getApiBaseUrl = getApiBaseUrl;
});

// node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
      return navigator.userAgent;
    }
    if (typeof process === "object" && process.version !== undefined) {
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
  }
  exports.getUserAgent = getUserAgent;
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS((exports, module) => {
  module.exports = register;
  function register(state, name, method, options) {
    if (typeof method !== "function") {
      throw new Error("method for before hook must be a function");
    }
    if (!options) {
      options = {};
    }
    if (Array.isArray(name)) {
      return name.reverse().reduce(function(callback, name2) {
        return register.bind(null, state, name2, callback, options);
      }, method)();
    }
    return Promise.resolve().then(function() {
      if (!state.registry[name]) {
        return method(options);
      }
      return state.registry[name].reduce(function(method2, registered) {
        return registered.hook.bind(null, method2, options);
      }, method)();
    });
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS((exports, module) => {
  module.exports = addHook;
  function addHook(state, kind, name, hook) {
    var orig = hook;
    if (!state.registry[name]) {
      state.registry[name] = [];
    }
    if (kind === "before") {
      hook = function(method, options) {
        return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
      };
    }
    if (kind === "after") {
      hook = function(method, options) {
        var result;
        return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
          result = result_;
          return orig(result, options);
        }).then(function() {
          return result;
        });
      };
    }
    if (kind === "error") {
      hook = function(method, options) {
        return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
          return orig(error, options);
        });
      };
    }
    state.registry[name].push({
      hook,
      orig
    });
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS((exports, module) => {
  module.exports = removeHook;
  function removeHook(state, name, method) {
    if (!state.registry[name]) {
      return;
    }
    var index = state.registry[name].map(function(registered) {
      return registered.orig;
    }).indexOf(method);
    if (index === -1) {
      return;
    }
    state.registry[name].splice(index, 1);
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS((exports, module) => {
  var register = require_register();
  var addHook = require_add();
  var removeHook = require_remove();
  var bind = Function.bind;
  var bindable = bind.bind(bind);
  function bindApi(hook, state, name) {
    var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
    hook.api = { remove: removeHookRef };
    hook.remove = removeHookRef;
    ["before", "error", "after", "wrap"].forEach(function(kind) {
      var args = name ? [state, kind, name] : [state, kind];
      hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
    });
  }
  function HookSingular() {
    var singularHookName = "h";
    var singularHookState = {
      registry: {}
    };
    var singularHook = register.bind(null, singularHookState, singularHookName);
    bindApi(singularHook, singularHookState, singularHookName);
    return singularHook;
  }
  function HookCollection() {
    var state = {
      registry: {}
    };
    var hook = register.bind(null, state);
    bindApi(hook, state);
    return hook;
  }
  var collectionHookDeprecationMessageDisplayed = false;
  function Hook() {
    if (!collectionHookDeprecationMessageDisplayed) {
      console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
      collectionHookDeprecationMessageDisplayed = true;
    }
    return HookCollection();
  }
  Hook.Singular = HookSingular.bind();
  Hook.Collection = HookCollection.bind();
  module.exports = Hook;
  module.exports.Hook = Hook;
  module.exports.Singular = Hook.Singular;
  module.exports.Collection = Hook.Collection;
});

// node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    endpoint: () => endpoint
  });
  module.exports = __toCommonJS2(dist_src_exports);
  var import_universal_user_agent = require_dist_node();
  var VERSION = "9.0.6";
  var userAgent = `octokit-endpoint.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`;
  var DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
      accept: "application/vnd.github.v3+json",
      "user-agent": userAgent
    },
    mediaType: {
      format: ""
    }
  };
  function lowercaseKeys(object) {
    if (!object) {
      return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
      newObj[key.toLowerCase()] = object[key];
      return newObj;
    }, {});
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return false;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null)
      return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
      if (isPlainObject(options[key])) {
        if (!(key in defaults))
          Object.assign(result, { [key]: options[key] });
        else
          result[key] = mergeDeep(defaults[key], options[key]);
      } else {
        Object.assign(result, { [key]: options[key] });
      }
    });
    return result;
  }
  function removeUndefinedProperties(obj) {
    for (const key in obj) {
      if (obj[key] === undefined) {
        delete obj[key];
      }
    }
    return obj;
  }
  function merge(defaults, route, options) {
    if (typeof route === "string") {
      let [method, url] = route.split(" ");
      options = Object.assign(url ? { method, url } : { url: method }, options);
    } else {
      options = Object.assign({}, route);
    }
    options.headers = lowercaseKeys(options.headers);
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    if (options.url === "/graphql") {
      if (defaults && defaults.mediaType.previews?.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
      }
      mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
    }
    return mergedOptions;
  }
  function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
      return url;
    }
    return url + separator + names.map((name) => {
      if (name === "q") {
        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
      }
      return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
  }
  var urlVariableRegex = /\{[^{}}]+\}/g;
  function removeNonChars(variableName) {
    return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
  }
  function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
      return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
  }
  function omit(object, keysToOmit) {
    const result = { __proto__: null };
    for (const key of Object.keys(object)) {
      if (keysToOmit.indexOf(key) === -1) {
        result[key] = object[key];
      }
    }
    return result;
  }
  function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
      if (!/%[0-9A-Fa-f]/.test(part)) {
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      }
      return part;
    }).join("");
  }
  function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeValue(operator, value, key) {
    value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
    if (key) {
      return encodeUnreserved(key) + "=" + value;
    } else {
      return value;
    }
  }
  function isDefined(value) {
    return value !== undefined && value !== null;
  }
  function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
  }
  function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
        if (modifier && modifier !== "*") {
          value = value.substring(0, parseInt(modifier, 10));
        }
        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
      } else {
        if (modifier === "*") {
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                result.push(encodeValue(operator, value[k], k));
              }
            });
          }
        } else {
          const tmp = [];
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              tmp.push(encodeValue(operator, value2));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                tmp.push(encodeUnreserved(k));
                tmp.push(encodeValue(operator, value[k].toString()));
              }
            });
          }
          if (isKeyOperator(operator)) {
            result.push(encodeUnreserved(key) + "=" + tmp.join(","));
          } else if (tmp.length !== 0) {
            result.push(tmp.join(","));
          }
        }
      }
    } else {
      if (operator === ";") {
        if (isDefined(value)) {
          result.push(encodeUnreserved(key));
        }
      } else if (value === "" && (operator === "&" || operator === "?")) {
        result.push(encodeUnreserved(key) + "=");
      } else if (value === "") {
        result.push("");
      }
    }
    return result;
  }
  function parseUrl(template) {
    return {
      expand: expand.bind(null, template)
    };
  }
  function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    });
    if (template === "/") {
      return template;
    } else {
      return template.replace(/\/$/, "");
    }
  }
  function parse(options) {
    let method = options.method.toUpperCase();
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "mediaType"
    ]);
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
      url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
      if (options.mediaType.format) {
        headers.accept = headers.accept.split(/,/).map((format) => format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
      }
      if (url.endsWith("/graphql")) {
        if (options.mediaType.previews?.length) {
          const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
          headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
            const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
            return `application/vnd.github.${preview}-preview${format}`;
          }).join(",");
        }
      }
    }
    if (["GET", "HEAD"].includes(method)) {
      url = addQueryParameters(url, remainingParameters);
    } else {
      if ("data" in remainingParameters) {
        body = remainingParameters.data;
      } else {
        if (Object.keys(remainingParameters).length) {
          body = remainingParameters;
        }
      }
    }
    if (!headers["content-type"] && typeof body !== "undefined") {
      headers["content-type"] = "application/json; charset=utf-8";
    }
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
      body = "";
    }
    return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
  }
  function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
  }
  function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS2 = merge(oldDefaults, newDefaults);
    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
      DEFAULTS: DEFAULTS2,
      defaults: withDefaults.bind(null, DEFAULTS2),
      merge: merge.bind(null, DEFAULTS2),
      parse
    });
  }
  var endpoint = withDefaults(null, DEFAULTS);
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class Deprecation extends Error {
    constructor(message) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "Deprecation";
    }
  }
  exports.Deprecation = Deprecation;
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports, module) => {
  module.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports, module) => {
  var wrappy = require_wrappy();
  module.exports = wrappy(once);
  module.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node4 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    RequestError: () => RequestError
  });
  module.exports = __toCommonJS2(dist_src_exports);
  var import_deprecation = require_dist_node3();
  var import_once = __toESM2(require_once());
  var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
  var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
  var RequestError = class extends Error {
    constructor(message, statusCode, options) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "HttpError";
      this.status = statusCode;
      let headers;
      if ("headers" in options && typeof options.headers !== "undefined") {
        headers = options.headers;
      }
      if ("response" in options) {
        this.response = options.response;
        headers = options.response.headers;
      }
      const requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization) {
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
        });
      }
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
      this.request = requestCopy;
      Object.defineProperty(this, "code", {
        get() {
          logOnceCode(new import_deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
          return statusCode;
        }
      });
      Object.defineProperty(this, "headers", {
        get() {
          logOnceHeaders(new import_deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
          return headers || {};
        }
      });
    }
  };
});

// node_modules/@octokit/request/dist-node/index.js
var require_dist_node5 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    request: () => request
  });
  module.exports = __toCommonJS2(dist_src_exports);
  var import_endpoint = require_dist_node2();
  var import_universal_user_agent = require_dist_node();
  var VERSION = "8.4.1";
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return false;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null)
      return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  var import_request_error = require_dist_node4();
  function getBufferResponse(response) {
    return response.arrayBuffer();
  }
  function fetchWrapper(requestOptions) {
    var _a, _b, _c, _d;
    const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
    const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? undefined : _a.parseSuccessResponseBody) !== false;
    if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
      requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    let { fetch: fetch2 } = globalThis;
    if ((_b = requestOptions.request) == null ? undefined : _b.fetch) {
      fetch2 = requestOptions.request.fetch;
    }
    if (!fetch2) {
      throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
    }
    return fetch2(requestOptions.url, {
      method: requestOptions.method,
      body: requestOptions.body,
      redirect: (_c = requestOptions.request) == null ? undefined : _c.redirect,
      headers: requestOptions.headers,
      signal: (_d = requestOptions.request) == null ? undefined : _d.signal,
      ...requestOptions.body && { duplex: "half" }
    }).then(async (response) => {
      url = response.url;
      status = response.status;
      for (const keyAndValue of response.headers) {
        headers[keyAndValue[0]] = keyAndValue[1];
      }
      if ("deprecation" in headers) {
        const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
        const deprecationLink = matches && matches.pop();
        log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
      }
      if (status === 204 || status === 205) {
        return;
      }
      if (requestOptions.method === "HEAD") {
        if (status < 400) {
          return;
        }
        throw new import_request_error.RequestError(response.statusText, status, {
          response: {
            url,
            status,
            headers,
            data: undefined
          },
          request: requestOptions
        });
      }
      if (status === 304) {
        throw new import_request_error.RequestError("Not modified", status, {
          response: {
            url,
            status,
            headers,
            data: await getResponseData(response)
          },
          request: requestOptions
        });
      }
      if (status >= 400) {
        const data = await getResponseData(response);
        const error = new import_request_error.RequestError(toErrorMessage(data), status, {
          response: {
            url,
            status,
            headers,
            data
          },
          request: requestOptions
        });
        throw error;
      }
      return parseSuccessResponseBody ? await getResponseData(response) : response.body;
    }).then((data) => {
      return {
        status,
        url,
        headers,
        data
      };
    }).catch((error) => {
      if (error instanceof import_request_error.RequestError)
        throw error;
      else if (error.name === "AbortError")
        throw error;
      let message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
      throw new import_request_error.RequestError(message, 500, {
        request: requestOptions
      });
    });
  }
  async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json().catch(() => response.text()).catch(() => "");
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  }
  function toErrorMessage(data) {
    if (typeof data === "string")
      return data;
    let suffix;
    if ("documentation_url" in data) {
      suffix = ` - ${data.documentation_url}`;
    } else {
      suffix = "";
    }
    if ("message" in data) {
      if (Array.isArray(data.errors)) {
        return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
      }
      return `${data.message}${suffix}`;
    }
    return `Unknown error: ${JSON.stringify(data)}`;
  }
  function withDefaults(oldEndpoint, newDefaults) {
    const endpoint2 = oldEndpoint.defaults(newDefaults);
    const newApi = function(route, parameters) {
      const endpointOptions = endpoint2.merge(route, parameters);
      if (!endpointOptions.request || !endpointOptions.request.hook) {
        return fetchWrapper(endpoint2.parse(endpointOptions));
      }
      const request2 = (route2, parameters2) => {
        return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
      };
      Object.assign(request2, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      });
      return endpointOptions.request.hook(request2, endpointOptions);
    };
    return Object.assign(newApi, {
      endpoint: endpoint2,
      defaults: withDefaults.bind(null, endpoint2)
    });
  }
  var request = withDefaults(import_endpoint.endpoint, {
    headers: {
      "user-agent": `octokit-request.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`
    }
  });
});

// node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node6 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var index_exports = {};
  __export2(index_exports, {
    GraphqlResponseError: () => GraphqlResponseError,
    graphql: () => graphql2,
    withCustomRequest: () => withCustomRequest
  });
  module.exports = __toCommonJS2(index_exports);
  var import_request3 = require_dist_node5();
  var import_universal_user_agent = require_dist_node();
  var VERSION = "7.1.1";
  var import_request2 = require_dist_node5();
  var import_request = require_dist_node5();
  function _buildMessageForResponseErrors(data) {
    return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join(`
`);
  }
  var GraphqlResponseError = class extends Error {
    constructor(request2, headers, response) {
      super(_buildMessageForResponseErrors(response));
      this.request = request2;
      this.headers = headers;
      this.response = response;
      this.name = "GraphqlResponseError";
      this.errors = response.errors;
      this.data = response.data;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
  };
  var NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType"
  ];
  var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
  var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
  function graphql(request2, query, options) {
    if (options) {
      if (typeof query === "string" && "query" in options) {
        return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
      }
      for (const key in options) {
        if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
          continue;
        return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
      }
    }
    const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
      if (NON_VARIABLE_OPTIONS.includes(key)) {
        result[key] = parsedOptions[key];
        return result;
      }
      if (!result.variables) {
        result.variables = {};
      }
      result.variables[key] = parsedOptions[key];
      return result;
    }, {});
    const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
      requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request2(requestOptions).then((response) => {
      if (response.data.errors) {
        const headers = {};
        for (const key of Object.keys(response.headers)) {
          headers[key] = response.headers[key];
        }
        throw new GraphqlResponseError(requestOptions, headers, response.data);
      }
      return response.data.data;
    });
  }
  function withDefaults(request2, newDefaults) {
    const newRequest = request2.defaults(newDefaults);
    const newApi = (query, options) => {
      return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
      defaults: withDefaults.bind(null, newRequest),
      endpoint: newRequest.endpoint
    });
  }
  var graphql2 = withDefaults(import_request3.request, {
    headers: {
      "user-agent": `octokit-graphql.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`
    },
    method: "POST",
    url: "/graphql"
  });
  function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
      method: "POST",
      url: "/graphql"
    });
  }
});

// node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node7 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    createTokenAuth: () => createTokenAuth
  });
  module.exports = __toCommonJS2(dist_src_exports);
  var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
  var REGEX_IS_INSTALLATION = /^ghs_/;
  var REGEX_IS_USER_TO_SERVER = /^ghu_/;
  async function auth(token) {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  }
  function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
      return `bearer ${token}`;
    }
    return `token ${token}`;
  }
  async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
  }
  var createTokenAuth = function createTokenAuth2(token) {
    if (!token) {
      throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
      throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
      hook: hook.bind(null, token)
    });
  };
});

// node_modules/@octokit/core/dist-node/index.js
var require_dist_node8 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var index_exports = {};
  __export2(index_exports, {
    Octokit: () => Octokit
  });
  module.exports = __toCommonJS2(index_exports);
  var import_universal_user_agent = require_dist_node();
  var import_before_after_hook = require_before_after_hook();
  var import_request = require_dist_node5();
  var import_graphql = require_dist_node6();
  var import_auth_token = require_dist_node7();
  var VERSION = "5.2.2";
  var noop = () => {};
  var consoleWarn = console.warn.bind(console);
  var consoleError = console.error.bind(console);
  function createLogger(logger = {}) {
    if (typeof logger.debug !== "function") {
      logger.debug = noop;
    }
    if (typeof logger.info !== "function") {
      logger.info = noop;
    }
    if (typeof logger.warn !== "function") {
      logger.warn = consoleWarn;
    }
    if (typeof logger.error !== "function") {
      logger.error = consoleError;
    }
    return logger;
  }
  var userAgentTrail = `octokit-core.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`;
  var Octokit = class {
    static {
      this.VERSION = VERSION;
    }
    static defaults(defaults) {
      const OctokitWithDefaults = class extends this {
        constructor(...args) {
          const options = args[0] || {};
          if (typeof defaults === "function") {
            super(defaults(options));
            return;
          }
          super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
            userAgent: `${options.userAgent} ${defaults.userAgent}`
          } : null));
        }
      };
      return OctokitWithDefaults;
    }
    static {
      this.plugins = [];
    }
    static plugin(...newPlugins) {
      const currentPlugins = this.plugins;
      const NewOctokit = class extends this {
        static {
          this.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
        }
      };
      return NewOctokit;
    }
    constructor(options = {}) {
      const hook = new import_before_after_hook.Collection;
      const requestDefaults = {
        baseUrl: import_request.request.endpoint.DEFAULTS.baseUrl,
        headers: {},
        request: Object.assign({}, options.request, {
          hook: hook.bind(null, "request")
        }),
        mediaType: {
          previews: [],
          format: ""
        }
      };
      requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
      if (options.baseUrl) {
        requestDefaults.baseUrl = options.baseUrl;
      }
      if (options.previews) {
        requestDefaults.mediaType.previews = options.previews;
      }
      if (options.timeZone) {
        requestDefaults.headers["time-zone"] = options.timeZone;
      }
      this.request = import_request.request.defaults(requestDefaults);
      this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults);
      this.log = createLogger(options.log);
      this.hook = hook;
      if (!options.authStrategy) {
        if (!options.auth) {
          this.auth = async () => ({
            type: "unauthenticated"
          });
        } else {
          const auth = (0, import_auth_token.createTokenAuth)(options.auth);
          hook.wrap("request", auth.hook);
          this.auth = auth;
        }
      } else {
        const { authStrategy, ...otherOptions } = options;
        const auth = authStrategy(Object.assign({
          request: this.request,
          log: this.log,
          octokit: this,
          octokitOptions: otherOptions
        }, options.auth));
        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
      const classConstructor = this.constructor;
      for (let i = 0;i < classConstructor.plugins.length; ++i) {
        Object.assign(this, classConstructor.plugins[i](this, options));
      }
    }
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node9 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    legacyRestEndpointMethods: () => legacyRestEndpointMethods,
    restEndpointMethods: () => restEndpointMethods
  });
  module.exports = __toCommonJS2(dist_src_exports);
  var VERSION = "10.4.1";
  var Endpoints = {
    actions: {
      addCustomLabelsToSelfHostedRunnerForOrg: [
        "POST /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      addCustomLabelsToSelfHostedRunnerForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      approveWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
      ],
      cancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
      ],
      createEnvironmentVariable: [
        "POST /repositories/{repository_id}/environments/{environment_name}/variables"
      ],
      createOrUpdateEnvironmentSecret: [
        "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      createOrgVariable: ["POST /orgs/{org}/actions/variables"],
      createRegistrationTokenForOrg: [
        "POST /orgs/{org}/actions/runners/registration-token"
      ],
      createRegistrationTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/registration-token"
      ],
      createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
      createRemoveTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/remove-token"
      ],
      createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
      createWorkflowDispatch: [
        "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
      ],
      deleteActionsCacheById: [
        "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
      ],
      deleteActionsCacheByKey: [
        "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
      ],
      deleteArtifact: [
        "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
      ],
      deleteEnvironmentSecret: [
        "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      deleteEnvironmentVariable: [
        "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
      deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      deleteRepoVariable: [
        "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
      ],
      deleteSelfHostedRunnerFromOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}"
      ],
      deleteSelfHostedRunnerFromRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
      deleteWorkflowRunLogs: [
        "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      disableSelectedRepositoryGithubActionsOrganization: [
        "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      disableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
      ],
      downloadArtifact: [
        "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
      ],
      downloadJobLogsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
      ],
      downloadWorkflowRunAttemptLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
      ],
      downloadWorkflowRunLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      enableSelectedRepositoryGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      enableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
      ],
      forceCancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
      ],
      generateRunnerJitconfigForOrg: [
        "POST /orgs/{org}/actions/runners/generate-jitconfig"
      ],
      generateRunnerJitconfigForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
      ],
      getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
      getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
      getActionsCacheUsageByRepoForOrg: [
        "GET /orgs/{org}/actions/cache/usage-by-repository"
      ],
      getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
      getAllowedActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/selected-actions"
      ],
      getAllowedActionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
      getCustomOidcSubClaimForRepo: [
        "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      getEnvironmentPublicKey: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
      ],
      getEnvironmentSecret: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      getEnvironmentVariable: [
        "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      getGithubActionsDefaultWorkflowPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions/workflow"
      ],
      getGithubActionsDefaultWorkflowPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      getGithubActionsPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions"
      ],
      getGithubActionsPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions"
      ],
      getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
      getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
      getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
      getPendingDeploymentsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      getRepoPermissions: [
        "GET /repos/{owner}/{repo}/actions/permissions",
        {},
        { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
      ],
      getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
      getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
      getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
      getReviewsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
      ],
      getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
      getSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
      getWorkflowAccessToRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/access"
      ],
      getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
      getWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
      ],
      getWorkflowRunUsage: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
      ],
      getWorkflowUsage: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
      ],
      listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
      listEnvironmentSecrets: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
      ],
      listEnvironmentVariables: [
        "GET /repositories/{repository_id}/environments/{environment_name}/variables"
      ],
      listJobsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
      ],
      listJobsForWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
      ],
      listLabelsForSelfHostedRunnerForOrg: [
        "GET /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      listLabelsForSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
      listOrgVariables: ["GET /orgs/{org}/actions/variables"],
      listRepoOrganizationSecrets: [
        "GET /repos/{owner}/{repo}/actions/organization-secrets"
      ],
      listRepoOrganizationVariables: [
        "GET /repos/{owner}/{repo}/actions/organization-variables"
      ],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
      listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
      listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
      listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
      listRunnerApplicationsForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/downloads"
      ],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      listSelectedReposForOrgVariable: [
        "GET /orgs/{org}/actions/variables/{name}/repositories"
      ],
      listSelectedRepositoriesEnabledGithubActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/repositories"
      ],
      listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
      listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
      listWorkflowRunArtifacts: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
      ],
      listWorkflowRuns: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
      ],
      listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
      reRunJobForWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
      ],
      reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
      reRunWorkflowFailedJobs: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      removeCustomLabelFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeCustomLabelFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgVariable: [
        "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      reviewCustomGatesForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
      ],
      reviewPendingDeploymentsForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      setAllowedActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/selected-actions"
      ],
      setAllowedActionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      setCustomLabelsForSelfHostedRunnerForOrg: [
        "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      setCustomLabelsForSelfHostedRunnerForRepo: [
        "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      setCustomOidcSubClaimForRepo: [
        "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      setGithubActionsDefaultWorkflowPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/workflow"
      ],
      setGithubActionsDefaultWorkflowPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      setGithubActionsPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions"
      ],
      setGithubActionsPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories"
      ],
      setSelectedRepositoriesEnabledGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories"
      ],
      setWorkflowAccessToRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/access"
      ],
      updateEnvironmentVariable: [
        "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
      updateRepoVariable: [
        "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
      ]
    },
    activity: {
      checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
      deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
      deleteThreadSubscription: [
        "DELETE /notifications/threads/{thread_id}/subscription"
      ],
      getFeeds: ["GET /feeds"],
      getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
      getThread: ["GET /notifications/threads/{thread_id}"],
      getThreadSubscriptionForAuthenticatedUser: [
        "GET /notifications/threads/{thread_id}/subscription"
      ],
      listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
      listNotificationsForAuthenticatedUser: ["GET /notifications"],
      listOrgEventsForAuthenticatedUser: [
        "GET /users/{username}/events/orgs/{org}"
      ],
      listPublicEvents: ["GET /events"],
      listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
      listPublicEventsForUser: ["GET /users/{username}/events/public"],
      listPublicOrgEvents: ["GET /orgs/{org}/events"],
      listReceivedEventsForUser: ["GET /users/{username}/received_events"],
      listReceivedPublicEventsForUser: [
        "GET /users/{username}/received_events/public"
      ],
      listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
      listRepoNotificationsForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/notifications"
      ],
      listReposStarredByAuthenticatedUser: ["GET /user/starred"],
      listReposStarredByUser: ["GET /users/{username}/starred"],
      listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
      listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
      listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
      listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
      markNotificationsAsRead: ["PUT /notifications"],
      markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
      markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
      markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
      setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
      setThreadSubscription: [
        "PUT /notifications/threads/{thread_id}/subscription"
      ],
      starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
      unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
    },
    apps: {
      addRepoToInstallation: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
      ],
      addRepoToInstallationForAuthenticatedUser: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      checkToken: ["POST /applications/{client_id}/token"],
      createFromManifest: ["POST /app-manifests/{code}/conversions"],
      createInstallationAccessToken: [
        "POST /app/installations/{installation_id}/access_tokens"
      ],
      deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
      deleteInstallation: ["DELETE /app/installations/{installation_id}"],
      deleteToken: ["DELETE /applications/{client_id}/token"],
      getAuthenticated: ["GET /app"],
      getBySlug: ["GET /apps/{app_slug}"],
      getInstallation: ["GET /app/installations/{installation_id}"],
      getOrgInstallation: ["GET /orgs/{org}/installation"],
      getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
      getSubscriptionPlanForAccount: [
        "GET /marketplace_listing/accounts/{account_id}"
      ],
      getSubscriptionPlanForAccountStubbed: [
        "GET /marketplace_listing/stubbed/accounts/{account_id}"
      ],
      getUserInstallation: ["GET /users/{username}/installation"],
      getWebhookConfigForApp: ["GET /app/hook/config"],
      getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
      listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
      listAccountsForPlanStubbed: [
        "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
      ],
      listInstallationReposForAuthenticatedUser: [
        "GET /user/installations/{installation_id}/repositories"
      ],
      listInstallationRequestsForAuthenticatedApp: [
        "GET /app/installation-requests"
      ],
      listInstallations: ["GET /app/installations"],
      listInstallationsForAuthenticatedUser: ["GET /user/installations"],
      listPlans: ["GET /marketplace_listing/plans"],
      listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
      listReposAccessibleToInstallation: ["GET /installation/repositories"],
      listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
      listSubscriptionsForAuthenticatedUserStubbed: [
        "GET /user/marketplace_purchases/stubbed"
      ],
      listWebhookDeliveries: ["GET /app/hook/deliveries"],
      redeliverWebhookDelivery: [
        "POST /app/hook/deliveries/{delivery_id}/attempts"
      ],
      removeRepoFromInstallation: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
      ],
      removeRepoFromInstallationForAuthenticatedUser: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      resetToken: ["PATCH /applications/{client_id}/token"],
      revokeInstallationAccessToken: ["DELETE /installation/token"],
      scopeToken: ["POST /applications/{client_id}/token/scoped"],
      suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
      unsuspendInstallation: [
        "DELETE /app/installations/{installation_id}/suspended"
      ],
      updateWebhookConfigForApp: ["PATCH /app/hook/config"]
    },
    billing: {
      getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
      getGithubActionsBillingUser: [
        "GET /users/{username}/settings/billing/actions"
      ],
      getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
      getGithubPackagesBillingUser: [
        "GET /users/{username}/settings/billing/packages"
      ],
      getSharedStorageBillingOrg: [
        "GET /orgs/{org}/settings/billing/shared-storage"
      ],
      getSharedStorageBillingUser: [
        "GET /users/{username}/settings/billing/shared-storage"
      ]
    },
    checks: {
      create: ["POST /repos/{owner}/{repo}/check-runs"],
      createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
      get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
      getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
      listAnnotations: [
        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
      ],
      listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
      listForSuite: [
        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
      ],
      listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
      rerequestRun: [
        "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
      ],
      rerequestSuite: [
        "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
      ],
      setSuitesPreferences: [
        "PATCH /repos/{owner}/{repo}/check-suites/preferences"
      ],
      update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
    },
    codeScanning: {
      deleteAnalysis: [
        "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
      ],
      getAlert: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
        {},
        { renamedParameters: { alert_id: "alert_number" } }
      ],
      getAnalysis: [
        "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
      ],
      getCodeqlDatabase: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
      ],
      getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
      getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
      listAlertInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
      listAlertsInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        {},
        { renamed: ["codeScanning", "listAlertInstances"] }
      ],
      listCodeqlDatabases: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
      ],
      listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
      ],
      updateDefaultSetup: [
        "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
      ],
      uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
    },
    codesOfConduct: {
      getAllCodesOfConduct: ["GET /codes_of_conduct"],
      getConductCode: ["GET /codes_of_conduct/{key}"]
    },
    codespaces: {
      addRepositoryForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      checkPermissionsForDevcontainer: [
        "GET /repos/{owner}/{repo}/codespaces/permissions_check"
      ],
      codespaceMachinesForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/machines"
      ],
      createForAuthenticatedUser: ["POST /user/codespaces"],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}"
      ],
      createWithPrForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
      ],
      createWithRepoForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/codespaces"
      ],
      deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
      deleteFromOrganization: [
        "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      deleteSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}"
      ],
      exportForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/exports"
      ],
      getCodespacesForUserInOrg: [
        "GET /orgs/{org}/members/{username}/codespaces"
      ],
      getExportDetailsForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/exports/{export_id}"
      ],
      getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
      getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
      getPublicKeyForAuthenticatedUser: [
        "GET /user/codespaces/secrets/public-key"
      ],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      getSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}"
      ],
      listDevcontainersInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/devcontainers"
      ],
      listForAuthenticatedUser: ["GET /user/codespaces"],
      listInOrganization: [
        "GET /orgs/{org}/codespaces",
        {},
        { renamedParameters: { org_id: "org" } }
      ],
      listInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces"
      ],
      listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
      listRepositoriesForSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}/repositories"
      ],
      listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      preFlightWithRepoForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/new"
      ],
      publishForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/publish"
      ],
      removeRepositoryForSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      repoMachinesForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/machines"
      ],
      setRepositoriesForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
      stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
      stopInOrganization: [
        "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
      ],
      updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
    },
    copilot: {
      addCopilotSeatsForTeams: [
        "POST /orgs/{org}/copilot/billing/selected_teams"
      ],
      addCopilotSeatsForUsers: [
        "POST /orgs/{org}/copilot/billing/selected_users"
      ],
      cancelCopilotSeatAssignmentForTeams: [
        "DELETE /orgs/{org}/copilot/billing/selected_teams"
      ],
      cancelCopilotSeatAssignmentForUsers: [
        "DELETE /orgs/{org}/copilot/billing/selected_users"
      ],
      getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
      getCopilotSeatDetailsForUser: [
        "GET /orgs/{org}/members/{username}/copilot"
      ],
      listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
    },
    dependabot: {
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
      getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/dependabot/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
      listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
      ]
    },
    dependencyGraph: {
      createRepositorySnapshot: [
        "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
      ],
      diffRange: [
        "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
      ],
      exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
    },
    emojis: { get: ["GET /emojis"] },
    gists: {
      checkIsStarred: ["GET /gists/{gist_id}/star"],
      create: ["POST /gists"],
      createComment: ["POST /gists/{gist_id}/comments"],
      delete: ["DELETE /gists/{gist_id}"],
      deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
      fork: ["POST /gists/{gist_id}/forks"],
      get: ["GET /gists/{gist_id}"],
      getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
      getRevision: ["GET /gists/{gist_id}/{sha}"],
      list: ["GET /gists"],
      listComments: ["GET /gists/{gist_id}/comments"],
      listCommits: ["GET /gists/{gist_id}/commits"],
      listForUser: ["GET /users/{username}/gists"],
      listForks: ["GET /gists/{gist_id}/forks"],
      listPublic: ["GET /gists/public"],
      listStarred: ["GET /gists/starred"],
      star: ["PUT /gists/{gist_id}/star"],
      unstar: ["DELETE /gists/{gist_id}/star"],
      update: ["PATCH /gists/{gist_id}"],
      updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
    },
    git: {
      createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
      createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
      createRef: ["POST /repos/{owner}/{repo}/git/refs"],
      createTag: ["POST /repos/{owner}/{repo}/git/tags"],
      createTree: ["POST /repos/{owner}/{repo}/git/trees"],
      deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
      getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
      getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
      getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
      getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
      getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
      listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
      updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
    },
    gitignore: {
      getAllTemplates: ["GET /gitignore/templates"],
      getTemplate: ["GET /gitignore/templates/{name}"]
    },
    interactions: {
      getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
      getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
      getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
      getRestrictionsForYourPublicRepos: [
        "GET /user/interaction-limits",
        {},
        { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
      ],
      removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
      removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
      removeRestrictionsForRepo: [
        "DELETE /repos/{owner}/{repo}/interaction-limits"
      ],
      removeRestrictionsForYourPublicRepos: [
        "DELETE /user/interaction-limits",
        {},
        { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
      ],
      setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
      setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
      setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
      setRestrictionsForYourPublicRepos: [
        "PUT /user/interaction-limits",
        {},
        { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
      ]
    },
    issues: {
      addAssignees: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
      checkUserCanBeAssignedToIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
      ],
      create: ["POST /repos/{owner}/{repo}/issues"],
      createComment: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
      ],
      createLabel: ["POST /repos/{owner}/{repo}/labels"],
      createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
      deleteComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
      ],
      deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
      deleteMilestone: [
        "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
      ],
      get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
      getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
      getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
      getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
      list: ["GET /issues"],
      listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
      listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
      listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
      listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
      listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
      listEventsForTimeline: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
      ],
      listForAuthenticatedUser: ["GET /user/issues"],
      listForOrg: ["GET /orgs/{org}/issues"],
      listForRepo: ["GET /repos/{owner}/{repo}/issues"],
      listLabelsForMilestone: [
        "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
      ],
      listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
      listLabelsOnIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
      lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      removeAllLabels: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      removeAssignees: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      removeLabel: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
      ],
      setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
      updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
      updateMilestone: [
        "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
      ]
    },
    licenses: {
      get: ["GET /licenses/{license}"],
      getAllCommonlyUsed: ["GET /licenses"],
      getForRepo: ["GET /repos/{owner}/{repo}/license"]
    },
    markdown: {
      render: ["POST /markdown"],
      renderRaw: [
        "POST /markdown/raw",
        { headers: { "content-type": "text/plain; charset=utf-8" } }
      ]
    },
    meta: {
      get: ["GET /meta"],
      getAllVersions: ["GET /versions"],
      getOctocat: ["GET /octocat"],
      getZen: ["GET /zen"],
      root: ["GET /"]
    },
    migrations: {
      cancelImport: [
        "DELETE /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
        }
      ],
      deleteArchiveForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/archive"
      ],
      deleteArchiveForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/archive"
      ],
      downloadArchiveForOrg: [
        "GET /orgs/{org}/migrations/{migration_id}/archive"
      ],
      getArchiveForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/archive"
      ],
      getCommitAuthors: [
        "GET /repos/{owner}/{repo}/import/authors",
        {},
        {
          deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
        }
      ],
      getImportStatus: [
        "GET /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
        }
      ],
      getLargeFiles: [
        "GET /repos/{owner}/{repo}/import/large_files",
        {},
        {
          deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
        }
      ],
      getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
      getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
      listForAuthenticatedUser: ["GET /user/migrations"],
      listForOrg: ["GET /orgs/{org}/migrations"],
      listReposForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/repositories"
      ],
      listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
      listReposForUser: [
        "GET /user/migrations/{migration_id}/repositories",
        {},
        { renamed: ["migrations", "listReposForAuthenticatedUser"] }
      ],
      mapCommitAuthor: [
        "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
        {},
        {
          deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
        }
      ],
      setLfsPreference: [
        "PATCH /repos/{owner}/{repo}/import/lfs",
        {},
        {
          deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
        }
      ],
      startForAuthenticatedUser: ["POST /user/migrations"],
      startForOrg: ["POST /orgs/{org}/migrations"],
      startImport: [
        "PUT /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
        }
      ],
      unlockRepoForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
      ],
      unlockRepoForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
      ],
      updateImport: [
        "PATCH /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
        }
      ]
    },
    oidc: {
      getOidcCustomSubTemplateForOrg: [
        "GET /orgs/{org}/actions/oidc/customization/sub"
      ],
      updateOidcCustomSubTemplateForOrg: [
        "PUT /orgs/{org}/actions/oidc/customization/sub"
      ]
    },
    orgs: {
      addSecurityManagerTeam: [
        "PUT /orgs/{org}/security-managers/teams/{team_slug}"
      ],
      assignTeamToOrgRole: [
        "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      assignUserToOrgRole: [
        "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      blockUser: ["PUT /orgs/{org}/blocks/{username}"],
      cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
      checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
      checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
      checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
      convertMemberToOutsideCollaborator: [
        "PUT /orgs/{org}/outside_collaborators/{username}"
      ],
      createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
      createInvitation: ["POST /orgs/{org}/invitations"],
      createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
      createOrUpdateCustomPropertiesValuesForRepos: [
        "PATCH /orgs/{org}/properties/values"
      ],
      createOrUpdateCustomProperty: [
        "PUT /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      createWebhook: ["POST /orgs/{org}/hooks"],
      delete: ["DELETE /orgs/{org}"],
      deleteCustomOrganizationRole: [
        "DELETE /orgs/{org}/organization-roles/{role_id}"
      ],
      deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
      enableOrDisableSecurityProductOnAllOrgRepos: [
        "POST /orgs/{org}/{security_product}/{enablement}"
      ],
      get: ["GET /orgs/{org}"],
      getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
      getCustomProperty: [
        "GET /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
      getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
      getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
      getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
      getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
      getWebhookDelivery: [
        "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      list: ["GET /organizations"],
      listAppInstallations: ["GET /orgs/{org}/installations"],
      listBlockedUsers: ["GET /orgs/{org}/blocks"],
      listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
      listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
      listForAuthenticatedUser: ["GET /user/orgs"],
      listForUser: ["GET /users/{username}/orgs"],
      listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
      listMembers: ["GET /orgs/{org}/members"],
      listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
      listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
      listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
      listOrgRoles: ["GET /orgs/{org}/organization-roles"],
      listOrganizationFineGrainedPermissions: [
        "GET /orgs/{org}/organization-fine-grained-permissions"
      ],
      listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
      listPatGrantRepositories: [
        "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
      ],
      listPatGrantRequestRepositories: [
        "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
      ],
      listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
      listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
      listPendingInvitations: ["GET /orgs/{org}/invitations"],
      listPublicMembers: ["GET /orgs/{org}/public_members"],
      listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
      listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
      listWebhooks: ["GET /orgs/{org}/hooks"],
      patchCustomOrganizationRole: [
        "PATCH /orgs/{org}/organization-roles/{role_id}"
      ],
      pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeCustomProperty: [
        "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      removeMember: ["DELETE /orgs/{org}/members/{username}"],
      removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
      removeOutsideCollaborator: [
        "DELETE /orgs/{org}/outside_collaborators/{username}"
      ],
      removePublicMembershipForAuthenticatedUser: [
        "DELETE /orgs/{org}/public_members/{username}"
      ],
      removeSecurityManagerTeam: [
        "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
      ],
      reviewPatGrantRequest: [
        "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
      ],
      reviewPatGrantRequestsInBulk: [
        "POST /orgs/{org}/personal-access-token-requests"
      ],
      revokeAllOrgRolesTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
      ],
      revokeAllOrgRolesUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}"
      ],
      revokeOrgRoleTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      revokeOrgRoleUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
      setPublicMembershipForAuthenticatedUser: [
        "PUT /orgs/{org}/public_members/{username}"
      ],
      unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
      update: ["PATCH /orgs/{org}"],
      updateMembershipForAuthenticatedUser: [
        "PATCH /user/memberships/orgs/{org}"
      ],
      updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
      updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
      updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
      updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
    },
    packages: {
      deletePackageForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}"
      ],
      deletePackageForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      deletePackageForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}"
      ],
      deletePackageVersionForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getAllPackageVersionsForAPackageOwnedByAnOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        {},
        { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
      ],
      getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions",
        {},
        {
          renamed: [
            "packages",
            "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
          ]
        }
      ],
      getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions"
      ],
      getPackageForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}"
      ],
      getPackageForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      getPackageForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}"
      ],
      getPackageVersionForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      listDockerMigrationConflictingPackagesForAuthenticatedUser: [
        "GET /user/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForOrganization: [
        "GET /orgs/{org}/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForUser: [
        "GET /users/{username}/docker/conflicts"
      ],
      listPackagesForAuthenticatedUser: ["GET /user/packages"],
      listPackagesForOrganization: ["GET /orgs/{org}/packages"],
      listPackagesForUser: ["GET /users/{username}/packages"],
      restorePackageForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageVersionForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ]
    },
    projects: {
      addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
      createCard: ["POST /projects/columns/{column_id}/cards"],
      createColumn: ["POST /projects/{project_id}/columns"],
      createForAuthenticatedUser: ["POST /user/projects"],
      createForOrg: ["POST /orgs/{org}/projects"],
      createForRepo: ["POST /repos/{owner}/{repo}/projects"],
      delete: ["DELETE /projects/{project_id}"],
      deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
      deleteColumn: ["DELETE /projects/columns/{column_id}"],
      get: ["GET /projects/{project_id}"],
      getCard: ["GET /projects/columns/cards/{card_id}"],
      getColumn: ["GET /projects/columns/{column_id}"],
      getPermissionForUser: [
        "GET /projects/{project_id}/collaborators/{username}/permission"
      ],
      listCards: ["GET /projects/columns/{column_id}/cards"],
      listCollaborators: ["GET /projects/{project_id}/collaborators"],
      listColumns: ["GET /projects/{project_id}/columns"],
      listForOrg: ["GET /orgs/{org}/projects"],
      listForRepo: ["GET /repos/{owner}/{repo}/projects"],
      listForUser: ["GET /users/{username}/projects"],
      moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
      moveColumn: ["POST /projects/columns/{column_id}/moves"],
      removeCollaborator: [
        "DELETE /projects/{project_id}/collaborators/{username}"
      ],
      update: ["PATCH /projects/{project_id}"],
      updateCard: ["PATCH /projects/columns/cards/{card_id}"],
      updateColumn: ["PATCH /projects/columns/{column_id}"]
    },
    pulls: {
      checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      create: ["POST /repos/{owner}/{repo}/pulls"],
      createReplyForReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
      ],
      createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      createReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      deletePendingReview: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      deleteReviewComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ],
      dismissReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
      ],
      get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
      getReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      list: ["GET /repos/{owner}/{repo}/pulls"],
      listCommentsForReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
      listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
      listRequestedReviewers: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      listReviewComments: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
      listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      removeRequestedReviewers: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      requestReviewers: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      submitReview: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
      ],
      update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
      updateBranch: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
      ],
      updateReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      updateReviewComment: [
        "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ]
    },
    rateLimit: { get: ["GET /rate_limit"] },
    reactions: {
      createForCommitComment: [
        "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      createForIssue: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
      ],
      createForIssueComment: [
        "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      createForPullRequestReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      createForRelease: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      createForTeamDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      createForTeamDiscussionInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ],
      deleteForCommitComment: [
        "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForIssue: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
      ],
      deleteForIssueComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForPullRequestComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForRelease: [
        "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussion: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussionComment: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
      ],
      listForCommitComment: [
        "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
      listForIssueComment: [
        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      listForPullRequestReviewComment: [
        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      listForRelease: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      listForTeamDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      listForTeamDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ]
    },
    repos: {
      acceptInvitation: [
        "PATCH /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
      ],
      acceptInvitationForAuthenticatedUser: [
        "PATCH /user/repository_invitations/{invitation_id}"
      ],
      addAppAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
      addStatusCheckContexts: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      addTeamAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      addUserAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      cancelPagesDeployment: [
        "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
      ],
      checkAutomatedSecurityFixes: [
        "GET /repos/{owner}/{repo}/automated-security-fixes"
      ],
      checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
      checkVulnerabilityAlerts: [
        "GET /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
      compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
      compareCommitsWithBasehead: [
        "GET /repos/{owner}/{repo}/compare/{basehead}"
      ],
      createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
      createCommitComment: [
        "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      createCommitSignatureProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
      createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
      createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
      createDeploymentBranchPolicy: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      createDeploymentProtectionRule: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      createDeploymentStatus: [
        "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
      createForAuthenticatedUser: ["POST /user/repos"],
      createFork: ["POST /repos/{owner}/{repo}/forks"],
      createInOrg: ["POST /orgs/{org}/repos"],
      createOrUpdateCustomPropertiesValues: [
        "PATCH /repos/{owner}/{repo}/properties/values"
      ],
      createOrUpdateEnvironment: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
      createOrgRuleset: ["POST /orgs/{org}/rulesets"],
      createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
      createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
      createRelease: ["POST /repos/{owner}/{repo}/releases"],
      createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
      createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
      createUsingTemplate: [
        "POST /repos/{template_owner}/{template_repo}/generate"
      ],
      createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
      declineInvitation: [
        "DELETE /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
      ],
      declineInvitationForAuthenticatedUser: [
        "DELETE /user/repository_invitations/{invitation_id}"
      ],
      delete: ["DELETE /repos/{owner}/{repo}"],
      deleteAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      deleteAdminBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      deleteAnEnvironment: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      deleteBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
      deleteCommitSignatureProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
      deleteDeployment: [
        "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
      ],
      deleteDeploymentBranchPolicy: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
      deleteInvitation: [
        "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
      deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
      deletePullRequestReviewProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
      deleteReleaseAsset: [
        "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      deleteTagProtection: [
        "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
      ],
      deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
      disableAutomatedSecurityFixes: [
        "DELETE /repos/{owner}/{repo}/automated-security-fixes"
      ],
      disableDeploymentProtectionRule: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      disablePrivateVulnerabilityReporting: [
        "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      disableVulnerabilityAlerts: [
        "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      downloadArchive: [
        "GET /repos/{owner}/{repo}/zipball/{ref}",
        {},
        { renamed: ["repos", "downloadZipballArchive"] }
      ],
      downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
      downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
      enableAutomatedSecurityFixes: [
        "PUT /repos/{owner}/{repo}/automated-security-fixes"
      ],
      enablePrivateVulnerabilityReporting: [
        "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      enableVulnerabilityAlerts: [
        "PUT /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      generateReleaseNotes: [
        "POST /repos/{owner}/{repo}/releases/generate-notes"
      ],
      get: ["GET /repos/{owner}/{repo}"],
      getAccessRestrictions: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      getAdminBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      getAllDeploymentProtectionRules: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
      getAllStatusCheckContexts: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
      ],
      getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
      getAppsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
      ],
      getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
      getBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
      getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
      getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
      getCollaboratorPermissionLevel: [
        "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
      ],
      getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
      getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
      getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
      getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
      getCommitSignatureProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
      getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
      getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
      getCustomDeploymentProtectionRule: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
      getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
      getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
      getDeploymentBranchPolicy: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      getDeploymentStatus: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
      ],
      getEnvironment: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
      getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
      getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
      getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
      getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
      getOrgRulesets: ["GET /orgs/{org}/rulesets"],
      getPages: ["GET /repos/{owner}/{repo}/pages"],
      getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
      getPagesDeployment: [
        "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
      ],
      getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
      getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
      getPullRequestReviewProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
      getReadme: ["GET /repos/{owner}/{repo}/readme"],
      getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
      getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
      getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
      getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
      getRepoRuleSuite: [
        "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
      ],
      getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
      getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
      getStatusChecksProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      getTeamsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
      ],
      getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
      getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
      getUsersWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
      ],
      getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
      getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
      getWebhookConfigForRepo: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      getWebhookDelivery: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      listActivities: ["GET /repos/{owner}/{repo}/activity"],
      listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
      listBranches: ["GET /repos/{owner}/{repo}/branches"],
      listBranchesForHeadCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
      ],
      listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
      listCommentsForCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
      listCommitStatusesForRef: [
        "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/commits"],
      listContributors: ["GET /repos/{owner}/{repo}/contributors"],
      listCustomDeploymentRuleIntegrations: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
      ],
      listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
      listDeploymentBranchPolicies: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      listDeploymentStatuses: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
      listForAuthenticatedUser: ["GET /user/repos"],
      listForOrg: ["GET /orgs/{org}/repos"],
      listForUser: ["GET /users/{username}/repos"],
      listForks: ["GET /repos/{owner}/{repo}/forks"],
      listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
      listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
      listLanguages: ["GET /repos/{owner}/{repo}/languages"],
      listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
      listPublic: ["GET /repositories"],
      listPullRequestsAssociatedWithCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
      ],
      listReleaseAssets: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
      ],
      listReleases: ["GET /repos/{owner}/{repo}/releases"],
      listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
      listTags: ["GET /repos/{owner}/{repo}/tags"],
      listTeams: ["GET /repos/{owner}/{repo}/teams"],
      listWebhookDeliveries: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
      ],
      listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
      merge: ["POST /repos/{owner}/{repo}/merges"],
      mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
      pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeAppAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      removeCollaborator: [
        "DELETE /repos/{owner}/{repo}/collaborators/{username}"
      ],
      removeStatusCheckContexts: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      removeStatusCheckProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      removeTeamAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      removeUserAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
      replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
      requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
      setAdminBranchProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      setAppAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      setStatusCheckContexts: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      setTeamAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      setUserAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
      transfer: ["POST /repos/{owner}/{repo}/transfer"],
      update: ["PATCH /repos/{owner}/{repo}"],
      updateBranchProtection: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
      updateDeploymentBranchPolicy: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
      updateInvitation: [
        "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
      updatePullRequestReviewProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
      updateReleaseAsset: [
        "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      updateStatusCheckPotection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        {},
        { renamed: ["repos", "updateStatusCheckProtection"] }
      ],
      updateStatusCheckProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
      updateWebhookConfigForRepo: [
        "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      uploadReleaseAsset: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
        { baseUrl: "https://uploads.github.com" }
      ]
    },
    search: {
      code: ["GET /search/code"],
      commits: ["GET /search/commits"],
      issuesAndPullRequests: ["GET /search/issues"],
      labels: ["GET /search/labels"],
      repos: ["GET /search/repositories"],
      topics: ["GET /search/topics"],
      users: ["GET /search/users"]
    },
    secretScanning: {
      getAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/secret-scanning/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
      listLocationsForAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ]
    },
    securityAdvisories: {
      createFork: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
      ],
      createPrivateVulnerabilityReport: [
        "POST /repos/{owner}/{repo}/security-advisories/reports"
      ],
      createRepositoryAdvisory: [
        "POST /repos/{owner}/{repo}/security-advisories"
      ],
      createRepositoryAdvisoryCveRequest: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
      ],
      getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
      getRepositoryAdvisory: [
        "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ],
      listGlobalAdvisories: ["GET /advisories"],
      listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
      listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
      updateRepositoryAdvisory: [
        "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ]
    },
    teams: {
      addOrUpdateMembershipForUserInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      addOrUpdateProjectPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      addOrUpdateRepoPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      checkPermissionsForProjectInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      checkPermissionsForRepoInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      create: ["POST /orgs/{org}/teams"],
      createDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
      deleteDiscussionCommentInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      deleteDiscussionInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
      getByName: ["GET /orgs/{org}/teams/{team_slug}"],
      getDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      getDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      getMembershipForUserInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      list: ["GET /orgs/{org}/teams"],
      listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
      listDiscussionCommentsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
      listForAuthenticatedUser: ["GET /user/teams"],
      listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
      listPendingInvitationsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/invitations"
      ],
      listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
      listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
      removeMembershipForUserInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      removeProjectInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      removeRepoInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      updateDiscussionCommentInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      updateDiscussionInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
    },
    users: {
      addEmailForAuthenticated: [
        "POST /user/emails",
        {},
        { renamed: ["users", "addEmailForAuthenticatedUser"] }
      ],
      addEmailForAuthenticatedUser: ["POST /user/emails"],
      addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
      block: ["PUT /user/blocks/{username}"],
      checkBlocked: ["GET /user/blocks/{username}"],
      checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
      checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
      createGpgKeyForAuthenticated: [
        "POST /user/gpg_keys",
        {},
        { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
      ],
      createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
      createPublicSshKeyForAuthenticated: [
        "POST /user/keys",
        {},
        { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
      ],
      createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
      createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
      deleteEmailForAuthenticated: [
        "DELETE /user/emails",
        {},
        { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
      ],
      deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
      deleteGpgKeyForAuthenticated: [
        "DELETE /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
      ],
      deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
      deletePublicSshKeyForAuthenticated: [
        "DELETE /user/keys/{key_id}",
        {},
        { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
      ],
      deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
      deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
      deleteSshSigningKeyForAuthenticatedUser: [
        "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      follow: ["PUT /user/following/{username}"],
      getAuthenticated: ["GET /user"],
      getByUsername: ["GET /users/{username}"],
      getContextForUser: ["GET /users/{username}/hovercard"],
      getGpgKeyForAuthenticated: [
        "GET /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
      ],
      getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
      getPublicSshKeyForAuthenticated: [
        "GET /user/keys/{key_id}",
        {},
        { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
      ],
      getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
      getSshSigningKeyForAuthenticatedUser: [
        "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      list: ["GET /users"],
      listBlockedByAuthenticated: [
        "GET /user/blocks",
        {},
        { renamed: ["users", "listBlockedByAuthenticatedUser"] }
      ],
      listBlockedByAuthenticatedUser: ["GET /user/blocks"],
      listEmailsForAuthenticated: [
        "GET /user/emails",
        {},
        { renamed: ["users", "listEmailsForAuthenticatedUser"] }
      ],
      listEmailsForAuthenticatedUser: ["GET /user/emails"],
      listFollowedByAuthenticated: [
        "GET /user/following",
        {},
        { renamed: ["users", "listFollowedByAuthenticatedUser"] }
      ],
      listFollowedByAuthenticatedUser: ["GET /user/following"],
      listFollowersForAuthenticatedUser: ["GET /user/followers"],
      listFollowersForUser: ["GET /users/{username}/followers"],
      listFollowingForUser: ["GET /users/{username}/following"],
      listGpgKeysForAuthenticated: [
        "GET /user/gpg_keys",
        {},
        { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
      ],
      listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
      listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
      listPublicEmailsForAuthenticated: [
        "GET /user/public_emails",
        {},
        { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
      ],
      listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
      listPublicKeysForUser: ["GET /users/{username}/keys"],
      listPublicSshKeysForAuthenticated: [
        "GET /user/keys",
        {},
        { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
      ],
      listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
      listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
      listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
      listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
      listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
      setPrimaryEmailVisibilityForAuthenticated: [
        "PATCH /user/email/visibility",
        {},
        { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
      ],
      setPrimaryEmailVisibilityForAuthenticatedUser: [
        "PATCH /user/email/visibility"
      ],
      unblock: ["DELETE /user/blocks/{username}"],
      unfollow: ["DELETE /user/following/{username}"],
      updateAuthenticated: ["PATCH /user"]
    }
  };
  var endpoints_default = Endpoints;
  var endpointMethodsMap = /* @__PURE__ */ new Map;
  for (const [scope, endpoints] of Object.entries(endpoints_default)) {
    for (const [methodName, endpoint] of Object.entries(endpoints)) {
      const [route, defaults, decorations] = endpoint;
      const [method, url] = route.split(/ /);
      const endpointDefaults = Object.assign({
        method,
        url
      }, defaults);
      if (!endpointMethodsMap.has(scope)) {
        endpointMethodsMap.set(scope, /* @__PURE__ */ new Map);
      }
      endpointMethodsMap.get(scope).set(methodName, {
        scope,
        methodName,
        endpointDefaults,
        decorations
      });
    }
  }
  var handler = {
    has({ scope }, methodName) {
      return endpointMethodsMap.get(scope).has(methodName);
    },
    getOwnPropertyDescriptor(target, methodName) {
      return {
        value: this.get(target, methodName),
        configurable: true,
        writable: true,
        enumerable: true
      };
    },
    defineProperty(target, methodName, descriptor) {
      Object.defineProperty(target.cache, methodName, descriptor);
      return true;
    },
    deleteProperty(target, methodName) {
      delete target.cache[methodName];
      return true;
    },
    ownKeys({ scope }) {
      return [...endpointMethodsMap.get(scope).keys()];
    },
    set(target, methodName, value) {
      return target.cache[methodName] = value;
    },
    get({ octokit, scope, cache }, methodName) {
      if (cache[methodName]) {
        return cache[methodName];
      }
      const method = endpointMethodsMap.get(scope).get(methodName);
      if (!method) {
        return;
      }
      const { endpointDefaults, decorations } = method;
      if (decorations) {
        cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
      } else {
        cache[methodName] = octokit.request.defaults(endpointDefaults);
      }
      return cache[methodName];
    }
  };
  function endpointsToMethods(octokit) {
    const newMethods = {};
    for (const scope of endpointMethodsMap.keys()) {
      newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
    }
    return newMethods;
  }
  function decorate(octokit, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit.request.defaults(defaults);
    function withDecorations(...args) {
      let options = requestWithDefaults.endpoint.merge(...args);
      if (decorations.mapToData) {
        options = Object.assign({}, options, {
          data: options[decorations.mapToData],
          [decorations.mapToData]: undefined
        });
        return requestWithDefaults(options);
      }
      if (decorations.renamed) {
        const [newScope, newMethodName] = decorations.renamed;
        octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
      }
      if (decorations.deprecated) {
        octokit.log.warn(decorations.deprecated);
      }
      if (decorations.renamedParameters) {
        const options2 = requestWithDefaults.endpoint.merge(...args);
        for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
          if (name in options2) {
            octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
            if (!(alias in options2)) {
              options2[alias] = options2[name];
            }
            delete options2[name];
          }
        }
        return requestWithDefaults(options2);
      }
      return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
  }
  function restEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit);
    return {
      rest: api
    };
  }
  restEndpointMethods.VERSION = VERSION;
  function legacyRestEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit);
    return {
      ...api,
      rest: api
    };
  }
  legacyRestEndpointMethods.VERSION = VERSION;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node10 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    composePaginateRest: () => composePaginateRest,
    isPaginatingEndpoint: () => isPaginatingEndpoint,
    paginateRest: () => paginateRest,
    paginatingEndpoints: () => paginatingEndpoints
  });
  module.exports = __toCommonJS2(dist_src_exports);
  var VERSION = "9.2.2";
  function normalizePaginatedListResponse(response) {
    if (!response.data) {
      return {
        ...response,
        data: []
      };
    }
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization)
      return response;
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
      response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
      response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
  }
  function iterator(octokit, route, parameters) {
    const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
      [Symbol.asyncIterator]: () => ({
        async next() {
          if (!url)
            return { done: true };
          try {
            const response = await requestMethod({ method, url, headers });
            const normalizedResponse = normalizePaginatedListResponse(response);
            url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
            return { value: normalizedResponse };
          } catch (error) {
            if (error.status !== 409)
              throw error;
            url = "";
            return {
              value: {
                status: 200,
                headers: {},
                data: []
              }
            };
          }
        }
      })
    };
  }
  function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
      mapFn = parameters;
      parameters = undefined;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
  }
  function gather(octokit, results, iterator2, mapFn) {
    return iterator2.next().then((result) => {
      if (result.done) {
        return results;
      }
      let earlyExit = false;
      function done() {
        earlyExit = true;
      }
      results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
      if (earlyExit) {
        return results;
      }
      return gather(octokit, results, iterator2, mapFn);
    });
  }
  var composePaginateRest = Object.assign(paginate, {
    iterator
  });
  var paginatingEndpoints = [
    "GET /advisories",
    "GET /app/hook/deliveries",
    "GET /app/installation-requests",
    "GET /app/installations",
    "GET /assignments/{assignment_id}/accepted_assignments",
    "GET /classrooms",
    "GET /classrooms/{classroom_id}/assignments",
    "GET /enterprises/{enterprise}/dependabot/alerts",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/actions/variables",
    "GET /orgs/{org}/actions/variables/{name}/repositories",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/codespaces/secrets",
    "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/copilot/billing/seats",
    "GET /orgs/{org}/dependabot/alerts",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/members/{username}/codespaces",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/organization-roles/{role_id}/teams",
    "GET /orgs/{org}/organization-roles/{role_id}/users",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/personal-access-token-requests",
    "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
    "GET /orgs/{org}/personal-access-tokens",
    "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/properties/values",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/rulesets",
    "GET /orgs/{org}/rulesets/rule-suites",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/security-advisories",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/organization-secrets",
    "GET /repos/{owner}/{repo}/actions/organization-variables",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/variables",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/activity",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/alerts",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/rules/branches/{branch}",
    "GET /repos/{owner}/{repo}/rulesets",
    "GET /repos/{owner}/{repo}/rulesets/rule-suites",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/security-advisories",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
    "GET /repositories/{repository_id}/environments/{environment_name}/variables",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/social_accounts",
    "GET /user/ssh_signing_keys",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/social_accounts",
    "GET /users/{username}/ssh_signing_keys",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions"
  ];
  function isPaginatingEndpoint(arg) {
    if (typeof arg === "string") {
      return paginatingEndpoints.includes(arg);
    } else {
      return false;
    }
  }
  function paginateRest(octokit) {
    return {
      paginate: Object.assign(paginate.bind(null, octokit), {
        iterator: iterator.bind(null, octokit)
      })
    };
  }
  paginateRest.VERSION = VERSION;
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/utils.js
var require_utils7 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = undefined;
  var Context = __importStar(require_context());
  var Utils = __importStar(require_utils6());
  var core_1 = require_dist_node8();
  var plugin_rest_endpoint_methods_1 = require_dist_node9();
  var plugin_paginate_rest_1 = require_dist_node10();
  exports.context = new Context.Context;
  var baseUrl = Utils.getApiBaseUrl();
  exports.defaults = {
    baseUrl,
    request: {
      agent: Utils.getProxyAgent(baseUrl),
      fetch: Utils.getProxyFetch(baseUrl)
    }
  };
  exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
  function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {});
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
      opts.auth = auth;
    }
    return opts;
  }
  exports.getOctokitOptions = getOctokitOptions;
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/github.js
var require_github = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOctokit = exports.context = undefined;
  var Context = __importStar(require_context());
  var utils_1 = require_utils7();
  exports.context = new Context.Context;
  function getOctokit(token, options, ...additionalPlugins) {
    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
    return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
  }
  exports.getOctokit = getOctokit;
});

// node_modules/traverse/index.js
var require_traverse = __commonJS((exports, module) => {
  module.exports = Traverse;
  function Traverse(obj) {
    if (!(this instanceof Traverse))
      return new Traverse(obj);
    this.value = obj;
  }
  Traverse.prototype.get = function(ps) {
    var node = this.value;
    for (var i = 0;i < ps.length; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node, key)) {
        node = undefined;
        break;
      }
      node = node[key];
    }
    return node;
  };
  Traverse.prototype.set = function(ps, value) {
    var node = this.value;
    for (var i = 0;i < ps.length - 1; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node, key))
        node[key] = {};
      node = node[key];
    }
    node[ps[i]] = value;
    return value;
  };
  Traverse.prototype.map = function(cb) {
    return walk(this.value, cb, true);
  };
  Traverse.prototype.forEach = function(cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
  };
  Traverse.prototype.reduce = function(cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function(x) {
      if (!this.isRoot || !skip) {
        acc = cb.call(this, acc, x);
      }
    });
    return acc;
  };
  Traverse.prototype.deepEqual = function(obj) {
    if (arguments.length !== 1) {
      throw new Error("deepEqual requires exactly one object to compare against");
    }
    var equal = true;
    var node = obj;
    this.forEach(function(y) {
      var notEqual = function() {
        equal = false;
        return;
      }.bind(this);
      if (!this.isRoot) {
        if (typeof node !== "object")
          return notEqual();
        node = node[this.key];
      }
      var x = node;
      this.post(function() {
        node = x;
      });
      var toS = function(o) {
        return Object.prototype.toString.call(o);
      };
      if (this.circular) {
        if (Traverse(obj).get(this.circular.path) !== x)
          notEqual();
      } else if (typeof x !== typeof y) {
        notEqual();
      } else if (x === null || y === null || x === undefined || y === undefined) {
        if (x !== y)
          notEqual();
      } else if (x.__proto__ !== y.__proto__) {
        notEqual();
      } else if (x === y) {} else if (typeof x === "function") {
        if (x instanceof RegExp) {
          if (x.toString() != y.toString())
            notEqual();
        } else if (x !== y)
          notEqual();
      } else if (typeof x === "object") {
        if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
          if (toS(x) !== toS(y)) {
            notEqual();
          }
        } else if (x instanceof Date || y instanceof Date) {
          if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
            notEqual();
          }
        } else {
          var kx = Object.keys(x);
          var ky = Object.keys(y);
          if (kx.length !== ky.length)
            return notEqual();
          for (var i = 0;i < kx.length; i++) {
            var k = kx[i];
            if (!Object.hasOwnProperty.call(y, k)) {
              notEqual();
            }
          }
        }
      }
    });
    return equal;
  };
  Traverse.prototype.paths = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.path);
    });
    return acc;
  };
  Traverse.prototype.nodes = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.node);
    });
    return acc;
  };
  Traverse.prototype.clone = function() {
    var parents = [], nodes = [];
    return function clone(src) {
      for (var i = 0;i < parents.length; i++) {
        if (parents[i] === src) {
          return nodes[i];
        }
      }
      if (typeof src === "object" && src !== null) {
        var dst = copy(src);
        parents.push(src);
        nodes.push(dst);
        Object.keys(src).forEach(function(key) {
          dst[key] = clone(src[key]);
        });
        parents.pop();
        nodes.pop();
        return dst;
      } else {
        return src;
      }
    }(this.value);
  };
  function walk(root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
      var node = immutable ? copy(node_) : node_;
      var modifiers = {};
      var state = {
        node,
        node_,
        path: [].concat(path),
        parent: parents.slice(-1)[0],
        key: path.slice(-1)[0],
        isRoot: path.length === 0,
        level: path.length,
        circular: null,
        update: function(x) {
          if (!state.isRoot) {
            state.parent.node[state.key] = x;
          }
          state.node = x;
        },
        delete: function() {
          delete state.parent.node[state.key];
        },
        remove: function() {
          if (Array.isArray(state.parent.node)) {
            state.parent.node.splice(state.key, 1);
          } else {
            delete state.parent.node[state.key];
          }
        },
        before: function(f) {
          modifiers.before = f;
        },
        after: function(f) {
          modifiers.after = f;
        },
        pre: function(f) {
          modifiers.pre = f;
        },
        post: function(f) {
          modifiers.post = f;
        },
        stop: function() {
          alive = false;
        }
      };
      if (!alive)
        return state;
      if (typeof node === "object" && node !== null) {
        state.isLeaf = Object.keys(node).length == 0;
        for (var i = 0;i < parents.length; i++) {
          if (parents[i].node_ === node_) {
            state.circular = parents[i];
            break;
          }
        }
      } else {
        state.isLeaf = true;
      }
      state.notLeaf = !state.isLeaf;
      state.notRoot = !state.isRoot;
      var ret = cb.call(state, state.node);
      if (ret !== undefined && state.update)
        state.update(ret);
      if (modifiers.before)
        modifiers.before.call(state, state.node);
      if (typeof state.node == "object" && state.node !== null && !state.circular) {
        parents.push(state);
        var keys = Object.keys(state.node);
        keys.forEach(function(key, i2) {
          path.push(key);
          if (modifiers.pre)
            modifiers.pre.call(state, state.node[key], key);
          var child = walker(state.node[key]);
          if (immutable && Object.hasOwnProperty.call(state.node, key)) {
            state.node[key] = child.node;
          }
          child.isLast = i2 == keys.length - 1;
          child.isFirst = i2 == 0;
          if (modifiers.post)
            modifiers.post.call(state, child);
          path.pop();
        });
        parents.pop();
      }
      if (modifiers.after)
        modifiers.after.call(state, state.node);
      return state;
    }(root).node;
  }
  Object.keys(Traverse.prototype).forEach(function(key) {
    Traverse[key] = function(obj) {
      var args = [].slice.call(arguments, 1);
      var t = Traverse(obj);
      return t[key].apply(t, args);
    };
  });
  function copy(src) {
    if (typeof src === "object" && src !== null) {
      var dst;
      if (Array.isArray(src)) {
        dst = [];
      } else if (src instanceof Date) {
        dst = new Date(src);
      } else if (src instanceof Boolean) {
        dst = new Boolean(src);
      } else if (src instanceof Number) {
        dst = new Number(src);
      } else if (src instanceof String) {
        dst = new String(src);
      } else {
        dst = Object.create(Object.getPrototypeOf(src));
      }
      Object.keys(src).forEach(function(key) {
        dst[key] = src[key];
      });
      return dst;
    } else
      return src;
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS((exports, module) => {
  var Traverse = require_traverse();
  var EventEmitter = __require("events").EventEmitter;
  module.exports = Chainsaw;
  function Chainsaw(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined)
      saw.handlers = r;
    saw.record();
    return saw.chain();
  }
  Chainsaw.light = function ChainsawLight(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined)
      saw.handlers = r;
    return saw.chain();
  };
  Chainsaw.saw = function(builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];
    saw.chain = function() {
      var ch = Traverse(saw.handlers).map(function(node) {
        if (this.isRoot)
          return node;
        var ps = this.path;
        if (typeof node === "function") {
          this.update(function() {
            saw.actions.push({
              path: ps,
              args: [].slice.call(arguments)
            });
            return ch;
          });
        }
      });
      process.nextTick(function() {
        saw.emit("begin");
        saw.next();
      });
      return ch;
    };
    saw.pop = function() {
      return saw.actions.shift();
    };
    saw.next = function() {
      var action = saw.pop();
      if (!action) {
        saw.emit("end");
      } else if (!action.trap) {
        var node = saw.handlers;
        action.path.forEach(function(key) {
          node = node[key];
        });
        node.apply(saw.handlers, action.args);
      }
    };
    saw.nest = function(cb) {
      var args = [].slice.call(arguments, 1);
      var autonext = true;
      if (typeof cb === "boolean") {
        var autonext = cb;
        cb = args.shift();
      }
      var s = Chainsaw.saw(builder, {});
      var r = builder.call(s.handlers, s);
      if (r !== undefined)
        s.handlers = r;
      if (typeof saw.step !== "undefined") {
        s.record();
      }
      cb.apply(s.chain(), args);
      if (autonext !== false)
        s.on("end", saw.next);
    };
    saw.record = function() {
      upgradeChainsaw(saw);
    };
    ["trap", "down", "jump"].forEach(function(method) {
      saw[method] = function() {
        throw new Error("To use the trap, down and jump features, please " + "call record() first to start recording actions.");
      };
    });
    return saw;
  };
  function upgradeChainsaw(saw) {
    saw.step = 0;
    saw.pop = function() {
      return saw.actions[saw.step++];
    };
    saw.trap = function(name, cb) {
      var ps = Array.isArray(name) ? name : [name];
      saw.actions.push({
        path: ps,
        step: saw.step,
        cb,
        trap: true
      });
    };
    saw.down = function(name) {
      var ps = (Array.isArray(name) ? name : [name]).join("/");
      var i = saw.actions.slice(saw.step).map(function(x) {
        if (x.trap && x.step <= saw.step)
          return false;
        return x.path.join("/") == ps;
      }).indexOf(true);
      if (i >= 0)
        saw.step += i;
      else
        saw.step = saw.actions.length;
      var act = saw.actions[saw.step - 1];
      if (act && act.trap) {
        saw.step = act.step;
        act.cb();
      } else
        saw.next();
    };
    saw.jump = function(step) {
      saw.step = step;
      saw.next();
    };
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS((exports, module) => {
  module.exports = Buffers;
  function Buffers(bufs) {
    if (!(this instanceof Buffers))
      return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function(size, buf) {
      return size + buf.length;
    }, 0);
  }
  Buffers.prototype.push = function() {
    for (var i = 0;i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to push a non-buffer");
      }
    }
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.push(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.unshift = function() {
    for (var i = 0;i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to unshift a non-buffer");
      }
    }
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.unshift(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.copy = function(dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
  };
  Buffers.prototype.splice = function(i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    if (howMany === undefined) {
      howMany = this.length - index;
    } else if (howMany > this.length - index) {
      howMany = this.length - index;
    }
    for (var i = 0;i < reps.length; i++) {
      this.length += reps[i].length;
    }
    var removed = new Buffers;
    var bytes = 0;
    var startBytes = 0;
    for (var ii = 0;ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
      startBytes += buffers[ii].length;
    }
    if (index - startBytes > 0) {
      var start = index - startBytes;
      if (start + howMany < buffers[ii].length) {
        removed.push(buffers[ii].slice(start, start + howMany));
        var orig = buffers[ii];
        var buf0 = new Buffer(start);
        for (var i = 0;i < start; i++) {
          buf0[i] = orig[i];
        }
        var buf1 = new Buffer(orig.length - start - howMany);
        for (var i = start + howMany;i < orig.length; i++) {
          buf1[i - howMany - start] = orig[i];
        }
        if (reps.length > 0) {
          var reps_ = reps.slice();
          reps_.unshift(buf0);
          reps_.push(buf1);
          buffers.splice.apply(buffers, [ii, 1].concat(reps_));
          ii += reps_.length;
          reps = [];
        } else {
          buffers.splice(ii, 1, buf0, buf1);
          ii += 2;
        }
      } else {
        removed.push(buffers[ii].slice(start));
        buffers[ii] = buffers[ii].slice(0, start);
        ii++;
      }
    }
    if (reps.length > 0) {
      buffers.splice.apply(buffers, [ii, 0].concat(reps));
      ii += reps.length;
    }
    while (removed.length < howMany) {
      var buf = buffers[ii];
      var len = buf.length;
      var take = Math.min(len, howMany - removed.length);
      if (take === len) {
        removed.push(buf);
        buffers.splice(ii, 1);
      } else {
        removed.push(buf.slice(0, take));
        buffers[ii] = buffers[ii].slice(take);
      }
    }
    this.length -= removed.length;
    return removed;
  };
  Buffers.prototype.slice = function(i, j) {
    var buffers = this.buffers;
    if (j === undefined)
      j = this.length;
    if (i === undefined)
      i = 0;
    if (j > this.length)
      j = this.length;
    var startBytes = 0;
    for (var si = 0;si < buffers.length && startBytes + buffers[si].length <= i; si++) {
      startBytes += buffers[si].length;
    }
    var target = new Buffer(j - i);
    var ti = 0;
    for (var ii = si;ti < j - i && ii < buffers.length; ii++) {
      var len = buffers[ii].length;
      var start = ti === 0 ? i - startBytes : 0;
      var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
      buffers[ii].copy(target, ti, start, end);
      ti += end - start;
    }
    return target;
  };
  Buffers.prototype.pos = function(i) {
    if (i < 0 || i >= this.length)
      throw new Error("oob");
    var l = i, bi = 0, bu = null;
    for (;; ) {
      bu = this.buffers[bi];
      if (l < bu.length) {
        return { buf: bi, offset: l };
      } else {
        l -= bu.length;
      }
      bi++;
    }
  };
  Buffers.prototype.get = function get(i) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].get(pos.offset);
  };
  Buffers.prototype.set = function set(i, b) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].set(pos.offset, b);
  };
  Buffers.prototype.indexOf = function(needle, offset) {
    if (typeof needle === "string") {
      needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {} else {
      throw new Error("Invalid type for a search string");
    }
    if (!needle.length) {
      return 0;
    }
    if (!this.length) {
      return -1;
    }
    var i = 0, j = 0, match = 0, mstart, pos = 0;
    if (offset) {
      var p = this.pos(offset);
      i = p.buf;
      j = p.offset;
      pos = offset;
    }
    for (;; ) {
      while (j >= this.buffers[i].length) {
        j = 0;
        i++;
        if (i >= this.buffers.length) {
          return -1;
        }
      }
      var char = this.buffers[i][j];
      if (char == needle[match]) {
        if (match == 0) {
          mstart = {
            i,
            j,
            pos
          };
        }
        match++;
        if (match == needle.length) {
          return mstart.pos;
        }
      } else if (match != 0) {
        i = mstart.i;
        j = mstart.j;
        pos = mstart.pos;
        match = 0;
      }
      j++;
      pos++;
    }
  };
  Buffers.prototype.toBuffer = function() {
    return this.slice();
  };
  Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS((exports, module) => {
  module.exports = function(store) {
    function getset(name, value) {
      var node = vars.store;
      var keys = name.split(".");
      keys.slice(0, -1).forEach(function(k) {
        if (node[k] === undefined)
          node[k] = {};
        node = node[k];
      });
      var key = keys[keys.length - 1];
      if (arguments.length == 1) {
        return node[key];
      } else {
        return node[key] = value;
      }
    }
    var vars = {
      get: function(name) {
        return getset(name);
      },
      set: function(name, value) {
        return getset(name, value);
      },
      store: store || {}
    };
    return vars;
  };
});

// node_modules/binary/index.js
var require_binary = __commonJS((exports, module) => {
  var Chainsaw = require_chainsaw();
  var EventEmitter = __require("events").EventEmitter;
  var Buffers = require_buffers();
  var Vars = require_vars();
  var Stream = __require("stream").Stream;
  exports = module.exports = function(bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
      return exports.parse(bufOrEm);
    }
    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe) {
      bufOrEm.pipe(s);
    } else if (bufOrEm) {
      bufOrEm.on(eventName || "data", function(buf) {
        s.write(buf);
      });
      bufOrEm.on("end", function() {
        s.end();
      });
    }
    return s;
  };
  exports.stream = function(input) {
    if (input)
      return exports.apply(null, arguments);
    var pending = null;
    function getBytes(bytes, cb, skip) {
      pending = {
        bytes,
        skip,
        cb: function(buf) {
          pending = null;
          cb(buf);
        }
      };
      dispatch();
    }
    var offset = null;
    function dispatch() {
      if (!pending) {
        if (caughtEnd)
          done = true;
        return;
      }
      if (typeof pending === "function") {
        pending();
      } else {
        var bytes = offset + pending.bytes;
        if (buffers.length >= bytes) {
          var buf;
          if (offset == null) {
            buf = buffers.splice(0, bytes);
            if (!pending.skip) {
              buf = buf.slice();
            }
          } else {
            if (!pending.skip) {
              buf = buffers.slice(offset, bytes);
            }
            offset = bytes;
          }
          if (pending.skip) {
            pending.cb();
          } else {
            pending.cb(buf);
          }
        }
      }
    }
    function builder(saw) {
      function next() {
        if (!done)
          saw.next();
      }
      var self2 = words(function(bytes, cb) {
        return function(name) {
          getBytes(bytes, function(buf) {
            vars.set(name, cb(buf));
            next();
          });
        };
      });
      self2.tap = function(cb) {
        saw.nest(cb, vars.store);
      };
      self2.into = function(key, cb) {
        if (!vars.get(key))
          vars.set(key, {});
        var parent = vars;
        vars = Vars(parent.get(key));
        saw.nest(function() {
          cb.apply(this, arguments);
          this.tap(function() {
            vars = parent;
          });
        }, vars.store);
      };
      self2.flush = function() {
        vars.store = {};
        next();
      };
      self2.loop = function(cb) {
        var end = false;
        saw.nest(false, function loop() {
          this.vars = vars.store;
          cb.call(this, function() {
            end = true;
            next();
          }, vars.store);
          this.tap(function() {
            if (end)
              saw.next();
            else
              loop.call(this);
          }.bind(this));
        }, vars.store);
      };
      self2.buffer = function(name, bytes) {
        if (typeof bytes === "string") {
          bytes = vars.get(bytes);
        }
        getBytes(bytes, function(buf) {
          vars.set(name, buf);
          next();
        });
      };
      self2.skip = function(bytes) {
        if (typeof bytes === "string") {
          bytes = vars.get(bytes);
        }
        getBytes(bytes, function() {
          next();
        });
      };
      self2.scan = function find(name, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        var taken = 0;
        pending = function() {
          var pos = buffers.indexOf(search, offset + taken);
          var i = pos - offset - taken;
          if (pos !== -1) {
            pending = null;
            if (offset != null) {
              vars.set(name, buffers.slice(offset, offset + taken + i));
              offset += taken + i + search.length;
            } else {
              vars.set(name, buffers.slice(0, taken + i));
              buffers.splice(0, taken + i + search.length);
            }
            next();
            dispatch();
          } else {
            i = Math.max(buffers.length - search.length - offset - taken, 0);
          }
          taken += i;
        };
        dispatch();
      };
      self2.peek = function(cb) {
        offset = 0;
        saw.nest(function() {
          cb.call(this, vars.store);
          this.tap(function() {
            offset = null;
          });
        });
      };
      return self2;
    }
    var stream = Chainsaw.light(builder);
    stream.writable = true;
    var buffers = Buffers();
    stream.write = function(buf) {
      buffers.push(buf);
      dispatch();
    };
    var vars = Vars();
    var done = false, caughtEnd = false;
    stream.end = function() {
      caughtEnd = true;
    };
    stream.pipe = Stream.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function(name) {
      stream[name] = EventEmitter.prototype[name];
    });
    return stream;
  };
  exports.parse = function parse(buffer) {
    var self2 = words(function(bytes, cb) {
      return function(name) {
        if (offset + bytes <= buffer.length) {
          var buf = buffer.slice(offset, offset + bytes);
          offset += bytes;
          vars.set(name, cb(buf));
        } else {
          vars.set(name, null);
        }
        return self2;
      };
    });
    var offset = 0;
    var vars = Vars();
    self2.vars = vars.store;
    self2.tap = function(cb) {
      cb.call(self2, vars.store);
      return self2;
    };
    self2.into = function(key, cb) {
      if (!vars.get(key)) {
        vars.set(key, {});
      }
      var parent = vars;
      vars = Vars(parent.get(key));
      cb.call(self2, vars.store);
      vars = parent;
      return self2;
    };
    self2.loop = function(cb) {
      var end = false;
      var ender = function() {
        end = true;
      };
      while (end === false) {
        cb.call(self2, ender, vars.store);
      }
      return self2;
    };
    self2.buffer = function(name, size) {
      if (typeof size === "string") {
        size = vars.get(size);
      }
      var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
      offset += size;
      vars.set(name, buf);
      return self2;
    };
    self2.skip = function(bytes) {
      if (typeof bytes === "string") {
        bytes = vars.get(bytes);
      }
      offset += bytes;
      return self2;
    };
    self2.scan = function(name, search) {
      if (typeof search === "string") {
        search = new Buffer(search);
      } else if (!Buffer.isBuffer(search)) {
        throw new Error("search must be a Buffer or a string");
      }
      vars.set(name, null);
      for (var i = 0;i + offset <= buffer.length - search.length + 1; i++) {
        for (var j = 0;j < search.length && buffer[offset + i + j] === search[j]; j++)
          ;
        if (j === search.length)
          break;
      }
      vars.set(name, buffer.slice(offset, offset + i));
      offset += i + search.length;
      return self2;
    };
    self2.peek = function(cb) {
      var was = offset;
      cb.call(self2, vars.store);
      offset = was;
      return self2;
    };
    self2.flush = function() {
      vars.store = {};
      return self2;
    };
    self2.eof = function() {
      return offset >= buffer.length;
    };
    return self2;
  };
  function decodeLEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++) {
      acc += Math.pow(256, i) * bytes[i];
    }
    return acc;
  }
  function decodeBEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++) {
      acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    }
    return acc;
  }
  function decodeBEs(bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function decodeLEs(bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function words(decode) {
    var self2 = {};
    [1, 2, 4, 8].forEach(function(bytes) {
      var bits = bytes * 8;
      self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes, decodeLEu);
      self2["word" + bits + "ls"] = decode(bytes, decodeLEs);
      self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes, decodeBEu);
      self2["word" + bits + "bs"] = decode(bytes, decodeBEs);
    });
    self2.word8 = self2.word8u = self2.word8be;
    self2.word8s = self2.word8bs;
    return self2;
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform;
  var util = __require("util");
  function MatcherStream(patternDesc, matchFn) {
    if (!(this instanceof MatcherStream)) {
      return new MatcherStream;
    }
    Transform.call(this);
    var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
    this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
    this.requiredLength = this.pattern.length;
    if (patternDesc.requiredExtraSize)
      this.requiredLength += patternDesc.requiredExtraSize;
    this.data = new Buffer("");
    this.bytesSoFar = 0;
    this.matchFn = matchFn;
  }
  util.inherits(MatcherStream, Transform);
  MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
    var enoughData = this.data.length >= this.requiredLength;
    if (!enoughData) {
      return;
    }
    var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
    if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
        this.data = this.data.slice(matchIndex);
      }
      return;
    }
    if (matchIndex === -1) {
      var packetLen = this.data.length - this.requiredLength + 1;
      var packet = this.data.slice(0, packetLen);
      this.push(packet);
      this.bytesSoFar += packetLen;
      this.data = this.data.slice(packetLen);
      return;
    }
    if (matchIndex > 0) {
      var packet = this.data.slice(0, matchIndex);
      this.data = this.data.slice(matchIndex);
      this.push(packet);
      this.bytesSoFar += matchIndex;
    }
    var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
    if (finished) {
      this.data = new Buffer("");
      return;
    }
    return true;
  };
  MatcherStream.prototype._transform = function(chunk, encoding, cb) {
    this.data = Buffer.concat([this.data, chunk]);
    var firstIteration = true;
    while (this.checkDataChunk(!firstIteration)) {
      firstIteration = false;
    }
    cb();
  };
  MatcherStream.prototype._flush = function(cb) {
    if (this.data.length > 0) {
      var firstIteration = true;
      while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
      }
    }
    if (this.data.length > 0) {
      this.push(this.data);
      this.data = null;
    }
    cb();
  };
  module.exports = MatcherStream;
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS((exports, module) => {
  var stream = __require("stream");
  var inherits = __require("util").inherits;
  function Entry() {
    if (!(this instanceof Entry)) {
      return new Entry;
    }
    stream.PassThrough.call(this);
    this.path = null;
    this.type = null;
    this.isDirectory = false;
  }
  inherits(Entry, stream.PassThrough);
  Entry.prototype.autodrain = function() {
    return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
      cb();
    } }));
  };
  module.exports = Entry;
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS((exports, module) => {
  var binary = require_binary();
  var stream = __require("stream");
  var util = __require("util");
  var zlib = __require("zlib");
  var MatcherStream = require_matcher_stream();
  var Entry = require_entry();
  var states = {
    STREAM_START: 0,
    START: 1,
    LOCAL_FILE_HEADER: 2,
    LOCAL_FILE_HEADER_SUFFIX: 3,
    FILE_DATA: 4,
    FILE_DATA_END: 5,
    DATA_DESCRIPTOR: 6,
    CENTRAL_DIRECTORY_FILE_HEADER: 7,
    CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
    CDIR64_END: 9,
    CDIR64_END_DATA_SECTOR: 10,
    CDIR64_LOCATOR: 11,
    CENTRAL_DIRECTORY_END: 12,
    CENTRAL_DIRECTORY_END_COMMENT: 13,
    TRAILING_JUNK: 14,
    ERROR: 99
  };
  var FOUR_GIGS = 4294967296;
  var SIG_LOCAL_FILE_HEADER = 67324752;
  var SIG_DATA_DESCRIPTOR = 134695760;
  var SIG_CDIR_RECORD = 33639248;
  var SIG_CDIR64_RECORD_END = 101075792;
  var SIG_CDIR64_LOCATOR_END = 117853008;
  var SIG_CDIR_RECORD_END = 101010256;
  function UnzipStream(options) {
    if (!(this instanceof UnzipStream)) {
      return new UnzipStream(options);
    }
    stream.Transform.call(this);
    this.options = options || {};
    this.data = new Buffer("");
    this.state = states.STREAM_START;
    this.skippedBytes = 0;
    this.parsedEntity = null;
    this.outStreamInfo = {};
  }
  util.inherits(UnzipStream, stream.Transform);
  UnzipStream.prototype.processDataChunk = function(chunk) {
    var requiredLength;
    switch (this.state) {
      case states.STREAM_START:
      case states.START:
        requiredLength = 4;
        break;
      case states.LOCAL_FILE_HEADER:
        requiredLength = 26;
        break;
      case states.LOCAL_FILE_HEADER_SUFFIX:
        requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
        break;
      case states.DATA_DESCRIPTOR:
        requiredLength = 12;
        break;
      case states.CENTRAL_DIRECTORY_FILE_HEADER:
        requiredLength = 42;
        break;
      case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
        requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
        break;
      case states.CDIR64_END:
        requiredLength = 52;
        break;
      case states.CDIR64_END_DATA_SECTOR:
        requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
        break;
      case states.CDIR64_LOCATOR:
        requiredLength = 16;
        break;
      case states.CENTRAL_DIRECTORY_END:
        requiredLength = 18;
        break;
      case states.CENTRAL_DIRECTORY_END_COMMENT:
        requiredLength = this.parsedEntity.commentLength;
        break;
      case states.FILE_DATA:
        return 0;
      case states.FILE_DATA_END:
        return 0;
      case states.TRAILING_JUNK:
        if (this.options.debug)
          console.log("found", chunk.length, "bytes of TRAILING_JUNK");
        return chunk.length;
      default:
        return chunk.length;
    }
    var chunkLength = chunk.length;
    if (chunkLength < requiredLength) {
      return 0;
    }
    switch (this.state) {
      case states.STREAM_START:
      case states.START:
        var signature = chunk.readUInt32LE(0);
        switch (signature) {
          case SIG_LOCAL_FILE_HEADER:
            this.state = states.LOCAL_FILE_HEADER;
            break;
          case SIG_CDIR_RECORD:
            this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
            break;
          case SIG_CDIR64_RECORD_END:
            this.state = states.CDIR64_END;
            break;
          case SIG_CDIR64_LOCATOR_END:
            this.state = states.CDIR64_LOCATOR;
            break;
          case SIG_CDIR_RECORD_END:
            this.state = states.CENTRAL_DIRECTORY_END;
            break;
          default:
            var isStreamStart = this.state === states.STREAM_START;
            if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
              var remaining = signature;
              var toSkip = 4;
              for (var i = 1;i < 4 && remaining !== 0; i++) {
                remaining = remaining >>> 8;
                if ((remaining & 255) === 80) {
                  toSkip = i;
                  break;
                }
              }
              this.skippedBytes += toSkip;
              if (this.options.debug)
                console.log("Skipped", this.skippedBytes, "bytes");
              return toSkip;
            }
            this.state = states.ERROR;
            var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
            if (this.options.debug) {
              var sig = chunk.readUInt32LE(0);
              var asString;
              try {
                asString = chunk.slice(0, 4).toString();
              } catch (e) {}
              console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
            }
            this.emit("error", new Error(errMsg));
            return chunk.length;
        }
        this.skippedBytes = 0;
        return requiredLength;
      case states.LOCAL_FILE_HEADER:
        this.parsedEntity = this._readFile(chunk);
        this.state = states.LOCAL_FILE_HEADER_SUFFIX;
        return requiredLength;
      case states.LOCAL_FILE_HEADER_SUFFIX:
        var entry = new Entry;
        var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
        entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
        var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
        var extra = this._readExtraFields(extraDataBuffer);
        if (extra && extra.parsed) {
          if (extra.parsed.path && !isUtf8) {
            entry.path = extra.parsed.path;
          }
          if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) {
            this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
          }
          if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) {
            this.parsedEntity.compressedSize = extra.parsed.compressedSize;
          }
        }
        this.parsedEntity.extra = extra.parsed || {};
        if (this.options.debug) {
          const debugObj = Object.assign({}, this.parsedEntity, {
            path: entry.path,
            flags: "0x" + this.parsedEntity.flags.toString(16),
            extraFields: extra && extra.debug
          });
          console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
        }
        this._prepareOutStream(this.parsedEntity, entry);
        this.emit("entry", entry);
        this.state = states.FILE_DATA;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_FILE_HEADER:
        this.parsedEntity = this._readCentralDirectoryEntry(chunk);
        this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
        var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
        var path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
        var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
        var extra = this._readExtraFields(extraDataBuffer);
        if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
          path = extra.parsed.path;
        }
        this.parsedEntity.extra = extra.parsed;
        var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
        var unixAttrs, isSymlink;
        if (isUnix) {
          unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
          var fileType = unixAttrs >>> 12;
          isSymlink = (fileType & 10) === 10;
        }
        if (this.options.debug) {
          const debugObj = Object.assign({}, this.parsedEntity, {
            path,
            flags: "0x" + this.parsedEntity.flags.toString(16),
            unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
            isSymlink,
            extraFields: extra.debug
          });
          console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
        }
        this.state = states.START;
        return requiredLength;
      case states.CDIR64_END:
        this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
        if (this.options.debug) {
          console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
        }
        this.state = states.CDIR64_END_DATA_SECTOR;
        return requiredLength;
      case states.CDIR64_END_DATA_SECTOR:
        this.state = states.START;
        return requiredLength;
      case states.CDIR64_LOCATOR:
        this.state = states.START;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_END:
        this.parsedEntity = this._readEndOfCentralDirectory(chunk);
        if (this.options.debug) {
          console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
        }
        this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_END_COMMENT:
        if (this.options.debug) {
          console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
        }
        this.state = states.TRAILING_JUNK;
        return requiredLength;
      case states.ERROR:
        return chunk.length;
      default:
        console.log("didn't handle state #", this.state, "discarding");
        return chunk.length;
    }
  };
  UnzipStream.prototype._prepareOutStream = function(vars, entry) {
    var self2 = this;
    var isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
    entry.path = entry.path.replace(/(?<=^|[/\\]+)[.][.]+(?=[/\\]+|$)/g, ".");
    entry.type = isDirectory ? "Directory" : "File";
    entry.isDirectory = isDirectory;
    var fileSizeKnown = !(vars.flags & 8);
    if (fileSizeKnown) {
      entry.size = vars.uncompressedSize;
    }
    var isVersionSupported = vars.versionsNeededToExtract <= 45;
    this.outStreamInfo = {
      stream: null,
      limit: fileSizeKnown ? vars.compressedSize : -1,
      written: 0
    };
    if (!fileSizeKnown) {
      var pattern = new Buffer(4);
      pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
      var zip64Mode = vars.extra.zip64Mode;
      var extraSize = zip64Mode ? 20 : 12;
      var searchPattern = {
        pattern,
        requiredExtraSize: extraSize
      };
      var matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
        var vars2 = self2._readDataDescriptor(matchedChunk, zip64Mode);
        var compressedSizeMatches = vars2.compressedSize === sizeSoFar;
        if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
          var overflown = sizeSoFar - FOUR_GIGS;
          while (overflown >= 0) {
            compressedSizeMatches = vars2.compressedSize === overflown;
            if (compressedSizeMatches)
              break;
            overflown -= FOUR_GIGS;
          }
        }
        if (!compressedSizeMatches) {
          return;
        }
        self2.state = states.FILE_DATA_END;
        var sliceOffset = zip64Mode ? 24 : 16;
        if (self2.data.length > 0) {
          self2.data = Buffer.concat([matchedChunk.slice(sliceOffset), self2.data]);
        } else {
          self2.data = matchedChunk.slice(sliceOffset);
        }
        return true;
      });
      this.outStreamInfo.stream = matcherStream;
    } else {
      this.outStreamInfo.stream = new stream.PassThrough;
    }
    var isEncrypted = vars.flags & 1 || vars.flags & 64;
    if (isEncrypted || !isVersionSupported) {
      var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
      entry.skip = true;
      setImmediate(() => {
        self2.emit("error", new Error(message));
      });
      this.outStreamInfo.stream.pipe(new Entry().autodrain());
      return;
    }
    var isCompressed = vars.compressionMethod > 0;
    if (isCompressed) {
      var inflater = zlib.createInflateRaw();
      inflater.on("error", function(err) {
        self2.state = states.ERROR;
        self2.emit("error", err);
      });
      this.outStreamInfo.stream.pipe(inflater).pipe(entry);
    } else {
      this.outStreamInfo.stream.pipe(entry);
    }
    if (this._drainAllEntries) {
      entry.autodrain();
    }
  };
  UnzipStream.prototype._readFile = function(data) {
    var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
    return vars;
  };
  UnzipStream.prototype._readExtraFields = function(data) {
    var extra = {};
    var result = { parsed: extra };
    if (this.options.debug) {
      result.debug = [];
    }
    var index = 0;
    while (index < data.length) {
      var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
      index += 4;
      var fieldType = undefined;
      switch (vars.extraId) {
        case 1:
          fieldType = "Zip64 extended information extra field";
          var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
          if (z64vars.uncompressedSize !== null) {
            extra.uncompressedSize = z64vars.uncompressedSize;
          }
          if (z64vars.compressedSize !== null) {
            extra.compressedSize = z64vars.compressedSize;
          }
          extra.zip64Mode = true;
          break;
        case 10:
          fieldType = "NTFS extra field";
          break;
        case 21589:
          fieldType = "extended timestamp";
          var timestampFields = data.readUInt8(index);
          var offset = 1;
          if (vars.extraSize >= offset + 4 && timestampFields & 1) {
            extra.mtime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
          }
          if (vars.extraSize >= offset + 4 && timestampFields & 2) {
            extra.atime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
          }
          if (vars.extraSize >= offset + 4 && timestampFields & 4) {
            extra.ctime = new Date(data.readUInt32LE(index + offset) * 1000);
          }
          break;
        case 28789:
          fieldType = "Info-ZIP Unicode Path Extra Field";
          var fieldVer = data.readUInt8(index);
          if (fieldVer === 1) {
            var offset = 1;
            var nameCrc32 = data.readUInt32LE(index + offset);
            offset += 4;
            var pathBuffer = data.slice(index + offset);
            extra.path = pathBuffer.toString();
          }
          break;
        case 13:
        case 22613:
          fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
          var offset = 0;
          if (vars.extraSize >= 8) {
            var atime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
            var mtime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
            extra.atime = atime;
            extra.mtime = mtime;
            if (vars.extraSize >= 12) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.uid = uid;
              extra.gid = gid;
            }
          }
          break;
        case 30805:
          fieldType = "Info-ZIP UNIX (type 2)";
          var offset = 0;
          if (vars.extraSize >= 4) {
            var uid = data.readUInt16LE(index + offset);
            offset += 2;
            var gid = data.readUInt16LE(index + offset);
            offset += 2;
            extra.uid = uid;
            extra.gid = gid;
          }
          break;
        case 30837:
          fieldType = "Info-ZIP New Unix";
          var offset = 0;
          var extraVer = data.readUInt8(index);
          offset += 1;
          if (extraVer === 1) {
            var uidSize = data.readUInt8(index + offset);
            offset += 1;
            if (uidSize <= 6) {
              extra.uid = data.readUIntLE(index + offset, uidSize);
            }
            offset += uidSize;
            var gidSize = data.readUInt8(index + offset);
            offset += 1;
            if (gidSize <= 6) {
              extra.gid = data.readUIntLE(index + offset, gidSize);
            }
          }
          break;
        case 30062:
          fieldType = "ASi Unix";
          var offset = 0;
          if (vars.extraSize >= 14) {
            var crc = data.readUInt32LE(index + offset);
            offset += 4;
            var mode = data.readUInt16LE(index + offset);
            offset += 2;
            var sizdev = data.readUInt32LE(index + offset);
            offset += 4;
            var uid = data.readUInt16LE(index + offset);
            offset += 2;
            var gid = data.readUInt16LE(index + offset);
            offset += 2;
            extra.mode = mode;
            extra.uid = uid;
            extra.gid = gid;
            if (vars.extraSize > 14) {
              var start = index + offset;
              var end = index + vars.extraSize - 14;
              var symlinkName = this._decodeString(data.slice(start, end));
              extra.symlink = symlinkName;
            }
          }
          break;
      }
      if (this.options.debug) {
        result.debug.push({
          extraId: "0x" + vars.extraId.toString(16),
          description: fieldType,
          data: data.slice(index, index + vars.extraSize).inspect()
        });
      }
      index += vars.extraSize;
    }
    return result;
  };
  UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
    if (zip64Mode) {
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
      return vars;
    }
    var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
    return vars;
  };
  UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
    var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
    return vars;
  };
  UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
    var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
    return vars;
  };
  UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
    var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
    return vars;
  };
  var cp437 = "\x00 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ";
  UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
    if (isUtf8) {
      return buffer.toString("utf8");
    }
    if (this.options.decodeString) {
      return this.options.decodeString(buffer);
    }
    let result = "";
    for (var i = 0;i < buffer.length; i++) {
      result += cp437[buffer[i]];
    }
    return result;
  };
  UnzipStream.prototype._parseOrOutput = function(encoding, cb) {
    var consume;
    while ((consume = this.processDataChunk(this.data)) > 0) {
      this.data = this.data.slice(consume);
      if (this.data.length === 0)
        break;
    }
    if (this.state === states.FILE_DATA) {
      if (this.outStreamInfo.limit >= 0) {
        var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
        var packet;
        if (remaining < this.data.length) {
          packet = this.data.slice(0, remaining);
          this.data = this.data.slice(remaining);
        } else {
          packet = this.data;
          this.data = new Buffer("");
        }
        this.outStreamInfo.written += packet.length;
        if (this.outStreamInfo.limit === this.outStreamInfo.written) {
          this.state = states.START;
          this.outStreamInfo.stream.end(packet, encoding, cb);
        } else {
          this.outStreamInfo.stream.write(packet, encoding, cb);
        }
      } else {
        var packet = this.data;
        this.data = new Buffer("");
        this.outStreamInfo.written += packet.length;
        var outputStream = this.outStreamInfo.stream;
        outputStream.write(packet, encoding, () => {
          if (this.state === states.FILE_DATA_END) {
            this.state = states.START;
            return outputStream.end(cb);
          }
          cb();
        });
      }
      return;
    }
    cb();
  };
  UnzipStream.prototype.drainAll = function() {
    this._drainAllEntries = true;
  };
  UnzipStream.prototype._transform = function(chunk, encoding, cb) {
    var self2 = this;
    if (self2.data.length > 0) {
      self2.data = Buffer.concat([self2.data, chunk]);
    } else {
      self2.data = chunk;
    }
    var startDataLength = self2.data.length;
    var done = function() {
      if (self2.data.length > 0 && self2.data.length < startDataLength) {
        startDataLength = self2.data.length;
        self2._parseOrOutput(encoding, done);
        return;
      }
      cb();
    };
    self2._parseOrOutput(encoding, done);
  };
  UnzipStream.prototype._flush = function(cb) {
    var self2 = this;
    if (self2.data.length > 0) {
      self2._parseOrOutput("buffer", function() {
        if (self2.data.length > 0)
          return setImmediate(function() {
            self2._flush(cb);
          });
        cb();
      });
      return;
    }
    if (self2.state === states.FILE_DATA) {
      return cb(new Error("Stream finished in an invalid state, uncompression failed"));
    }
    setImmediate(cb);
  };
  module.exports = UnzipStream;
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform;
  var util = __require("util");
  var UnzipStream = require_unzip_stream();
  function ParserStream(opts) {
    if (!(this instanceof ParserStream)) {
      return new ParserStream(opts);
    }
    var transformOpts = opts || {};
    Transform.call(this, { readableObjectMode: true });
    this.opts = opts || {};
    this.unzipStream = new UnzipStream(this.opts);
    var self2 = this;
    this.unzipStream.on("entry", function(entry) {
      self2.push(entry);
    });
    this.unzipStream.on("error", function(error) {
      self2.emit("error", error);
    });
  }
  util.inherits(ParserStream, Transform);
  ParserStream.prototype._transform = function(chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
  };
  ParserStream.prototype._flush = function(cb) {
    var self2 = this;
    this.unzipStream.end(function() {
      process.nextTick(function() {
        self2.emit("close");
      });
      cb();
    });
  };
  ParserStream.prototype.on = function(eventName, fn) {
    if (eventName === "entry") {
      return Transform.prototype.on.call(this, "data", fn);
    }
    return Transform.prototype.on.call(this, eventName, fn);
  };
  ParserStream.prototype.drainAll = function() {
    this.unzipStream.drainAll();
    return this.pipe(new Transform({ objectMode: true, transform: function(d, e, cb) {
      cb();
    } }));
  };
  module.exports = ParserStream;
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var _0777 = parseInt("0777", 8);
  module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
      mode = _0777;
    }
    if (!made)
      made = null;
    var cb = f || function() {};
    p = path.resolve(p);
    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path.dirname(p) === p)
            return cb(er);
          mkdirP(path.dirname(p), opts, function(er2, made2) {
            if (er2)
              cb(er2, made2);
            else
              mkdirP(p, opts, cb, made2);
          });
          break;
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory())
              cb(er, made);
            else
              cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
      mode = _0777;
    }
    if (!made)
      made = null;
    p = path.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path.dirname(p), opts, made);
          sync(p, opts, made);
          break;
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
          break;
      }
    }
    return made;
  };
});

// node_modules/unzip-stream/lib/extract.js
var require_extract2 = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var util = __require("util");
  var mkdirp = require_mkdirp();
  var Transform = __require("stream").Transform;
  var UnzipStream = require_unzip_stream();
  function Extract(opts) {
    if (!(this instanceof Extract))
      return new Extract(opts);
    Transform.call(this);
    this.opts = opts || {};
    this.unzipStream = new UnzipStream(this.opts);
    this.unfinishedEntries = 0;
    this.afterFlushWait = false;
    this.createdDirectories = {};
    var self2 = this;
    this.unzipStream.on("entry", this._processEntry.bind(this));
    this.unzipStream.on("error", function(error) {
      self2.emit("error", error);
    });
  }
  util.inherits(Extract, Transform);
  Extract.prototype._transform = function(chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
  };
  Extract.prototype._flush = function(cb) {
    var self2 = this;
    var allDone = function() {
      process.nextTick(function() {
        self2.emit("close");
      });
      cb();
    };
    this.unzipStream.end(function() {
      if (self2.unfinishedEntries > 0) {
        self2.afterFlushWait = true;
        return self2.on("await-finished", allDone);
      }
      allDone();
    });
  };
  Extract.prototype._processEntry = function(entry) {
    var self2 = this;
    var destPath = path.join(this.opts.path, entry.path);
    var directory = entry.isDirectory ? destPath : path.dirname(destPath);
    this.unfinishedEntries++;
    var writeFileFn = function() {
      var pipedStream = fs.createWriteStream(destPath);
      pipedStream.on("close", function() {
        self2.unfinishedEntries--;
        self2._notifyAwaiter();
      });
      pipedStream.on("error", function(error) {
        self2.emit("error", error);
      });
      entry.pipe(pipedStream);
    };
    if (this.createdDirectories[directory] || directory === ".") {
      return writeFileFn();
    }
    mkdirp(directory, function(err) {
      if (err)
        return self2.emit("error", err);
      self2.createdDirectories[directory] = true;
      if (entry.isDirectory) {
        self2.unfinishedEntries--;
        self2._notifyAwaiter();
        return;
      }
      writeFileFn();
    });
  };
  Extract.prototype._notifyAwaiter = function() {
    if (this.afterFlushWait && this.unfinishedEntries === 0) {
      this.emit("await-finished");
      this.afterFlushWait = false;
    }
  };
  module.exports = Extract;
});

// node_modules/unzip-stream/unzip.js
var require_unzip = __commonJS((exports) => {
  exports.Parse = require_parser_stream();
  exports.Extract = require_extract2();
});

// node_modules/@actions/artifact/lib/internal/download/download-artifact.js
var require_download_artifact = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.streamExtractExternal = streamExtractExternal;
  exports.downloadArtifactPublic = downloadArtifactPublic;
  exports.downloadArtifactInternal = downloadArtifactInternal;
  var promises_1 = __importDefault(__require("fs/promises"));
  var crypto2 = __importStar(__require("crypto"));
  var stream = __importStar(__require("stream"));
  var github = __importStar(require_github());
  var core = __importStar(require_core());
  var httpClient = __importStar(require_lib());
  var unzip_stream_1 = __importDefault(require_unzip());
  var user_agent_1 = require_user_agent();
  var config_1 = require_config();
  var artifact_twirp_client_1 = require_artifact_twirp_client2();
  var generated_1 = require_generated();
  var util_1 = require_util9();
  var errors_1 = require_errors2();
  var scrubQueryParameters = (url) => {
    const parsed = new URL(url);
    parsed.search = "";
    return parsed.toString();
  };
  function exists(path) {
    return __awaiter(this, undefined, undefined, function* () {
      try {
        yield promises_1.default.access(path);
        return true;
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        } else {
          throw error;
        }
      }
    });
  }
  function streamExtract(url, directory) {
    return __awaiter(this, undefined, undefined, function* () {
      let retryCount = 0;
      while (retryCount < 5) {
        try {
          return yield streamExtractExternal(url, directory);
        } catch (error) {
          retryCount++;
          core.debug(`Failed to download artifact after ${retryCount} retries due to ${error.message}. Retrying in 5 seconds...`);
          yield new Promise((resolve) => setTimeout(resolve, 5000));
        }
      }
      throw new Error(`Artifact download failed after ${retryCount} retries.`);
    });
  }
  function streamExtractExternal(url_1, directory_1) {
    return __awaiter(this, arguments, undefined, function* (url, directory, opts = { timeout: 30 * 1000 }) {
      const client = new httpClient.HttpClient((0, user_agent_1.getUserAgentString)());
      const response = yield client.get(url);
      if (response.message.statusCode !== 200) {
        throw new Error(`Unexpected HTTP response from blob storage: ${response.message.statusCode} ${response.message.statusMessage}`);
      }
      let sha256Digest = undefined;
      return new Promise((resolve, reject) => {
        const timerFn = () => {
          const timeoutError = new Error(`Blob storage chunk did not respond in ${opts.timeout}ms`);
          response.message.destroy(timeoutError);
          reject(timeoutError);
        };
        const timer = setTimeout(timerFn, opts.timeout);
        const hashStream = crypto2.createHash("sha256").setEncoding("hex");
        const passThrough = new stream.PassThrough;
        response.message.pipe(passThrough);
        passThrough.pipe(hashStream);
        const extractStream = passThrough;
        extractStream.on("data", () => {
          timer.refresh();
        }).on("error", (error) => {
          core.debug(`response.message: Artifact download failed: ${error.message}`);
          clearTimeout(timer);
          reject(error);
        }).pipe(unzip_stream_1.default.Extract({ path: directory })).on("close", () => {
          clearTimeout(timer);
          if (hashStream) {
            hashStream.end();
            sha256Digest = hashStream.read();
            core.info(`SHA256 digest of downloaded artifact is ${sha256Digest}`);
          }
          resolve({ sha256Digest: `sha256:${sha256Digest}` });
        }).on("error", (error) => {
          reject(error);
        });
      });
    });
  }
  function downloadArtifactPublic(artifactId, repositoryOwner, repositoryName, token, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const downloadPath = yield resolveOrCreateDirectory(options === null || options === undefined ? undefined : options.path);
      const api = github.getOctokit(token);
      let digestMismatch = false;
      core.info(`Downloading artifact '${artifactId}' from '${repositoryOwner}/${repositoryName}'`);
      const { headers, status } = yield api.rest.actions.downloadArtifact({
        owner: repositoryOwner,
        repo: repositoryName,
        artifact_id: artifactId,
        archive_format: "zip",
        request: {
          redirect: "manual"
        }
      });
      if (status !== 302) {
        throw new Error(`Unable to download artifact. Unexpected status: ${status}`);
      }
      const { location } = headers;
      if (!location) {
        throw new Error(`Unable to redirect to artifact download url`);
      }
      core.info(`Redirecting to blob download url: ${scrubQueryParameters(location)}`);
      try {
        core.info(`Starting download of artifact to: ${downloadPath}`);
        const extractResponse = yield streamExtract(location, downloadPath);
        core.info(`Artifact download completed successfully.`);
        if (options === null || options === undefined ? undefined : options.expectedHash) {
          if ((options === null || options === undefined ? undefined : options.expectedHash) !== extractResponse.sha256Digest) {
            digestMismatch = true;
            core.debug(`Computed digest: ${extractResponse.sha256Digest}`);
            core.debug(`Expected digest: ${options.expectedHash}`);
          }
        }
      } catch (error) {
        throw new Error(`Unable to download and extract artifact: ${error.message}`);
      }
      return { downloadPath, digestMismatch };
    });
  }
  function downloadArtifactInternal(artifactId, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const downloadPath = yield resolveOrCreateDirectory(options === null || options === undefined ? undefined : options.path);
      const artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
      let digestMismatch = false;
      const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
      const listReq = {
        workflowRunBackendId,
        workflowJobRunBackendId,
        idFilter: generated_1.Int64Value.create({ value: artifactId.toString() })
      };
      const { artifacts } = yield artifactClient.ListArtifacts(listReq);
      if (artifacts.length === 0) {
        throw new errors_1.ArtifactNotFoundError(`No artifacts found for ID: ${artifactId}
Are you trying to download from a different run? Try specifying a github-token with \`actions:read\` scope.`);
      }
      if (artifacts.length > 1) {
        core.warning("Multiple artifacts found, defaulting to first.");
      }
      const signedReq = {
        workflowRunBackendId: artifacts[0].workflowRunBackendId,
        workflowJobRunBackendId: artifacts[0].workflowJobRunBackendId,
        name: artifacts[0].name
      };
      const { signedUrl } = yield artifactClient.GetSignedArtifactURL(signedReq);
      core.info(`Redirecting to blob download url: ${scrubQueryParameters(signedUrl)}`);
      try {
        core.info(`Starting download of artifact to: ${downloadPath}`);
        const extractResponse = yield streamExtract(signedUrl, downloadPath);
        core.info(`Artifact download completed successfully.`);
        if (options === null || options === undefined ? undefined : options.expectedHash) {
          if ((options === null || options === undefined ? undefined : options.expectedHash) !== extractResponse.sha256Digest) {
            digestMismatch = true;
            core.debug(`Computed digest: ${extractResponse.sha256Digest}`);
            core.debug(`Expected digest: ${options.expectedHash}`);
          }
        }
      } catch (error) {
        throw new Error(`Unable to download and extract artifact: ${error.message}`);
      }
      return { downloadPath, digestMismatch };
    });
  }
  function resolveOrCreateDirectory() {
    return __awaiter(this, arguments, undefined, function* (downloadPath = (0, config_1.getGitHubWorkspaceDir)()) {
      if (!(yield exists(downloadPath))) {
        core.debug(`Artifact destination folder does not exist, creating: ${downloadPath}`);
        yield promises_1.default.mkdir(downloadPath, { recursive: true });
      } else {
        core.debug(`Artifact destination folder already exists: ${downloadPath}`);
      }
      return downloadPath;
    });
  }
});

// node_modules/@actions/artifact/lib/internal/find/retry-options.js
var require_retry_options = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRetryOptions = getRetryOptions;
  var core = __importStar(require_core());
  var defaultMaxRetryNumber = 5;
  var defaultExemptStatusCodes = [400, 401, 403, 404, 422];
  function getRetryOptions(defaultOptions, retries = defaultMaxRetryNumber, exemptStatusCodes = defaultExemptStatusCodes) {
    var _a;
    if (retries <= 0) {
      return [{ enabled: false }, defaultOptions.request];
    }
    const retryOptions = {
      enabled: true
    };
    if (exemptStatusCodes.length > 0) {
      retryOptions.doNotRetry = exemptStatusCodes;
    }
    const requestOptions = Object.assign(Object.assign({}, defaultOptions.request), { retries });
    core.debug(`GitHub client configured with: (retries: ${requestOptions.retries}, retry-exempt-status-code: ${(_a = retryOptions.doNotRetry) !== null && _a !== undefined ? _a : "octokit default: [400, 401, 403, 404, 422]"})`);
    return [retryOptions, requestOptions];
  }
});

// node_modules/@octokit/plugin-request-log/dist-node/index.js
var require_dist_node11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var VERSION = "1.0.4";
  function requestLog(octokit) {
    octokit.hook.wrap("request", (request, options) => {
      octokit.log.debug("request", options);
      const start = Date.now();
      const requestOptions = octokit.request.endpoint.parse(options);
      const path = requestOptions.url.replace(options.baseUrl, "");
      return request(options).then((response) => {
        octokit.log.info(`${requestOptions.method} ${path} - ${response.status} in ${Date.now() - start}ms`);
        return response;
      }).catch((error) => {
        octokit.log.info(`${requestOptions.method} ${path} - ${error.status} in ${Date.now() - start}ms`);
        throw error;
      });
    });
  }
  requestLog.VERSION = VERSION;
  exports.requestLog = requestLog;
});

// node_modules/bottleneck/light.js
var require_light = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.Bottleneck = factory();
  })(exports, function() {
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getCjsExportFromNamespace(n) {
      return n && n["default"] || n;
    }
    var load = function(received, defaults, onto = {}) {
      var k, ref, v;
      for (k in defaults) {
        v = defaults[k];
        onto[k] = (ref = received[k]) != null ? ref : v;
      }
      return onto;
    };
    var overwrite = function(received, defaults, onto = {}) {
      var k, v;
      for (k in received) {
        v = received[k];
        if (defaults[k] !== undefined) {
          onto[k] = v;
        }
      }
      return onto;
    };
    var parser = {
      load,
      overwrite
    };
    var DLList;
    DLList = class DLList2 {
      constructor(incr, decr) {
        this.incr = incr;
        this.decr = decr;
        this._first = null;
        this._last = null;
        this.length = 0;
      }
      push(value) {
        var node;
        this.length++;
        if (typeof this.incr === "function") {
          this.incr();
        }
        node = {
          value,
          prev: this._last,
          next: null
        };
        if (this._last != null) {
          this._last.next = node;
          this._last = node;
        } else {
          this._first = this._last = node;
        }
        return;
      }
      shift() {
        var value;
        if (this._first == null) {
          return;
        } else {
          this.length--;
          if (typeof this.decr === "function") {
            this.decr();
          }
        }
        value = this._first.value;
        if ((this._first = this._first.next) != null) {
          this._first.prev = null;
        } else {
          this._last = null;
        }
        return value;
      }
      first() {
        if (this._first != null) {
          return this._first.value;
        }
      }
      getArray() {
        var node, ref, results;
        node = this._first;
        results = [];
        while (node != null) {
          results.push((ref = node, node = node.next, ref.value));
        }
        return results;
      }
      forEachShift(cb) {
        var node;
        node = this.shift();
        while (node != null) {
          cb(node), node = this.shift();
        }
        return;
      }
      debug() {
        var node, ref, ref1, ref2, results;
        node = this._first;
        results = [];
        while (node != null) {
          results.push((ref = node, node = node.next, {
            value: ref.value,
            prev: (ref1 = ref.prev) != null ? ref1.value : undefined,
            next: (ref2 = ref.next) != null ? ref2.value : undefined
          }));
        }
        return results;
      }
    };
    var DLList_1 = DLList;
    var Events;
    Events = class Events2 {
      constructor(instance) {
        this.instance = instance;
        this._events = {};
        if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
          throw new Error("An Emitter already exists for this object");
        }
        this.instance.on = (name, cb) => {
          return this._addListener(name, "many", cb);
        };
        this.instance.once = (name, cb) => {
          return this._addListener(name, "once", cb);
        };
        this.instance.removeAllListeners = (name = null) => {
          if (name != null) {
            return delete this._events[name];
          } else {
            return this._events = {};
          }
        };
      }
      _addListener(name, status, cb) {
        var base;
        if ((base = this._events)[name] == null) {
          base[name] = [];
        }
        this._events[name].push({ cb, status });
        return this.instance;
      }
      listenerCount(name) {
        if (this._events[name] != null) {
          return this._events[name].length;
        } else {
          return 0;
        }
      }
      async trigger(name, ...args) {
        var e, promises;
        try {
          if (name !== "debug") {
            this.trigger("debug", `Event triggered: ${name}`, args);
          }
          if (this._events[name] == null) {
            return;
          }
          this._events[name] = this._events[name].filter(function(listener) {
            return listener.status !== "none";
          });
          promises = this._events[name].map(async (listener) => {
            var e2, returned;
            if (listener.status === "none") {
              return;
            }
            if (listener.status === "once") {
              listener.status = "none";
            }
            try {
              returned = typeof listener.cb === "function" ? listener.cb(...args) : undefined;
              if (typeof (returned != null ? returned.then : undefined) === "function") {
                return await returned;
              } else {
                return returned;
              }
            } catch (error) {
              e2 = error;
              {
                this.trigger("error", e2);
              }
              return null;
            }
          });
          return (await Promise.all(promises)).find(function(x) {
            return x != null;
          });
        } catch (error) {
          e = error;
          {
            this.trigger("error", e);
          }
          return null;
        }
      }
    };
    var Events_1 = Events;
    var DLList$1, Events$1, Queues;
    DLList$1 = DLList_1;
    Events$1 = Events_1;
    Queues = class Queues2 {
      constructor(num_priorities) {
        var i;
        this.Events = new Events$1(this);
        this._length = 0;
        this._lists = function() {
          var j, ref, results;
          results = [];
          for (i = j = 1, ref = num_priorities;1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
            results.push(new DLList$1(() => {
              return this.incr();
            }, () => {
              return this.decr();
            }));
          }
          return results;
        }.call(this);
      }
      incr() {
        if (this._length++ === 0) {
          return this.Events.trigger("leftzero");
        }
      }
      decr() {
        if (--this._length === 0) {
          return this.Events.trigger("zero");
        }
      }
      push(job) {
        return this._lists[job.options.priority].push(job);
      }
      queued(priority) {
        if (priority != null) {
          return this._lists[priority].length;
        } else {
          return this._length;
        }
      }
      shiftAll(fn) {
        return this._lists.forEach(function(list) {
          return list.forEachShift(fn);
        });
      }
      getFirst(arr = this._lists) {
        var j, len, list;
        for (j = 0, len = arr.length;j < len; j++) {
          list = arr[j];
          if (list.length > 0) {
            return list;
          }
        }
        return [];
      }
      shiftLastFrom(priority) {
        return this.getFirst(this._lists.slice(priority).reverse()).shift();
      }
    };
    var Queues_1 = Queues;
    var BottleneckError;
    BottleneckError = class BottleneckError2 extends Error {
    };
    var BottleneckError_1 = BottleneckError;
    var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser$1 = parser;
    BottleneckError$1 = BottleneckError_1;
    Job = class Job2 {
      constructor(task, args, options, jobDefaults, rejectOnDrop, Events2, _states, Promise2) {
        this.task = task;
        this.args = args;
        this.rejectOnDrop = rejectOnDrop;
        this.Events = Events2;
        this._states = _states;
        this.Promise = Promise2;
        this.options = parser$1.load(options, jobDefaults);
        this.options.priority = this._sanitizePriority(this.options.priority);
        if (this.options.id === jobDefaults.id) {
          this.options.id = `${this.options.id}-${this._randomIndex()}`;
        }
        this.promise = new this.Promise((_resolve, _reject) => {
          this._resolve = _resolve;
          this._reject = _reject;
        });
        this.retryCount = 0;
      }
      _sanitizePriority(priority) {
        var sProperty;
        sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
        if (sProperty < 0) {
          return 0;
        } else if (sProperty > NUM_PRIORITIES - 1) {
          return NUM_PRIORITIES - 1;
        } else {
          return sProperty;
        }
      }
      _randomIndex() {
        return Math.random().toString(36).slice(2);
      }
      doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
        if (this._states.remove(this.options.id)) {
          if (this.rejectOnDrop) {
            this._reject(error != null ? error : new BottleneckError$1(message));
          }
          this.Events.trigger("dropped", { args: this.args, options: this.options, task: this.task, promise: this.promise });
          return true;
        } else {
          return false;
        }
      }
      _assertStatus(expected) {
        var status;
        status = this._states.jobStatus(this.options.id);
        if (!(status === expected || expected === "DONE" && status === null)) {
          throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
        }
      }
      doReceive() {
        this._states.start(this.options.id);
        return this.Events.trigger("received", { args: this.args, options: this.options });
      }
      doQueue(reachedHWM, blocked) {
        this._assertStatus("RECEIVED");
        this._states.next(this.options.id);
        return this.Events.trigger("queued", { args: this.args, options: this.options, reachedHWM, blocked });
      }
      doRun() {
        if (this.retryCount === 0) {
          this._assertStatus("QUEUED");
          this._states.next(this.options.id);
        } else {
          this._assertStatus("EXECUTING");
        }
        return this.Events.trigger("scheduled", { args: this.args, options: this.options });
      }
      async doExecute(chained, clearGlobalState, run, free) {
        var error, eventInfo, passed;
        if (this.retryCount === 0) {
          this._assertStatus("RUNNING");
          this._states.next(this.options.id);
        } else {
          this._assertStatus("EXECUTING");
        }
        eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
        this.Events.trigger("executing", eventInfo);
        try {
          passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));
          if (clearGlobalState()) {
            this.doDone(eventInfo);
            await free(this.options, eventInfo);
            this._assertStatus("DONE");
            return this._resolve(passed);
          }
        } catch (error1) {
          error = error1;
          return this._onFailure(error, eventInfo, clearGlobalState, run, free);
        }
      }
      doExpire(clearGlobalState, run, free) {
        var error, eventInfo;
        if (this._states.jobStatus(this.options.id === "RUNNING")) {
          this._states.next(this.options.id);
        }
        this._assertStatus("EXECUTING");
        eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
        error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);
        return this._onFailure(error, eventInfo, clearGlobalState, run, free);
      }
      async _onFailure(error, eventInfo, clearGlobalState, run, free) {
        var retry, retryAfter;
        if (clearGlobalState()) {
          retry = await this.Events.trigger("failed", error, eventInfo);
          if (retry != null) {
            retryAfter = ~~retry;
            this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);
            this.retryCount++;
            return run(retryAfter);
          } else {
            this.doDone(eventInfo);
            await free(this.options, eventInfo);
            this._assertStatus("DONE");
            return this._reject(error);
          }
        }
      }
      doDone(eventInfo) {
        this._assertStatus("EXECUTING");
        this._states.next(this.options.id);
        return this.Events.trigger("done", eventInfo);
      }
    };
    var Job_1 = Job;
    var BottleneckError$2, LocalDatastore, parser$2;
    parser$2 = parser;
    BottleneckError$2 = BottleneckError_1;
    LocalDatastore = class LocalDatastore2 {
      constructor(instance, storeOptions, storeInstanceOptions) {
        this.instance = instance;
        this.storeOptions = storeOptions;
        this.clientId = this.instance._randomIndex();
        parser$2.load(storeInstanceOptions, storeInstanceOptions, this);
        this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
        this._running = 0;
        this._done = 0;
        this._unblockTime = 0;
        this.ready = this.Promise.resolve();
        this.clients = {};
        this._startHeartbeat();
      }
      _startHeartbeat() {
        var base;
        if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
          return typeof (base = this.heartbeat = setInterval(() => {
            var amount, incr, maximum, now, reservoir;
            now = Date.now();
            if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
              this._lastReservoirRefresh = now;
              this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
              this.instance._drainAll(this.computeCapacity());
            }
            if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
              ({
                reservoirIncreaseAmount: amount,
                reservoirIncreaseMaximum: maximum,
                reservoir
              } = this.storeOptions);
              this._lastReservoirIncrease = now;
              incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
              if (incr > 0) {
                this.storeOptions.reservoir += incr;
                return this.instance._drainAll(this.computeCapacity());
              }
            }
          }, this.heartbeatInterval)).unref === "function" ? base.unref() : undefined;
        } else {
          return clearInterval(this.heartbeat);
        }
      }
      async __publish__(message) {
        await this.yieldLoop();
        return this.instance.Events.trigger("message", message.toString());
      }
      async __disconnect__(flush) {
        await this.yieldLoop();
        clearInterval(this.heartbeat);
        return this.Promise.resolve();
      }
      yieldLoop(t = 0) {
        return new this.Promise(function(resolve, reject) {
          return setTimeout(resolve, t);
        });
      }
      computePenalty() {
        var ref;
        return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;
      }
      async __updateSettings__(options) {
        await this.yieldLoop();
        parser$2.overwrite(options, options, this.storeOptions);
        this._startHeartbeat();
        this.instance._drainAll(this.computeCapacity());
        return true;
      }
      async __running__() {
        await this.yieldLoop();
        return this._running;
      }
      async __queued__() {
        await this.yieldLoop();
        return this.instance.queued();
      }
      async __done__() {
        await this.yieldLoop();
        return this._done;
      }
      async __groupCheck__(time) {
        await this.yieldLoop();
        return this._nextRequest + this.timeout < time;
      }
      computeCapacity() {
        var maxConcurrent, reservoir;
        ({ maxConcurrent, reservoir } = this.storeOptions);
        if (maxConcurrent != null && reservoir != null) {
          return Math.min(maxConcurrent - this._running, reservoir);
        } else if (maxConcurrent != null) {
          return maxConcurrent - this._running;
        } else if (reservoir != null) {
          return reservoir;
        } else {
          return null;
        }
      }
      conditionsCheck(weight) {
        var capacity;
        capacity = this.computeCapacity();
        return capacity == null || weight <= capacity;
      }
      async __incrementReservoir__(incr) {
        var reservoir;
        await this.yieldLoop();
        reservoir = this.storeOptions.reservoir += incr;
        this.instance._drainAll(this.computeCapacity());
        return reservoir;
      }
      async __currentReservoir__() {
        await this.yieldLoop();
        return this.storeOptions.reservoir;
      }
      isBlocked(now) {
        return this._unblockTime >= now;
      }
      check(weight, now) {
        return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
      }
      async __check__(weight) {
        var now;
        await this.yieldLoop();
        now = Date.now();
        return this.check(weight, now);
      }
      async __register__(index, weight, expiration) {
        var now, wait;
        await this.yieldLoop();
        now = Date.now();
        if (this.conditionsCheck(weight)) {
          this._running += weight;
          if (this.storeOptions.reservoir != null) {
            this.storeOptions.reservoir -= weight;
          }
          wait = Math.max(this._nextRequest - now, 0);
          this._nextRequest = now + wait + this.storeOptions.minTime;
          return {
            success: true,
            wait,
            reservoir: this.storeOptions.reservoir
          };
        } else {
          return {
            success: false
          };
        }
      }
      strategyIsBlock() {
        return this.storeOptions.strategy === 3;
      }
      async __submit__(queueLength, weight) {
        var blocked, now, reachedHWM;
        await this.yieldLoop();
        if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) {
          throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
        }
        now = Date.now();
        reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);
        blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
        if (blocked) {
          this._unblockTime = now + this.computePenalty();
          this._nextRequest = this._unblockTime + this.storeOptions.minTime;
          this.instance._dropAllQueued();
        }
        return {
          reachedHWM,
          blocked,
          strategy: this.storeOptions.strategy
        };
      }
      async __free__(index, weight) {
        await this.yieldLoop();
        this._running -= weight;
        this._done += weight;
        this.instance._drainAll(this.computeCapacity());
        return {
          running: this._running
        };
      }
    };
    var LocalDatastore_1 = LocalDatastore;
    var BottleneckError$3, States;
    BottleneckError$3 = BottleneckError_1;
    States = class States2 {
      constructor(status1) {
        this.status = status1;
        this._jobs = {};
        this.counts = this.status.map(function() {
          return 0;
        });
      }
      next(id) {
        var current, next;
        current = this._jobs[id];
        next = current + 1;
        if (current != null && next < this.status.length) {
          this.counts[current]--;
          this.counts[next]++;
          return this._jobs[id]++;
        } else if (current != null) {
          this.counts[current]--;
          return delete this._jobs[id];
        }
      }
      start(id) {
        var initial;
        initial = 0;
        this._jobs[id] = initial;
        return this.counts[initial]++;
      }
      remove(id) {
        var current;
        current = this._jobs[id];
        if (current != null) {
          this.counts[current]--;
          delete this._jobs[id];
        }
        return current != null;
      }
      jobStatus(id) {
        var ref;
        return (ref = this.status[this._jobs[id]]) != null ? ref : null;
      }
      statusJobs(status) {
        var k, pos, ref, results, v;
        if (status != null) {
          pos = this.status.indexOf(status);
          if (pos < 0) {
            throw new BottleneckError$3(`status must be one of ${this.status.join(", ")}`);
          }
          ref = this._jobs;
          results = [];
          for (k in ref) {
            v = ref[k];
            if (v === pos) {
              results.push(k);
            }
          }
          return results;
        } else {
          return Object.keys(this._jobs);
        }
      }
      statusCounts() {
        return this.counts.reduce((acc, v, i) => {
          acc[this.status[i]] = v;
          return acc;
        }, {});
      }
    };
    var States_1 = States;
    var DLList$2, Sync;
    DLList$2 = DLList_1;
    Sync = class Sync2 {
      constructor(name, Promise2) {
        this.schedule = this.schedule.bind(this);
        this.name = name;
        this.Promise = Promise2;
        this._running = 0;
        this._queue = new DLList$2;
      }
      isEmpty() {
        return this._queue.length === 0;
      }
      async _tryToRun() {
        var args, cb, error, reject, resolve, returned, task;
        if (this._running < 1 && this._queue.length > 0) {
          this._running++;
          ({ task, args, resolve, reject } = this._queue.shift());
          cb = await async function() {
            try {
              returned = await task(...args);
              return function() {
                return resolve(returned);
              };
            } catch (error1) {
              error = error1;
              return function() {
                return reject(error);
              };
            }
          }();
          this._running--;
          this._tryToRun();
          return cb();
        }
      }
      schedule(task, ...args) {
        var promise, reject, resolve;
        resolve = reject = null;
        promise = new this.Promise(function(_resolve, _reject) {
          resolve = _resolve;
          return reject = _reject;
        });
        this._queue.push({ task, args, resolve, reject });
        this._tryToRun();
        return promise;
      }
    };
    var Sync_1 = Sync;
    var version = "2.19.5";
    var version$1 = {
      version
    };
    var version$2 = /* @__PURE__ */ Object.freeze({
      version,
      default: version$1
    });
    var require$$2 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var require$$3 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var require$$4 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;
    parser$3 = parser;
    Events$2 = Events_1;
    RedisConnection$1 = require$$2;
    IORedisConnection$1 = require$$3;
    Scripts$1 = require$$4;
    Group = function() {

      class Group2 {
        constructor(limiterOptions = {}) {
          this.deleteKey = this.deleteKey.bind(this);
          this.limiterOptions = limiterOptions;
          parser$3.load(this.limiterOptions, this.defaults, this);
          this.Events = new Events$2(this);
          this.instances = {};
          this.Bottleneck = Bottleneck_1;
          this._startAutoCleanup();
          this.sharedConnection = this.connection != null;
          if (this.connection == null) {
            if (this.limiterOptions.datastore === "redis") {
              this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
            } else if (this.limiterOptions.datastore === "ioredis") {
              this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
            }
          }
        }
        key(key = "") {
          var ref;
          return (ref = this.instances[key]) != null ? ref : (() => {
            var limiter;
            limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
              id: `${this.id}-${key}`,
              timeout: this.timeout,
              connection: this.connection
            }));
            this.Events.trigger("created", limiter, key);
            return limiter;
          })();
        }
        async deleteKey(key = "") {
          var deleted, instance;
          instance = this.instances[key];
          if (this.connection) {
            deleted = await this.connection.__runCommand__(["del", ...Scripts$1.allKeys(`${this.id}-${key}`)]);
          }
          if (instance != null) {
            delete this.instances[key];
            await instance.disconnect();
          }
          return instance != null || deleted > 0;
        }
        limiters() {
          var k, ref, results, v;
          ref = this.instances;
          results = [];
          for (k in ref) {
            v = ref[k];
            results.push({
              key: k,
              limiter: v
            });
          }
          return results;
        }
        keys() {
          return Object.keys(this.instances);
        }
        async clusterKeys() {
          var cursor, end, found, i, k, keys, len, next, start;
          if (this.connection == null) {
            return this.Promise.resolve(this.keys());
          }
          keys = [];
          cursor = null;
          start = `b_${this.id}-`.length;
          end = "_settings".length;
          while (cursor !== 0) {
            [next, found] = await this.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${this.id}-*_settings`, "count", 1e4]);
            cursor = ~~next;
            for (i = 0, len = found.length;i < len; i++) {
              k = found[i];
              keys.push(k.slice(start, -end));
            }
          }
          return keys;
        }
        _startAutoCleanup() {
          var base;
          clearInterval(this.interval);
          return typeof (base = this.interval = setInterval(async () => {
            var e, k, ref, results, time, v;
            time = Date.now();
            ref = this.instances;
            results = [];
            for (k in ref) {
              v = ref[k];
              try {
                if (await v._store.__groupCheck__(time)) {
                  results.push(this.deleteKey(k));
                } else {
                  results.push(undefined);
                }
              } catch (error) {
                e = error;
                results.push(v.Events.trigger("error", e));
              }
            }
            return results;
          }, this.timeout / 2)).unref === "function" ? base.unref() : undefined;
        }
        updateSettings(options = {}) {
          parser$3.overwrite(options, this.defaults, this);
          parser$3.overwrite(options, options, this.limiterOptions);
          if (options.timeout != null) {
            return this._startAutoCleanup();
          }
        }
        disconnect(flush = true) {
          var ref;
          if (!this.sharedConnection) {
            return (ref = this.connection) != null ? ref.disconnect(flush) : undefined;
          }
        }
      }
      Group2.prototype.defaults = {
        timeout: 1000 * 60 * 5,
        connection: null,
        Promise,
        id: "group-key"
      };
      return Group2;
    }.call(commonjsGlobal);
    var Group_1 = Group;
    var Batcher, Events$3, parser$4;
    parser$4 = parser;
    Events$3 = Events_1;
    Batcher = function() {

      class Batcher2 {
        constructor(options = {}) {
          this.options = options;
          parser$4.load(this.options, this.defaults, this);
          this.Events = new Events$3(this);
          this._arr = [];
          this._resetPromise();
          this._lastFlush = Date.now();
        }
        _resetPromise() {
          return this._promise = new this.Promise((res, rej) => {
            return this._resolve = res;
          });
        }
        _flush() {
          clearTimeout(this._timeout);
          this._lastFlush = Date.now();
          this._resolve();
          this.Events.trigger("batch", this._arr);
          this._arr = [];
          return this._resetPromise();
        }
        add(data) {
          var ret;
          this._arr.push(data);
          ret = this._promise;
          if (this._arr.length === this.maxSize) {
            this._flush();
          } else if (this.maxTime != null && this._arr.length === 1) {
            this._timeout = setTimeout(() => {
              return this._flush();
            }, this.maxTime);
          }
          return ret;
        }
      }
      Batcher2.prototype.defaults = {
        maxTime: null,
        maxSize: null,
        Promise
      };
      return Batcher2;
    }.call(commonjsGlobal);
    var Batcher_1 = Batcher;
    var require$$4$1 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var require$$8 = getCjsExportFromNamespace(version$2);
    var Bottleneck, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
    NUM_PRIORITIES$1 = 10;
    DEFAULT_PRIORITY$1 = 5;
    parser$5 = parser;
    Queues$1 = Queues_1;
    Job$1 = Job_1;
    LocalDatastore$1 = LocalDatastore_1;
    RedisDatastore$1 = require$$4$1;
    Events$4 = Events_1;
    States$1 = States_1;
    Sync$1 = Sync_1;
    Bottleneck = function() {

      class Bottleneck2 {
        constructor(options = {}, ...invalid) {
          var storeInstanceOptions, storeOptions;
          this._addToQueue = this._addToQueue.bind(this);
          this._validateOptions(options, invalid);
          parser$5.load(options, this.instanceDefaults, this);
          this._queues = new Queues$1(NUM_PRIORITIES$1);
          this._scheduled = {};
          this._states = new States$1(["RECEIVED", "QUEUED", "RUNNING", "EXECUTING"].concat(this.trackDoneStatus ? ["DONE"] : []));
          this._limiter = null;
          this.Events = new Events$4(this);
          this._submitLock = new Sync$1("submit", this.Promise);
          this._registerLock = new Sync$1("register", this.Promise);
          storeOptions = parser$5.load(options, this.storeDefaults, {});
          this._store = function() {
            if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
              storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});
              return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
            } else if (this.datastore === "local") {
              storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});
              return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
            } else {
              throw new Bottleneck2.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
            }
          }.call(this);
          this._queues.on("leftzero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : undefined : undefined;
          });
          this._queues.on("zero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : undefined : undefined;
          });
        }
        _validateOptions(options, invalid) {
          if (!(options != null && typeof options === "object" && invalid.length === 0)) {
            throw new Bottleneck2.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
          }
        }
        ready() {
          return this._store.ready;
        }
        clients() {
          return this._store.clients;
        }
        channel() {
          return `b_${this.id}`;
        }
        channel_client() {
          return `b_${this.id}_${this._store.clientId}`;
        }
        publish(message) {
          return this._store.__publish__(message);
        }
        disconnect(flush = true) {
          return this._store.__disconnect__(flush);
        }
        chain(_limiter) {
          this._limiter = _limiter;
          return this;
        }
        queued(priority) {
          return this._queues.queued(priority);
        }
        clusterQueued() {
          return this._store.__queued__();
        }
        empty() {
          return this.queued() === 0 && this._submitLock.isEmpty();
        }
        running() {
          return this._store.__running__();
        }
        done() {
          return this._store.__done__();
        }
        jobStatus(id) {
          return this._states.jobStatus(id);
        }
        jobs(status) {
          return this._states.statusJobs(status);
        }
        counts() {
          return this._states.statusCounts();
        }
        _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
        check(weight = 1) {
          return this._store.__check__(weight);
        }
        _clearGlobalState(index) {
          if (this._scheduled[index] != null) {
            clearTimeout(this._scheduled[index].expiration);
            delete this._scheduled[index];
            return true;
          } else {
            return false;
          }
        }
        async _free(index, job, options, eventInfo) {
          var e, running;
          try {
            ({ running } = await this._store.__free__(index, options.weight));
            this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);
            if (running === 0 && this.empty()) {
              return this.Events.trigger("idle");
            }
          } catch (error1) {
            e = error1;
            return this.Events.trigger("error", e);
          }
        }
        _run(index, job, wait) {
          var clearGlobalState, free, run;
          job.doRun();
          clearGlobalState = this._clearGlobalState.bind(this, index);
          run = this._run.bind(this, index, job);
          free = this._free.bind(this, index, job);
          return this._scheduled[index] = {
            timeout: setTimeout(() => {
              return job.doExecute(this._limiter, clearGlobalState, run, free);
            }, wait),
            expiration: job.options.expiration != null ? setTimeout(function() {
              return job.doExpire(clearGlobalState, run, free);
            }, wait + job.options.expiration) : undefined,
            job
          };
        }
        _drainOne(capacity) {
          return this._registerLock.schedule(() => {
            var args, index, next, options, queue;
            if (this.queued() === 0) {
              return this.Promise.resolve(null);
            }
            queue = this._queues.getFirst();
            ({ options, args } = next = queue.first());
            if (capacity != null && options.weight > capacity) {
              return this.Promise.resolve(null);
            }
            this.Events.trigger("debug", `Draining ${options.id}`, { args, options });
            index = this._randomIndex();
            return this._store.__register__(index, options.weight, options.expiration).then(({ success, wait, reservoir }) => {
              var empty;
              this.Events.trigger("debug", `Drained ${options.id}`, { success, args, options });
              if (success) {
                queue.shift();
                empty = this.empty();
                if (empty) {
                  this.Events.trigger("empty");
                }
                if (reservoir === 0) {
                  this.Events.trigger("depleted", empty);
                }
                this._run(index, next, wait);
                return this.Promise.resolve(options.weight);
              } else {
                return this.Promise.resolve(null);
              }
            });
          });
        }
        _drainAll(capacity, total = 0) {
          return this._drainOne(capacity).then((drained) => {
            var newCapacity;
            if (drained != null) {
              newCapacity = capacity != null ? capacity - drained : capacity;
              return this._drainAll(newCapacity, total + drained);
            } else {
              return this.Promise.resolve(total);
            }
          }).catch((e) => {
            return this.Events.trigger("error", e);
          });
        }
        _dropAllQueued(message) {
          return this._queues.shiftAll(function(job) {
            return job.doDrop({ message });
          });
        }
        stop(options = {}) {
          var done, waitForExecuting;
          options = parser$5.load(options, this.stopDefaults);
          waitForExecuting = (at) => {
            var finished;
            finished = () => {
              var counts;
              counts = this._states.counts;
              return counts[0] + counts[1] + counts[2] + counts[3] === at;
            };
            return new this.Promise((resolve, reject) => {
              if (finished()) {
                return resolve();
              } else {
                return this.on("done", () => {
                  if (finished()) {
                    this.removeAllListeners("done");
                    return resolve();
                  }
                });
              }
            });
          };
          done = options.dropWaitingJobs ? (this._run = function(index, next) {
            return next.doDrop({
              message: options.dropErrorMessage
            });
          }, this._drainOne = () => {
            return this.Promise.resolve(null);
          }, this._registerLock.schedule(() => {
            return this._submitLock.schedule(() => {
              var k, ref, v;
              ref = this._scheduled;
              for (k in ref) {
                v = ref[k];
                if (this.jobStatus(v.job.options.id) === "RUNNING") {
                  clearTimeout(v.timeout);
                  clearTimeout(v.expiration);
                  v.job.doDrop({
                    message: options.dropErrorMessage
                  });
                }
              }
              this._dropAllQueued(options.dropErrorMessage);
              return waitForExecuting(0);
            });
          })) : this.schedule({
            priority: NUM_PRIORITIES$1 - 1,
            weight: 0
          }, () => {
            return waitForExecuting(1);
          });
          this._receive = function(job) {
            return job._reject(new Bottleneck2.prototype.BottleneckError(options.enqueueErrorMessage));
          };
          this.stop = () => {
            return this.Promise.reject(new Bottleneck2.prototype.BottleneckError("stop() has already been called"));
          };
          return done;
        }
        async _addToQueue(job) {
          var args, blocked, error, options, reachedHWM, shifted, strategy;
          ({ args, options } = job);
          try {
            ({ reachedHWM, blocked, strategy } = await this._store.__submit__(this.queued(), options.weight));
          } catch (error1) {
            error = error1;
            this.Events.trigger("debug", `Could not queue ${options.id}`, { args, options, error });
            job.doDrop({ error });
            return false;
          }
          if (blocked) {
            job.doDrop();
            return true;
          } else if (reachedHWM) {
            shifted = strategy === Bottleneck2.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck2.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck2.prototype.strategy.OVERFLOW ? job : undefined;
            if (shifted != null) {
              shifted.doDrop();
            }
            if (shifted == null || strategy === Bottleneck2.prototype.strategy.OVERFLOW) {
              if (shifted == null) {
                job.doDrop();
              }
              return reachedHWM;
            }
          }
          job.doQueue(reachedHWM, blocked);
          this._queues.push(job);
          await this._drainAll();
          return reachedHWM;
        }
        _receive(job) {
          if (this._states.jobStatus(job.options.id) != null) {
            job._reject(new Bottleneck2.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
            return false;
          } else {
            job.doReceive();
            return this._submitLock.schedule(this._addToQueue, job);
          }
        }
        submit(...args) {
          var cb, fn, job, options, ref, ref1, task;
          if (typeof args[0] === "function") {
            ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);
            options = parser$5.load({}, this.jobDefaults);
          } else {
            ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);
            options = parser$5.load(options, this.jobDefaults);
          }
          task = (...args2) => {
            return new this.Promise(function(resolve, reject) {
              return fn(...args2, function(...args3) {
                return (args3[0] != null ? reject : resolve)(args3);
              });
            });
          };
          job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          job.promise.then(function(args2) {
            return typeof cb === "function" ? cb(...args2) : undefined;
          }).catch(function(args2) {
            if (Array.isArray(args2)) {
              return typeof cb === "function" ? cb(...args2) : undefined;
            } else {
              return typeof cb === "function" ? cb(args2) : undefined;
            }
          });
          return this._receive(job);
        }
        schedule(...args) {
          var job, options, task;
          if (typeof args[0] === "function") {
            [task, ...args] = args;
            options = {};
          } else {
            [options, task, ...args] = args;
          }
          job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          this._receive(job);
          return job.promise;
        }
        wrap(fn) {
          var schedule, wrapped;
          schedule = this.schedule.bind(this);
          wrapped = function(...args) {
            return schedule(fn.bind(this), ...args);
          };
          wrapped.withOptions = function(options, ...args) {
            return schedule(options, fn, ...args);
          };
          return wrapped;
        }
        async updateSettings(options = {}) {
          await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));
          parser$5.overwrite(options, this.instanceDefaults, this);
          return this;
        }
        currentReservoir() {
          return this._store.__currentReservoir__();
        }
        incrementReservoir(incr = 0) {
          return this._store.__incrementReservoir__(incr);
        }
      }
      Bottleneck2.default = Bottleneck2;
      Bottleneck2.Events = Events$4;
      Bottleneck2.version = Bottleneck2.prototype.version = require$$8.version;
      Bottleneck2.strategy = Bottleneck2.prototype.strategy = {
        LEAK: 1,
        OVERFLOW: 2,
        OVERFLOW_PRIORITY: 4,
        BLOCK: 3
      };
      Bottleneck2.BottleneckError = Bottleneck2.prototype.BottleneckError = BottleneckError_1;
      Bottleneck2.Group = Bottleneck2.prototype.Group = Group_1;
      Bottleneck2.RedisConnection = Bottleneck2.prototype.RedisConnection = require$$2;
      Bottleneck2.IORedisConnection = Bottleneck2.prototype.IORedisConnection = require$$3;
      Bottleneck2.Batcher = Bottleneck2.prototype.Batcher = Batcher_1;
      Bottleneck2.prototype.jobDefaults = {
        priority: DEFAULT_PRIORITY$1,
        weight: 1,
        expiration: null,
        id: "<no-id>"
      };
      Bottleneck2.prototype.storeDefaults = {
        maxConcurrent: null,
        minTime: 0,
        highWater: null,
        strategy: Bottleneck2.prototype.strategy.LEAK,
        penalty: null,
        reservoir: null,
        reservoirRefreshInterval: null,
        reservoirRefreshAmount: null,
        reservoirIncreaseInterval: null,
        reservoirIncreaseAmount: null,
        reservoirIncreaseMaximum: null
      };
      Bottleneck2.prototype.localStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 250
      };
      Bottleneck2.prototype.redisStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 5000,
        clientTimeout: 1e4,
        Redis: null,
        clientOptions: {},
        clusterNodes: null,
        clearDatastore: false,
        connection: null
      };
      Bottleneck2.prototype.instanceDefaults = {
        datastore: "local",
        connection: null,
        id: "<no-id>",
        rejectOnDrop: true,
        trackDoneStatus: false,
        Promise
      };
      Bottleneck2.prototype.stopDefaults = {
        enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
        dropWaitingJobs: true,
        dropErrorMessage: "This limiter has been stopped."
      };
      return Bottleneck2;
    }.call(commonjsGlobal);
    var Bottleneck_1 = Bottleneck;
    var lib = Bottleneck_1;
    return lib;
  });
});

// node_modules/@octokit/plugin-retry/dist-node/index.js
var require_dist_node12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var Bottleneck = _interopDefault(require_light());
  async function errorRequest(octokit, state, error, options) {
    if (!error.request || !error.request.request) {
      throw error;
    }
    if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
      const retries = options.request.retries != null ? options.request.retries : state.retries;
      const retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
      throw octokit.retry.retryRequest(error, retries, retryAfter);
    }
    throw error;
  }
  async function wrapRequest(state, request, options) {
    const limiter = new Bottleneck;
    limiter.on("failed", function(error, info) {
      const maxRetries = ~~error.request.request.retries;
      const after = ~~error.request.request.retryAfter;
      options.request.retryCount = info.retryCount + 1;
      if (maxRetries > info.retryCount) {
        return after * state.retryAfterBaseValue;
      }
    });
    return limiter.schedule(request, options);
  }
  var VERSION = "3.0.9";
  function retry(octokit, octokitOptions) {
    const state = Object.assign({
      enabled: true,
      retryAfterBaseValue: 1000,
      doNotRetry: [400, 401, 403, 404, 422],
      retries: 3
    }, octokitOptions.retry);
    if (state.enabled) {
      octokit.hook.error("request", errorRequest.bind(null, octokit, state));
      octokit.hook.wrap("request", wrapRequest.bind(null, state));
    }
    return {
      retry: {
        retryRequest: (error, retries, retryAfter) => {
          error.request.request = Object.assign({}, error.request.request, {
            retries,
            retryAfter
          });
          return error;
        }
      }
    };
  }
  retry.VERSION = VERSION;
  exports.VERSION = VERSION;
  exports.retry = retry;
});

// node_modules/@actions/artifact/lib/internal/find/get-artifact.js
var require_get_artifact = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getArtifactPublic = getArtifactPublic;
  exports.getArtifactInternal = getArtifactInternal;
  var github_1 = require_github();
  var plugin_retry_1 = require_dist_node12();
  var core = __importStar(require_core());
  var utils_1 = require_utils7();
  var retry_options_1 = require_retry_options();
  var plugin_request_log_1 = require_dist_node11();
  var util_1 = require_util9();
  var user_agent_1 = require_user_agent();
  var artifact_twirp_client_1 = require_artifact_twirp_client2();
  var generated_1 = require_generated();
  var errors_1 = require_errors2();
  function getArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a;
      const [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults);
      const opts = {
        log: undefined,
        userAgent: (0, user_agent_1.getUserAgentString)(),
        previews: undefined,
        retry: retryOpts,
        request: requestOpts
      };
      const github = (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog);
      const getArtifactResp = yield github.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts{?name}", {
        owner: repositoryOwner,
        repo: repositoryName,
        run_id: workflowRunId,
        name: artifactName
      });
      if (getArtifactResp.status !== 200) {
        throw new errors_1.InvalidResponseError(`Invalid response from GitHub API: ${getArtifactResp.status} (${(_a = getArtifactResp === null || getArtifactResp === undefined ? undefined : getArtifactResp.headers) === null || _a === undefined ? undefined : _a["x-github-request-id"]})`);
      }
      if (getArtifactResp.data.artifacts.length === 0) {
        throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
      }
      let artifact = getArtifactResp.data.artifacts[0];
      if (getArtifactResp.data.artifacts.length > 1) {
        artifact = getArtifactResp.data.artifacts.sort((a, b) => b.id - a.id)[0];
        core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.id})`);
      }
      return {
        artifact: {
          name: artifact.name,
          id: artifact.id,
          size: artifact.size_in_bytes,
          createdAt: artifact.created_at ? new Date(artifact.created_at) : undefined,
          digest: artifact.digest
        }
      };
    });
  }
  function getArtifactInternal(artifactName) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a;
      const artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
      const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
      const req = {
        workflowRunBackendId,
        workflowJobRunBackendId,
        nameFilter: generated_1.StringValue.create({ value: artifactName })
      };
      const res = yield artifactClient.ListArtifacts(req);
      if (res.artifacts.length === 0) {
        throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
      }
      let artifact = res.artifacts[0];
      if (res.artifacts.length > 1) {
        artifact = res.artifacts.sort((a, b) => Number(b.databaseId) - Number(a.databaseId))[0];
        core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.databaseId})`);
      }
      return {
        artifact: {
          name: artifact.name,
          id: Number(artifact.databaseId),
          size: Number(artifact.size),
          createdAt: artifact.createdAt ? generated_1.Timestamp.toDate(artifact.createdAt) : undefined,
          digest: (_a = artifact.digest) === null || _a === undefined ? undefined : _a.value
        }
      };
    });
  }
});

// node_modules/@actions/artifact/lib/internal/delete/delete-artifact.js
var require_delete_artifact = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteArtifactPublic = deleteArtifactPublic;
  exports.deleteArtifactInternal = deleteArtifactInternal;
  var core_1 = require_core();
  var github_1 = require_github();
  var user_agent_1 = require_user_agent();
  var retry_options_1 = require_retry_options();
  var utils_1 = require_utils7();
  var plugin_request_log_1 = require_dist_node11();
  var plugin_retry_1 = require_dist_node12();
  var artifact_twirp_client_1 = require_artifact_twirp_client2();
  var util_1 = require_util9();
  var generated_1 = require_generated();
  var get_artifact_1 = require_get_artifact();
  var errors_1 = require_errors2();
  function deleteArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a;
      const [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults);
      const opts = {
        log: undefined,
        userAgent: (0, user_agent_1.getUserAgentString)(),
        previews: undefined,
        retry: retryOpts,
        request: requestOpts
      };
      const github = (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog);
      const getArtifactResp = yield (0, get_artifact_1.getArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
      const deleteArtifactResp = yield github.rest.actions.deleteArtifact({
        owner: repositoryOwner,
        repo: repositoryName,
        artifact_id: getArtifactResp.artifact.id
      });
      if (deleteArtifactResp.status !== 204) {
        throw new errors_1.InvalidResponseError(`Invalid response from GitHub API: ${deleteArtifactResp.status} (${(_a = deleteArtifactResp === null || deleteArtifactResp === undefined ? undefined : deleteArtifactResp.headers) === null || _a === undefined ? undefined : _a["x-github-request-id"]})`);
      }
      return {
        id: getArtifactResp.artifact.id
      };
    });
  }
  function deleteArtifactInternal(artifactName) {
    return __awaiter(this, undefined, undefined, function* () {
      const artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
      const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
      const listReq = {
        workflowRunBackendId,
        workflowJobRunBackendId,
        nameFilter: generated_1.StringValue.create({ value: artifactName })
      };
      const listRes = yield artifactClient.ListArtifacts(listReq);
      if (listRes.artifacts.length === 0) {
        throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}`);
      }
      let artifact = listRes.artifacts[0];
      if (listRes.artifacts.length > 1) {
        artifact = listRes.artifacts.sort((a, b) => Number(b.databaseId) - Number(a.databaseId))[0];
        (0, core_1.debug)(`More than one artifact found for a single name, returning newest (id: ${artifact.databaseId})`);
      }
      const req = {
        workflowRunBackendId: artifact.workflowRunBackendId,
        workflowJobRunBackendId: artifact.workflowJobRunBackendId,
        name: artifact.name
      };
      const res = yield artifactClient.DeleteArtifact(req);
      (0, core_1.info)(`Artifact '${artifactName}' (ID: ${res.artifactId}) deleted`);
      return {
        id: Number(res.artifactId)
      };
    });
  }
});

// node_modules/@actions/artifact/lib/internal/find/list-artifacts.js
var require_list_artifacts = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listArtifactsPublic = listArtifactsPublic;
  exports.listArtifactsInternal = listArtifactsInternal;
  var core_1 = require_core();
  var github_1 = require_github();
  var user_agent_1 = require_user_agent();
  var retry_options_1 = require_retry_options();
  var utils_1 = require_utils7();
  var plugin_request_log_1 = require_dist_node11();
  var plugin_retry_1 = require_dist_node12();
  var artifact_twirp_client_1 = require_artifact_twirp_client2();
  var util_1 = require_util9();
  var config_1 = require_config();
  var generated_1 = require_generated();
  var maximumArtifactCount = (0, config_1.getMaxArtifactListCount)();
  var paginationCount = 100;
  var maxNumberOfPages = Math.ceil(maximumArtifactCount / paginationCount);
  function listArtifactsPublic(workflowRunId_1, repositoryOwner_1, repositoryName_1, token_1) {
    return __awaiter(this, arguments, undefined, function* (workflowRunId, repositoryOwner, repositoryName, token, latest = false) {
      (0, core_1.info)(`Fetching artifact list for workflow run ${workflowRunId} in repository ${repositoryOwner}/${repositoryName}`);
      let artifacts = [];
      const [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults);
      const opts = {
        log: undefined,
        userAgent: (0, user_agent_1.getUserAgentString)(),
        previews: undefined,
        retry: retryOpts,
        request: requestOpts
      };
      const github = (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog);
      let currentPageNumber = 1;
      const { data: listArtifactResponse } = yield github.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", {
        owner: repositoryOwner,
        repo: repositoryName,
        run_id: workflowRunId,
        per_page: paginationCount,
        page: currentPageNumber
      });
      let numberOfPages = Math.ceil(listArtifactResponse.total_count / paginationCount);
      const totalArtifactCount = listArtifactResponse.total_count;
      if (totalArtifactCount > maximumArtifactCount) {
        (0, core_1.warning)(`Workflow run ${workflowRunId} has ${totalArtifactCount} artifacts, exceeding the limit of ${maximumArtifactCount}. Results will be incomplete as only the first ${maximumArtifactCount} artifacts will be returned`);
        numberOfPages = maxNumberOfPages;
      }
      for (const artifact of listArtifactResponse.artifacts) {
        artifacts.push({
          name: artifact.name,
          id: artifact.id,
          size: artifact.size_in_bytes,
          createdAt: artifact.created_at ? new Date(artifact.created_at) : undefined,
          digest: artifact.digest
        });
      }
      currentPageNumber++;
      for (currentPageNumber;currentPageNumber <= numberOfPages; currentPageNumber++) {
        (0, core_1.debug)(`Fetching page ${currentPageNumber} of artifact list`);
        const { data: listArtifactResponse2 } = yield github.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", {
          owner: repositoryOwner,
          repo: repositoryName,
          run_id: workflowRunId,
          per_page: paginationCount,
          page: currentPageNumber
        });
        for (const artifact of listArtifactResponse2.artifacts) {
          artifacts.push({
            name: artifact.name,
            id: artifact.id,
            size: artifact.size_in_bytes,
            createdAt: artifact.created_at ? new Date(artifact.created_at) : undefined,
            digest: artifact.digest
          });
        }
      }
      if (latest) {
        artifacts = filterLatest(artifacts);
      }
      (0, core_1.info)(`Found ${artifacts.length} artifact(s)`);
      return {
        artifacts
      };
    });
  }
  function listArtifactsInternal() {
    return __awaiter(this, arguments, undefined, function* (latest = false) {
      const artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
      const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
      const req = {
        workflowRunBackendId,
        workflowJobRunBackendId
      };
      const res = yield artifactClient.ListArtifacts(req);
      let artifacts = res.artifacts.map((artifact) => {
        var _a;
        return {
          name: artifact.name,
          id: Number(artifact.databaseId),
          size: Number(artifact.size),
          createdAt: artifact.createdAt ? generated_1.Timestamp.toDate(artifact.createdAt) : undefined,
          digest: (_a = artifact.digest) === null || _a === undefined ? undefined : _a.value
        };
      });
      if (latest) {
        artifacts = filterLatest(artifacts);
      }
      (0, core_1.info)(`Found ${artifacts.length} artifact(s)`);
      return {
        artifacts
      };
    });
  }
  function filterLatest(artifacts) {
    artifacts.sort((a, b) => b.id - a.id);
    const latestArtifacts = [];
    const seenArtifactNames = new Set;
    for (const artifact of artifacts) {
      if (!seenArtifactNames.has(artifact.name)) {
        latestArtifacts.push(artifact);
        seenArtifactNames.add(artifact.name);
      }
    }
    return latestArtifacts;
  }
});

// node_modules/@actions/artifact/lib/internal/client.js
var require_client2 = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultArtifactClient = undefined;
  var core_1 = require_core();
  var config_1 = require_config();
  var upload_artifact_1 = require_upload_artifact();
  var download_artifact_1 = require_download_artifact();
  var delete_artifact_1 = require_delete_artifact();
  var get_artifact_1 = require_get_artifact();
  var list_artifacts_1 = require_list_artifacts();
  var errors_1 = require_errors2();

  class DefaultArtifactClient {
    uploadArtifact(name, files, rootDirectory, options) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          if ((0, config_1.isGhes)()) {
            throw new errors_1.GHESNotSupportedError;
          }
          return (0, upload_artifact_1.uploadArtifact)(name, files, rootDirectory, options);
        } catch (error) {
          (0, core_1.warning)(`Artifact upload failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions is operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
          throw error;
        }
      });
    }
    downloadArtifact(artifactId, options) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          if ((0, config_1.isGhes)()) {
            throw new errors_1.GHESNotSupportedError;
          }
          if (options === null || options === undefined ? undefined : options.findBy) {
            const { findBy: { repositoryOwner, repositoryName, token } } = options, downloadOptions = __rest(options, ["findBy"]);
            return (0, download_artifact_1.downloadArtifactPublic)(artifactId, repositoryOwner, repositoryName, token, downloadOptions);
          }
          return (0, download_artifact_1.downloadArtifactInternal)(artifactId, options);
        } catch (error) {
          (0, core_1.warning)(`Download Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
          throw error;
        }
      });
    }
    listArtifacts(options) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          if ((0, config_1.isGhes)()) {
            throw new errors_1.GHESNotSupportedError;
          }
          if (options === null || options === undefined ? undefined : options.findBy) {
            const { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
            return (0, list_artifacts_1.listArtifactsPublic)(workflowRunId, repositoryOwner, repositoryName, token, options === null || options === undefined ? undefined : options.latest);
          }
          return (0, list_artifacts_1.listArtifactsInternal)(options === null || options === undefined ? undefined : options.latest);
        } catch (error) {
          (0, core_1.warning)(`Listing Artifacts failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
          throw error;
        }
      });
    }
    getArtifact(artifactName, options) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          if ((0, config_1.isGhes)()) {
            throw new errors_1.GHESNotSupportedError;
          }
          if (options === null || options === undefined ? undefined : options.findBy) {
            const { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
            return (0, get_artifact_1.getArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
          }
          return (0, get_artifact_1.getArtifactInternal)(artifactName);
        } catch (error) {
          (0, core_1.warning)(`Get Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
          throw error;
        }
      });
    }
    deleteArtifact(artifactName, options) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          if ((0, config_1.isGhes)()) {
            throw new errors_1.GHESNotSupportedError;
          }
          if (options === null || options === undefined ? undefined : options.findBy) {
            const { findBy: { repositoryOwner, repositoryName, workflowRunId, token } } = options;
            return (0, delete_artifact_1.deleteArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
          }
          return (0, delete_artifact_1.deleteArtifactInternal)(artifactName);
        } catch (error) {
          (0, core_1.warning)(`Delete Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
          throw error;
        }
      });
    }
  }
  exports.DefaultArtifactClient = DefaultArtifactClient;
});

// node_modules/@actions/artifact/lib/internal/shared/interfaces.js
var require_interfaces2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@actions/artifact/lib/artifact.js
var require_artifact2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var client_1 = require_client2();
  __exportStar(require_interfaces2(), exports);
  __exportStar(require_errors2(), exports);
  __exportStar(require_client2(), exports);
  var client = new client_1.DefaultArtifactClient;
  exports.default = client;
});

// src/post/index.ts
var import_artifact = __toESM(require_artifact2(), 1);
var import_core = __toESM(require_core(), 1);
import { promises as fs } from "node:fs";

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_2) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// src/post/renderer.ts
class Renderer {
  render(renderParamsList) {
    return `## Workflow Metrics

${renderParamsList.filter(({
      metricsInfoList
    }) => metricsInfoList.length > 0).map((p) => {
      const colors = p.metricsInfoList.map(({ color }) => color);
      const stackedDatum = p.metricsInfoList.toReversed().reduce((prev, { data }, i) => {
        prev.push(data.map((d, j) => d + prev[i][j]));
        return prev;
      }, [p.metricsInfoList[0].data.map(() => 0)]).slice(1).toReversed();
      return `### ${p.title}

#### Legends

${p.metricsInfoList.map((i) => `* $\${\\color{${i.color}} \\verb|${i.color}: ${i.name}|}$$`).join(`
`)}

#### Chart

\`\`\`mermaid
%%{
  init: {
    "themeVariables": {
      "xyChart": {
        "plotColorPalette": "${colors.join(", ")}"
      }
    }
  }
}%%
xychart

x-axis "Time" ${JSON.stringify(p.times.map((d) => d.toLocaleTimeString("en-GB", { hour12: false })))}
y-axis "${p.yAxis.title}"${p.yAxis.range ? ` ${p.yAxis.range}` : ""}
${stackedDatum.map((d) => `bar ${JSON.stringify(d)}`).join(`
`)}
\`\`\``;
    }).join(`

`)}`;
  }
}

// src/lib.ts
var cpuLoadPercentageSchema = exports_external.object({
  time: exports_external.number().finite(),
  user: exports_external.number().finite().nonnegative().max(100),
  system: exports_external.number().finite().nonnegative().max(100)
});
var cpuLoadPercentagesSchema = exports_external.array(cpuLoadPercentageSchema);
var memoryUsageMBSchema = exports_external.object({
  time: exports_external.number().finite(),
  used: exports_external.number().finite().nonnegative(),
  free: exports_external.number().finite().nonnegative()
});
var memoryUsageMBsSchema = exports_external.array(memoryUsageMBSchema);
var metricsDataSchema = exports_external.object({
  cpuLoadPercentages: cpuLoadPercentagesSchema,
  memoryUsageMBs: memoryUsageMBsSchema
});
var serverPort = 7777;

// src/post/lib.ts
var metricsInfoSchema = exports_external.object({
  color: exports_external.string(),
  name: exports_external.string(),
  data: exports_external.array(exports_external.number())
});
var metricsInfoListSchema = exports_external.array(metricsInfoSchema);
var renderParamsSchema = exports_external.object({
  title: exports_external.string(),
  metricsInfoList: metricsInfoListSchema,
  times: exports_external.array(exports_external.coerce.date()),
  yAxis: exports_external.object({
    title: exports_external.string(),
    range: exports_external.string().optional()
  })
});
var renderParamsListSchema = exports_external.array(renderParamsSchema);
async function getMetricsData() {
  const controller = new AbortController;
  const timer = setTimeout(() => controller.abort(), 10 * 1000);
  try {
    const res = await fetch(`http://localhost:${serverPort}/metrics`, {
      signal: controller.signal
    });
    if (!res.ok) {
      throw new Error(`Failed to fetch metrics: ${res.status} ${res.statusText}`);
    }
    return metricsDataSchema.parse(await res.json());
  } finally {
    clearTimeout(timer);
  }
}
function render(metricsData) {
  const renderer = new Renderer;
  return renderer.render(renderParamsListSchema.parse([
    {
      title: "CPU Loads",
      metricsInfoList: [
        {
          color: "Orange",
          name: "System",
          data: metricsData.cpuLoadPercentages.map(({ system }) => system)
        },
        {
          color: "Red",
          name: "User",
          data: metricsData.cpuLoadPercentages.map(({ user }) => user)
        }
      ],
      times: metricsData.cpuLoadPercentages.map(({ time }) => time),
      yAxis: {
        title: "%",
        range: "0 --> 100"
      }
    },
    {
      title: "Memory Usages",
      metricsInfoList: [
        {
          color: "Green",
          name: "Free",
          data: metricsData.memoryUsageMBs.map(({ free }) => free)
        },
        {
          color: "Blue",
          name: "Used",
          data: metricsData.memoryUsageMBs.map(({ used }) => used)
        }
      ],
      times: metricsData.memoryUsageMBs.map(({ time }) => time),
      yAxis: {
        title: "MB"
      }
    }
  ]));
}

// src/post/index.ts
async function index() {
  try {
    const metricsData = await getMetricsData();
    await import_core.summary.addRaw(render(metricsData)).write();
    const artifactName = ["workflow_metrics"].concat(process.env.GITHUB_JOB ? [process.env.GITHUB_JOB] : []).join("_");
    const fileName = `${artifactName}.json`;
    await fs.writeFile(fileName, JSON.stringify(metricsData));
    const client = new import_artifact.DefaultArtifactClient;
    await client.uploadArtifact(artifactName, [fileName], ".");
  } catch (error) {
    import_core.setFailed(error);
  } finally {
    const controller = new AbortController;
    const timer = setTimeout(() => controller.abort(), 10 * 1000);
    try {
      const res = await fetch(`http://localhost:${serverPort}/finish`, {
        signal: controller.signal
      });
      if (res.ok) {
        import_core.info("Server finished");
      } else {
        import_core.setFailed(`Failed to finish server: ${res.status} ${res.statusText}`);
      }
    } finally {
      clearTimeout(timer);
    }
  }
}
await index();

//# debugId=D1E3FA79B66A15C264756E2164756E21
//# sourceMappingURL=index.bundle.js.map
