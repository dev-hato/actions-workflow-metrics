import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toCommandValue = toCommandValue;
  exports.toCommandProperties = toCommandProperties;
  function toCommandValue(input) {
    if (input === null || input === undefined) {
      return "";
    } else if (typeof input === "string" || input instanceof String) {
      return input;
    }
    return JSON.stringify(input);
  }
  function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
      return {};
    }
    return {
      title: annotationProperties.title,
      file: annotationProperties.file,
      line: annotationProperties.startLine,
      endLine: annotationProperties.endLine,
      col: annotationProperties.startColumn,
      endColumn: annotationProperties.endColumn
    };
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.issueCommand = issueCommand;
  exports.issue = issue;
  var os = __importStar(__require("os"));
  var utils_1 = require_utils();
  function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  var CMD_STRING = "::";

  class Command {
    constructor(command, properties, message) {
      if (!command) {
        command = "missing.command";
      }
      this.command = command;
      this.properties = properties;
      this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = true;
        for (const key in this.properties) {
          if (this.properties.hasOwnProperty(key)) {
            const val = this.properties[key];
            if (val) {
              if (first) {
                first = false;
              } else {
                cmdStr += ",";
              }
              cmdStr += `${key}=${escapeProperty(val)}`;
            }
          }
        }
      }
      cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
      return cmdStr;
    }
  }
  function escapeData(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.issueFileCommand = issueFileCommand;
  exports.prepareKeyValueMessage = prepareKeyValueMessage;
  var crypto = __importStar(__require("crypto"));
  var fs = __importStar(__require("fs"));
  var os = __importStar(__require("os"));
  var utils_1 = require_utils();
  function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
      throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
      throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
    const convertedValue = (0, utils_1.toCommandValue)(value);
    if (key.includes(delimiter)) {
      throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
      throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getProxyUrl = getProxyUrl;
  exports.checkBypass = checkBypass;
  function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl)) {
      return;
    }
    const proxyVar = (() => {
      if (usingSsl) {
        return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        return process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
    })();
    if (proxyVar) {
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    } else {
      return;
    }
  }
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
      return true;
    }
    const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
        return true;
      }
    }
    return false;
  }
  function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username);
      this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS((exports) => {
  var net = __require("net");
  var tls = __require("tls");
  var http = __require("http");
  var https = __require("https");
  var events = __require("events");
  var assert = __require("assert");
  var util = __require("util");
  exports.httpOverHttp = httpOverHttp;
  exports.httpsOverHttp = httpsOverHttp;
  exports.httpOverHttps = httpOverHttps;
  exports.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self = this;
    self.options = options || {};
    self.proxyOptions = self.options.proxy || {};
    self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
    self.requests = [];
    self.sockets = [];
    self.on("free", function onFree(socket, host, port, localAddress) {
      var options2 = toOptions(host, port, localAddress);
      for (var i = 0, len = self.requests.length;i < len; ++i) {
        var pending = self.requests[i];
        if (pending.host === options2.host && pending.port === options2.port) {
          self.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
    var self = this;
    var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));
    if (self.sockets.length >= this.maxSockets) {
      self.requests.push(options);
      return;
    }
    self.createSocket(options, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      req.onSocket(socket);
      function onFree() {
        self.emit("free", socket, options);
      }
      function onCloseOrRemove(err) {
        self.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self = this;
    var placeholder = {};
    self.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: false,
      headers: {
        host: options.host + ":" + options.port
      }
    });
    if (options.localAddress) {
      connectOptions.localAddress = options.localAddress;
    }
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode !== 200) {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        socket.destroy();
        var error2 = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode);
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug("got illegal response body from proxy");
        socket.destroy();
        var error2 = new Error("got illegal response body from proxy");
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self.removeSocket(placeholder);
        return;
      }
      debug("tunneling connection has established");
      self.sockets[self.sockets.indexOf(placeholder)] = socket;
      return cb(socket);
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug(`tunneling socket could not be established, cause=%s
`, cause.message, cause.stack);
      var error2 = new Error("tunneling socket could not be established, " + "cause=" + cause.message);
      error2.code = "ECONNRESET";
      options.request.emit("error", error2);
      self.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) {
      return;
    }
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
    }
  };
  function createSecureSocket(options, cb) {
    var self = this;
    TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
      var hostHeader = options.request.getHeader("host");
      var tlsOptions = mergeOptions({}, self.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
      });
      var secureSocket = tls.connect(0, tlsOptions);
      self.sockets[self.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function toOptions(host, port, localAddress) {
    if (typeof host === "string") {
      return {
        host,
        port,
        localAddress
      };
    }
    return host;
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length;i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length;j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== undefined) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {};
  }
  exports.debug = debug;
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kBody: Symbol("abstracted request body"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kResume: Symbol("resume"),
    kOnError: Symbol("on error"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable"),
    kListeners: Symbol("listeners"),
    kHTTPContext: Symbol("http context"),
    kMaxConcurrentStreams: Symbol("max concurrent streams"),
    kHTTP2InitialWindowSize: Symbol("http2 initial window size"),
    kHTTP2ConnectionWindowSize: Symbol("http2 connection window size"),
    kEnableConnectProtocol: Symbol("http2session connect protocol"),
    kRemoteSettings: Symbol("http2session remote settings"),
    kHTTP2Stream: Symbol("http2session client stream"),
    kNoProxyAgent: Symbol("no proxy agent"),
    kHttpProxyAgent: Symbol("http proxy agent"),
    kHttpsProxyAgent: Symbol("https proxy agent")
  };
});

// node_modules/undici/lib/util/timers.js
var require_timers = __commonJS((exports, module) => {
  var fastNow = 0;
  var RESOLUTION_MS = 1000;
  var TICK_MS = (RESOLUTION_MS >> 1) - 1;
  var fastNowTimeout;
  var kFastTimer = Symbol("kFastTimer");
  var fastTimers = [];
  var NOT_IN_LIST = -2;
  var TO_BE_CLEARED = -1;
  var PENDING = 0;
  var ACTIVE = 1;
  function onTick() {
    fastNow += TICK_MS;
    let idx = 0;
    let len = fastTimers.length;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer._state === PENDING) {
        timer._idleStart = fastNow - TICK_MS;
        timer._state = ACTIVE;
      } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
        timer._state = TO_BE_CLEARED;
        timer._idleStart = -1;
        timer._onTimeout(timer._timerArg);
      }
      if (timer._state === TO_BE_CLEARED) {
        timer._state = NOT_IN_LIST;
        if (--len !== 0) {
          fastTimers[idx] = fastTimers[len];
        }
      } else {
        ++idx;
      }
    }
    fastTimers.length = len;
    if (fastTimers.length !== 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout?.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTick, TICK_MS);
      fastNowTimeout?.unref();
    }
  }

  class FastTimer {
    [kFastTimer] = true;
    _state = NOT_IN_LIST;
    _idleTimeout = -1;
    _idleStart = -1;
    _onTimeout;
    _timerArg;
    constructor(callback, delay, arg) {
      this._onTimeout = callback;
      this._idleTimeout = delay;
      this._timerArg = arg;
      this.refresh();
    }
    refresh() {
      if (this._state === NOT_IN_LIST) {
        fastTimers.push(this);
      }
      if (!fastNowTimeout || fastTimers.length === 1) {
        refreshTimeout();
      }
      this._state = PENDING;
    }
    clear() {
      this._state = TO_BE_CLEARED;
      this._idleStart = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, arg) {
      return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
    },
    clearTimeout(timeout) {
      if (timeout[kFastTimer]) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    },
    setFastTimeout(callback, delay, arg) {
      return new FastTimer(callback, delay, arg);
    },
    clearFastTimeout(timeout) {
      timeout.clear();
    },
    now() {
      return fastNow;
    },
    tick(delay = 0) {
      fastNow += delay - RESOLUTION_MS + 1;
      onTick();
      onTick();
    },
    reset() {
      fastNow = 0;
      fastTimers.length = 0;
      clearTimeout(fastNowTimeout);
      fastNowTimeout = null;
    },
    kFastTimer
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  var kUndiciError = Symbol.for("undici.error.UND_ERR");

  class UndiciError extends Error {
    constructor(message, options) {
      super(message, options);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kUndiciError] === true;
    }
    get [kUndiciError]() {
      return true;
    }
  }
  var kConnectTimeoutError = Symbol.for("undici.error.UND_ERR_CONNECT_TIMEOUT");

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kConnectTimeoutError] === true;
    }
    get [kConnectTimeoutError]() {
      return true;
    }
  }
  var kHeadersTimeoutError = Symbol.for("undici.error.UND_ERR_HEADERS_TIMEOUT");

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHeadersTimeoutError] === true;
    }
    get [kHeadersTimeoutError]() {
      return true;
    }
  }
  var kHeadersOverflowError = Symbol.for("undici.error.UND_ERR_HEADERS_OVERFLOW");

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHeadersOverflowError] === true;
    }
    get [kHeadersOverflowError]() {
      return true;
    }
  }
  var kBodyTimeoutError = Symbol.for("undici.error.UND_ERR_BODY_TIMEOUT");

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kBodyTimeoutError] === true;
    }
    get [kBodyTimeoutError]() {
      return true;
    }
  }
  var kInvalidArgumentError = Symbol.for("undici.error.UND_ERR_INVALID_ARG");

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInvalidArgumentError] === true;
    }
    get [kInvalidArgumentError]() {
      return true;
    }
  }
  var kInvalidReturnValueError = Symbol.for("undici.error.UND_ERR_INVALID_RETURN_VALUE");

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInvalidReturnValueError] === true;
    }
    get [kInvalidReturnValueError]() {
      return true;
    }
  }
  var kAbortError = Symbol.for("undici.error.UND_ERR_ABORT");

  class AbortError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "The operation was aborted";
      this.code = "UND_ERR_ABORT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kAbortError] === true;
    }
    get [kAbortError]() {
      return true;
    }
  }
  var kRequestAbortedError = Symbol.for("undici.error.UND_ERR_ABORTED");

  class RequestAbortedError extends AbortError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestAbortedError] === true;
    }
    get [kRequestAbortedError]() {
      return true;
    }
  }
  var kInformationalError = Symbol.for("undici.error.UND_ERR_INFO");

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInformationalError] === true;
    }
    get [kInformationalError]() {
      return true;
    }
  }
  var kRequestContentLengthMismatchError = Symbol.for("undici.error.UND_ERR_REQ_CONTENT_LENGTH_MISMATCH");

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestContentLengthMismatchError] === true;
    }
    get [kRequestContentLengthMismatchError]() {
      return true;
    }
  }
  var kResponseContentLengthMismatchError = Symbol.for("undici.error.UND_ERR_RES_CONTENT_LENGTH_MISMATCH");

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseContentLengthMismatchError] === true;
    }
    get [kResponseContentLengthMismatchError]() {
      return true;
    }
  }
  var kClientDestroyedError = Symbol.for("undici.error.UND_ERR_DESTROYED");

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kClientDestroyedError] === true;
    }
    get [kClientDestroyedError]() {
      return true;
    }
  }
  var kClientClosedError = Symbol.for("undici.error.UND_ERR_CLOSED");

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kClientClosedError] === true;
    }
    get [kClientClosedError]() {
      return true;
    }
  }
  var kSocketError = Symbol.for("undici.error.UND_ERR_SOCKET");

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kSocketError] === true;
    }
    get [kSocketError]() {
      return true;
    }
  }
  var kNotSupportedError = Symbol.for("undici.error.UND_ERR_NOT_SUPPORTED");

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kNotSupportedError] === true;
    }
    get [kNotSupportedError]() {
      return true;
    }
  }
  var kBalancedPoolMissingUpstreamError = Symbol.for("undici.error.UND_ERR_BPL_MISSING_UPSTREAM");

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kBalancedPoolMissingUpstreamError] === true;
    }
    get [kBalancedPoolMissingUpstreamError]() {
      return true;
    }
  }
  var kHTTPParserError = Symbol.for("undici.error.UND_ERR_HTTP_PARSER");

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : undefined;
      this.data = data ? data.toString() : undefined;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHTTPParserError] === true;
    }
    get [kHTTPParserError]() {
      return true;
    }
  }
  var kResponseExceededMaxSizeError = Symbol.for("undici.error.UND_ERR_RES_EXCEEDED_MAX_SIZE");

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseExceededMaxSizeError] === true;
    }
    get [kResponseExceededMaxSizeError]() {
      return true;
    }
  }
  var kRequestRetryError = Symbol.for("undici.error.UND_ERR_REQ_RETRY");

  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      this.name = "RequestRetryError";
      this.message = message || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data;
      this.headers = headers;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestRetryError] === true;
    }
    get [kRequestRetryError]() {
      return true;
    }
  }
  var kResponseError = Symbol.for("undici.error.UND_ERR_RESPONSE");

  class ResponseError extends UndiciError {
    constructor(message, code, { headers, body }) {
      super(message);
      this.name = "ResponseError";
      this.message = message || "Response error";
      this.code = "UND_ERR_RESPONSE";
      this.statusCode = code;
      this.body = body;
      this.headers = headers;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseError] === true;
    }
    get [kResponseError]() {
      return true;
    }
  }
  var kSecureProxyConnectionError = Symbol.for("undici.error.UND_ERR_PRX_TLS");

  class SecureProxyConnectionError extends UndiciError {
    constructor(cause, message, options = {}) {
      super(message, { cause, ...options });
      this.name = "SecureProxyConnectionError";
      this.message = message || "Secure Proxy Connection failed";
      this.code = "UND_ERR_PRX_TLS";
      this.cause = cause;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kSecureProxyConnectionError] === true;
    }
    get [kSecureProxyConnectionError]() {
      return true;
    }
  }
  var kMaxOriginsReachedError = Symbol.for("undici.error.UND_ERR_MAX_ORIGINS_REACHED");

  class MaxOriginsReachedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MaxOriginsReachedError";
      this.message = message || "Maximum allowed origins reached";
      this.code = "UND_ERR_MAX_ORIGINS_REACHED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kMaxOriginsReachedError] === true;
    }
    get [kMaxOriginsReachedError]() {
      return true;
    }
  }
  module.exports = {
    AbortError,
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError,
    ResponseError,
    SecureProxyConnectionError,
    MaxOriginsReachedError
  };
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS((exports, module) => {
  var wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  var headerNameLowerCasedRecord = {};
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  var wellknownHeaderNameBuffers = {};
  Object.setPrototypeOf(wellknownHeaderNameBuffers, null);
  function getHeaderNameAsBuffer(header) {
    let buffer = wellknownHeaderNameBuffers[header];
    if (buffer === undefined) {
      buffer = Buffer.from(header);
    }
    return buffer;
  }
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    const key = wellknownHeaderNames[i];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  module.exports = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord,
    getHeaderNameAsBuffer
  };
});

// node_modules/undici/lib/core/tree.js
var require_tree = __commonJS((exports, module) => {
  var {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  } = require_constants();

  class TstNode {
    value = null;
    left = null;
    middle = null;
    right = null;
    code;
    constructor(key, value, index) {
      if (index === undefined || index >= key.length) {
        throw new TypeError("Unreachable");
      }
      const code = this.code = key.charCodeAt(index);
      if (code > 127) {
        throw new TypeError("key must be ascii string");
      }
      if (key.length !== ++index) {
        this.middle = new TstNode(key, value, index);
      } else {
        this.value = value;
      }
    }
    add(key, value) {
      const length = key.length;
      if (length === 0) {
        throw new TypeError("Unreachable");
      }
      let index = 0;
      let node = this;
      while (true) {
        const code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (node.code === code) {
          if (length === ++index) {
            node.value = value;
            break;
          } else if (node.middle !== null) {
            node = node.middle;
          } else {
            node.middle = new TstNode(key, value, index);
            break;
          }
        } else if (node.code < code) {
          if (node.left !== null) {
            node = node.left;
          } else {
            node.left = new TstNode(key, value, index);
            break;
          }
        } else if (node.right !== null) {
          node = node.right;
        } else {
          node.right = new TstNode(key, value, index);
          break;
        }
      }
    }
    search(key) {
      const keylength = key.length;
      let index = 0;
      let node = this;
      while (node !== null && index < keylength) {
        let code = key[index];
        if (code <= 90 && code >= 65) {
          code |= 32;
        }
        while (node !== null) {
          if (code === node.code) {
            if (keylength === ++index) {
              return node;
            }
            node = node.middle;
            break;
          }
          node = node.code < code ? node.left : node.right;
        }
      }
      return null;
    }
  }

  class TernarySearchTree {
    node = null;
    insert(key, value) {
      if (this.node === null) {
        this.node = new TstNode(key, value, 0);
      } else {
        this.node.add(key, value);
      }
    }
    lookup(key) {
      return this.node?.search(key)?.value ?? null;
    }
  }
  var tree = new TernarySearchTree;
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
    tree.insert(key, key);
  }
  module.exports = {
    TernarySearchTree,
    tree
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { kDestroyed, kBodyUsed, kListeners, kBody } = require_symbols();
  var { IncomingMessage } = __require("node:http");
  var stream = __require("node:stream");
  var net = __require("node:net");
  var { stringify } = __require("node:querystring");
  var { EventEmitter: EE } = __require("node:events");
  var timers = require_timers();
  var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
  var { headerNameLowerCasedRecord } = require_constants();
  var { tree } = require_tree();
  var [nodeMajor, nodeMinor] = process.versions.node.split(".", 2).map((v) => Number(v));

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  function noop() {}
  function wrapRequestBody(body) {
    if (isStream(body)) {
      if (bodyLength(body) === 0) {
        body.on("data", function() {
          assert(false);
        });
      }
      if (typeof body.readableDidRead !== "boolean") {
        body[kBodyUsed] = false;
        EE.prototype.on.call(body, "data", function() {
          this[kBodyUsed] = true;
        });
      }
      return body;
    } else if (body && typeof body.pipeTo === "function") {
      return new BodyAsyncIterable(body);
    } else if (body && isFormDataLike(body)) {
      return body;
    } else if (body && typeof body !== "string" && !ArrayBuffer.isView(body) && isIterable(body)) {
      return new BodyAsyncIterable(body);
    } else {
      return body;
    }
  }
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    if (object === null) {
      return false;
    } else if (object instanceof Blob) {
      return true;
    } else if (typeof object !== "object") {
      return false;
    } else {
      const sTag = object[Symbol.toStringTag];
      return (sTag === "Blob" || sTag === "File") && (("stream" in object) && typeof object.stream === "function" || ("arrayBuffer" in object) && typeof object.arrayBuffer === "function");
    }
  }
  function pathHasQueryOrFragment(url) {
    return url.includes("?") || url.includes("#");
  }
  function serializePathWithQuery(url, queryParams) {
    if (pathHasQueryOrFragment(url)) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function isValidPort(port) {
    const value = parseInt(port, 10);
    return value === Number(port) && value >= 0 && value <= 65535;
  }
  function isHttpOrHttpsPrefixed(value) {
    return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
      let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin[origin.length - 1] === "/") {
        origin = origin.slice(0, origin.length - 1);
      }
      if (path && path[0] !== "/") {
        path = `/${path}`;
      }
      return new URL(`${origin}${path}`);
    }
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert(typeof host === "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body) {
    if (body == null) {
      return 0;
    } else if (isStream(body)) {
      const state = body._readableState;
      return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body)) {
      return body.size != null ? body.size : null;
    } else if (isBuffer(body)) {
      return body.byteLength;
    }
    return null;
  }
  function isDestroyed(body) {
    return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      queueMicrotask(() => {
        stream2.emit("error", err);
      });
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m = val.match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  }
  function headerNameToString(value) {
    return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function bufferToLowerCasedHeaderName(value) {
    return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function parseHeaders(headers, obj) {
    if (obj === undefined)
      obj = {};
    for (let i = 0;i < headers.length; i += 2) {
      const key = headerNameToString(headers[i]);
      let val = obj[key];
      if (val) {
        if (typeof val === "string") {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1].toString("utf8"));
      } else {
        const headersValue = headers[i + 1];
        if (typeof headersValue === "string") {
          obj[key] = headersValue;
        } else {
          obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
        }
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers) {
    const headersLength = headers.length;
    const ret = new Array(headersLength);
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    let key;
    let val;
    let kLen = 0;
    for (let n = 0;n < headersLength; n += 2) {
      key = headers[n];
      val = headers[n + 1];
      typeof key !== "string" && (key = key.toString());
      typeof val !== "string" && (val = val.toString("utf8"));
      kLen = key.length;
      if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
        hasContentLength = true;
      } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = n + 1;
      }
      ret[n] = key;
      ret[n + 1] = val;
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function encodeRawHeaders(headers) {
    if (!Array.isArray(headers)) {
      throw new TypeError("expected headers to be an array");
    }
    return headers.map((x) => Buffer.from(x));
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function assertRequestHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onRequestStart === "function") {
      return;
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body) {
    return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  function ReadableStreamFrom(iterable) {
    let iterator;
    return new ReadableStream({
      start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      pull(controller) {
        return iterator.next().then(({ done, value }) => {
          if (done) {
            return queueMicrotask(() => {
              controller.close();
              controller.byobRequest?.respond(0);
            });
          } else {
            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
            if (buf.byteLength) {
              return controller.enqueue(new Uint8Array(buf));
            } else {
              return this.pull(controller);
            }
          }
        });
      },
      cancel() {
        return iterator.return();
      },
      type: "bytes"
    });
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.once("abort", listener);
    return () => signal.removeListener("abort", listener);
  }
  var validTokenChars = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function isTokenCharCode(c) {
    return validTokenChars[c] === 1;
  }
  var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
  function isValidHTTPToken(characters) {
    if (characters.length >= 12)
      return tokenRegExp.test(characters);
    if (characters.length === 0)
      return false;
    for (let i = 0;i < characters.length; i++) {
      if (validTokenChars[characters.charCodeAt(i)] !== 1) {
        return false;
      }
    }
    return true;
  }
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function isValidHeaderValue(characters) {
    return !headerCharRegex.test(characters);
  }
  var rangeHeaderRegex = /^bytes (\d+)-(\d+)\/(\d+)?$/;
  function parseRangeHeader(range) {
    if (range == null || range === "")
      return { start: 0, end: null, size: null };
    const m = range ? range.match(rangeHeaderRegex) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  function addListener(obj, name, listener) {
    const listeners = obj[kListeners] ??= [];
    listeners.push([name, listener]);
    obj.on(name, listener);
    return obj;
  }
  function removeAllListeners(obj) {
    if (obj[kListeners] != null) {
      for (const [name, listener] of obj[kListeners]) {
        obj.removeListener(name, listener);
      }
      obj[kListeners] = null;
    }
    return obj;
  }
  function errorRequest(client, request, err) {
    try {
      request.onError(err);
      assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  }
  var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop;
    }
    let s1 = null;
    let s2 = null;
    const fastTimer = timers.setFastTimeout(() => {
      s1 = setImmediate(() => {
        s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
      });
    }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  } : (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop;
    }
    let s1 = null;
    const fastTimer = timers.setFastTimeout(() => {
      s1 = setImmediate(() => {
        onConnectTimeout(socketWeakRef.deref(), opts);
      });
    }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer);
      clearImmediate(s1);
    };
  };
  function onConnectTimeout(socket, opts) {
    if (socket == null) {
      return;
    }
    let message = "Connect Timeout Error";
    if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
      message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
    } else {
      message += ` (attempted address: ${opts.hostname}:${opts.port},`;
    }
    message += ` timeout: ${opts.timeout}ms)`;
    destroy(socket, new ConnectTimeoutError(message));
  }
  function getProtocolFromUrlString(urlString) {
    if (urlString[0] === "h" && urlString[1] === "t" && urlString[2] === "t" && urlString[3] === "p") {
      switch (urlString[4]) {
        case ":":
          return "http:";
        case "s":
          if (urlString[5] === ":") {
            return "https:";
          }
      }
    }
    return urlString.slice(0, urlString.indexOf(":") + 1);
  }
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  var normalizedMethodRecordsBase = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  var normalizedMethodRecords = {
    ...normalizedMethodRecordsBase,
    patch: "patch",
    PATCH: "PATCH"
  };
  Object.setPrototypeOf(normalizedMethodRecordsBase, null);
  Object.setPrototypeOf(normalizedMethodRecords, null);
  module.exports = {
    kEnumerableProperty,
    isDisturbed,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    bufferToLowerCasedHeaderName,
    addListener,
    removeAllListeners,
    errorRequest,
    parseRawHeaders,
    encodeRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    assertRequestHandler,
    getSocketInfo,
    isFormDataLike,
    pathHasQueryOrFragment,
    serializePathWithQuery,
    addAbortListener,
    isValidHTTPToken,
    isValidHeaderValue,
    isTokenCharCode,
    parseRangeHeader,
    normalizedMethodRecordsBase,
    normalizedMethodRecords,
    isValidPort,
    isHttpOrHttpsPrefixed,
    nodeMajor,
    nodeMinor,
    safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]),
    wrapRequestBody,
    setupConnectTimeout,
    getProtocolFromUrlString
  };
});

// node_modules/undici/lib/util/stats.js
var require_stats = __commonJS((exports, module) => {
  var {
    kConnected,
    kPending,
    kRunning,
    kSize,
    kFree,
    kQueued
  } = require_symbols();

  class ClientStats {
    constructor(client) {
      this.connected = client[kConnected];
      this.pending = client[kPending];
      this.running = client[kRunning];
      this.size = client[kSize];
    }
  }

  class PoolStats {
    constructor(pool) {
      this.connected = pool[kConnected];
      this.free = pool[kFree];
      this.pending = pool[kPending];
      this.queued = pool[kQueued];
      this.running = pool[kRunning];
      this.size = pool[kSize];
    }
  }
  module.exports = { ClientStats, PoolStats };
});

// node_modules/undici/lib/core/diagnostics.js
var require_diagnostics = __commonJS((exports, module) => {
  var diagnosticsChannel = __require("node:diagnostics_channel");
  var util = __require("node:util");
  var undiciDebugLog = util.debuglog("undici");
  var fetchDebuglog = util.debuglog("fetch");
  var websocketDebuglog = util.debuglog("websocket");
  var channels = {
    beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
    connected: diagnosticsChannel.channel("undici:client:connected"),
    connectError: diagnosticsChannel.channel("undici:client:connectError"),
    sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
    create: diagnosticsChannel.channel("undici:request:create"),
    bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
    bodyChunkSent: diagnosticsChannel.channel("undici:request:bodyChunkSent"),
    bodyChunkReceived: diagnosticsChannel.channel("undici:request:bodyChunkReceived"),
    headers: diagnosticsChannel.channel("undici:request:headers"),
    trailers: diagnosticsChannel.channel("undici:request:trailers"),
    error: diagnosticsChannel.channel("undici:request:error"),
    open: diagnosticsChannel.channel("undici:websocket:open"),
    close: diagnosticsChannel.channel("undici:websocket:close"),
    socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
    ping: diagnosticsChannel.channel("undici:websocket:ping"),
    pong: diagnosticsChannel.channel("undici:websocket:pong"),
    proxyConnected: diagnosticsChannel.channel("undici:proxy:connected")
  };
  var isTrackingClientEvents = false;
  function trackClientEvents(debugLog = undiciDebugLog) {
    if (isTrackingClientEvents) {
      return;
    }
    if (channels.beforeConnect.hasSubscribers || channels.connected.hasSubscribers || channels.connectError.hasSubscribers || channels.sendHeaders.hasSubscribers) {
      isTrackingClientEvents = true;
      return;
    }
    isTrackingClientEvents = true;
    diagnosticsChannel.subscribe("undici:client:beforeConnect", (evt) => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt;
      debugLog("connecting to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
    });
    diagnosticsChannel.subscribe("undici:client:connected", (evt) => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt;
      debugLog("connected to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
    });
    diagnosticsChannel.subscribe("undici:client:connectError", (evt) => {
      const {
        connectParams: { version, protocol, port, host },
        error: error2
      } = evt;
      debugLog("connection to %s%s using %s%s errored - %s", host, port ? `:${port}` : "", protocol, version, error2.message);
    });
    diagnosticsChannel.subscribe("undici:client:sendHeaders", (evt) => {
      const {
        request: { method, path, origin }
      } = evt;
      debugLog("sending request to %s %s%s", method, origin, path);
    });
  }
  var isTrackingRequestEvents = false;
  function trackRequestEvents(debugLog = undiciDebugLog) {
    if (isTrackingRequestEvents) {
      return;
    }
    if (channels.headers.hasSubscribers || channels.trailers.hasSubscribers || channels.error.hasSubscribers) {
      isTrackingRequestEvents = true;
      return;
    }
    isTrackingRequestEvents = true;
    diagnosticsChannel.subscribe("undici:request:headers", (evt) => {
      const {
        request: { method, path, origin },
        response: { statusCode }
      } = evt;
      debugLog("received response to %s %s%s - HTTP %d", method, origin, path, statusCode);
    });
    diagnosticsChannel.subscribe("undici:request:trailers", (evt) => {
      const {
        request: { method, path, origin }
      } = evt;
      debugLog("trailers received from %s %s%s", method, origin, path);
    });
    diagnosticsChannel.subscribe("undici:request:error", (evt) => {
      const {
        request: { method, path, origin },
        error: error2
      } = evt;
      debugLog("request to %s %s%s errored - %s", method, origin, path, error2.message);
    });
  }
  var isTrackingWebSocketEvents = false;
  function trackWebSocketEvents(debugLog = websocketDebuglog) {
    if (isTrackingWebSocketEvents) {
      return;
    }
    if (channels.open.hasSubscribers || channels.close.hasSubscribers || channels.socketError.hasSubscribers || channels.ping.hasSubscribers || channels.pong.hasSubscribers) {
      isTrackingWebSocketEvents = true;
      return;
    }
    isTrackingWebSocketEvents = true;
    diagnosticsChannel.subscribe("undici:websocket:open", (evt) => {
      const {
        address: { address, port }
      } = evt;
      debugLog("connection opened %s%s", address, port ? `:${port}` : "");
    });
    diagnosticsChannel.subscribe("undici:websocket:close", (evt) => {
      const { websocket, code, reason } = evt;
      debugLog("closed connection to %s - %s %s", websocket.url, code, reason);
    });
    diagnosticsChannel.subscribe("undici:websocket:socket_error", (err) => {
      debugLog("connection errored - %s", err.message);
    });
    diagnosticsChannel.subscribe("undici:websocket:ping", (evt) => {
      debugLog("ping received");
    });
    diagnosticsChannel.subscribe("undici:websocket:pong", (evt) => {
      debugLog("pong received");
    });
  }
  if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
    trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
    trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
  }
  if (websocketDebuglog.enabled) {
    trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog);
    trackWebSocketEvents(websocketDebuglog);
  }
  module.exports = {
    channels
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var assert = __require("node:assert");
  var {
    isValidHTTPToken,
    isValidHeaderValue,
    isStream,
    destroy,
    isBuffer,
    isFormDataLike,
    isIterable,
    isBlobLike,
    serializePathWithQuery,
    assertRequestHandler,
    getServerName,
    normalizedMethodRecords,
    getProtocolFromUrlString
  } = require_util();
  var { channels } = require_diagnostics();
  var { headerNameLowerCasedRecord } = require_constants();
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      expectContinue,
      servername,
      throwOnError,
      maxRedirections
    }, handler) {
      if (typeof path !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.test(path)) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      if (throwOnError != null) {
        throw new InvalidArgumentError("invalid throwOnError");
      }
      if (maxRedirections != null && maxRedirections !== 0) {
        throw new InvalidArgumentError("maxRedirections is not supported, use the redirect interceptor");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.method = method;
      this.abort = null;
      if (body == null) {
        this.body = null;
      } else if (isStream(body)) {
        this.body = body;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (isBuffer(body)) {
        this.body = body.byteLength ? body : null;
      } else if (ArrayBuffer.isView(body)) {
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      } else if (body instanceof ArrayBuffer) {
        this.body = body.byteLength ? Buffer.from(body) : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {
        this.body = body;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? serializePathWithQuery(path, query) : path;
      this.origin = origin;
      this.protocol = getProtocolFromUrlString(origin);
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking ?? this.method !== "HEAD";
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = [];
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(this, headers[i], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        if (headers[Symbol.iterator]) {
          for (const header of headers) {
            if (!Array.isArray(header) || header.length !== 2) {
              throw new InvalidArgumentError("headers must be in key-value pair format");
            }
            processHeader(this, header[0], header[1]);
          }
        } else {
          const keys = Object.keys(headers);
          for (let i = 0;i < keys.length; ++i) {
            processHeader(this, keys[i], headers[keys[i]]);
          }
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      assertRequestHandler(handler, method, upgrade);
      this.servername = servername || getServerName(this.host) || null;
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (channels.bodyChunkSent.hasSubscribers) {
        channels.bodyChunkSent.publish({ request: this, chunk });
      }
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onResponseStarted() {
      return this[kHandler].onResponseStarted?.();
    }
    onHeaders(statusCode, headers, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.bodyChunkReceived.hasSubscribers) {
        channels.bodyChunkReceived.publish({ request: this, chunk });
      }
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      assert(!this.completed);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error2) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error: error2 });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error2);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
  }
  function processHeader(request, key, val) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === undefined) {
      return;
    }
    let headerName = headerNameLowerCasedRecord[key];
    if (headerName === undefined) {
      headerName = key.toLowerCase();
      if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {
        throw new InvalidArgumentError("invalid header key");
      }
    }
    if (Array.isArray(val)) {
      const arr = [];
      for (let i = 0;i < val.length; i++) {
        if (typeof val[i] === "string") {
          if (!isValidHeaderValue(val[i])) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          }
          arr.push(val[i]);
        } else if (val[i] === null) {
          arr.push("");
        } else if (typeof val[i] === "object") {
          throw new InvalidArgumentError(`invalid ${key} header`);
        } else {
          arr.push(`${val[i]}`);
        }
      }
      val = arr;
    } else if (typeof val === "string") {
      if (!isValidHeaderValue(val)) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
    } else if (val === null) {
      val = "";
    } else {
      val = `${val}`;
    }
    if (request.host === null && headerName === "host") {
      if (typeof val !== "string") {
        throw new InvalidArgumentError("invalid host header");
      }
      request.host = val;
    } else if (request.contentLength === null && headerName === "content-length") {
      request.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request.contentType === null && headerName === "content-type") {
      request.contentType = val;
      request.headers.push(key, val);
    } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
      throw new InvalidArgumentError(`invalid ${headerName} header`);
    } else if (headerName === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      }
      if (value === "close") {
        request.reset = true;
      }
    } else if (headerName === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request.headers.push(key, val);
    }
  }
  module.exports = Request;
});

// node_modules/undici/lib/handler/wrap-handler.js
var require_wrap_handler = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors();
  module.exports = class WrapHandler {
    #handler;
    constructor(handler) {
      this.#handler = handler;
    }
    static wrap(handler) {
      return handler.onRequestStart ? handler : new WrapHandler(handler);
    }
    onConnect(abort, context) {
      return this.#handler.onConnect?.(abort, context);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      return this.#handler.onHeaders?.(statusCode, rawHeaders, resume, statusMessage);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
    }
    onData(data) {
      return this.#handler.onData?.(data);
    }
    onComplete(trailers) {
      return this.#handler.onComplete?.(trailers);
    }
    onError(err) {
      if (!this.#handler.onError) {
        throw err;
      }
      return this.#handler.onError?.(err);
    }
    onRequestStart(controller, context) {
      this.#handler.onConnect?.((reason) => controller.abort(reason), context);
    }
    onRequestUpgrade(controller, statusCode, headers, socket) {
      const rawHeaders = [];
      for (const [key, val] of Object.entries(headers)) {
        rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
      }
      this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      const rawHeaders = [];
      for (const [key, val] of Object.entries(headers)) {
        rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
      }
      if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {
        controller.pause();
      }
    }
    onResponseData(controller, data) {
      if (this.#handler.onData?.(data) === false) {
        controller.pause();
      }
    }
    onResponseEnd(controller, trailers) {
      const rawTrailers = [];
      for (const [key, val] of Object.entries(trailers)) {
        rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
      }
      this.#handler.onComplete?.(rawTrailers);
    }
    onResponseError(controller, err) {
      if (!this.#handler.onError) {
        throw new InvalidArgumentError("invalid onError method");
      }
      this.#handler.onError?.(err);
    }
  };
});

// node_modules/undici/lib/dispatcher/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var WrapHandler = require_wrap_handler();
  var wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler));

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...args) {
      const interceptors = Array.isArray(args[0]) ? args[0] : args;
      let dispatch = this.dispatch.bind(this);
      for (const interceptor of interceptors) {
        if (interceptor == null) {
          continue;
        }
        if (typeof interceptor !== "function") {
          throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
        }
        dispatch = interceptor(dispatch);
        dispatch = wrapInterceptor(dispatch);
        if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
          throw new TypeError("invalid interceptor");
        }
      }
      return new Proxy(this, {
        get: (target, key) => key === "dispatch" ? dispatch : target[key]
      });
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/handler/unwrap-handler.js
var require_unwrap_handler = __commonJS((exports, module) => {
  var { parseHeaders } = require_util();
  var { InvalidArgumentError } = require_errors();
  var kResume = Symbol("resume");

  class UnwrapController {
    #paused = false;
    #reason = null;
    #aborted = false;
    #abort;
    [kResume] = null;
    constructor(abort) {
      this.#abort = abort;
    }
    pause() {
      this.#paused = true;
    }
    resume() {
      if (this.#paused) {
        this.#paused = false;
        this[kResume]?.();
      }
    }
    abort(reason) {
      if (!this.#aborted) {
        this.#aborted = true;
        this.#reason = reason;
        this.#abort(reason);
      }
    }
    get aborted() {
      return this.#aborted;
    }
    get reason() {
      return this.#reason;
    }
    get paused() {
      return this.#paused;
    }
  }
  module.exports = class UnwrapHandler {
    #handler;
    #controller;
    constructor(handler) {
      this.#handler = handler;
    }
    static unwrap(handler) {
      return !handler.onRequestStart ? handler : new UnwrapHandler(handler);
    }
    onConnect(abort, context) {
      this.#controller = new UnwrapController(abort);
      this.#handler.onRequestStart?.(this.#controller, context);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders(rawHeaders), socket);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      this.#controller[kResume] = resume;
      this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders(rawHeaders), statusMessage);
      return !this.#controller.paused;
    }
    onData(data) {
      this.#handler.onResponseData?.(this.#controller, data);
      return !this.#controller.paused;
    }
    onComplete(rawTrailers) {
      this.#handler.onResponseEnd?.(this.#controller, parseHeaders(rawTrailers));
    }
    onError(err) {
      if (!this.#handler.onResponseError) {
        throw new InvalidArgumentError("invalid onError method");
      }
      this.#handler.onResponseError?.(this.#controller, err);
    }
  };
});

// node_modules/undici/lib/dispatcher/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var UnwrapHandler = require_unwrap_handler();
  var {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors();
  var { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = require_symbols();
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");

  class DispatcherBase extends Dispatcher {
    [kDestroyed] = false;
    [kOnDestroyed] = null;
    [kClosed] = false;
    [kOnClosed] = null;
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    close(callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        const err = new ClientDestroyedError;
        queueMicrotask(() => callback(err, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed] ??= [];
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => queueMicrotask(onClosed));
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError;
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] ??= [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => queueMicrotask(onDestroyed));
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      handler = UnwrapHandler.unwrap(handler);
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError;
        }
        if (this[kClosed]) {
          throw new ClientClosedError;
        }
        return this[kDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw err;
        }
        handler.onError(err);
        return false;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  var net = __require("node:net");
  var assert = __require("node:assert");
  var util = require_util();
  var { InvalidArgumentError } = require_errors();
  var tls;
  var SessionCache = class WeakSessionCache {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions;
      this._sessionCache = new Map;
      this._sessionRegistry = new FinalizationRegistry((key) => {
        if (this._sessionCache.size < this._maxCachedSessions) {
          return;
        }
        const ref = this._sessionCache.get(key);
        if (ref !== undefined && ref.deref() === undefined) {
          this._sessionCache.delete(key);
        }
      });
    }
    get(sessionKey) {
      const ref = this._sessionCache.get(sessionKey);
      return ref ? ref.deref() : null;
    }
    set(sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return;
      }
      this._sessionCache.set(sessionKey, new WeakRef(session));
      this._sessionRegistry.register(session, sessionKey);
    }
  };
  function buildConnector({ allowH2, useH2c, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = __require("node:tls");
        }
        servername = servername || options.servername || util.getServerName(host) || null;
        const sessionKey = servername || hostname;
        assert(sessionKey);
        const session = customSession || sessionCache.get(sessionKey) || null;
        port = port || 443;
        socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        port = port || 80;
        socket = net.connect({
          highWaterMark: 64 * 1024,
          ...options,
          localAddress,
          port,
          host: hostname
        });
        if (useH2c === true) {
          socket.alpnProtocol = "h2";
        }
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const clearConnectTimeout = util.setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enumToMap = enumToMap;
  function enumToMap(obj, filter = [], exceptions = []) {
    const emptyFilter = (filter?.length ?? 0) === 0;
    const emptyExceptions = (exceptions?.length ?? 0) === 0;
    return Object.fromEntries(Object.entries(obj).filter(([, value]) => {
      return typeof value === "number" && (emptyFilter || filter.includes(value)) && (emptyExceptions || !exceptions.includes(value));
    }));
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.MINOR = exports.MAJOR = exports.HTAB_SP_VCHAR_OBS_TEXT = exports.QUOTED_STRING = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.HEX = exports.URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.STATUSES_HTTP = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.HEADER_STATE = exports.FINISH = exports.STATUSES = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
  var utils_1 = require_utils2();
  exports.ERROR = {
    OK: 0,
    INTERNAL: 1,
    STRICT: 2,
    CR_EXPECTED: 25,
    LF_EXPECTED: 3,
    UNEXPECTED_CONTENT_LENGTH: 4,
    UNEXPECTED_SPACE: 30,
    CLOSED_CONNECTION: 5,
    INVALID_METHOD: 6,
    INVALID_URL: 7,
    INVALID_CONSTANT: 8,
    INVALID_VERSION: 9,
    INVALID_HEADER_TOKEN: 10,
    INVALID_CONTENT_LENGTH: 11,
    INVALID_CHUNK_SIZE: 12,
    INVALID_STATUS: 13,
    INVALID_EOF_STATE: 14,
    INVALID_TRANSFER_ENCODING: 15,
    CB_MESSAGE_BEGIN: 16,
    CB_HEADERS_COMPLETE: 17,
    CB_MESSAGE_COMPLETE: 18,
    CB_CHUNK_HEADER: 19,
    CB_CHUNK_COMPLETE: 20,
    PAUSED: 21,
    PAUSED_UPGRADE: 22,
    PAUSED_H2_UPGRADE: 23,
    USER: 24,
    CB_URL_COMPLETE: 26,
    CB_STATUS_COMPLETE: 27,
    CB_METHOD_COMPLETE: 32,
    CB_VERSION_COMPLETE: 33,
    CB_HEADER_FIELD_COMPLETE: 28,
    CB_HEADER_VALUE_COMPLETE: 29,
    CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,
    CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,
    CB_RESET: 31,
    CB_PROTOCOL_COMPLETE: 38
  };
  exports.TYPE = {
    BOTH: 0,
    REQUEST: 1,
    RESPONSE: 2
  };
  exports.FLAGS = {
    CONNECTION_KEEP_ALIVE: 1 << 0,
    CONNECTION_CLOSE: 1 << 1,
    CONNECTION_UPGRADE: 1 << 2,
    CHUNKED: 1 << 3,
    UPGRADE: 1 << 4,
    CONTENT_LENGTH: 1 << 5,
    SKIPBODY: 1 << 6,
    TRAILING: 1 << 7,
    TRANSFER_ENCODING: 1 << 9
  };
  exports.LENIENT_FLAGS = {
    HEADERS: 1 << 0,
    CHUNKED_LENGTH: 1 << 1,
    KEEP_ALIVE: 1 << 2,
    TRANSFER_ENCODING: 1 << 3,
    VERSION: 1 << 4,
    DATA_AFTER_CLOSE: 1 << 5,
    OPTIONAL_LF_AFTER_CR: 1 << 6,
    OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,
    OPTIONAL_CR_BEFORE_LF: 1 << 8,
    SPACES_AFTER_CHUNK_SIZE: 1 << 9
  };
  exports.METHODS = {
    DELETE: 0,
    GET: 1,
    HEAD: 2,
    POST: 3,
    PUT: 4,
    CONNECT: 5,
    OPTIONS: 6,
    TRACE: 7,
    COPY: 8,
    LOCK: 9,
    MKCOL: 10,
    MOVE: 11,
    PROPFIND: 12,
    PROPPATCH: 13,
    SEARCH: 14,
    UNLOCK: 15,
    BIND: 16,
    REBIND: 17,
    UNBIND: 18,
    ACL: 19,
    REPORT: 20,
    MKACTIVITY: 21,
    CHECKOUT: 22,
    MERGE: 23,
    "M-SEARCH": 24,
    NOTIFY: 25,
    SUBSCRIBE: 26,
    UNSUBSCRIBE: 27,
    PATCH: 28,
    PURGE: 29,
    MKCALENDAR: 30,
    LINK: 31,
    UNLINK: 32,
    SOURCE: 33,
    PRI: 34,
    DESCRIBE: 35,
    ANNOUNCE: 36,
    SETUP: 37,
    PLAY: 38,
    PAUSE: 39,
    TEARDOWN: 40,
    GET_PARAMETER: 41,
    SET_PARAMETER: 42,
    REDIRECT: 43,
    RECORD: 44,
    FLUSH: 45,
    QUERY: 46
  };
  exports.STATUSES = {
    CONTINUE: 100,
    SWITCHING_PROTOCOLS: 101,
    PROCESSING: 102,
    EARLY_HINTS: 103,
    RESPONSE_IS_STALE: 110,
    REVALIDATION_FAILED: 111,
    DISCONNECTED_OPERATION: 112,
    HEURISTIC_EXPIRATION: 113,
    MISCELLANEOUS_WARNING: 199,
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    NON_AUTHORITATIVE_INFORMATION: 203,
    NO_CONTENT: 204,
    RESET_CONTENT: 205,
    PARTIAL_CONTENT: 206,
    MULTI_STATUS: 207,
    ALREADY_REPORTED: 208,
    TRANSFORMATION_APPLIED: 214,
    IM_USED: 226,
    MISCELLANEOUS_PERSISTENT_WARNING: 299,
    MULTIPLE_CHOICES: 300,
    MOVED_PERMANENTLY: 301,
    FOUND: 302,
    SEE_OTHER: 303,
    NOT_MODIFIED: 304,
    USE_PROXY: 305,
    SWITCH_PROXY: 306,
    TEMPORARY_REDIRECT: 307,
    PERMANENT_REDIRECT: 308,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    PAYMENT_REQUIRED: 402,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    METHOD_NOT_ALLOWED: 405,
    NOT_ACCEPTABLE: 406,
    PROXY_AUTHENTICATION_REQUIRED: 407,
    REQUEST_TIMEOUT: 408,
    CONFLICT: 409,
    GONE: 410,
    LENGTH_REQUIRED: 411,
    PRECONDITION_FAILED: 412,
    PAYLOAD_TOO_LARGE: 413,
    URI_TOO_LONG: 414,
    UNSUPPORTED_MEDIA_TYPE: 415,
    RANGE_NOT_SATISFIABLE: 416,
    EXPECTATION_FAILED: 417,
    IM_A_TEAPOT: 418,
    PAGE_EXPIRED: 419,
    ENHANCE_YOUR_CALM: 420,
    MISDIRECTED_REQUEST: 421,
    UNPROCESSABLE_ENTITY: 422,
    LOCKED: 423,
    FAILED_DEPENDENCY: 424,
    TOO_EARLY: 425,
    UPGRADE_REQUIRED: 426,
    PRECONDITION_REQUIRED: 428,
    TOO_MANY_REQUESTS: 429,
    REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430,
    REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
    LOGIN_TIMEOUT: 440,
    NO_RESPONSE: 444,
    RETRY_WITH: 449,
    BLOCKED_BY_PARENTAL_CONTROL: 450,
    UNAVAILABLE_FOR_LEGAL_REASONS: 451,
    CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460,
    INVALID_X_FORWARDED_FOR: 463,
    REQUEST_HEADER_TOO_LARGE: 494,
    SSL_CERTIFICATE_ERROR: 495,
    SSL_CERTIFICATE_REQUIRED: 496,
    HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497,
    INVALID_TOKEN: 498,
    CLIENT_CLOSED_REQUEST: 499,
    INTERNAL_SERVER_ERROR: 500,
    NOT_IMPLEMENTED: 501,
    BAD_GATEWAY: 502,
    SERVICE_UNAVAILABLE: 503,
    GATEWAY_TIMEOUT: 504,
    HTTP_VERSION_NOT_SUPPORTED: 505,
    VARIANT_ALSO_NEGOTIATES: 506,
    INSUFFICIENT_STORAGE: 507,
    LOOP_DETECTED: 508,
    BANDWIDTH_LIMIT_EXCEEDED: 509,
    NOT_EXTENDED: 510,
    NETWORK_AUTHENTICATION_REQUIRED: 511,
    WEB_SERVER_UNKNOWN_ERROR: 520,
    WEB_SERVER_IS_DOWN: 521,
    CONNECTION_TIMEOUT: 522,
    ORIGIN_IS_UNREACHABLE: 523,
    TIMEOUT_OCCURED: 524,
    SSL_HANDSHAKE_FAILED: 525,
    INVALID_SSL_CERTIFICATE: 526,
    RAILGUN_ERROR: 527,
    SITE_IS_OVERLOADED: 529,
    SITE_IS_FROZEN: 530,
    IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561,
    NETWORK_READ_TIMEOUT: 598,
    NETWORK_CONNECT_TIMEOUT: 599
  };
  exports.FINISH = {
    SAFE: 0,
    SAFE_WITH_CB: 1,
    UNSAFE: 2
  };
  exports.HEADER_STATE = {
    GENERAL: 0,
    CONNECTION: 1,
    CONTENT_LENGTH: 2,
    TRANSFER_ENCODING: 3,
    UPGRADE: 4,
    CONNECTION_KEEP_ALIVE: 5,
    CONNECTION_CLOSE: 6,
    CONNECTION_UPGRADE: 7,
    TRANSFER_ENCODING_CHUNKED: 8
  };
  exports.METHODS_HTTP = [
    exports.METHODS.DELETE,
    exports.METHODS.GET,
    exports.METHODS.HEAD,
    exports.METHODS.POST,
    exports.METHODS.PUT,
    exports.METHODS.CONNECT,
    exports.METHODS.OPTIONS,
    exports.METHODS.TRACE,
    exports.METHODS.COPY,
    exports.METHODS.LOCK,
    exports.METHODS.MKCOL,
    exports.METHODS.MOVE,
    exports.METHODS.PROPFIND,
    exports.METHODS.PROPPATCH,
    exports.METHODS.SEARCH,
    exports.METHODS.UNLOCK,
    exports.METHODS.BIND,
    exports.METHODS.REBIND,
    exports.METHODS.UNBIND,
    exports.METHODS.ACL,
    exports.METHODS.REPORT,
    exports.METHODS.MKACTIVITY,
    exports.METHODS.CHECKOUT,
    exports.METHODS.MERGE,
    exports.METHODS["M-SEARCH"],
    exports.METHODS.NOTIFY,
    exports.METHODS.SUBSCRIBE,
    exports.METHODS.UNSUBSCRIBE,
    exports.METHODS.PATCH,
    exports.METHODS.PURGE,
    exports.METHODS.MKCALENDAR,
    exports.METHODS.LINK,
    exports.METHODS.UNLINK,
    exports.METHODS.PRI,
    exports.METHODS.SOURCE,
    exports.METHODS.QUERY
  ];
  exports.METHODS_ICE = [
    exports.METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    exports.METHODS.OPTIONS,
    exports.METHODS.DESCRIBE,
    exports.METHODS.ANNOUNCE,
    exports.METHODS.SETUP,
    exports.METHODS.PLAY,
    exports.METHODS.PAUSE,
    exports.METHODS.TEARDOWN,
    exports.METHODS.GET_PARAMETER,
    exports.METHODS.SET_PARAMETER,
    exports.METHODS.REDIRECT,
    exports.METHODS.RECORD,
    exports.METHODS.FLUSH,
    exports.METHODS.GET,
    exports.METHODS.POST
  ];
  exports.METHOD_MAP = (0, utils_1.enumToMap)(exports.METHODS);
  exports.H_METHOD_MAP = Object.fromEntries(Object.entries(exports.METHODS).filter(([k]) => k.startsWith("H")));
  exports.STATUSES_HTTP = [
    exports.STATUSES.CONTINUE,
    exports.STATUSES.SWITCHING_PROTOCOLS,
    exports.STATUSES.PROCESSING,
    exports.STATUSES.EARLY_HINTS,
    exports.STATUSES.RESPONSE_IS_STALE,
    exports.STATUSES.REVALIDATION_FAILED,
    exports.STATUSES.DISCONNECTED_OPERATION,
    exports.STATUSES.HEURISTIC_EXPIRATION,
    exports.STATUSES.MISCELLANEOUS_WARNING,
    exports.STATUSES.OK,
    exports.STATUSES.CREATED,
    exports.STATUSES.ACCEPTED,
    exports.STATUSES.NON_AUTHORITATIVE_INFORMATION,
    exports.STATUSES.NO_CONTENT,
    exports.STATUSES.RESET_CONTENT,
    exports.STATUSES.PARTIAL_CONTENT,
    exports.STATUSES.MULTI_STATUS,
    exports.STATUSES.ALREADY_REPORTED,
    exports.STATUSES.TRANSFORMATION_APPLIED,
    exports.STATUSES.IM_USED,
    exports.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,
    exports.STATUSES.MULTIPLE_CHOICES,
    exports.STATUSES.MOVED_PERMANENTLY,
    exports.STATUSES.FOUND,
    exports.STATUSES.SEE_OTHER,
    exports.STATUSES.NOT_MODIFIED,
    exports.STATUSES.USE_PROXY,
    exports.STATUSES.SWITCH_PROXY,
    exports.STATUSES.TEMPORARY_REDIRECT,
    exports.STATUSES.PERMANENT_REDIRECT,
    exports.STATUSES.BAD_REQUEST,
    exports.STATUSES.UNAUTHORIZED,
    exports.STATUSES.PAYMENT_REQUIRED,
    exports.STATUSES.FORBIDDEN,
    exports.STATUSES.NOT_FOUND,
    exports.STATUSES.METHOD_NOT_ALLOWED,
    exports.STATUSES.NOT_ACCEPTABLE,
    exports.STATUSES.PROXY_AUTHENTICATION_REQUIRED,
    exports.STATUSES.REQUEST_TIMEOUT,
    exports.STATUSES.CONFLICT,
    exports.STATUSES.GONE,
    exports.STATUSES.LENGTH_REQUIRED,
    exports.STATUSES.PRECONDITION_FAILED,
    exports.STATUSES.PAYLOAD_TOO_LARGE,
    exports.STATUSES.URI_TOO_LONG,
    exports.STATUSES.UNSUPPORTED_MEDIA_TYPE,
    exports.STATUSES.RANGE_NOT_SATISFIABLE,
    exports.STATUSES.EXPECTATION_FAILED,
    exports.STATUSES.IM_A_TEAPOT,
    exports.STATUSES.PAGE_EXPIRED,
    exports.STATUSES.ENHANCE_YOUR_CALM,
    exports.STATUSES.MISDIRECTED_REQUEST,
    exports.STATUSES.UNPROCESSABLE_ENTITY,
    exports.STATUSES.LOCKED,
    exports.STATUSES.FAILED_DEPENDENCY,
    exports.STATUSES.TOO_EARLY,
    exports.STATUSES.UPGRADE_REQUIRED,
    exports.STATUSES.PRECONDITION_REQUIRED,
    exports.STATUSES.TOO_MANY_REQUESTS,
    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,
    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,
    exports.STATUSES.LOGIN_TIMEOUT,
    exports.STATUSES.NO_RESPONSE,
    exports.STATUSES.RETRY_WITH,
    exports.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,
    exports.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,
    exports.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,
    exports.STATUSES.INVALID_X_FORWARDED_FOR,
    exports.STATUSES.REQUEST_HEADER_TOO_LARGE,
    exports.STATUSES.SSL_CERTIFICATE_ERROR,
    exports.STATUSES.SSL_CERTIFICATE_REQUIRED,
    exports.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,
    exports.STATUSES.INVALID_TOKEN,
    exports.STATUSES.CLIENT_CLOSED_REQUEST,
    exports.STATUSES.INTERNAL_SERVER_ERROR,
    exports.STATUSES.NOT_IMPLEMENTED,
    exports.STATUSES.BAD_GATEWAY,
    exports.STATUSES.SERVICE_UNAVAILABLE,
    exports.STATUSES.GATEWAY_TIMEOUT,
    exports.STATUSES.HTTP_VERSION_NOT_SUPPORTED,
    exports.STATUSES.VARIANT_ALSO_NEGOTIATES,
    exports.STATUSES.INSUFFICIENT_STORAGE,
    exports.STATUSES.LOOP_DETECTED,
    exports.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,
    exports.STATUSES.NOT_EXTENDED,
    exports.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,
    exports.STATUSES.WEB_SERVER_UNKNOWN_ERROR,
    exports.STATUSES.WEB_SERVER_IS_DOWN,
    exports.STATUSES.CONNECTION_TIMEOUT,
    exports.STATUSES.ORIGIN_IS_UNREACHABLE,
    exports.STATUSES.TIMEOUT_OCCURED,
    exports.STATUSES.SSL_HANDSHAKE_FAILED,
    exports.STATUSES.INVALID_SSL_CERTIFICATE,
    exports.STATUSES.RAILGUN_ERROR,
    exports.STATUSES.SITE_IS_OVERLOADED,
    exports.STATUSES.SITE_IS_FROZEN,
    exports.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,
    exports.STATUSES.NETWORK_READ_TIMEOUT,
    exports.STATUSES.NETWORK_CONNECT_TIMEOUT
  ];
  exports.ALPHA = [];
  for (let i = 65;i <= 90; i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.QUOTED_STRING = ["\t", " "];
  for (let i = 33;i <= 255; i++) {
    if (i !== 34 && i !== 92) {
      exports.QUOTED_STRING.push(i);
    }
  }
  exports.HTAB_SP_VCHAR_OBS_TEXT = ["\t", " "];
  for (let i = 33;i <= 126; i++) {
    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);
  }
  for (let i = 128;i <= 255; i++) {
    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);
  }
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  exports.SPECIAL_HEADERS = {
    connection: exports.HEADER_STATE.CONNECTION,
    "content-length": exports.HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": exports.HEADER_STATE.CONNECTION,
    "transfer-encoding": exports.HEADER_STATE.TRANSFER_ENCODING,
    upgrade: exports.HEADER_STATE.UPGRADE
  };
  exports.default = {
    ERROR: exports.ERROR,
    TYPE: exports.TYPE,
    FLAGS: exports.FLAGS,
    LENIENT_FLAGS: exports.LENIENT_FLAGS,
    METHODS: exports.METHODS,
    STATUSES: exports.STATUSES,
    FINISH: exports.FINISH,
    HEADER_STATE: exports.HEADER_STATE,
    ALPHA: exports.ALPHA,
    NUM_MAP: exports.NUM_MAP,
    HEX_MAP: exports.HEX_MAP,
    NUM: exports.NUM,
    ALPHANUM: exports.ALPHANUM,
    MARK: exports.MARK,
    USERINFO_CHARS: exports.USERINFO_CHARS,
    URL_CHAR: exports.URL_CHAR,
    HEX: exports.HEX,
    TOKEN: exports.TOKEN,
    HEADER_CHARS: exports.HEADER_CHARS,
    CONNECTION_TOKEN_CHARS: exports.CONNECTION_TOKEN_CHARS,
    QUOTED_STRING: exports.QUOTED_STRING,
    HTAB_SP_VCHAR_OBS_TEXT: exports.HTAB_SP_VCHAR_OBS_TEXT,
    MAJOR: exports.MAJOR,
    MINOR: exports.MINOR,
    SPECIAL_HEADERS: exports.SPECIAL_HEADERS,
    METHODS_HTTP: exports.METHODS_HTTP,
    METHODS_ICE: exports.METHODS_ICE,
    METHODS_RTSP: exports.METHODS_RTSP,
    METHOD_MAP: exports.METHOD_MAP,
    H_METHOD_MAP: exports.H_METHOD_MAP,
    STATUSES_HTTP: exports.STATUSES_HTTP
  };
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzU0BQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEBAwAAAwAAAAQFAXABExMFAwEAAgYIAX8BQcDZBAsHxQcoBm1lbW9yeQIAC19pbml0aWFsaXplAAgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC2xsaHR0cF9pbml0AAkYbGxodHRwX3Nob3VsZF9rZWVwX2FsaXZlADcMbGxodHRwX2FsbG9jAAsGbWFsbG9jADkLbGxodHRwX2ZyZWUADARmcmVlAAwPbGxodHRwX2dldF90eXBlAA0VbGxodHRwX2dldF9odHRwX21ham9yAA4VbGxodHRwX2dldF9odHRwX21pbm9yAA8RbGxodHRwX2dldF9tZXRob2QAEBZsbGh0dHBfZ2V0X3N0YXR1c19jb2RlABESbGxodHRwX2dldF91cGdyYWRlABIMbGxodHRwX3Jlc2V0ABMObGxodHRwX2V4ZWN1dGUAFBRsbGh0dHBfc2V0dGluZ3NfaW5pdAAVDWxsaHR0cF9maW5pc2gAFgxsbGh0dHBfcGF1c2UAFw1sbGh0dHBfcmVzdW1lABgbbGxodHRwX3Jlc3VtZV9hZnRlcl91cGdyYWRlABkQbGxodHRwX2dldF9lcnJubwAaF2xsaHR0cF9nZXRfZXJyb3JfcmVhc29uABsXbGxodHRwX3NldF9lcnJvcl9yZWFzb24AHBRsbGh0dHBfZ2V0X2Vycm9yX3BvcwAdEWxsaHR0cF9lcnJub19uYW1lAB4SbGxodHRwX21ldGhvZF9uYW1lAB8SbGxodHRwX3N0YXR1c19uYW1lACAabGxodHRw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AXRrQT5qIQILIAEgAjYCHCABQgA3AhAgAkECdEH01wBqIQACQEHI1QAoAgAiA0EBIAJ0IgdxRQRAIAAgATYCAEHI1QAgAyAHcjYCACABIAA2AhggASABNgIIIAEgATYCDAwBCyAEQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQACQANAIAAiAygCBEF4cSAERg0BIAJBHXYhACACQQF0IQIgAyAAQQRxakEQaiIHKAIAIgANAAsgByABNgIAIAEgAzYCGCABIAE2AgwgASABNgIIDAELIAMoAggiACABNgIMIAMgATYCCCABQQA2AhggASADNgIMIAEgADYCCAtB5NUAQeTVACgCAEEBayIAQX8gABs2AgALCwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BNAsHACAALQAwC0ABBH8gACgCGCEBIAAvAS4hAiAALQAoIQMgACgCOCEEIAAQOCAAIAQ2AjggACADOgAoIAAgAjsBLiAAIAE2AhgL5YUCAgd/A34gASACaiEEAkAgACIDKAIMIgANACADKAIEBEAgAyABNgIECyMAQRBrIgkkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQJrDvwBAfkBAgMEBQYHCAkKCwwNDg8QERL4ARP3ARQV9gEWF/UBGBkaGxwdHh8g/QH7ASH0ASIjJCUmJygpKivzASwtLi8wMTLyAfEBMzTwAe8BNTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5P+gFQUVJT7gHtAVTsAVXrAVZXWFla6gFbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHpAegBzwHnAdAB5gHRAdIB0wHUAeUB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMBAPwBC0EADOMBC0EODOIBC0ENDOEBC0EPDOABC0EQDN8BC0ETDN4BC0EUDN0BC0EVDNwBC0EWDNsBC0EXDNoBC0EYDNkBC0EZDNgBC0EaDNcBC0EbDNYBC0EcDNUBC0EdDNQBC0EeDNMBC0EfDNIBC0EgDNEBC0EhDNABC0EIDM8BC0EiDM4BC0EkDM0BC0EjDMwBC0EHDMsBC0ElDMoBC0EmDMkBC0EnDMgBC0EoDMcBC0ESDMYBC0ERDMUBC0EpDMQBC0EqDMMBC0ErDMIBC0EsDMEBC0HeAQzAAQtBLgy/AQtBLwy+AQtBMAy9AQtBMQy8AQtBMgy7AQtBMwy6AQtBNAy5AQtB3wEMuAELQTUMtwELQTkMtgELQQwMtQELQTYMtAELQTcMswELQTgMsgELQT4MsQELQToMsAELQeABDK8BC0ELDK4BC0E/DK0BC0E7DKwBC0EKDKsBC0E8DKoBC0E9DKkBC0HhAQyoAQtBwQAMpwELQcAADKYBC0HCAAylAQtBCQykAQtBLQyjAQtBwwAMogELQcQADKEBC0HFAAygAQtBxgAMnwELQccADJ4BC0HIAAydAQtByQAMnAELQcoADJsBC0HLAAyaAQtBzAAMmQELQc0ADJgBC0HOAAyXAQtBzwAMlgELQdAADJUBC0HRAAyUAQtB0gAMkwELQdMADJIBC0HVAAyRAQtB1AAMkAELQdYADI8BC0HXAAyOAQtB2AAMjQELQdkADIwBC0HaAAyLAQtB2wAMigELQdwADIkBC0HdAAyIAQtB3gAMhwELQd8ADIYBC0HgAAyFAQtB4QAMhAELQeIADIMBC0HjAAyCAQtB5AAMgQELQeUADIABC0HiAQx/C0HmAAx+C0HnAAx9C0EGDHwLQegADHsLQQUMegtB6QAMeQtBBAx4C0HqAAx3C0HrAAx2C0HsAAx1C0HtAAx0C0EDDHMLQe4ADHILQe8ADHELQfAADHALQfIADG8LQfEADG4LQfMADG0LQfQADGwLQfUADGsLQfYADGoLQQIMaQtB9wAMaAtB+AAMZwtB+QAMZgtB+gAMZQtB+wAMZAtB/AAMYwtB/QAMYgtB/gAMYQtB/wAMYAtBgAEMXwtBgQEMXgtBggEMXQtBgwEMXAtBhAEMWwtBhQEMWgtBhgEMWQtBhwEMWAtBiAEMVwtBiQEMVgtBigEMVQtBiwEMVAtBjAEMUwtBjQEMUgtBjgEMUQtBjwEMUAtBkAEMTwtBkQEMTgtBkgEMTQtBkwEMTAtBlAEMSwtBlQEMSgtBlgEMSQtBlwEMSAtBmAEMRwtBmQEMRgtBmgEMRQtBmwEMRAtBnAEMQwtBnQEMQgtBngEMQQtBnwEMQAtBoAEMPwtBoQEMPgtBogEMPQtBowEMPAtBpAEMOwtBpQEMOgtBpgEMOQtBpwEMOAtBqAEMNwtBqQEMNgtBqgEMNQtBqwEMNAtBrAEMMwtBrQEMMgtBrgEMMQtBrwEMMAtBsAEMLwtBsQEMLgtBsgEMLQtBswEMLAtBtAEMKwtBtQEMKgtBtgEMKQtBtwEMKAtBuAEMJwtBuQEMJgtBugEMJQtBuwEMJAtBvAEMIwtBvQEMIgtBvgEMIQtBvwEMIAtBwAEMHwtBwQEMHgtBwgEMHQtBAQwcC0HDAQwbC0HEAQwaC0HFAQwZC0HGAQwYC0HHAQwXC0HIAQwWC0HJAQwVC0HKAQwUC0HLAQwTC0HMAQwSC0HNAQwRC0HOAQwQC0HPAQwPC0HQAQwOC0HRAQwNC0HSAQwMC0HTAQwLC0HUAQwKC0HVAQwJC0HWAQwIC0HjAQwHC0HXAQwGC0HYAQwFC0HZAQwEC0HaAQwDC0HbAQwCC0HdAQwBC0HcAQshAgNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAg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ogKiAqICogKiAqICogKiAqICogKiAqICogIAogILIAQgAUEBaiIBRw0AC0HJACECDOwCCyABQQFqIQEgA0Evai0AAEEBcQ2lAiADQQA2AhwgAyABNgIUIANBlxA2AhAgA0EKNgIMQQAhAgzrAgsgASAERwRAA0AgAS0AAEEgRw0VIAQgAUEBaiIBRw0AC0H4ACECDOsCC0H4ACECDOoCCyADQQI6ACgMOAtBACECIANBADYCHCADQb8LNgIQIANBAjYCDCADIAFBAWo2AhQM6AILQQAhAgzOAgtBDSECDM0CC0ETIQIMzAILQRUhAgzLAgtBFiECDMoCC0EYIQIMyQILQRkhAgzIAgtBGiECDMcCC0EbIQIMxgILQRwhAgzFAgtBHSECDMQCC0EeIQIMwwILQR8hAgzCAgtBICECDMECC0EiIQIMwAILQSMhAgy/AgtBJSECDL4CC0HlACECDL0CCyADQT02AhwgAyABNgIUIAMgADYCDEEAIQIM1QILIANBGzYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDNQCCyADQSA2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzTAgsgA0ETNgIcIAMgATYCFCADQZgaNgIQIANBFTYCDEEAIQIM0gILIANBCzYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNECCyADQRA2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzQAgsgA0EgNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIMzwILIANBCzYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDM4CCyADQQw2AhwgAyABNgIUIANBpBw2AhAgA0EVNgIMQQAhAgzNAgtBACECIANBADYCHCADIAE2AhQgA0HdDjYCECADQRI2AgwMzAILAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB/QEhAgzMAgsCQAJAIAMtADZBAUcNAEEAIQACQCADKAI4IgJFDQAgAigCYCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUcNASADQfwBNgIcIAMgATYCFCADQdwZNgIQIANBFTYCDEEAIQIMzQILQdwBIQIMswILIANBADYCHCADIAE2AhQgA0H5CzYCECADQR82AgxBACECDMsCCwJAAkAgAy0AKEEBaw4CBAEAC0HbASECDLICC0HUASECDLECCyADQQI6ADFBACEAAkAgAygCOCICRQ0AIAIoAgAiAkUNACADIAIRAAAhAAsgAEUEQEHdASECDLECCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQbQMNgIQIANBEDYCDEEAIQIMygILIANB+wE2AhwgAyABNgIUIANBgRo2AhAgA0EVNgIMQQAhAgzJAgsgASAERgRAQfoBIQIMyQILIAEtAABByABGDQEgA0EBOgAoC0HAASECDK4CC0HaASECDK0CCyABIARHBEAgA0EMNgIIIAMgATYCBEHZASECDK0CC0H5ASECDMUCCyABIARGBEBB+AEhAgzFAgsgAS0AAEHIAEcNBCABQQFqIQFB2AEhAgyrAgsgASAERgRAQfcBIQIMxAILAkACQCABLQAAQcUAaw4QAAUFBQUFBQUFBQUFBQUFAQULIAFBAWohAUHWASECDKsCCyABQQFqIQFB1wEhAgyqAgtB9gEhAiABIARGDcICIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbrVAGotAABHDQMgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMMCCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQLiIARQRAQeMBIQIMqgILIANB9QE2AhwgAyABNgIUIAMgADYCDEEAIQIMwgILQfQBIQIgASAERg3BAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEG41QBqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzCAgsgA0GBBDsBKCADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQLiIADQMMAgsgA0EANgIAC0EAIQIgA0EANgIcIAMgATYCFCADQeUfNgIQIANBCDYCDAy/AgtB1QEhAgylAgsgA0HzATYCHCADIAE2AhQgAyAANgIMQQAhAgy9AgtBACEAAkAgAygCOCICRQ0AIAIoAkAiAkUNACADIAIRAAAhAAsgAEUNbiAAQRVHBEAgA0EANgIcIAMgATYCFCADQYIPNgIQIANBIDYCDEEAIQIMvQILIANBjwE2AhwgAyABNgIUIANB7Bs2AhAgA0EVNgIMQQAhAgy8AgsgASAERwRAIANBDTYCCCADIAE2AgRB0wEhAgyjAgtB8gEhAgy7AgsgASAERgRAQfEBIQIMuwILAkACQAJAIAEtAABByABrDgsAAQgICAgICAgIAggLIAFBAWohAUHQASECDKMCCyABQQFqIQFB0QEhAgyiAgsgAUEBaiEBQdIBIQIMoQILQfABIQIgASAERg25AiADKAIAIgAgBCABa2ohBiABIABrQQJqIQUDQCABLQAAIABBtdUAai0AAEcNBCAAQQJGDQMgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMuQILQe8BIQIgASAERg24AiADKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABBs9UAai0AAEcNAyAAQQFGDQIgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMuAILQe4BIQIgASAERg23AiADKAIAIgAgBCABa2ohBiABIABrQQJqIQUDQCABLQAAIABBsNUAai0AAEcNAiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMtwILIAMoAgQhACADQgA3AwAgAyAAIAVBAWoiARArIgBFDQIgA0HsATYCHCADIAE2AhQgAyAANgIMQQAhAgy2AgsgA0EANgIACyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNnAIgA0HtATYCHCADIAE2AhQgAyAANgIMQQAhAgy0AgtBzwEhAgyaAgtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDLQCC0HOASECDJoCCyADQesBNgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMsgILIAEgBEYEQEHrASECDLICCyABLQAAQS9GBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GyODYCECADQQg2AgxBACECDLECC0HNASECDJcCCyABIARHBEAgA0EONgIIIAMgATYCBEHMASECDJcCC0HqASECDK8CCyABIARGBEBB6QEhAgyvAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBywEhAgyWAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZcCIANB6AE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILIAEgBEYEQEHnASECDK4CCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZgCIANB5gE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILQcoBIQIMlAILIAEgBEYEQEHlASECDK0CC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDQIgA0HiATYCHCADIAE2AhQgAyAANgIMQQAhAgyvAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZoCIANB4wE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ2YAiADQeQBNgIcIAMgATYCFCADIAA2AgwMrQILQckBIQIMkwILQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBpA02AhAgA0EhNgIMQQAhAgytAgtByAEhAgyTAgsgA0HhATYCHCADIAE2AhQgA0HQGjYCECADQRU2AgxBACECDKsCCyABIARGBEBB4QEhAgyrAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANBmRE2AhAgA0EJNgIMQQAhAgyrAgtBxwEhAgyRAgsgASAERgRAQeABIQIMqgILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDAyrAgsgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDEEAIQIMqgILQcYBIQIMkAILIAEgBEYEQEHfASECDKkCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgwMqgILIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgxBACECDKkCC0HFASECDI8CCyABIARGBEBB3gEhAgyoAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMDKkCCyADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMQQAhAgyoAgtBxAEhAgyOAgsgASAERgRAQd0BIQIMpwILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUHDASECDI8CCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GNCzYCECADQQ02AgxBACECDKcCCyADQQA2AhwgAyABNgIUIANBjQs2AhAgA0ENNgIMQQAhAgymAgsgASAERwRAIANBDzYCCCADIAE2AgRBASECDI0CC0HcASECDKUCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB2wEhAgymAgsgAygCBCEAIANBADYCBCADIAAgARAtIgBFBEAgAUEBaiEBDAQLIANB2gE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMpQILIAMoAgQhACADQQA2AgQgAyAAIAEQLSIADQEgAUEBagshAUHBASECDIoCCyADQdkBNgIcIAMgADYCDCADIAFBAWo2AhRBACECDKICC0HCASECDIgCCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQeQcNgIQIANBGTYCDEEAIQIMoAILIAEgBEYEQEHZASEC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IAFBAWohAUGeASECDOQBCyABQQFqIQFBnwEhAgzjAQtBtwEhAiABIARGDfsBIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQezUAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPwBCyADQQA2AgAgBkEBaiEBQQ0MKAtBtgEhAiABIARGDfoBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQaHVAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPsBCyADQQA2AgAgBkEBaiEBQQwMJwtBtQEhAiABIARGDfkBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQerUAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPoBCyADQQA2AgAgBkEBaiEBQQMMJgtBtAEhAiABIARGDfgBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQejUAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPkBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQbMBIQIM+AELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBmQEhAgzfAQsgAUEBaiEBQZoBIQIM3gELQbIBIQIgASAERg32ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm1ABqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz3AQsgA0EANgIAIAZBAWohAUEnDCMLQbEBIQIgASAERg31ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk1ABqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz2AQsgA0EANgIAIAZBAWohAUEcDCILQbABIQIgASAERg30ASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHe1ABqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz1AQsgA0EANgIAIAZBAWohAUEGDCELQa8BIQIgASAERg3zASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHZ1ABqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz0AQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGuASECDPMBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQY4BIQIM3AELIAFBAWohAUGPASECDNsBCyABQQFqIQFBlAEhAgzaAQsgAUEBaiEBQZUBIQIM2QELQa0BIQIgASAERg3xASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHX1ABqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzyAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGsASECDPEBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGQASECDNgBCyABQQFqIQFBkwEhAgzXAQsgASAERgRAQasBIQIM8AELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQZEBIQIM1wELIAFBAWohAUGSASECDNYBCyABIARGBEBBqgEhAgzvAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GpASECIAEgBEYN7QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB0dQAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7gELIANBADYCACAGQQFqIQFBHgwaC0GoASECIAEgBEYN7AEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBytQAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7QELIANBADYCACAGQQFqIQFBFQwZC0GnASECIAEgBEYN6wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBx9QAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7AELIANBADYCACAGQQFqIQFBFwwYC0GmASECIAEgBEYN6gEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBwdQAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6wELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBpQEhAgzqAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYsBIQIM0QELIAFBAWohAUGMASECDNABC0GkASECIAEgBEYN6AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBptUAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6QELIANBADYCACAGQQFqIQFBCQwVC0GjASECIAEgBEYN5wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBpNUAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6AELIANBADYCACAGQQFqIQFBHwwUC0GiASECIAEgBEYN5gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtQAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM5wELIANBADYCACAGQQFqIQFBAgwTC0GhASECIAEgBEYN5QEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQbzUAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOUBCyABIARGBEBBoAEhAgzlAQtBASABLQAAQd8ARw0RGiABQQFqIQFBhwEhAgzLAQsgA0EANgIAIAZBAWohAUGIASECDMoBC0GfASECIAEgBEYN4gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBhNUAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4wELIANBADYCACAGQQFqIQFBKQwPC0GeASECIAEgBEYN4QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBuNQAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4gELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBnQEhAgzhAQsgAS0AAEHFAEcNDiABQQFqIQFBhAEhAgzHAQsgASAERgRAQZwBIQIM4AELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFBggEhAgzHAQsgAUEBaiEBQYMBIQIMxgELQZsBIQIgASAERg3eASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGz1ABqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzfAQsgA0EANgIAIAZBAWohAUEjDAsLQZoBIQIgASAERg3dASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGw1ABqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzeAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGZASECDN0BCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQf0AIQIMxAELIAFBAWohAUGAASECDMMBCyABIARGBEBBmAEhAgzcAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB/gAhAgzDAQsgAUEBaiEBQf8AIQIMwgELIAEgBEYEQEGXASECDNsBCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQZYBIQIgASAERg3ZASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEGs1ABqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzaAQsgA0EANgIAIAZBAWohAUEFDAYLQZUBIQIgASAERg3YASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGm1ABqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzZAQsgA0EANgIAIAZBAWohAUEWDAULQZQBIQIgASAERg3XASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGh1QBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzYAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGTASECDNcBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUH5ACECDL4BCyABQQFqIQFB+gAhAgy9AQtBkgEhAiABIARGDdUBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQaDUAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNYBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGRASECDNQBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC4iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB/h82AhAgA0EGNgIMDNEBC0H4ACECDLcBCyADQZABNgIcIAMgATYCFCADIAA2AgxBACECDM8BC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANBgg82AhAgA0EgNgIMQQAhAgzOAQtB9wAhAgy0AQsgA0GPATYCHCADIAE2AhQgA0HsGzYCECADQRU2AgxBACECDMwBCyABIARGBEBBjwEhAgzMAQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GbHzYCECADQQY2AgxBACECDMwBC0ECIQIMsgELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GOASECDMoBCyABIARGBEBBjQEhAgzKAQsCQCABLQAAQQlrDgRKAABKAAtB9QAhAgywAQsgAy0AKUEFRgRAQfYAIQIMsAELQfQAIQIMrwELIAEgBEYEQEGMASECDMgBCyADQRA2AgggAyABNgIEDAoLIAEgBEYEQEGLASECDMcBCwJAIAEtAABBCWsOBEcAAEcAC0HzACECDK0BCyABIARHBEAgA0EQNgIIIAMgATYCBEHxACECDK0BC0GKASECDMUBCwJAIAEgBEcEQANAIAEtAABBoNAAai0AACIAQQNHBEACQCAAQQFrDgJJAAQLQfAAIQIMrwELIAQgAUEBaiIBRw0AC0GIASEC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BCABQQFqIgFHDQALQfsAIQIMpwELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMpgELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMpQELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB+gA2AhwgAyABNgIUIAMgADYCDEEAIQIMpAELIANBADYCHCADIAE2AhQgA0G8CjYCECADQQc2AgxBACECDKMBC0HPACECDIkBC0HRACECDIgBC0HnACECDIcBCyABIARGBEBB+gAhAgygAQsCQCABLQAAQQlrDgQgAAAgAAsgAUEBaiEBQeYAIQIMhgELIAEgBEYEQEH5ACECDJ8BCwJAIAEtAABBCWsOBB8AAB8AC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQRAQeIBIQIMhgELIABBFUcEQCADQQA2AhwgAyABNgIUIANByQ02AhAgA0EaNgIMQQAhAgyfAQsgA0H4ADYCHCADIAE2AhQgA0HqGjYCECADQRU2AgxBACECDJ4BCyABIARHBEAgA0ENNgIIIAMgATYCBEHkACECDIUBC0H3ACECDJ0BCyABIARGBEBB9gAhAgydAQsCQAJAAkAgAS0AAEHIAGsOCwABCwsLCwsLCwsCCwsgAUEBaiEBQd0AIQIMhQELIAFBAWohAUHgACECDIQBCyABQQFqIQFB4wAhAgyDAQtB9QAhAiABIARGDZsBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbXVAGotAABHDQggAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJwBCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQKyIABEAgA0H0ADYCHCADIAE2AhQgAyAANgIMQQAhAgycAQtB4gAhAgyCAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJwBC0HhACECDIIBCyADQfMANgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMmgELIAMtACkiAEEja0ELSQ0JAkAgAEEGSw0AQQEgAHRBygBxRQ0ADAoLQQAhAiADQQA2AhwgAyABNgIUIANB7Qk2AhAgA0EINgIMDJkBC0HyACECIAEgBEYNmAEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBs9UAai0AAEcNBSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMmQELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgAEQCADQfEANgIcIAMgATYCFCADIAA2AgxBACECDJkBC0HfACECDH8LQQAhAAJAIAMoAjgiAkUNACACKAI0IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANB6g02AhAgA0EmNgIMQQAhAgyZAQtB3gAhAgx/CyADQfAANgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMlwELIAMtAClBIUYNBiADQQA2AhwgAyABNgIUIANBkQo2AhAgA0EINgIMQQAhAgyWAQtB7wAhAiABIARGDZUBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbDVAGotAABHDQIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJYBCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQKyIARQ0CIANB7QA2AhwgAyABNgIUIAMgADYCDEEAIQIMlQELIANBADYCAAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDYABIANB7gA2AhwgAyABNgIUIAMgADYCDEEAIQIMkwELQdwAIQIMeQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJMBC0HbACECDHkLIANB7AA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyRAQsgAy0AKSIAQSNJDQAgAEEuRg0AIANBADYCHCADIAE2AhQgA0HJCTYCECADQQg2AgxBACECDJABC0HaACECDHYLIAEgBEYEQEHrACECDI8BCwJAIAEtAABBL0YEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDEEAIQIMjwELQdkAIQIMdQsgASAERwRAIANBDjYCCCADIAE2AgRB2AAhAgx1C0HqACECDI0BCyABIARGBEBB6QAhAgyNAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1wAhAgx0CyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNeiADQegANgIcIAMgATYCFCADIAA2AgxBACECDIwBCyABIARGBEBB5wAhAgyMAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ17IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMjAELQdYAIQIMcgsgASAERgRAQeUAIQIMiwELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDI0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNfSADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIwBCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNeyADQeQANgIcIAMgATYCFCADIAA2AgwMiwELQdQAIQIMcQsgAy0AKUEiRg2GAUHTACECDHALQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFBEBB1QAhAgxwCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQaQNNgIQIANBITYCDEEAIQIMiQELIANB4QA2AhwgAyABNgIUIANB0Bo2AhAgA0EVNgIMQQAhAgyIAQsgASAERgRAQeAAIQIMiAELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HSACECDHALIANBADYCHCADIAE2AhQgA0G2ETYCECADQQk2AgxBACECDIgBCyADQQA2AhwgAyABNgIUIANBthE2AhAgA0EJNgIMQQAhAgyHAQsgASAERgRAQd8AIQIMhwELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBthE2AhAgA0ECNgIMQQAhAgyGAQsgASAERgRAQd0AIQIMhgELIAEtAAAiAkENRgRAIAFBAWohAUHQACECDG0LIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyFAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0HKLTYCECADQQc2AgwMgwELIAEgBEYEQEHbACECDIMBCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc4AIQIMaAsgASAERgRAQdoAIQIMgQELIAEtAABBCWsOBAABAQABC0EAIQIgA0EANgIcIANBmhI2AhAgA0EHNgIMIAMgAUEBajYCFAx/CyADQYASOwEqQQAhAAJAIAMoAjgiAkUNACACKAI4IgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2QA2AhwgAyABNgIUIANB6ho2AhAgA0EVNgIMQQAhAgx+C0HNACECDGQLIANBADYCHCADIAE2AhQgA0HJDTYCECADQRo2AgxBACECDHwLIAEgBEYEQEHZACECDHwLIAEtAABBIEcNPSABQQFqIQEgAy0ALkEBcQ09IANBADYCHCADIAE2AhQgA0HCHDYCECADQR42AgxBACECDHsLIAEgBEYEQEHYACECDHsLAkACQAJAAkACQCABLQAAIgBBCmsOBAIDAwABCyABQQFqIQFBLCECDGULIABBOkcNASADQQA2AhwgAyABNgIUIANB5xE2AhAgA0EKNgIMQQAhAgx9CyABQQFqIQEgA0Evai0AAEEBcUUNcyADLQAyQYABcUUEQCADQTJqIQIgAxA1QQAhAAJAIAMoAjgiBkUNACAGKAIoIgZFDQAgAyAGEQAAIQALAkACQCAADhZNTEsBAQEBAQEBAQEBAQEBAQEBAQEAAQsgA0EpNgIcIAMgATYCFCADQawZNgIQIANBFTYCDEEAIQIMfgsg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c3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3Byb3RvY29sX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fcHJvdG9jb2wARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBVbmV4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fcHJvdG9jb2xfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX1BST1RPQ09MX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8sIFJUU1AvIG9yIElDRS8A5xUAAK8VAACkEgAAkhoAACYWAACeFAAA2xkAAHkVAAB+EgAA/hQAADYVAAALFgAA2BYAAPMSAABCGAAArBYAABIVAAAUFwAA7xcAAEgUAABxFwAAshoAAGsZAAB+GQAANRQAAIIaAABEFwAA/RYAAB4YAACHFwAAqhkAAJMSAAAHGAAALBcAAMoXAACkFwAA5xUAAOcVAABYFwAAOxgAAKASAAAtHAAAwxEAAEgRAADeEgAAQhMAAKQZAAD9EAAA9xUAAKUVAADvFgAA+BkAAEoWAABWFgAA9RUAAAoaAAAIGgAAARoAAKsVAABCEgAA1xAAAEwRAAAFGQAAVBYAAB4RAADKGQAAyBkAAE4WAAD/GAAAcRQAAPAVAADuFQAAlBkAAPwVAAC/GQAAmxkAAHwUAABDEQAAcBgAAJUUAAAnFAAAGRQAANUSAADUGQAARBYAAPcQAEG5OwsBAQBB0DsL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBuj0LBAEAAAIAQdE9C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEG6PwsEAQAAAgBB0T8LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQbDBAAsNbG9zZWVlcC1hbGl2ZQBBycEACwEBAEHgwQAL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBycMACwEBAEHgwwAL5wEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAQfHFAAteAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBB0McACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQYDIAAsgcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQpTTQ0KDQoAQanIAAsFAQIAAQMAQcDIAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanKAAsFAQIAAQMAQcDKAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanMAAsEAQAAAQBBwcwAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEGpzgALBQECAAEDAEHAzgALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEGp0AALBQEBAAEBAEHA0AALAQEAQdrQAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQanSAAsFAQEAAQEAQcDSAAsBAQBBytIACwYCAAAAAAIAQeHSAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBoNQAC50BTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFVFRQQ0VUU1BBRFRQLw==";
  var wasmBuffer;
  Object.defineProperty(module, "exports", {
    get: () => {
      return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
    }
  });
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzU0BQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEBAwAAAwAAAAQFAXABExMFAwEAAgYIAX8BQcDZBAsHxQcoBm1lbW9yeQIAC19pbml0aWFsaXplAAgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC2xsaHR0cF9pbml0AAkYbGxodHRwX3Nob3VsZF9rZWVwX2FsaXZlADcMbGxodHRwX2FsbG9jAAsGbWFsbG9jADkLbGxodHRwX2ZyZWUADARmcmVlAAwPbGxodHRwX2dldF90eXBlAA0VbGxodHRwX2dldF9odHRwX21ham9yAA4VbGxodHRwX2dldF9odHRwX21pbm9yAA8RbGxodHRwX2dldF9tZXRob2QAEBZsbGh0dHBfZ2V0X3N0YXR1c19jb2RlABESbGxodHRwX2dldF91cGdyYWRlABIMbGxodHRwX3Jlc2V0ABMObGxodHRwX2V4ZWN1dGUAFBRsbGh0dHBfc2V0dGluZ3NfaW5pdAAVDWxsaHR0cF9maW5pc2gAFgxsbGh0dHBfcGF1c2UAFw1sbGh0dHBfcmVzdW1lABgbbGxodHRwX3Jlc3VtZV9hZnRlcl91cGdyYWRlABkQbGxodHRwX2dldF9lcnJubwAaF2xsaHR0cF9nZXRfZXJyb3JfcmVhc29uABsXbGxodHRwX3NldF9lcnJvcl9yZWFzb24AHBRsbGh0dHBfZ2V0X2Vycm9yX3BvcwAdEWxsaHR0cF9lcnJub19uYW1lAB4SbGxodHRwX21ldGhvZF9uYW1lAB8SbGxodHRwX3N0YXR1c19uYW1lACAabGxodHRw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AXRrQT5qIQILIAEgAjYCHCABQgA3AhAgAkECdEH01wBqIQACQEHI1QAoAgAiA0EBIAJ0IgdxRQRAIAAgATYCAEHI1QAgAyAHcjYCACABIAA2AhggASABNgIIIAEgATYCDAwBCyAEQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQACQANAIAAiAygCBEF4cSAERg0BIAJBHXYhACACQQF0IQIgAyAAQQRxakEQaiIHKAIAIgANAAsgByABNgIAIAEgAzYCGCABIAE2AgwgASABNgIIDAELIAMoAggiACABNgIMIAMgATYCCCABQQA2AhggASADNgIMIAEgADYCCAtB5NUAQeTVACgCAEEBayIAQX8gABs2AgALCwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BNAsHACAALQAwC0ABBH8gACgCGCEBIAAvAS4hAiAALQAoIQMgACgCOCEEIAAQOCAAIAQ2AjggACADOgAoIAAgAjsBLiAAIAE2AhgLhocCAwd/A34BeyABIAJqIQQCQCAAIgMoAgwiAA0AIAMoAgQEQCADIAE2AgQLIwBBEGsiCSQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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DAgLQeMBDAcLQdcBDAYLQdgBDAULQdkBDAQLQdoBDAMLQdsBDAILQd0BDAELQdwBCyECA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAn8CQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAwJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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A0EXNgIcIAMgADYCDCADIAFBAWo2AhQM+AILIABBFUYNI0EAIQIgA0EANgIcIAMgATYCFCADQdYMNgIQIANBIzYCDAz3AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQwdCyADQRk2AhwgAyAANgIMIAMgAUEBajYCFAz2AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQzvAgsgA0EaNgIcIAMgADYCDCADIAFBAWo2AhQM9QILIABBFUYNH0EAIQIgA0EANgIcIAMgATYCFCADQdAPNgIQIANBIjYCDAz0AgsgAygCBCEAIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgzzAgsgAygCBCEAIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDOsCCyADQR02AhwgAyAANgIMIAMgAUEBajYCFEEAIQIM8gILIABBO0cNASABQQFqIQELQSYhAgzXAgtBACECIANBADYCHCADIAE2AhQgA0GfFTYCECADQQw2AgwM7wILIAEgBEcEQANAIAEtAABBIEcNhAIgBCABQQFqIgFHDQALQSwhAgzvAgtBLCECDO4CCyABIARGBEBBNCECDO4CCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtBNCECDO8CCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUNnwIgA0EyNgIcIAMgATYCFCADIAA2AgxBACECDO4CCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUEQCABQQFqIQEMnwILIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgztAgsgASAERwRAAkADQCABLQAAQTBrIgBB/wFxQQpPBEBBOiECDNcCCyADKQMgIgtCmbPmzJmz5swZVg0BIAMgC0IKfiIKNwMgIAogAK1C/wGDIgtCf4VWDQEgAyAKIAt8NwMgIAQgAUEBaiIBRw0AC0HAACECDO4CCyADKAIEIQAgA0EANgIEIAMgACABQQFqIgEQMSIADRcM4gILQcAAIQIM7AILIAEgBEYEQEHJACECDOwCCwJAA0ACQCABLQAAQQlrDhgAAqICogKpAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAgCiAgsgBCABQQFqIgFHDQALQckAIQIM7AILIAFBAWohASADQS9qLQAAQQFxDaUCIANBADYCHCADIAE2AhQgA0GXEDYCECADQQo2AgxBACECDOsCCyABIARHBEADQCABLQAAQSBHDRUgBCABQQFqIgFHDQALQfgAIQIM6wILQfgAIQIM6gILIANBAjoAKAw4C0EAIQIgA0EANgIcIANBvws2AhAgA0ECNgIMIAMgAUEBajYCFAzoAgtBACECDM4CC0ENIQIMzQILQRMhAgzMAgtBFSECDMsCC0EWIQIMygILQRghAgzJAgtBGSECDMgCC0EaIQIMxwILQRshAgzGAgtBHCECDMUCC0EdIQIMxAILQR4hAgzDAgtBHyECDMICC0EgIQIMwQILQSIhAgzAAgtBIyECDL8CC0ElIQIMvgILQeUAIQIMvQILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgzVAgsgA0EbNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIM1AILIANBIDYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNMCCyADQRM2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzSAgsgA0ELNgIcIAMgATYCFCADQZgaNgIQIANBFTYCDEEAIQIM0QILIANBEDYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNACCyADQSA2AhwgAyABNgIUIANBpBw2AhAgA0EVNgIMQQAhAgzPAgsgA0ELNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIMzgILIANBDDYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDM0CC0EAIQIgA0EANgIcIAMgATYCFCADQd0ONgIQIANBEjYCDAzMAgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0H9ASECDMwCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJgIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB/AE2AhwgAyABNgIUIANB3Bk2AhAgA0EVNgIMQQAhAgzNAgtB3AEhAgyzAgsgA0EANgIcIAMgATYCFCADQfkLNgIQIANBHzYCDEEAIQIMywILAkACQCADLQAoQQFrDgIEAQALQdsBIQIMsgILQdQBIQIMsQILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQd0BIQIMsQILIABBFUcEQCADQQA2AhwgAyABNgIUIANBtAw2AhAgA0EQNgIMQQAhAgzKAgsgA0H7ATYCHCADIAE2AhQgA0GBGjYCECADQRU2AgxBACECDMkCCyABIARGBEBB+gEhAgzJAgsgAS0AAEHIAEYNASADQQE6ACgLQcABIQIMrgILQdoBIQIMrQILIAEgBEcEQCADQQw2AgggAyABNgIEQdkBIQIMrQILQfkBIQIMxQILIAEgBEYEQEH4ASECDMUCCyABLQAAQcgARw0EIAFBAWohAUHYASECDKsCCyABIARGBEBB9wEhAgzEAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQdYBIQIMqwILIAFBAWohAUHXASECDKoCC0H2ASECIAEgBEYNwgIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABButUAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMwwILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAuIgBFBEBB4wEhAgyqAgsgA0H1ATYCHCADIAE2AhQgAyAANgIMQQAhAgzCAgtB9AEhAiABIARGDcECIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjVAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMICCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAuIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB5R82AhAgA0EINgIMDL8CC0HVASECDKUCCyADQfMBNgIcIAMgATYCFCADIAA2AgxBACECDL0CC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQ1uIABBFUcEQCADQQA2AhwgAyABNgIUIANBgg82AhAgA0EgNgIMQQAhAgy9AgsgA0GPATYCHCADIAE2AhQgA0HsGzYCECADQRU2AgxBACECDLwCCyABIARHBEAgA0ENNgIIIAMgATYCBEHTASECDKMCC0HyASECDLsCCyABIARGBEBB8QEhAgy7AgsCQAJAAkAgAS0AAEHIAGsOCwABCAgICAgICAgCCAsgAUEBaiEBQdABIQIMowILIAFBAWohAUHRASECDKICCyABQQFqIQFB0gEhAgyhAgtB8AEhAiABIARGDbkCIAMoAgAiACAEIAFraiEGIAEgAGtBAmohBQNAIAEtAAAgAEG11QBqLQAARw0EIABBAkYNAyAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy5AgtB7wEhAiABIARGDbgCIAMoAgAiACAEIAFraiEGIAEgAGtBAWohBQNAIAEtAAAgAEGz1QBqLQAARw0DIABBAUYNAiAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy4AgtB7gEhAiABIARGDbcCIAMoAgAiACAEIAFraiEGIAEgAGtBAmohBQNAIAEtAAAgAEGw1QBqLQAARw0CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy3AgsgAygCBCEAIANCADcDACADIAAgBUEBaiIBECsiAEUNAiADQewBNgIcIAMgATYCFCADIAA2AgxBACECDLYCCyADQQA2AgALIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ2cAiADQe0BNgIcIAMgATYCFCADIAA2AgxBACECDLQCC0HPASECDJoCC0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMtAILQc4BIQIMmgILIANB6wE2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyyAgsgASAERgRAQesBIQIMsgILIAEtAABBL0YEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDEEAIQIMsQILQc0BIQIMlwILIAEgBEcEQCADQQ42AgggAyABNgIEQcwBIQIMlwILQeoBIQIMrwILIAEgBEYEQEHpASECDK8CCyABLQAAQTBrIgBB/wFxQQpJBEAgAyAAOgAqIAFBAWohAUHLASECDJYCCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNlwIgA0HoATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgsgASAERgRAQecBIQIMrgILAkAgAS0AAEEuRgRAIAFBAWohAQwBCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNmAIgA0HmATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgtBygEhAgyUAgsgASAERgRAQeUBIQIMrQILQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNAiADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDK8CCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNmgIgA0HjATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZgCIANB5AE2AhwgAyABNgIUIAMgADYCDAytAgtByQEhAgyTAgtBACEAAkAgAygCOCICRQ0AIAIoAkQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0GkDTYCECADQSE2AgxBACECDK0CC0HIASECDJMCCyADQeEBNgIcIAMgATYCFCADQdAaNgIQIANBFTYCDEEAIQIMqwILIAEgBEYEQEHhASECDKsCCwJAIAEtAABBIEYEQCADQQA7ATQgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GZETYCECADQQk2AgxBACECDKsCC0HHASECDJECCyABIARGBEBB4AEhAgyqAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMDKsCCyADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMQQAhAgyqAgtBxgEhAgyQAgsgASAERgRAQd8BIQIMqQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDAyqAgsgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDEEAIQIMqQILQcUBIQIMjwILIAEgBEYEQEHeASECDKgCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgwMqQILIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgxBACECDKgCC0HEASECDI4CCyABIARGBEBB3QEhAgynAgsCQAJAAkACQCABLQAAQQprDhcCAwMAAwMDAwMDAwMDAwMDAwMDAwMDAQMLIAFBAWoMBQsgAUEBaiEBQcMBIQIMjwILIAFBAWohASADQS9qLQAAQQFxDQggA0EANgIcIAMgATYCFCADQY0LNgIQIANBDTYCDEEAIQIMpwILIANBADYCHCADIAE2AhQgA0GNCzYCECADQQ02AgxBACECDKYCCyABIARHBEAgA0EPNgIIIAMgATYCBEEBIQIMjQILQdwBIQIMpQILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0HbASECDKYCCyADKAIEIQAgA0EANgIEIAMgACABEC0iAEUEQCABQQFqIQEMBAsgA0HaATYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgylAgsgAygCBCEAIANBADYCBCADIAAgARAtIgANASABQQFqCyEBQcEBIQIMigILIANB2QE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMogILQcIBIQIMiAILIANBL2otAABBAXENASADQQA2AhwgAyABNgIUIANB5Bw2AhAgA0EZNgIMQQAhAgygAgsgASAERgRAQdkB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CyADIAU2AgAMkAILIANBADYCACAGQQFqIQFBGgw8C0HKASECIAEgBEYNjgIgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBjdUAai0AAEcNOyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMjwILIANBADYCACAGQQFqIQFBIQw7CyABIARGBEBByQEhAgyOAgsCQAJAIAEtAABBwQBrDhQAPT09PT09PT09PT09PT09PT09AT0LIAFBAWohAUGtASECDPUBCyABQQFqIQFBsAEhAgz0AQsgASAERgRAQcgBIQIMjQILAkACQCABLQAAQdUAaw4LADw8PDw8PDw8PAE8CyABQQFqIQFBrgEhAgz0AQsgAUEBaiEBQa8BIQIM8wELQccBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEGE1QBqLQAARw04IABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEqDDgLIAEgBEYEQEHGASECDIsCCyABLQAAQdAARw04IAFBAWohAUElDDcLQcUBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGB1QBqLQAARw02IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEODDYLIAEgBEYEQEHEASECDIkCCyABLQAAQcUARw02IAFBAWohAUGrASECDO8BCyABIARGBEBBwwEhAgyIAgsCQAJAAkACQCABLQAAQcIAaw4PAAECOTk5OTk5OTk5OTkDOQsgAUEBaiEBQacBIQIM8QELIAFBAWohAUGoASECDPABCyABQQFqIQFBqQEhAgzvAQsgAUEBaiEBQaoBIQIM7gELQcIBIQIgASAERg2GAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEH+1ABqLQAARw0zIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyHAgsgA0EANgIAIAZBAWohAUEUDDMLQcEBIQIgASAERg2FAiADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEH51ABqLQAARw0yIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyGAgsgA0EANgIAIAZBAWohAUErDDILQcABIQIgASAERg2EAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEH21ABqLQAARw0xIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyFAgsgA0EANgIAIAZBAWohAUEsDDELQb8BIQIgASAERg2DAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGh1QBqLQAARw0wIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyEAgsgA0EANgIAIAZBAWohAUERDDALQb4BIQIgASAERg2CAiADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHy1ABqLQAARw0vIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyDAgsgA0EANgIAIAZBAWohAUEuDC8LIAEgBEYEQEG9ASECDIICCwJAAkACQAJAAkAgAS0AAEHBAGsOFQA0NDQ0NDQ0NDQ0ATQ0AjQ0AzQ0BDQLIAFBAWohAUGbASECDOwBCyABQQFqIQFBnAEhAgzrAQsgAUEBaiEBQZ0BIQIM6gELIAFBAWohAUGiASECDOkBCyABQQFqIQFBpAEhAgzoAQsgASAERgRAQbwBIQIMgQILAkACQCABLQAAQdIAaw4DADABMAsgAUEBaiEBQaMBIQIM6AELIAFBAWohAUEEDC0LQbsBIQIgASAERg3/ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHw1ABqLQAARw0sIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyAAgsgA0EANgIAIAZBAWohAUEdDCwLIAEgBEYEQEG6ASECDP8BCwJAAkAgAS0AAEHJAGsOBwEuLi4uLgAuCyABQQFqIQFBoQEhAgzmAQsgAUEBaiEBQSIMKwsgASAERgRAQbkBIQIM/gELIAEtAABB0ABHDSsgAUEBaiEBQaABIQIM5AELIAEgBEYEQEG4ASECDP0BCwJAAkAgAS0AAEHGAGsOCwAsLCwsLCwsLCwBLAsgAUEBaiEBQZ4BIQIM5AELIAFBAWohAUGfASECDOMBC0G3ASECIAEgBEYN+wEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB7NQAai0AAEcNKCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/AELIANBADYCACAGQQFqIQFBDQwoC0G2ASECIAEgBEYN+gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBodUAai0AAEcNJyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+wELIANBADYCACAGQQFqIQFBDAwnC0G1ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB6tQAai0AAEcNJiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBAwwmC0G0ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB6NQAai0AAEcNJSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBJgwlCyABIARGBEBBswEhAgz4AQsCQAJAIAEtAABB1ABrDgIAAScLIAFBAWohAUGZASECDN8BCyABQQFqIQFBmgEhAgzeAQtBsgEhAiABIARGDfYBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQebUAGotAABHDSMgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPcBCyADQQA2AgAgBkEBaiEBQScMIwtBsQEhAiABIARGDfUBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQeTUAGotAABHDSIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPYBCyADQQA2AgAgBkEBaiEBQRwMIgtBsAEhAiABIARGDfQBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQd7UAGotAABHDSEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPUBCyADQQA2AgAgBkEBaiEBQQYMIQtBrwEhAiABIARGDfMBIAMoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQdnUAGotAABHDSAgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPQBCyADQQA2AgAgBkEBaiEBQRkMIAsgASAERgRAQa4BIQIM8wELAkACQAJAAkAgAS0AAEEtaw4jACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkASQkJCQkAiQkJAMkCyABQQFqIQFBjgEhAgzcAQsgAUEBaiEBQY8BIQIM2wELIAFBAWohAUGUASECDNoBCyABQQFqIQFBlQEhAgzZAQtBrQEhAiABIARGDfEBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQdfUAGotAABHDR4gAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPIBCyADQQA2AgAgBkEBaiEBQQsMHgsgASAERgRAQawBIQIM8QELAkACQCABLQAAQcEAaw4DACABIAsgAUEBaiEBQZABIQIM2AELIAFBAWohAUGTASECDNcBCyABIARGBEBBqwEhAgzwAQsCQAJAIAEtAABBwQBrDg8AHx8fHx8fHx8fHx8fHwEfCyABQQFqIQFBkQEhAgzXAQsgAUEBaiEBQZIBIQIM1gELIAEgBEYEQEGqASECDO8BCyABLQAAQcwARw0cIAFBAWohAUEKDBsLQakBIQIgASAERg3tASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHR1ABqLQAARw0aIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzuAQsgA0EANgIAIAZBAWohAUEeDBoLQagBIQIgASAERg3sASADKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEHK1ABqLQAARw0ZIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAztAQsgA0EANgIAIAZBAWohAUEVDBkLQacBIQIgASAERg3rASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHH1ABqLQAARw0YIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzsAQsgA0EANgIAIAZBAWohAUEXDBgLQaYBIQIgASAERg3qASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHB1ABqLQAARw0XIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzrAQsgA0EANgIAIAZBAWohAUEYDBcLIAEgBEYEQEGlASECDOoBCwJAAkAgAS0AAEHJAGsOBwAZGRkZGQEZCyABQQFqIQFBiwEhAgzRAQsgAUEBaiEBQYwBIQIM0AELQaQBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm1QBqLQAARw0VIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEJDBULQaMBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk1QBqLQAARw0UIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEfDBQLQaIBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEG+1ABqLQAARw0TIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUECDBMLQaEBIQIgASAERg3lASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYDQCABLQAAIABBvNQAai0AAEcNESAAQQFGDQIgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM5QELIAEgBEYEQEGgASECDOUBC0EBIAEtAABB3wBHDREaIAFBAWohAUGHASECDMsBCyADQQA2AgAgBkEBaiEBQYgBIQIMygELQZ8BIQIgASAERg3iASADKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEGE1QBqLQAARw0PIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzjAQsgA0EANgIAIAZBAWohAUEpDA8LQZ4BIQIgASAERg3hASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEG41ABqLQAARw0OIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAziAQsgA0EANgIAIAZBAWohAUEtDA4LIAEgBEYEQEGdASECDOEBCyABLQAAQcUARw0OIAFBAWohAUGEASECDMcBCyABIARGBEBBnAEhAgzgAQsCQAJAIAEtAABBzABrDggADw8PDw8PAQ8LIAFBAWohAUGCASECDMcBCyABQQFqIQFBgwEhAgzGAQtBmwEhAiABIARGDd4BIAMoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQbPUAGotAABHDQsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADN8BCyADQQA2AgAgBkEBaiEBQSMMCwtBmgEhAiABIARGDd0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbDUAGotAABHDQogAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADN4BCyADQQA2AgAgBkEBaiEBQQAMCgsgASAERgRAQZkBIQIM3QELAkACQCABLQAAQcgAaw4IAAwMDAwMDAEMCyABQQFqIQFB/QAhAgzEAQsgAUEBaiEBQYABIQIMwwELIAEgBEYEQEGYASECDNwBCwJAAkAgAS0AAEHOAGsOAwALAQsLIAFBAWohAUH+ACECDMMBCyABQQFqIQFB/wAhAgzCAQsgASAERgRAQZcBIQIM2wELIAEtAABB2QBHDQggAUEBaiEBQQgMBwtBlgEhAiABIARGDdkBIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazUAGotAABHDQYgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNoBCyADQQA2AgAgBkEBaiEBQQUMBgtBlQEhAiABIARGDdgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQabUAGotAABHDQUgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNkBCyADQQA2AgAgBkEBaiEBQRYMBQtBlAEhAiABIARGDdcBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQaHVAGotAABHDQQgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyADQQA2AgAgBkEBaiEBQRAMBAsgASAERgRAQZMBIQIM1wELAkACQCABLQAAQcMAaw4MAAYGBgYGBgYGBgYBBgsgAUEBaiEBQfkAIQIMvgELIAFBAWohAUH6ACECDL0BC0GSASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBoNQAai0AAEcNAiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBJAwCCyADQQA2AgAMAgsgASAERgRAQZEBIQIM1AELIAEtAABBzABHDQEgAUEBaiEBQRMLOgApIAMoAgQhACADQQA2AgQgAyAAIAEQLiIADQIMAQtBACECIANBADYCHCADIAE2AhQgA0H+HzYCECADQQY2AgwM0QELQfgAIQIMtwELIANBkAE2AhwgAyABNgIUIAMgADYCDEEAIQIMzwELQQAhAAJAIAMoAjgiAkUNACACKAJAIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRg0BIANBADYCHCADIAE2AhQgA0GCDzYCECADQSA2AgxBACECDM4BC0H3ACECDLQBCyADQY8BNgIcIAMgATYCFCADQewbNgIQIANBFTYCDEEAIQIMzAELIAEgBEYEQEGPASECDMwBCwJAIAEtAABBIEYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZsfNgIQIANBBjYCDEEAIQIMzAELQQIhAgyyAQsDQCABLQAAQSBHDQIgBCABQQFqIgFHDQALQY4BIQIMygELIAEgBEYEQEGNASECDMoBCwJAIAEtAABBCWsOBEoAAEoAC0H1ACECDLABCyADLQApQQVGBEBB9gAhAgywAQtB9AAhAgyvAQsgASAERgRAQYwBIQIMyAELIANBEDYCCCADIAE2AgQMCgsgASAERgRAQYsBIQIMxwELAkAgAS0AAEEJaw4ERwAARwALQfMAIQIMrQELIAEgBEcEQCADQRA2AgggAyABNgIEQfEAIQIMrQELQYoBIQIMxQELAkAgASAERwRAA0AgAS0AAEGg0ABqLQAAIgBBA0cEQAJAIABBAWsOAkkABAtB8AAhAgyvAQsgBCABQQFqIgFHDQALQYgBIQIMxgELQYgBIQIMxQELIANBADYCHCADIAE2AhQgA0HbIDYCECADQQc2AgxBACECDMQBCyABIARGBEBBiQEhAgzEAQsCQAJAAkAgAS0AAEGg0gBqLQAAQQFrDgNGAgABC0HyACECDKwBCyADQQA2AhwgAyABNgIUIANBtBI2AhAgA0EHNgIMQQAhAgzEAQtB6gAhAgyqAQsgASAERwRAIAFBAWohAUHvACECDKoBC0GHASECDMIBCyAEIAEiAEYEQEGGASECDMIBCyAALQAAIgFBL0YEQCAAQQFqIQFB7gAhAgypAQsgAUEJayICQRdLDQEgACEBQQEgAnRBm4CABHENQQwBCyAEIAEiAEYEQEGFASECDMEBCyAALQAAQS9HDQAgAEEBaiEBDAMLQQAhAiADQQA2AhwgAyAANgIUIANB2yA2AhAgA0EHNgIMDL8BCwJAAkACQAJAAkADQCABLQAAQaDOAGotAAAiAEEFRwRAAkACQCAAQQFrDghHBQYHCAAEAQgLQesAIQIMrQELIAFBAWohAUHtACECDKwBCyAEIAFBAWoiAUcNAAtBhAEhAgzDAQsgAUEBagwUCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQdsANgIcIAMgATYCFCADIAA2AgxBACECDMEBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDMABCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQfoANgIcIAMgATYCFCADIAA2AgxBACECDL8BCyADQQA2AhwgAyABNgIUIANB+Q82AhAgA0EHNgIMQQAhAgy+AQsgASAERgRAQYMBIQIMvgELAkAgAS0AAEGgzgBqLQAAQQFrDgg+BAUGAAgCAwcLIAFBAWohAQtBAyECDKMBCyABQQFqDA0LQQAhAiADQQA2AhwgA0HREjYCECADQQc2AgwgAyABQQFqNgIUDLoBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQdsANgIcIAMgATYCFCADIAA2AgxBACECDLkBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDLgBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQfoANgIcIAMgATYCFCADIAA2AgxBACECDLcBCyADQQA2AhwgAyABNgIUIANB+Q82AhAgA0EHNgIMQQAhAgy2AQtB7AAhAgycAQsgASAERgRAQYIBIQIMtQELIAFBAWoMAgsgASAERgRAQYEBIQIMtAELIAFBAWoMAQsgASAERg0BIAFBAWoLIQFBBCECDJgBC0GAASECDLABCwNAIAEtAABBoMwAai0AACIAQQJHBEAgAEEBRwRAQekAIQIMmQELDDELIAQgAUEBaiIBRw0AC0H/ACECDK8BCyABIARGBEBB/gAhAgyvAQsCQCABLQAAQQlrDjcvAwYvBAYGBgYGBgYGBgYGBgYGBgYGBgUGBgIGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYABgsgAUEBagshAUEFIQIMlAELIAFBAWoMBgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgypAQsgA0EANgIcIAMgATYCFCADQY0UNgIQIANBBzYCDEEAIQIMqAELAkACQAJAAkADQCABLQAAQaDKAGotAAAiAEEFRwRAAkAgAEEBaw4GLgMEBQYABgtB6AAhAgyUAQsgBCABQQFqIgFHDQALQf0AIQIMqwELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMqgELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMqQELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB+gA2AhwgAyABNgIUIAMgADYCDEEAIQIMqAELIANBADYCHCADIAE2AhQgA0HkCDYCECADQQc2AgxBACECDKcBCyABIARGDQEgAUEBagshAUEGIQIMjAELQfwAIQIMpAELAkACQAJAAkADQCABLQAAQaDIAGotAAAiAEEFRwRAIABBAWsOBCkCAwQFCyAEIAFBAWoiAUcNAAtB+wAhAgynAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgymAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgylAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgykAQsgA0EANgIcIAMgATYCFCADQbwKNgIQIANBBzYCDEEAIQIMowELQc8AIQIMiQELQdEAIQIMiAELQecAIQIMhwELIAEgBEYEQEH6ACECDKABCwJAIAEtAABBCWsOBCAAACAACyABQQFqIQFB5gAhAgyGAQsgASAERgRAQfkAIQIMnwELAkAgAS0AAEEJaw4EHwAAHwALQQAhAAJAIAMoAjgiAkUNACACKAI4IgJFDQAgAyACEQAAIQALIABFBEBB4gEhAgyGAQsgAEEVRwRAIANBADYCHCADIAE2AhQgA0HJDTYCECADQRo2AgxBACECDJ8BCyADQfgANgIcIAMgATYCFCADQeoaNgIQIANBFTYCDEEAIQIMngELIAEgBEcEQCADQQ02AgggAyABNgIEQeQAIQIMhQELQfcAIQIMnQELIAEgBEYEQEH2ACECDJ0BCwJAAkACQCABLQAAQcgAaw4LAAELCwsLCwsLCwILCyABQQFqIQFB3QAhAgyFAQsgAUEBaiEBQeAAIQIMhAELIAFBAWohAUHjACECDIMBC0H1ACECIAEgBEYNmwEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBtdUAai0AAEcNCCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMnAELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgAEQCADQfQANgIcIAMgATYCFCADIAA2AgxBACECDJwBC0HiACECDIIBC0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMnAELQeEAIQIMggELIANB8wA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyaAQsgAy0AKSIAQSNrQQtJDQkCQCAAQQZLDQBBASAAdEHKAHFFDQAMCgtBACECIANBADYCHCADIAE2AhQgA0HtCTYCECADQQg2AgwMmQELQfIAIQIgASAERg2YASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGz1QBqLQAARw0FIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyZAQsgAygCBCEAIANCADcDACADIAAgBkEBaiIBECsiAARAIANB8QA2AhwgAyABNgIUIAMgADYCDEEAIQIMmQELQd8AIQIMfwtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJkBC0HeACECDH8LIANB8AA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyXAQsgAy0AKUEhRg0GIANBADYCHCADIAE2AhQgA0GRCjYCECADQQg2AgxBACECDJYBC0HvACECIAEgBEYNlQEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBsNUAai0AAEcNAiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMlgELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgBFDQIgA0HtADYCHCADIAE2AhQgAyAANgIMQQAhAgyVAQsgA0EANgIACyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNgAEgA0HuADYCHCADIAE2AhQgAyAANgIMQQAhAgyTAQtB3AAhAgx5C0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMkwELQdsAIQIMeQsgA0HsADYCHCADIAE2AhQgA0GAGzYCECADQRU2AgxBACECDJEBCyADLQApIgBBI0kNACAAQS5GDQAgA0EANgIcIAMgATYCFCADQckJNgIQIANBCDYCDEEAIQIMkAELQdoAIQIMdgsgASAERgRAQesAIQIMjwELAkAgAS0AAEEvRgRAIAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANBsjg2AhAgA0EINgIMQQAhAgyPAQtB2QAhAgx1CyABIARHBEAgA0EONgIIIAMgATYCBEHYACECDHULQeoAIQIMjQELIAEgBEYEQEHpACECDI0BCyABLQAAQTBrIgBB/wFxQQpJBEAgAyAAOgAqIAFBAWohAUHXACECDHQLIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ16IANB6AA2AhwgAyABNgIUIAMgADYCDEEAIQIMjAELIAEgBEYEQEHnACECDIwBCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDXsgA0HmADYCHCADIAE2AhQgAyAANgIMQQAhAgyMAQtB1gAhAgxyCyABIARGBEBB5QAhAgyLAQtBACEAQQEhBUEBIQdBACECAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkAgAS0AAEEwaw4KCgkAAQIDBAUGCAsLQQIMBgtBAwwFC0EEDAQLQQUMAwtBBgwCC0EHDAELQQgLIQJBACEFQQAhBwwCC0EJIQJBASEAQQAhBUEAIQcMAQtBACEFQQEhAgsgAyACOgArIAFBAWohAQJAAkAgAy0ALkEQcQ0AAkACQAJAIAMtACoOAwEAAgQLIAdFDQMMAgsgAA0BDAILIAVFDQELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANB4gA2AhwgAyABNgIUIAMgADYCDEEAIQIMjQELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ19IANB4wA2AhwgAyABNgIUIAMgADYCDEEAIQIMjAELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ17IANB5AA2AhwgAyABNgIUIAMgADYCDAyLAQtB1AAhAgxxCyADLQApQSJGDYYBQdMAIQIMcAtBACEAAkAgAygCOCICRQ0AIAIoAkQiAkUNACADIAIRAAAhAAsgAEUEQEHVACECDHALIABBFUcEQCADQQA2AhwgAyABNgIUIANBpA02AhAgA0EhNgIMQQAhAgyJAQsgA0HhADYCHCADIAE2AhQgA0HQGjYCECADQRU2AgxBACECDIgBCyABIARGBEBB4AAhAgyIAQsCQAJAAkACQAJAIAEtAABBCmsOBAEEBAAECyABQQFqIQEMAQsgAUEBaiEBIANBL2otAABBAXFFDQELQdIAIQIMcAsgA0EANgIcIAMgATYCFCADQbYRNgIQIANBCTYCDEEAIQIMiAELIANBADYCHCADIAE2AhQgA0G2ETYCECADQQk2AgxBACECDIcBCyABIARGBEBB3wAhAgyHAQsgAS0AAEEKRgRAIAFBAWohAQwJCyADLQAuQcAAcQ0IIANBADYCHCADIAE2AhQgA0G2ETYCECADQQI2AgxBACECDIYBCyABIARGBEBB3QAhAgyGAQsgAS0AACICQQ1GBEAgAUEBaiEBQdAAIQIMbQsgASEAIAJBCWsOBAUBAQUBCyAEIAEiAEYEQEHcACECDIUBCyAALQAAQQpHDQAgAEEBagwCC0EAIQIgA0EANgIcIAMgADYCFCADQcotNgIQIANBBzYCDAyDAQsgASAERgRAQdsAIQIMgwELAkAgAS0AAEEJaw4EAwAAAwALIAFBAWoLIQFBzgAhAgxoCyABIARGBEBB2gAhAgyBAQsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0GaEjYCECADQQc2AgwgAyABQQFqNgIUDH8LIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjgiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HqGjYCECADQRU2AgxBACECDH4LQc0AIQIMZAsgA0EANgIcIAMgATYCFCADQckNNgIQIANBGjYCDEEAIQIMfAsgASAERgRAQdkAIQIMfAsgAS0AAEEgRw09IAFBAWohASADLQAuQQFxDT0gA0EANgIcIAMgATYCFCADQcIcNgIQIANBHjYCDEEAIQIMewsgASAERgRAQdgAIQIMewsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUEsIQIMZQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0HnETYCECADQQo2AgxBACECDH0LIAFBAWohASADQS9qLQAAQQFxRQ1zIAMtADJBgAFxRQRAIANBMmohAiADEDVBACEAAkAgAygCOCIGRQ0AIAYoAigiBkUNACADIAYRAAAhAAsCQAJAIAAOFk1MSwEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBrBk2AhAgA0EVNgIMQQAhAgx+CyADQQA2AhwgAyABNgIUIANB5Qs2AhAgA0ERNgIMQQAhAgx9C0EAIQACQCADKAI4IgJFDQAgAigCXCICRQ0AIAMgAhEAACEACyAARQ1ZIABBFUcNASADQQU2AhwgAyABNgIUIANBmxs2AhAgA0EVNgIMQQAhAgx8C0HLACECDGILQQAhAiADQQA2AhwgAyABNgIUIANBkA42AhAgA0EUNgIMDHoLIAMgAy8BMkGAAXI7ATIMOwsgASAERwRAIANBETYCCCADIAE2AgRBygAhAgxgC0HXACECDHgLIAEgBEYEQEHWACECDHgLAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAQEBAQEBAQEBAQEBAAUBAQAIDQAsgAUEBaiEBQcYAIQIMYQsgAUEBaiEBQccAIQIMYAsgAUEBaiEBQcgAIQIMXwsgAUEBaiEBQckAIQIMXgtB1QAhAiAEIAEiAEYNdiAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQZDIAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHYLQdQAIQIgBCABIgBGDXUgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGAyABqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAx1C0HTACECIAQgASIARg10IAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFB4scAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMdAtB0gAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQeDHAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHMLIAEgBEYEQEHRACECDHMLAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA5OTk5OQE5CyABQQFqIQFBwwAhAgxaCyABQQFqIQFBxAAhAgxZCyADQQA2AgAgBkEBaiEBQcUAIQIMWAtB0AAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQdbHAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHALQc8AIQIgBCABIgBGDW8gBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUHQxwBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxvCyAAIQEgA0EANgIADDMLQQELOgAsIANBADYCACAHQQFqIQELQS0hAgxSCwJAA0AgAS0AAEHQxQBqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMawtBwgAhAgxRCyABIARGBEBBzAAhAgxqCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAwIgBFDTMgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxqCyADQQA2AhwgAyABNgIUIANB5xE2AhAgA0EKNgIMQQAhAgxpCwJAAkAgAy0ALEECaw4CAAEnCyADQTNqLQAAQQJxRQ0mIAMtAC5BAnENJiADQQA2AhwgAyABNgIUIANBphQ2AhAgA0ELNgIMQQAhAgxpCyADLQAyQSBxRQ0lIAMtAC5BAnENJSADQQA2AhwgAyABNgIUIANBvRM2AhAgA0EPNgIMQQAhAgxoC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAARQRAQcEAIQIMTwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0GmDzYCECADQRw2AgxBACECDGgLIANBygA2AhwgAyABNgIUIANBhRw2AhAgA0EVNgIMQQAhAgxnCyABIARHBEAgASECA0AgBCACIgFrQRBOBEAgAUEQaiEC/Qz/////////////////////IAH9AAAAIg1BB/1sIA39DODg4ODg4ODg4ODg4ODg4OD9bv0MX19fX19fX19fX19fX19fX/0mIA39DAkJCQkJCQkJCQkJCQkJCQn9I/1Q/VL9ZEF/c2giAEEQRg0BIAAgAWohAQwYCyABIARGBEBBxAAhAgxpCyABLQAAQcDBAGotAABBAUcNFyAEIAFBAWoiAkcNAAtBxAAhAgxnC0HEACECDGYLIAEgBEcEQANAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXEiAEEJRg0AIABBIEYNAAJAAkACQAJAIABB4wBrDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTYhAgxSCyABQQFqIQFBNyECDFELIAFBAWohAUE4IQIMUAsMFQsgBCABQQFqIgFHDQALQTwhAgxmC0E8IQIMZQsgASAERgRAQcgAIQIMZQsgA0ESNgIIIAMgATYCBAJAAkACQAJAAkAgAy0ALEEBaw4EFAABAgkLIAMtADJBIHENA0HgASECDE8LAkAgAy8BMiIAQQhxRQ0AIAMtAChBAUcNACADLQAuQQhxRQ0CCyADIABB9/sDcUGABHI7ATIMCwsgAyADLwEyQRByOwEyDAQLIANBADYCBCADIAEgARAxIgAEQCADQcEANgIcIAMgADYCDCADIAFBAWo2AhRBACECDGYLIAFBAWohAQxYCyADQQA2AhwgAyABNgIUIANB9BM2AhAgA0EENgIMQQAhAgxkC0HHACECIAEgBEYNYyADKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIABBwMUAai0AACABLQAAQSByRw0BIABBBkYNSiAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAxkCyADQQA2AgAMBQsCQCABIARHBEADQCABLQAAQcDDAGotAAAiAEEBRwRAIABBAkcNAyABQQFqIQEMBQsgBCABQQFqIgFHDQALQcUAIQIMZAtBxQAhAgxjCwsgA0EAOgAsDAELQQshAgxHC0E/IQIMRgsCQAJAA0AgAS0AACIAQSBHBEACQCAAQQprDgQDBQUDAAsgAEEsRg0DDAQLIAQgAUEBaiIBRw0AC0HGACECDGALIANBCDoALAwOCyADLQAoQQFHDQIgAy0ALkEIcQ0CIAMoAgQhACADQQA2AgQgAyAAIAEQMSIABEAgA0HCADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxfCyABQQFqIQEMUAtBOyECDEQLAkADQCABLQAAIgBBIEcgAEEJR3ENASAEIAFBAWoiAUcNAAtBwwAhAgxdCwtBPCECDEILAkACQCABIARHBEADQCABLQAAIgBBIEcEQCAAQQprDgQDBAQDBAsgBCABQQFqIgFHDQALQT8hAgxdC0E/IQIMXAsgAyADLwEyQSByOwEyDAoLIAMoAgQhACADQQA2AgQgAyAAIAEQMSIARQ1OIANBPjYCHCADIAE2AhQgAyAANgIMQQAhAgxaCwJAIAEgBEcEQANAIAEtAABBwMMAai0AACIAQQFHBEAgAEECRg0DDAwLIAQgAUEBaiIBRw0AC0E3IQIMWwtBNyECDFoLIAFBAWohAQwEC0E7IQIgBCABIgBGDVggBCABayADKAIAIgFqIQYgACABa0EFaiEHAkADQCABQZDIAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEFRgRAQQchAQw/CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxZCyADQQA2AgAgACEBDAULQTohAiAEIAEiAEYNVyAEIAFrIAMoAgAiAWohBiAAIAFrQQhqIQcCQANAIAFBtMEAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQhGBEBBBSEBDD4LIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFgLIANBADYCACAAIQEMBAtBOSECIAQgASIARg1WIAQgAWsgAygCACIBaiEGIAAgAWtBA2ohBwJAA0AgAUGwwQBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMPQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVwsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMVgsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPiECDDsLIANBADoALAtBOSECDDkLIAEgBEYEQEE2IQIMUgsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMVQsgAygCBCEAIANBADYCBCADIAAgARAxIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxUCyADLQAuQQFxBEBB3wEhAgw7CyADKAIEIQAgA0EANgIEIAMgACABEDEiAA0BDEkLQTQhAgw5CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMUQtBNSECDDcLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB6xY2AhAgA0EZNgIMQQAhAgxPC0EzIQIMNQsgASAERgRAQTIhAgxOCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZIXNgIQIANBAzYCDEEAIQIMTgtBMiECDDQLIAEgBEYEQEExIQIMTQsCQCABLQAAIgBBCUYNACAAQSBGDQBBASECAkAgAy0ALEEFaw4EBgQFAA0LIAMgAy8BMkEIcjsBMgwMCyADLQAuQQFxRQ0BIAMtACxBCEcNACADQQA6ACwLQT0hAgwyCyADQQA2AhwgAyABNgIUIANBwhY2AhAgA0EKNgIMQQAhAgxKC0ECIQIMAQtBBCECCyADQQE6ACwgAyADLwEyIAJyOwEyDAYLIAEgBEYEQEEwIQIMRwsgAS0AAEEKRgRAIAFBAWohAQwBCyADLQAuQQFxDQAgA0EANgIcIAMgATYCFCADQdwoNgIQIANBAjYCDEEAIQIMRgtBMCECDCwLIAFBAWohAUExIQIMKwsgASAERgRAQS8hAgxECyABLQAAIgBBCUcgAEEgR3FFBEAgAUEBaiEBIAMtAC5BAXENASADQQA2AhwgAyABNgIUIANBlxA2AhAgA0EKNgIMQQAhAgxEC0EBIQICQAJAAkACQAJAAkAgAy0ALEECaw4HBQQEAwECAAQLIAMgAy8BMkEIcjsBMgwDC0ECIQIMAQtBBCECCyADQQE6ACwgAyADLwEyIAJyOwEyC0EvIQIMKwsgA0EANgIcIAMgATYCFCADQYQTNgIQIANBCzYCDEEAIQIMQwtB4QEhAgwpCyABIARGBEBBLiECDEILIANBADYCBCADQRI2AgggAyABIAEQMSIADQELQS4hAgwnCyADQS02AhwgAyABNgIUIAMgADYCDEEAIQIMPwtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HYADYCHCADIAE2AhQgA0GzGzYCECADQRU2AgxBACECDD4LQcwAIQIMJAsgA0EANgIcIAMgATYCFCADQbMONgIQIANBHTYCDEEAIQIMPAsgASAERgRAQc4AIQIMPAsgAS0AACIAQSBGDQIgAEE6Rg0BCyADQQA6ACxBCSECDCELIAMoAgQhACADQQA2AgQgAyAAIAEQMCIADQEMAgsgAy0ALkEBcQRAQd4BIQIMIAsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDQIgA0EqNgIcIAMgADYCDCADIAFBAWo2AhRBACECDDgLIANBywA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMNwsgAUEBaiEBQcAAIQIMHQsgAUEBaiEBDCwLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJcIgJFDQAgAyACEQAAIQALIABFDRIgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GbGzYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0GQDjYCECADQRQ2AgxBACECDDULIANBMmohAiADEDVBACEAAkAgAygCOCIGRQ0AIAYoAigiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKyECDBgLIANBKTYCHCADIAE2AhQgA0GsGTYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HlCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GlCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNkEAR0ECdCEADAELQQBBAyADKQMgUBshAAsgAEEBaw4FAgAHAQMEC0ERIQIMEwsgA0EBOgAxDCkLQQAhAgJAIAMoAjgiAEUNACAAKAIwIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0HSGzYCECADQRU2AgxBACECDCsLQQAhAiADQQA2AhwgAyABNgIUIANB3Q42AhAgA0ESNgIMDCoLIANBADYCHCADIAE2AhQgA0H5IDYCECADQQ82AgxBACECDCkLQQAhAAJAIAMoAjgiAkUNACACKAIwIgJFDQAgAyACEQAAIQALIAANAQtBDiECDA4LIABBFUYEQCADQQI2AhwgAyABNgIUIANB0hs2AhAgA0EVNgIMQQAhAgwnCyADQQA2AhwgAyABNgIUIANB3Q42AhAgA0ESNgIMQQAhAgwmC0EqIQIMDAsgASAERwRAIANBCTYCCCADIAE2AgRBKSECDAwLQSYhAgwkCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwkCyADKAIEIQAgA0EANgIEIAMgACABIAynaiIBEDIiAEUNACADQQU2AhwgAyABNgIUIAMgADYCDEEAIQIMIwtBDyECDAkLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcXFgABAgMEBQYHFBQUFBQUFAgJCgsMDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUDg8QERITFAtCAiEKDBYLQgMhCgwVC0IEIQoMFAtCBSEKDBMLQgYhCgwSC0IHIQoMEQtCCCEKDBALQgkhCgwPC0IKIQoMDgtCCyEKDA0LQgwhCgwMC0INIQoMCwtCDiEKDAoLQg8hCgwJC0IKIQoMCAtCCyEKDAcLQgwhCgwGC0INIQoMBQtCDiEKDAQLQg8hCgwDCyADQQA2AhwgAyABNgIUIANBnxU2AhAgA0EMNgIMQQAhAgwhCyABIARGBEBBIiECDCELQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43FRQAAQIDBAUGBxYWFhYWFhYICQoLDA0WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFg4PEBESExYLQgIhCgwUC0IDIQoMEwtCBCEKDBILQgUhCgwRC0IGIQoMEAtCByEKDA8LQgghCgwOC0IJIQoMDQtCCiEKDAwLQgshCgwLC0IMIQoMCgtCDSEKDAkLQg4hCgwIC0IPIQoMBwtCCiEKDAYLQgshCgwFC0IMIQoMBAtCDSEKDAMLQg4hCgwCC0IPIQoMAQtCASEKCyABQQFqIQEgAykDICILQv//////////D1gEQCADIAtCBIYgCoQ3AyAMAgsgA0EANgIcIAMgATYCFCADQbUJNgIQIANBDDYCDEEAIQIMHgtBJyECDAQLQSghAgwDCyADIAE6ACwgA0EANgIAIAdBAWohAUEMIQIMAgsgA0EANgIAIAZBAWohAUEKIQIMAQsgAUEBaiEBQQghAgwACwALQQAhAiADQQA2AhwgAyABNgIUIANBsjg2AhAgA0EINgIMDBcLQQAhAiADQQA2AhwgAyABNgIUIANBgxE2AhAgA0EJNgIMDBYLQQAhAiADQQA2AhwgAyABNgIUIANB3wo2AhAgA0EJNgIMDBULQQAhAiADQQA2AhwgAyABNgIUIANB7RA2AhAgA0EJNgIMDBQLQQAhAiADQQA2AhwgAyABNgIUIANB0hE2AhAgA0EJNgIMDBMLQQAhAiADQQA2AhwgAyABNgIUIANBsjg2AhAgA0EINgIMDBILQQAhAiADQQA2AhwgAyABNgIUIANBgxE2AhAgA0EJNgIMDBELQQAhAiADQQA2AhwgAyABNgIUIANB3wo2AhAgA0EJNgIMDBALQQAhAiADQQA2AhwgAyABNgIUIANB7RA2AhAgA0EJNgIMDA8LQQAhAiADQQA2AhwgAyABNgIUIANB0hE2AhAgA0EJNgIMDA4LQQAhAiADQQA2AhwgAyABNgIUIANBuRc2AhAgA0EPNgIMDA0LQQAhAiADQQA2AhwgAyABNgIUIANBuRc2AhAgA0EPNgIMDAwLQQAhAiADQQA2AhwgAyABNgIUIANBmRM2AhAgA0ELNgIMDAsLQQAhAiADQQA2AhwgAyABNgIUIANBnQk2AhAgA0ELNgIMDAoLQQAhAiADQQA2AhwgAyABNgIUIANBlxA2AhAgA0EKNgIMDAkLQQAhAiADQQA2AhwgAyABNgIUIANBsRA2AhAgA0EKNgIMDAgLQQAhAiADQQA2AhwgAyABNgIUIANBux02AhAgA0ECNgIMDAcLQQAhAiADQQA2AhwgAyABNgIUIANBlhY2AhAgA0ECNgIMDAYLQQAhAiADQQA2AhwgAyABNgIUIANB+Rg2AhAgA0ECNgIMDAULQQAhAiADQQA2AhwgAyABNgIUIANBxBg2AhAgA0ECNgIMDAQLIANBAjYCHCADIAE2AhQgA0GpHjYCECADQRY2AgxBACECDAMLQd4AIQIgASAERg0CIAlBCGohByADKAIAIQUCQAJAIAEgBEcEQCAFQZbIAGohCCAEIAVqIAFrIQYgBUF/c0EKaiIFIAFqIQADQCABLQAAIAgtAABHBEBBAiEIDAMLIAVFBEBBACEIIAAhAQwDCyAFQQFrIQUgCEEBaiEIIAQgAUEBaiIBRw0ACyAGIQUgBCEBCyAHQQE2AgAgAyAFNgIADAELIANBADYCACAHIAg2AgALIAcgATYCBCAJKAIMIQACQAJAIAkoAghBAWsOAgQBAAsgA0EANgIcIANBwh42AhAgA0EXNgIMIAMgAEEBajYCFEEAIQIMAwsgA0EANgIcIAMgADYCFCADQdceNgIQIANBCTYCDEEAIQIMAgsgASAERgRAQSghAgwCCyADQQk2AgggAyABNgIEQSchAgwBCyABIARGBEBBASECDAELA0ACQAJAAkAgAS0AAEEKaw4EAAEBAAELIAFBAWohAQwBCyABQQFqIQEgAy0ALkEgcQ0AQQAhAiADQQA2AhwgAyABNgIUIANBoSE2AhAgA0EFNgIMDAILQQEhAiABIARHDQALCyAJQRBqJAAgAkUEQCADKAIMIQAMAQsgAyACNgIcQQAhACADKAIEIgFFDQAgAyABIAQgAygCCBEBACIBRQ0AIAMgBDYCFCADIAE2AgwgASEACyAAC74CAQJ/IABBADoAACAAQeQAaiIBQQFrQQA6AAAgAEEAOgACIABBADoAASABQQNrQQA6AAAgAUECa0EAOgAAIABBADoAAyABQQRrQQA6AABBACAAa0EDcSIBIABqIgBBADYCAEHkACABa0F8cSICIABqIgFBBGtBADYCAAJAIAJBCUkNACAAQQA2AgggAEEANgIEIAFBCGtBADYCACABQQxrQQA2AgAgAkEZSQ0AIABBADYCGCAAQQA2AhQgAEEANgIQIABBADYCDCABQRBrQQA2AgAgAUEUa0EANgIAIAFBGGtBADYCACABQRxrQQA2AgAgAiAAQQRxQRhyIgJrIgFBIEkNACAAIAJqIQADQCAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAgAEEgaiEAIAFBIGsiAUEfSw0ACwsLVgEBfwJAIAAoAgwNAAJAAkACQAJAIAAtADEOAwEAAwILIAAoAjgiAUUNACABKAIwIgFFDQAgACABEQAAIgENAwtBAA8LAAsgAEHKGTYCEEEOIQELIAELGgAgACgCDEUEQCAAQd4fNgIQIABBFTYCDAsLFAAgACgCDEEVRgRAIABBADYCDAsLFAAgACgCDEEWRgRAIABBADYCDAsLBwAgACgCDAsHACAAKAIQCwkAIAAgATYCEAsHACAAKAIUCysAAkAgAEEnTw0AQv//////CSAArYhCAYNQDQAgAEECdEHQOGooAgAPCwALFwAgAEEvTwRAAAsgAEECdEHsOWooAgALvwkBAX9B9C0hAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HqLA8LQZgmDwtB7TEPC0GgNw8LQckpDwtBtCkPC0GWLQ8LQesrDwtBojUPC0HbNA8LQeApDwtB4yQPC0HVJA8LQe4kDwtB5iUPC0HKNA8LQdA3DwtBqjUPC0H1LA8LQfYmDwtBgiIPC0HyMw8LQb4oDwtB5zcPC0HNIQ8LQcAhDwtBuCUPC0HLJQ8LQZYkDwtBjzQPC0HNNQ8LQd0qDwtB7jMPC0GcNA8LQZ4xDwtB9DUPC0HlIg8LQa8lDwtBmTEPC0GyNg8LQfk2DwtBxDIPC0HdLA8LQYIxDwtBwTEPC0GNNw8LQckkDwtB7DYPC0HnKg8LQcgjDwtB4iEPC0HJNw8LQaUiDwtBlCIPC0HbNg8LQd41DwtBhiYPC0G8Kw8LQYsyDwtBoCMPC0H2MA8LQYAsDwtBiSsPC0GkJg8LQfIjDwtBgSgPC0GrMg8LQesnDwtBwjYPC0GiJA8LQc8qDwtB3CMPC0GHJw8LQeQ0DwtBtyIPC0GtMQ8LQdUiDwtBrzQPC0HeJg8LQdYyDwtB9DQPC0GBOA8LQfQ3DwtBkjYPC0GdJw8LQYIpDwtBjSMPC0HXMQ8LQb01DwtBtDcPC0HYMA8LQbYnDwtBmjgPC0GnKg8LQcQnDwtBriMPC0H1Ig8LAAtByiYhAQsgAQsXACAAIAAvAS5B/v8DcSABQQBHcjsBLgsaACAAIAAvAS5B/f8DcSABQQBHQQF0cjsBLgsaACAAIAAvAS5B+/8DcSABQQBHQQJ0cjsBLgsaACAAIAAvAS5B9/8DcSABQQBHQQN0cjsBLgsaACAAIAAvAS5B7/8DcSABQQBHQQR0cjsBLgsaACAAIAAvAS5B3/8DcSABQQBHQQV0cjsBLgsaACAAIAAvAS5Bv/8DcSABQQBHQQZ0cjsBLgsaACAAIAAvAS5B//4DcSABQQBHQQd0cjsBLgsaACAAIAAvAS5B//0DcSABQQBHQQh0cjsBLgsaACAAIAAvAS5B//sDcSABQQBHQQl0cjsBLgs+AQJ/AkAgACgCOCIDRQ0AIAMoAgQiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQeESNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAggiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQfwRNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAgwiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQewKNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhAiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQfoeNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhQiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQcsQNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhgiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQbcfNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhwiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQb8VNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAiwiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQf4INgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAiAiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQYwdNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAiQiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQeYVNgIQQRghBAsgBAs4ACAAAn8gAC8BMkEUcUEURgRAQQEgAC0AKEEBRg0BGiAALwE0QeUARgwBCyAALQApQQVGCzoAMAtZAQJ/AkAgAC0AKEEBRg0AIAAvATQiAUHkAGtB5ABJDQAgAUHMAUYNACABQbACRg0AIAAvATIiAEHAAHENAEEBIQIgAEGIBHFBgARGDQAgAEEocUUhAgsgAguMAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQAgAC8BMiIBQQJxRQ0BDAILIAAvATIiAUEBcUUNAQtBASECIAAtAChBAUYNACAALwE0IgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNACABQcAAcQ0AQQAhAiABQYgEcUGABEYNACABQShxQQBHIQILIAILcwAgAEEQav0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAEEwav0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAEEgav0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAEH9ATYCHAsGACAAEDoLmi0BC38jAEEQayIKJABB3NUAKAIAIglFBEBBnNkAKAIAIgVFBEBBqNkAQn83AgBBoNkAQoCAhICAgMAANwIAQZzZACAKQQhqQXBxQdiq1aoFcyIFNgIAQbDZAEEANgIAQYDZAEEANgIAC0GE2QBBwNkENgIAQdTVAEHA2QQ2AgBB6NUAIAU2AgBB5NUAQX82AgBBiNkAQcCmAzYCAANAIAFBgNYAaiABQfTVAGoiAjYCACACIAFB7NUAaiIDNgIAIAFB+NUAaiADNgIAIAFBiNYAaiABQfzVAGoiAzYCACADIAI2AgAgAUGQ1gBqIAFBhNYAaiICNgIAIAIgAzYCACABQYzWAGogAjYCACABQSBqIgFBgAJHDQALQczZBEGBpgM2AgBB4NUAQazZACgCADYCAEHQ1QBBgKYDNgIAQdzVAEHI2QQ2AgBBzP8HQTg2AgBByNkEIQkLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAU0EQEHE1QAoAgAiBkEQIABBE2pBcHEgAEELSRsiBEEDdiIAdiIBQQNxBEACQCABQQFxIAByQQFzIgJBA3QiAEHs1QBqIgEgAEH01QBqKAIAIgAoAggiA0YEQEHE1QAgBkF+IAJ3cTYCAAwBCyABIAM2AgggAyABNgIMCyAAQQhqIQEgACACQQN0IgJBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMEQtBzNUAKAIAIgggBE8NASABBEACQEECIAB0IgJBACACa3IgASAAdHFoIgBBA3QiAkHs1QBqIgEgAkH01QBqKAIAIgIoAggiA0YEQEHE1QAgBkF+IAB3cSIGNgIADAELIAEgAzYCCCADIAE2AgwLIAIgBEEDcjYCBCAAQQN0IgAgBGshBSAAIAJqIAU2AgAgAiAEaiIEIAVBAXI2AgQgCARAIAhBeHFB7NUAaiEAQdjVACgCACEDAn9BASAIQQN2dCIBIAZxRQRAQcTVACABIAZyNgIAIAAMAQsgACgCCAsiASADNgIMIAAgAzYCCCADIAA2AgwgAyABNgIICyACQQhqIQFB2NUAIAQ2AgBBzNUAIAU2AgAMEQtByNUAKAIAIgtFDQEgC2hBAnRB9NcAaigCACIAKAIEQXhxIARrIQUgACECA0ACQCACKAIQIgFFBEAgAkEUaigCACIBRQ0BCyABKAIEQXhxIARrIgMgBUkhAiADIAUgAhshBSABIAAgAhshACABIQIMAQsLIAAoAhghCSAAKAIMIgMgAEcEQEHU1QAoAgAaIAMgACgCCCIBNgIIIAEgAzYCDAwQCyAAQRRqIgIoAgAiAUUEQCAAKAIQIgFFDQMgAEEQaiECCwNAIAIhByABIgNBFGoiAigCACIBDQAgA0EQaiECIAMoAhAiAQ0ACyAHQQA2AgAMDwtBfyEEIABBv39LDQAgAEETaiIBQXBxIQRByNUAKAIAIghFDQBBACAEayEFAkACQAJAAn9BACAEQYACSQ0AGkEfIARB////B0sNABogBEEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+agsiBkECdEH01wBqKAIAIgJFBEBBACEBQQAhAwwBC0EAIQEgBEEZIAZBAXZrQQAgBkEfRxt0IQBBACEDA0ACQCACKAIEQXhxIARrIgcgBU8NACACIQMgByIFDQBBACEFIAIhAQwDCyABIAJBFGooAgAiByAHIAIgAEEddkEEcWpBEGooAgAiAkYbIAEgBxshASAAQQF0IQAgAg0ACwsgASADckUEQEEAIQNBAiAGdCIAQQAgAGtyIAhxIgBFDQMgAGhBAnRB9NcAaigCACEBCyABRQ0BCwNAIAEoAgRBeHEgBGsiAiAFSSEAIAIgBSAAGyEFIAEgAyAAGyEDIAEoAhAiAAR/IAAFIAFBFGooAgALIgENAAsLIANFDQAgBUHM1QAoAgAgBGtPDQAgAygCGCEHIAMgAygCDCIARwRAQdTVACgCABogACADKAIIIgE2AgggASAANgIMDA4LIANBFGoiAigCACIBRQRAIAMoAhAiAUUNAyADQRBqIQILA0AgAiEGIAEiAEEUaiICKAIAIgENACAAQRBqIQIgACgCECIBDQALIAZBADYCAAwNC0HM1QAoAgAiAyAETwRAQdjVACgCACEBAkAgAyAEayICQRBPBEAgASAEaiIAIAJBAXI2AgQgASADaiACNgIAIAEgBEEDcjYCBAwBCyABIANBA3I2AgQgASADaiIAIAAoAgRBAXI2AgRBACEAQQAhAgtBzNUAIAI2AgBB2NUAIAA2AgAgAUEIaiEBDA8LQdDVACgCACIDIARLBEAgBCAJaiIAIAMgBGsiAUEBcjYCBEHc1QAgADYCAEHQ1QAgATYCACAJIARBA3I2AgQgCUEIaiEBDA8LQQAhASAEAn9BnNkAKAIABEBBpNkAKAIADAELQajZAEJ/NwIAQaDZAEKAgISAgIDAADcCAEGc2QAgCkEMakFwcUHYqtWqBXM2AgBBsNkAQQA2AgBBgNkAQQA2AgBBgIAECyIAIARBxwBqIgVqIgZBACAAayIHcSICTwRAQbTZAEEwNgIADA8LAkBB/NgAKAIAIgFFDQBB9NgAKAIAIgggAmohACAAIAFNIAAgCEtxDQBBACEBQbTZAEEwNgIADA8LQYDZAC0AAEEEcQ0EAkACQCAJBEBBhNkAIQEDQCABKAIAIgAgCU0EQCAAIAEoAgRqIAlLDQMLIAEoAggiAQ0ACwtBABA7IgBBf0YNBSACIQZBoNkAKAIAIgFBAWsiAyAAcQRAIAIgAGsgACADakEAIAFrcWohBgsgBCAGTw0FIAZB/v///wdLDQVB/NgAKAIAIgMEQEH02AAoAgAiByAGaiEBIAEgB00NBiABIANLDQYLIAYQOyIBIABHDQEMBwsgBiADayAHcSIGQf7///8HSw0EIAYQOyEAIAAgASgCACABKAIEakYNAyAAIQELAkAgBiAEQcgAak8NACABQX9GDQBBpNkAKAIAIgAgBSAGa2pBACAAa3EiAEH+////B0sEQCABIQAMBwsgABA7QX9HBEAgACAGaiEGIAEhAAwHC0EAIAZrEDsaDAQLIAEiAEF/Rw0FDAMLQQAhAwwMC0EAIQAMCgsgAEF/Rw0CC0GA2QBBgNkAKAIAQQRyNgIACyACQf7///8HSw0BIAIQOyEAQQAQOyEBIABBf0YNASABQX9GDQEgACABTw0BIAEgAGsiBiAEQThqTQ0BC0H02ABB9NgAKAIAIAZqIgE2AgBB+NgAKAIAIAFJBEBB+NgAIAE2AgALAkACQAJAQdzVACgCACICBEBBhNkAIQEDQCAAIAEoAgAiAyABKAIEIgVqRg0CIAEoAggiAQ0ACwwCC0HU1QAoAgAiAUEARyAAIAFPcUUEQEHU1QAgADYCAAtBACEBQYjZACAGNgIAQYTZACAANgIAQeTVAEF/NgIAQejVAEGc2QAoAgA2AgBBkNkAQQA2AgADQCABQYDWAGogAUH01QBqIgI2AgAgAiABQezVAGoiAzYCACABQfjVAGogAzYCACABQYjWAGogAUH81QBqIgM2AgAgAyACNgIAIAFBkNYAaiABQYTWAGoiAjYCACACIAM2AgAgAUGM1gBqIAI2AgAgAUEgaiIBQYACRw0AC0F4IABrQQ9xIgEgAGoiAiAGQThrIgMgAWsiAUEBcjYCBEHg1QBBrNkAKAIANgIAQdDVACABNgIAQdzVACACNgIAIAAgA2pBODYCBAwCCyAAIAJNDQAgAiADSQ0AIAEoAgxBCHENAEF4IAJrQQ9xIgAgAmoiA0HQ1QAoAgAgBmoiByAAayIAQQFyNgIEIAEgBSAGajYCBEHg1QBBrNkAKAIANgIAQdDVACAANgIAQdzVACADNgIAIAIgB2pBODYCBAwBCyAAQdTVACgCAEkEQEHU1QAgADYCAAsgACAGaiEDQYTZACEBAkACQAJAA0AgAyABKAIARwRAIAEoAggiAQ0BDAILCyABLQAMQQhxRQ0BC0GE2QAhAQNAIAEoAgAiAyACTQRAIAMgASgCBGoiBSACSw0DCyABKAIIIQEMAAsACyABIAA2AgAgASABKAIEIAZqNgIEIABBeCAAa0EPcWoiCSAEQQNyNgIEIANBeCADa0EPcWoiBiAEIAlqIgRrIQEgAiAGRgRAQdzVACAENgIAQdDVAEHQ1QAoAgAgAWoiADYCACAEIABBAXI2AgQMCAtB2NUAKAIAIAZGBEBB2NUAIAQ2AgBBzNUAQczVACgCACABaiIANgIAIAQgAEEBcjYCBCAAIARqIAA2AgAMCAsgBigCBCIFQQNxQQFHDQYgBUF4cSEIIAVB/wFNBEAgBUEDdiEDIAYoAggiACAGKAIMIgJGBEBBxNUAQcTVACgCAEF+IAN3cTYCAAwHCyACIAA2AgggACACNgIMDAYLIAYoAhghByAGIAYoAgwiAEcEQCAAIAYoAggiAjYCCCACIAA2AgwMBQsgBkEUaiICKAIAIgVFBEAgBigCECIFRQ0EIAZBEGohAgsDQCACIQMgBSIAQRRqIgIoAgAiBQ0AIABBEGohAiAAKAIQIgUNAAsgA0EANgIADAQLQXggAGtBD3EiASAAaiIHIAZBOGsiAyABayIBQQFyNgIEIAAgA2pBODYCBCACIAVBNyAFa0EPcWpBP2siAyADIAJBEGpJGyIDQSM2AgRB4NUAQazZACgCADYCAEHQ1QAgATYCAEHc1QAgBzYCACADQRBqQYzZACkCADcCACADQYTZACkCADcCCEGM2QAgA0EIajYCAEGI2QAgBjYCAEGE2QAgADYCAEGQ2QBBADYCACADQSRqIQEDQCABQQc2AgAgBSABQQRqIgFLDQALIAIgA0YNACADIAMoAgRBfnE2AgQgAyADIAJrIgU2AgAgAiAFQQFyNgIEIAVB/wFNBEAgBUF4cUHs1QBqIQACf0HE1QAoAgAiAUEBIAVBA3Z0IgNxRQRAQcTVACABIANyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRB9NcAaiEAQcjVACgCACIDQQEgAXQiBnFFBEAgACACNgIAQcjVACADIAZyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhAwJAA0AgAyIAKAIEQXhxIAVGDQEgAUEddiEDIAFBAXQhASAAIANBBHFqQRBqIgYoAgAiAw0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIIC0HQ1QAoAgAiASAETQ0AQdzVACgCACIAIARqIgIgASAEayIBQQFyNgIEQdDVACABNgIAQdzVACACNgIAIAAgBEEDcjYCBCAAQQhqIQEMCAtBACEBQbTZAEEwNgIADAcLQQAhAAsgB0UNAAJAIAYoAhwiAkECdEH01wBqIgMoAgAgBkYEQCADIAA2AgAgAA0BQcjVAEHI1QAoAgBBfiACd3E2AgAMAgsgB0EQQRQgBygCECAGRhtqIAA2AgAgAEUNAQsgACAHNgIYIAYoAhAiAgRAIAAgAjYCECACIAA2AhgLIAZBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAhqIQEgBiAIaiIGKAIEIQULIAYgBUF+cTYCBCABIARqIAE2AgAgBCABQQFyNgIEIAFB/wFNBEAgAUF4cUHs1QBqIQACf0HE1QAoAgAiAkEBIAFBA3Z0IgFxRQRAQcTVACABIAJyNgIAIAAMAQsgACgCCAsiASAENgIMIAAgBDYCCCAEIAA2AgwgBCABNgIIDAELQR8hBSABQf///wdNBEAgAUEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEFCyAEIAU2AhwgBEIANwIQIAVBAnRB9NcAaiEAQcjVACgCACICQQEgBXQiA3FFBEAgACAENgIAQcjVACACIANyNgIAIAQgADYCGCAEIAQ2AgggBCAENgIMDAELIAFBGSAFQQF2a0EAIAVBH0cbdCEFIAAoAgAhAAJAA0AgACICKAIEQXhxIAFGDQEgBUEddiEAIAVBAXQhBSACIABBBHFqQRBqIgMoAgAiAA0ACyADIAQ2AgAgBCACNgIYIAQgBDYCDCAEIAQ2AggMAQsgAigCCCIAIAQ2AgwgAiAENgIIIARBADYCGCAEIAI2AgwgBCAANgIICyAJQQhqIQEMAgsCQCAHRQ0AAkAgAygCHCIBQQJ0QfTXAGoiAigCACADRgRAIAIgADYCACAADQFByNUAIAhBfiABd3EiCDYCAAwCCyAHQRBBFCAHKAIQIANGG2ogADYCACAARQ0BCyAAIAc2AhggAygCECIBBEAgACABNgIQIAEgADYCGAsgA0EUaigCACIBRQ0AIABBFGogATYCACABIAA2AhgLAkAgBUEPTQRAIAMgBCAFaiIAQQNyNgIEIAAgA2oiACAAKAIEQQFyNgIEDAELIAMgBGoiAiAFQQFyNgIEIAMgBEEDcjYCBCACIAVqIAU2AgAgBUH/AU0EQCAFQXhxQezVAGohAAJ/QcTVACgCACIBQQEgBUEDdnQiBXFFBEBBxNUAIAEgBXI2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEH01wBqIQBBASABdCIEIAhxRQRAIAAgAjYCAEHI1QAgBCAIcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQQCQANAIAQiACgCBEF4cSAFRg0BIAFBHXYhBCABQQF0IQEgACAEQQRxakEQaiIGKAIAIgQNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAsgA0EIaiEBDAELAkAgCUUNAAJAIAAoAhwiAUECdEH01wBqIgIoAgAgAEYEQCACIAM2AgAgAw0BQcjVACALQX4gAXdxNgIADAILIAlBEEEUIAkoAhAgAEYbaiADNgIAIANFDQELIAMgCTYCGCAAKAIQIgEEQCADIAE2AhAgASADNgIYCyAAQRRqKAIAIgFFDQAgA0EUaiABNgIAIAEgAzYCGAsCQCAFQQ9NBEAgACAEIAVqIgFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQsgACAEaiIHIAVBAXI2AgQgACAEQQNyNgIEIAUgB2ogBTYCACAIBEAgCEF4cUHs1QBqIQFB2NUAKAIAIQMCf0EBIAhBA3Z0IgIgBnFFBEBBxNUAIAIgBnI2AgAgAQwBCyABKAIICyICIAM2AgwgASADNgIIIAMgATYCDCADIAI2AggLQdjVACAHNgIAQczVACAFNgIACyAAQQhqIQELIApBEGokACABC0MAIABFBEA/AEEQdA8LAkAgAEH//wNxDQAgAEEASA0AIABBEHZAACIAQX9GBEBBtNkAQTA2AgBBfw8LIABBEHQPCwALC5lCIgBBgAgLDQEAAAAAAAAAAgAAAAMAQZgICwUEAAAABQBBqAgLCQYAAAAHAAAACABB5AgLwjJJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3Byb3RvY29sX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fcHJvdG9jb2wARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBVbmV4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fcHJvdG9jb2xfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX1BST1RPQ09MX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8sIFJUU1AvIG9yIElDRS8A5xUAAK8VAACkEgAAkhoAACYWAACeFAAA2xkAAHkVAAB+EgAA/hQAADYVAAALFgAA2BYAAPMSAABCGAAArBYAABIVAAAUFwAA7xcAAEgUAABxFwAAshoAAGsZAAB+GQAANRQAAIIaAABEFwAA/RYAAB4YAACHFwAAqhkAAJMSAAAHGAAALBcAAMoXAACkFwAA5xUAAOcVAABYFwAAOxgAAKASAAAtHAAAwxEAAEgRAADeEgAAQhMAAKQZAAD9EAAA9xUAAKUVAADvFgAA+BkAAEoWAABWFgAA9RUAAAoaAAAIGgAAARoAAKsVAABCEgAA1xAAAEwRAAAFGQAAVBYAAB4RAADKGQAAyBkAAE4WAAD/GAAAcRQAAPAVAADuFQAAlBkAAPwVAAC/GQAAmxkAAHwUAABDEQAAcBgAAJUUAAAnFAAAGRQAANUSAADUGQAARBYAAPcQAEG5OwsBAQBB0DsL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBuj0LBAEAAAIAQdE9C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEG6PwsEAQAAAgBB0T8LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQbDBAAsNbG9zZWVlcC1hbGl2ZQBBycEACwEBAEHgwQAL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBycMACwEBAEHgwwAL5wEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAQfHFAAteAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBB0McACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQYDIAAsgcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQpTTQ0KDQoAQanIAAsFAQIAAQMAQcDIAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanKAAsFAQIAAQMAQcDKAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanMAAsEAQAAAQBBwcwAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEGpzgALBQECAAEDAEHAzgALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEGp0AALBQEBAAEBAEHA0AALAQEAQdrQAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQanSAAsFAQEAAQEAQcDSAAsBAQBBytIACwYCAAAAAAIAQeHSAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBoNQAC50BTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFVFRQQ0VUU1BBRFRQLw==";
  var wasmBuffer;
  Object.defineProperty(module, "exports", {
    get: () => {
      return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
    }
  });
});

// node_modules/undici/lib/web/fetch/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var corsSafeListedMethods = ["GET", "HEAD", "POST"];
  var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  var nullBodyStatus = [101, 204, 205, 304];
  var redirectStatus = [301, 302, 303, 307, 308];
  var redirectStatusSet = new Set(redirectStatus);
  var badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "4190",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6679",
    "6697",
    "10080"
  ];
  var badPortsSet = new Set(badPorts);
  var referrerPolicyTokens = [
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  var referrerPolicy = [
    "",
    ...referrerPolicyTokens
  ];
  var referrerPolicyTokensSet = new Set(referrerPolicyTokens);
  var requestRedirect = ["follow", "manual", "error"];
  var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  var safeMethodsSet = new Set(safeMethods);
  var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  var requestCredentials = ["omit", "same-origin", "include"];
  var requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  var requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ];
  var requestDuplex = [
    "half"
  ];
  var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  var forbiddenMethodsSet = new Set(forbiddenMethods);
  var subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  var subresourceSet = new Set(subresource);
  module.exports = {
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicyTokens: referrerPolicyTokensSet
  };
});

// node_modules/undici/lib/web/fetch/global.js
var require_global = __commonJS((exports, module) => {
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === undefined) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/encoding/index.js
var require_encoding = __commonJS((exports, module) => {
  var textDecoder = new TextDecoder;
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }
  module.exports = {
    utf8DecodeBytes
  };
});

// node_modules/undici/lib/web/infra/index.js
var require_infra = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { utf8DecodeBytes } = require_encoding();
  function collectASequenceOfCodePoints(condition, input, position) {
    let result2 = "";
    while (position.position < input.length && condition(input[position.position])) {
      result2 += input[position.position];
      position.position++;
    }
    return result2;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  var ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
  function forgivingBase64(data) {
    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data.length;
    if (dataLength % 4 === 0) {
      if (data.charCodeAt(dataLength - 1) === 61) {
        --dataLength;
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
        }
      }
    }
    if (dataLength % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
      return "failure";
    }
    const buffer = Buffer.from(data, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function isASCIIWhitespace(char) {
    return char === 9 || char === 10 || char === 12 || char === 13 || char === 32;
  }
  function isomorphicDecode(input) {
    const length = input.length;
    if ((2 << 15) - 1 > length) {
      return String.fromCharCode.apply(null, input);
    }
    let result2 = "";
    let i = 0;
    let addition = (2 << 15) - 1;
    while (i < length) {
      if (i + addition > length) {
        addition = length - i;
      }
      result2 += String.fromCharCode.apply(null, input.subarray(i, i += addition));
    }
    return result2;
  }
  var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    assert(!invalidIsomorphicEncodeValueRegex.test(input));
    return input;
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      while (lead < str.length && predicate(str.charCodeAt(lead)))
        lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(str.charCodeAt(trail)))
        trail--;
    }
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  function serializeJavascriptValueToJSONString(value) {
    const result2 = JSON.stringify(value);
    if (result2 === undefined) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result2 === "string");
    return result2;
  }
  module.exports = {
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    forgivingBase64,
    isASCIIWhitespace,
    isomorphicDecode,
    isomorphicEncode,
    parseJSONFromBytes,
    removeASCIIWhitespace,
    removeChars,
    serializeJavascriptValueToJSONString
  };
});

// node_modules/undici/lib/web/fetch/data-url.js
var require_data_url = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { forgivingBase64, collectASequenceOfCodePoints, collectASequenceOfCodePointsFast, isomorphicDecode, removeASCIIWhitespace, removeChars } = require_infra();
  var encoder = new TextEncoder;
  var HTTP_TOKEN_CODEPOINTS = /^[-!#$%&'*+.^_|~A-Za-z0-9]+$/u;
  var HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/u;
  var HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/u;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(",", input, position);
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body = stringPercentDecode(encodedBody);
    if (/;(?:\u0020*)base64$/ui.test(mimeType)) {
      const stringBody = isomorphicDecode(body);
      body = forgivingBase64(stringBody);
      if (body === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020+)$/u, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    if (!hashLength && href.endsWith("#")) {
      return serialized.slice(0, -1);
    }
    return serialized;
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  function hexByteToNumber(byte) {
    return byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55;
  }
  function percentDecode(input) {
    const length = input.length;
    const output = new Uint8Array(length);
    let j = 0;
    let i = 0;
    while (i < length) {
      const byte = input[i];
      if (byte !== 37) {
        output[j++] = byte;
      } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
        output[j++] = 37;
      } else {
        output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
        i += 2;
      }
      ++i;
    }
    return length === j ? output : output.subarray(0, j);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position >= input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(";", input, position);
      } else {
        parameterValue = collectASequenceOfCodePointsFast(";", input, position);
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function collectAnHTTPQuotedString(input, position, extractValue = false) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/[\\"]/ug, "\\$&");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    if (mimeType.subtype.endsWith("+json")) {
      return "application/json";
    }
    if (mimeType.subtype.endsWith("+xml")) {
      return "application/xml";
    }
    return "";
  }
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType,
    removeHTTPWhitespace,
    minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS
  };
});

// node_modules/undici/lib/util/runtime-features.js
var require_runtime_features = __commonJS((exports, module) => {
  var lazyLoaders = {
    __proto__: null,
    "node:crypto": () => __require("node:crypto"),
    "node:sqlite": () => __require("node:sqlite"),
    "node:worker_threads": () => __require("node:worker_threads"),
    "node:zlib": () => __require("node:zlib")
  };
  function detectRuntimeFeatureByNodeModule(moduleName) {
    try {
      lazyLoaders[moduleName]();
      return true;
    } catch (err) {
      if (err.code !== "ERR_UNKNOWN_BUILTIN_MODULE" && err.code !== "ERR_NO_CRYPTO") {
        throw err;
      }
      return false;
    }
  }
  function detectRuntimeFeatureByExportedProperty(moduleName, property) {
    const module2 = lazyLoaders[moduleName]();
    return typeof module2[property] !== "undefined";
  }
  var runtimeFeaturesByExportedProperty = ["markAsUncloneable", "zstd"];
  var exportedPropertyLookup = {
    markAsUncloneable: ["node:worker_threads", "markAsUncloneable"],
    zstd: ["node:zlib", "createZstdDecompress"]
  };
  var runtimeFeaturesAsNodeModule = ["crypto", "sqlite"];
  var features = [
    ...runtimeFeaturesAsNodeModule,
    ...runtimeFeaturesByExportedProperty
  ];
  function detectRuntimeFeature(feature) {
    if (runtimeFeaturesAsNodeModule.includes(feature)) {
      return detectRuntimeFeatureByNodeModule(`node:${feature}`);
    } else if (runtimeFeaturesByExportedProperty.includes(feature)) {
      const [moduleName, property] = exportedPropertyLookup[feature];
      return detectRuntimeFeatureByExportedProperty(moduleName, property);
    }
    throw new TypeError(`unknown feature: ${feature}`);
  }

  class RuntimeFeatures {
    #map = new Map;
    clear() {
      this.#map.clear();
    }
    has(feature) {
      return this.#map.get(feature) ?? this.#detectRuntimeFeature(feature);
    }
    set(feature, value) {
      if (features.includes(feature) === false) {
        throw new TypeError(`unknown feature: ${feature}`);
      }
      this.#map.set(feature, value);
    }
    #detectRuntimeFeature(feature) {
      const result2 = detectRuntimeFeature(feature);
      this.#map.set(feature, result2);
      return result2;
    }
  }
  var instance = new RuntimeFeatures;
  exports.runtimeFeatures = instance;
  exports.default = instance;
});

// node_modules/undici/lib/web/webidl/index.js
var require_webidl = __commonJS((exports, module) => {
  var { types, inspect } = __require("node:util");
  var { runtimeFeatures } = require_runtime_features();
  var UNDEFINED = 1;
  var BOOLEAN = 2;
  var STRING = 3;
  var SYMBOL = 4;
  var NUMBER = 5;
  var BIGINT = 6;
  var NULL = 7;
  var OBJECT = 8;
  var FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance]);
  var webidl = {
    converters: {},
    util: {},
    errors: {},
    is: {}
  };
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(opts) {
    const plural = opts.types.length === 1 ? "" : " one of";
    const message = `${opts.argument} could not be converted to` + `${plural}: ${opts.types.join(", ")}.`;
    return webidl.errors.exception({
      header: opts.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I) {
    if (!FunctionPrototypeSymbolHasInstance(I, V)) {
      const err = new TypeError("Illegal invocation");
      err.code = "ERR_INVALID_THIS";
      throw err;
    }
  };
  webidl.brandCheckMultiple = function(List) {
    const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c));
    return (V) => {
      if (prototypes.every((typeCheck) => !typeCheck(V))) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    };
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
        header: ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.MakeTypeAssertion = function(I) {
    return (O) => FunctionPrototypeSymbolHasInstance(I, O);
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return UNDEFINED;
      case "boolean":
        return BOOLEAN;
      case "string":
        return STRING;
      case "symbol":
        return SYMBOL;
      case "number":
        return NUMBER;
      case "bigint":
        return BIGINT;
      case "function":
      case "object": {
        if (V === null) {
          return NULL;
        }
        return OBJECT;
      }
    }
  };
  webidl.util.Types = {
    UNDEFINED,
    BOOLEAN,
    STRING,
    SYMBOL,
    NUMBER,
    BIGINT,
    NULL,
    OBJECT
  };
  webidl.util.TypeValueToString = function(o) {
    switch (webidl.util.Type(o)) {
      case UNDEFINED:
        return "Undefined";
      case BOOLEAN:
        return "Boolean";
      case STRING:
        return "String";
      case SYMBOL:
        return "Symbol";
      case NUMBER:
        return "Number";
      case BIGINT:
        return "BigInt";
      case NULL:
        return "Null";
      case OBJECT:
        return "Object";
    }
  };
  webidl.util.markAsUncloneable = runtimeFeatures.has("markAsUncloneable") ? __require("node:worker_threads").markAsUncloneable : () => {};
  webidl.util.ConvertToInt = function(V, bitLength, signedness, flags) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (webidl.util.HasFlag(flags, webidl.attributes.EnforceRange)) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && webidl.util.HasFlag(flags, webidl.attributes.Clamp)) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.util.Stringify = function(V) {
    const type = webidl.util.Type(V);
    switch (type) {
      case SYMBOL:
        return `Symbol(${V.description})`;
      case OBJECT:
        return inspect(V);
      case STRING:
        return `"${V}"`;
      case BIGINT:
        return `${V}n`;
      default:
        return `${V}`;
    }
  };
  webidl.util.IsResizableArrayBuffer = function(V) {
    if (types.isArrayBuffer(V)) {
      return V.resizable;
    }
    if (types.isSharedArrayBuffer(V)) {
      return V.growable;
    }
    throw webidl.errors.exception({
      header: "IsResizableArrayBuffer",
      message: `"${webidl.util.Stringify(V)}" is not an array buffer.`
    });
  };
  webidl.util.HasFlag = function(flags, attributes) {
    return typeof flags === "number" && (flags & attributes) === attributes;
  };
  webidl.sequenceConverter = function(converter) {
    return (V, prefix, argument, Iterable) => {
      if (webidl.util.Type(V) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
        });
      }
      const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
      const seq = [];
      let index = 0;
      if (method === undefined || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is not iterable.`
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} ("${webidl.util.TypeValueToString(O)}") is not an Object.`
        });
      }
      const result2 = {};
      if (!types.isProxy(O)) {
        const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (const key of keys2) {
          const keyName = webidl.util.Stringify(key);
          const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`);
          const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`);
          result2[typedKey] = typedValue;
        }
        return result2;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result2[typedKey] = typedValue;
        }
      }
      return result2;
    };
  };
  webidl.interfaceConverter = function(TypeCheck, name) {
    return (V, prefix, argument) => {
      if (!TypeCheck(V)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary, prefix, argument) => {
      const dict = {};
      if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (dictionary == null || !Object.hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary?.[key];
        const hasDefault = defaultValue !== undefined;
        if (hasDefault && value === undefined) {
          value = defaultValue();
        }
        if (required || hasDefault || value !== undefined) {
          value = converter(value, prefix, `${argument}.${key}`);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V, prefix, argument) => {
      if (V === null) {
        return V;
      }
      return converter(V, prefix, argument);
    };
  };
  webidl.is.USVString = function(value) {
    return typeof value === "string" && value.isWellFormed();
  };
  webidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream);
  webidl.is.Blob = webidl.util.MakeTypeAssertion(Blob);
  webidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams);
  webidl.is.File = webidl.util.MakeTypeAssertion(File);
  webidl.is.URL = webidl.util.MakeTypeAssertion(URL);
  webidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal);
  webidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort);
  webidl.is.BufferSource = function(V) {
    return types.isArrayBuffer(V) || ArrayBuffer.isView(V) && types.isArrayBuffer(V.buffer);
  };
  webidl.converters.DOMString = function(V, prefix, argument, flags) {
    if (V === null && webidl.util.HasFlag(flags, webidl.attributes.LegacyNullToEmptyString)) {
      return "";
    }
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a DOMString.`
      });
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V, prefix, argument) {
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a ByteString.`
      });
    }
    const x = String(V);
    for (let index = 0;index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
      }
    }
    return x;
  };
  webidl.converters.USVString = function(value) {
    if (typeof value === "string") {
      return value.toWellFormed();
    }
    return `${value}`.toWellFormed();
  };
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "signed", 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned", 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned", 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned short"] = function(V, prefix, argument, flags) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", flags, prefix, argument);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBuffer"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a resizable ArrayBuffer.`
      });
    }
    return V;
  };
  webidl.converters.SharedArrayBuffer = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isSharedArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["SharedArrayBuffer"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a resizable SharedArrayBuffer.`
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: [T.name]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a shared array buffer.`
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a resizable array buffer.`
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["DataView"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a shared array buffer.`
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a resizable array buffer.`
      });
    }
    return V;
  };
  webidl.converters.ArrayBufferView = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isArrayBufferView(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBufferView"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a shared array buffer.`
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a resizable array buffer.`
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, prefix, argument, flags) {
    if (types.isArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, argument, flags);
    }
    if (types.isArrayBufferView(V)) {
      flags &= ~webidl.attributes.AllowShared;
      return webidl.converters.ArrayBufferView(V, prefix, argument, flags);
    }
    if (types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a SharedArrayBuffer.`
      });
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${argument} ("${webidl.util.Stringify(V)}")`,
      types: ["ArrayBuffer", "ArrayBufferView"]
    });
  };
  webidl.converters.AllowSharedBufferSource = function(V, prefix, argument, flags) {
    if (types.isArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, argument, flags);
    }
    if (types.isSharedArrayBuffer(V)) {
      return webidl.converters.SharedArrayBuffer(V, prefix, argument, flags);
    }
    if (types.isArrayBufferView(V)) {
      flags |= webidl.attributes.AllowShared;
      return webidl.converters.ArrayBufferView(V, prefix, argument, flags);
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${argument} ("${webidl.util.Stringify(V)}")`,
      types: ["ArrayBuffer", "SharedArrayBuffer", "ArrayBufferView"]
    });
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  webidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, "Blob");
  webidl.converters.AbortSignal = webidl.interfaceConverter(webidl.is.AbortSignal, "AbortSignal");
  webidl.converters.EventHandlerNonNull = function(V) {
    if (webidl.util.Type(V) !== OBJECT) {
      return null;
    }
    if (typeof V === "function") {
      return V;
    }
    return () => {};
  };
  webidl.attributes = {
    Clamp: 1 << 0,
    EnforceRange: 1 << 1,
    AllowShared: 1 << 2,
    AllowResizable: 1 << 3,
    LegacyNullToEmptyString: 1 << 4
  };
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/web/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var zlib = __require("node:zlib");
  var { redirectStatusSet, referrerPolicyTokens, badPortsSet } = require_constants3();
  var { getGlobalOrigin } = require_global();
  var { collectAnHTTPQuotedString, parseMIMEType } = require_data_url();
  var { performance: performance2 } = __require("node:perf_hooks");
  var { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require_util();
  var assert = __require("node:assert");
  var { isUint8Array } = __require("node:util/types");
  var { webidl } = require_webidl();
  var { isomorphicEncode, collectASequenceOfCodePoints, removeChars } = require_infra();
  function responseURL(response) {
    const urlList = response.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status)) {
      return null;
    }
    let location = response.headersList.get("location", true);
    if (location !== null && isValidHeaderValue(location)) {
      if (!isValidEncodedURL(location)) {
        location = normalizeBinaryStringToUtf8(location);
      }
      location = new URL(location, responseURL(response));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function isValidEncodedURL(url) {
    for (let i = 0;i < url.length; ++i) {
      const code = url.charCodeAt(i);
      if (code > 126 || code < 32) {
        return false;
      }
    }
    return true;
  }
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  function requestBadPort(request) {
    const url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  var isValidHeaderName = isValidHTTPToken;
  function isValidHeaderValue(potentialValue) {
    return (potentialValue[0] === "\t" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "\t" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes(`
`) || potentialValue.includes("\r") || potentialValue.includes("\x00")) === false;
  }
  function parseReferrerPolicy(actualResponse) {
    const policyHeader = (actualResponse.headersList.get("referrer-policy", true) ?? "").split(",");
    let policy = "";
    if (policyHeader.length) {
      for (let i = policyHeader.length;i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    return policy;
  }
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    const policy = parseReferrerPolicy(actualResponse);
    if (policy !== "") {
      request.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header, true);
  }
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (serializedOrigin === "client" || serializedOrigin === undefined) {
      return;
    }
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      request.headersList.append("origin", serializedOrigin, true);
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        default:
      }
      request.headersList.append("origin", serializedOrigin, true);
    }
  }
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
      return {
        domainLookupStartTime: defaultStartTime,
        domainLookupEndTime: defaultStartTime,
        connectionStartTime: defaultStartTime,
        connectionEndTime: defaultStartTime,
        secureConnectionStartTime: defaultStartTime,
        ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
      };
    }
    return {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance2.now(), crossOriginIsolatedCapability);
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request) {
    const policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (webidl.is.URL(request.referrer)) {
      referrerSource = request.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    switch (policy) {
      case "no-referrer":
        return "no-referrer";
      case "origin":
        if (referrerOrigin != null) {
          return referrerOrigin;
        }
        return stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "strict-origin": {
        const currentURL = requestCurrentURL(request);
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "same-origin":
        if (sameOrigin(request, referrerURL)) {
          return referrerURL;
        }
        return "no-referrer";
      case "origin-when-cross-origin":
        if (sameOrigin(request, referrerURL)) {
          return referrerURL;
        }
        return referrerOrigin;
      case "no-referrer-when-downgrade": {
        const currentURL = requestCurrentURL(request);
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerURL;
      }
    }
  }
  function stripURLForReferrer(url, originOnly = false) {
    assert(webidl.is.URL(url));
    url = new URL(url);
    if (urlIsLocal(url)) {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly === true) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  var isPotentialleTrustworthyIPv4 = RegExp.prototype.test.bind(/^127\.(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){2}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$/);
  var isPotentiallyTrustworthyIPv6 = RegExp.prototype.test.bind(/^(?:(?:0{1,4}:){7}|(?:0{1,4}:){1,6}:|::)0{0,3}1$/);
  function isOriginIPPotentiallyTrustworthy(origin) {
    if (origin.includes(":")) {
      if (origin[0] === "[" && origin[origin.length - 1] === "]") {
        origin = origin.slice(1, -1);
      }
      return isPotentiallyTrustworthyIPv6(origin);
    }
    return isPotentialleTrustworthyIPv4(origin);
  }
  function isOriginPotentiallyTrustworthy(origin) {
    if (origin == null || origin === "null") {
      return false;
    }
    origin = new URL(origin);
    if (origin.protocol === "https:" || origin.protocol === "wss:") {
      return true;
    }
    if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {
      return true;
    }
    if (origin.hostname === "localhost" || origin.hostname === "localhost.") {
      return true;
    }
    if (origin.hostname.endsWith(".localhost") || origin.hostname.endsWith(".localhost.")) {
      return true;
    }
    if (origin.protocol === "file:") {
      return true;
    }
    return false;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!webidl.is.URL(url)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:")
      return true;
    if (url.protocol === "blob:")
      return true;
    return isOriginPotentiallyTrustworthy(url.origin);
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
  }
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {

    class FastIterableIterator {
      #target;
      #kind;
      #index;
      constructor(target, kind) {
        this.#target = target;
        this.#kind = kind;
        this.#index = 0;
      }
      next() {
        if (typeof this !== "object" || this === null || !(#target in this)) {
          throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        }
        const index = this.#index;
        const values = kInternalIterator(this.#target);
        const len = values.length;
        if (index >= len) {
          return {
            value: undefined,
            done: true
          };
        }
        const { [keyIndex]: key, [valueIndex]: value } = values[index];
        this.#index = index + 1;
        let result2;
        switch (this.#kind) {
          case "key":
            result2 = key;
            break;
          case "value":
            result2 = value;
            break;
          case "key+value":
            result2 = [key, value];
            break;
        }
        return {
          value: result2,
          done: false
        };
      }
    }
    delete FastIterableIterator.prototype.constructor;
    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
    Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: false,
        enumerable: false,
        configurable: true,
        value: `${name} Iterator`
      },
      next: { writable: true, enumerable: true, configurable: true }
    });
    return function(target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
    const properties = {
      keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function keys() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key");
        }
      },
      values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function values() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "value");
        }
      },
      entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function entries() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key+value");
        }
      },
      forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function forEach(callbackfn, thisArg = globalThis) {
          webidl.brandCheck(this, object);
          webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
          if (typeof callbackfn !== "function") {
            throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);
          }
          for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
            callbackfn.call(thisArg, value, key, this);
          }
        }
      }
    };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: properties.entries.value
      }
    });
  }
  function fullyReadBody(body, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    try {
      const reader = body.stream.getReader();
      readAllBytes(reader, successSteps, errorSteps);
    } catch (e) {
      errorSteps(e);
    }
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
      controller.byobRequest?.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
        throw err;
      }
    }
  }
  async function readAllBytes(reader, successSteps, failureSteps) {
    try {
      const bytes = [];
      let byteLength = 0;
      do {
        const { done, value: chunk } = await reader.read();
        if (done) {
          successSteps(Buffer.concat(bytes, byteLength));
          return;
        }
        if (!isUint8Array(chunk)) {
          failureSteps(new TypeError("Received non-Uint8Array chunk"));
          return;
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      } while (true);
    } catch (e) {
      failureSteps(e);
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  function simpleRangeHeaderValue(value, allowWhitespace) {
    const data = value;
    if (!data.startsWith("bytes")) {
      return "failure";
    }
    const position = { position: 5 };
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    if (data.charCodeAt(position.position) !== 61) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    const rangeStart = collectASequenceOfCodePoints((char) => {
      const code = char.charCodeAt(0);
      return code >= 48 && code <= 57;
    }, data, position);
    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    if (data.charCodeAt(position.position) !== 45) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    const rangeEnd = collectASequenceOfCodePoints((char) => {
      const code = char.charCodeAt(0);
      return code >= 48 && code <= 57;
    }, data, position);
    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    if (position.position < data.length) {
      return "failure";
    }
    if (rangeEndValue === null && rangeStartValue === null) {
      return "failure";
    }
    if (rangeStartValue > rangeEndValue) {
      return "failure";
    }
    return { rangeStartValue, rangeEndValue };
  }
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    contentRange += isomorphicEncode(`${rangeStart}`);
    contentRange += "-";
    contentRange += isomorphicEncode(`${rangeEnd}`);
    contentRange += "/";
    contentRange += isomorphicEncode(`${fullLength}`);
    return contentRange;
  }

  class InflateStream extends Transform {
    #zlibOptions;
    constructor(zlibOptions) {
      super();
      this.#zlibOptions = zlibOptions;
    }
    _transform(chunk, encoding, callback) {
      if (!this._inflateStream) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(this.#zlibOptions) : zlib.createInflateRaw(this.#zlibOptions);
        this._inflateStream.on("data", this.push.bind(this));
        this._inflateStream.on("end", () => this.push(null));
        this._inflateStream.on("error", (err) => this.destroy(err));
      }
      this._inflateStream.write(chunk, encoding, callback);
    }
    _final(callback) {
      if (this._inflateStream) {
        this._inflateStream.end();
        this._inflateStream = null;
      }
      callback();
    }
  }
  function createInflate(zlibOptions) {
    return new InflateStream(zlibOptions);
  }
  function extractMimeType(headers) {
    let charset = null;
    let essence = null;
    let mimeType = null;
    const values = getDecodeSplit("content-type", headers);
    if (values === null) {
      return "failure";
    }
    for (const value of values) {
      const temporaryMimeType = parseMIMEType(value);
      if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
        continue;
      }
      mimeType = temporaryMimeType;
      if (mimeType.essence !== essence) {
        charset = null;
        if (mimeType.parameters.has("charset")) {
          charset = mimeType.parameters.get("charset");
        }
        essence = mimeType.essence;
      } else if (!mimeType.parameters.has("charset") && charset !== null) {
        mimeType.parameters.set("charset", charset);
      }
    }
    if (mimeType == null) {
      return "failure";
    }
    return mimeType;
  }
  function gettingDecodingSplitting(value) {
    const input = value;
    const position = { position: 0 };
    const values = [];
    let temporaryValue = "";
    while (position.position < input.length) {
      temporaryValue += collectASequenceOfCodePoints((char) => char !== '"' && char !== ",", input, position);
      if (position.position < input.length) {
        if (input.charCodeAt(position.position) === 34) {
          temporaryValue += collectAnHTTPQuotedString(input, position);
          if (position.position < input.length) {
            continue;
          }
        } else {
          assert(input.charCodeAt(position.position) === 44);
          position.position++;
        }
      }
      temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
      values.push(temporaryValue);
      temporaryValue = "";
    }
    return values;
  }
  function getDecodeSplit(name, list) {
    const value = list.get(name, true);
    if (value === null) {
      return null;
    }
    return gettingDecodingSplitting(value);
  }
  function hasAuthenticationEntry(request) {
    return false;
  }
  function includesCredentials(url) {
    return !!(url.username && url.password);
  }
  function isTraversableNavigable(navigable) {
    return true;
  }

  class EnvironmentSettingsObjectBase {
    get baseUrl() {
      return getGlobalOrigin();
    }
    get origin() {
      return this.baseUrl?.origin;
    }
    policyContainer = makePolicyContainer();
  }

  class EnvironmentSettingsObject {
    settingsObject = new EnvironmentSettingsObjectBase;
  }
  var environmentSettingsObject = new EnvironmentSettingsObject;
  module.exports = {
    isAborted,
    isCancelled,
    isValidEncodedURL,
    ReadableStreamFrom,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    iteratorMixin,
    createIterator,
    isValidHeaderName,
    isValidHeaderValue,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType,
    getDecodeSplit,
    environmentSettingsObject,
    isOriginIPPotentiallyTrustworthy,
    hasAuthenticationEntry,
    includesCredentials,
    isTraversableNavigable
  };
});

// node_modules/undici/lib/web/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  var { iteratorMixin } = require_util2();
  var { kEnumerableProperty } = require_util();
  var { webidl } = require_webidl();
  var nodeUtil = __require("node:util");

  class FormData {
    #state = [];
    constructor(form = undefined) {
      webidl.util.markAsUncloneable(this);
      if (form !== undefined) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
    }
    append(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.append";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.USVString(name);
      if (arguments.length === 3 || webidl.is.Blob(value)) {
        value = webidl.converters.Blob(value, prefix, "value");
        if (filename !== undefined) {
          filename = webidl.converters.USVString(filename);
        }
      } else {
        value = webidl.converters.USVString(value);
      }
      const entry = makeEntry(name, value, filename);
      this.#state.push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      this.#state = this.#state.filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.get";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      const idx = this.#state.findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this.#state[idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.getAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      return this.#state.filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      return this.#state.findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.set";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.USVString(name);
      if (arguments.length === 3 || webidl.is.Blob(value)) {
        value = webidl.converters.Blob(value, prefix, "value");
        if (filename !== undefined) {
          filename = webidl.converters.USVString(filename);
        }
      } else {
        value = webidl.converters.USVString(value);
      }
      const entry = makeEntry(name, value, filename);
      const idx = this.#state.findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this.#state = [
          ...this.#state.slice(0, idx),
          entry,
          ...this.#state.slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this.#state.push(entry);
      }
    }
    [nodeUtil.inspect.custom](depth, options) {
      const state = this.#state.reduce((a, b) => {
        if (a[b.name]) {
          if (Array.isArray(a[b.name])) {
            a[b.name].push(b.value);
          } else {
            a[b.name] = [a[b.name], b.value];
          }
        } else {
          a[b.name] = b.value;
        }
        return a;
      }, { __proto__: null });
      options.depth ??= depth;
      options.colors ??= true;
      const output = nodeUtil.formatWithOptions(options, state);
      return `FormData ${output.slice(output.indexOf("]") + 2)}`;
    }
    static getFormDataState(formData) {
      return formData.#state;
    }
    static setFormDataState(formData, newState) {
      formData.#state = newState;
    }
  }
  var { getFormDataState, setFormDataState } = FormData;
  Reflect.deleteProperty(FormData, "getFormDataState");
  Reflect.deleteProperty(FormData, "setFormDataState");
  iteratorMixin("FormData", FormData, getFormDataState, "name", "value");
  Object.defineProperties(FormData.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    getAll: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value === "string") {} else {
      if (!webidl.is.File(value)) {
        value = new File([value], "blob", { type: value.type });
      }
      if (filename !== undefined) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = new File([value], filename, options);
      }
    }
    return { name, value };
  }
  webidl.is.FormData = webidl.util.MakeTypeAssertion(FormData);
  module.exports = { FormData, makeEntry, setFormDataState };
});

// node_modules/undici/lib/web/fetch/formdata-parser.js
var require_formdata_parser = __commonJS((exports, module) => {
  var { bufferToLowerCasedHeaderName } = require_util();
  var { HTTP_TOKEN_CODEPOINTS } = require_data_url();
  var { makeEntry } = require_formdata();
  var { webidl } = require_webidl();
  var assert = __require("node:assert");
  var { isomorphicDecode } = require_infra();
  var { utf8DecodeBytes } = require_encoding();
  var dd = Buffer.from("--");
  var decoder = new TextDecoder;
  function isAsciiString(chars) {
    for (let i = 0;i < chars.length; ++i) {
      if ((chars.charCodeAt(i) & ~127) !== 0) {
        return false;
      }
    }
    return true;
  }
  function validateBoundary(boundary) {
    const length = boundary.length;
    if (length < 27 || length > 70) {
      return false;
    }
    for (let i = 0;i < length; ++i) {
      const cp = boundary.charCodeAt(i);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
        return false;
      }
    }
    return true;
  }
  function multipartFormDataParser(input, mimeType) {
    assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    const boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === undefined) {
      throw parsingError("missing boundary in content-type header");
    }
    const boundary = Buffer.from(`--${boundaryString}`, "utf8");
    const entryList = [];
    const position = { position: 0 };
    const firstBoundaryIndex = input.indexOf(boundary);
    if (firstBoundaryIndex === -1) {
      throw parsingError("no boundary found in multipart body");
    }
    position.position = firstBoundaryIndex;
    while (true) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
        position.position += boundary.length;
      } else {
        throw parsingError("expected a value starting with -- and the boundary");
      }
      if (bufferStartsWith(input, dd, position)) {
        return entryList;
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      }
      position.position += 2;
      const result2 = parseMultipartFormDataHeaders(input, position);
      let { name, filename, contentType, encoding } = result2;
      position.position += 2;
      let body;
      {
        const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) {
          throw parsingError("expected boundary after body");
        }
        body = input.subarray(position.position, boundaryIndex - 4);
        position.position += body.length;
        if (encoding === "base64") {
          body = Buffer.from(body.toString(), "base64");
        }
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      } else {
        position.position += 2;
      }
      let value;
      if (filename !== null) {
        contentType ??= "text/plain";
        if (!isAsciiString(contentType)) {
          contentType = "";
        }
        value = new File([body], filename, { type: contentType });
      } else {
        value = utf8DecodeBytes(Buffer.from(body));
      }
      assert(webidl.is.USVString(name));
      assert(typeof value === "string" && webidl.is.USVString(value) || webidl.is.File(value));
      entryList.push(makeEntry(name, value, filename));
    }
  }
  function parseContentDispositionAttribute(input, position) {
    if (input[position.position] === 59) {
      position.position++;
    }
    collectASequenceOfBytes((char) => char === 32 || char === 9, input, position);
    const attributeName = collectASequenceOfBytes((char) => isToken(char) && char !== 61 && char !== 42, input, position);
    if (attributeName.length === 0) {
      return null;
    }
    const attrNameStr = attributeName.toString("ascii").toLowerCase();
    const isExtended = input[position.position] === 42;
    if (isExtended) {
      position.position++;
    }
    if (input[position.position] !== 61) {
      return null;
    }
    position.position++;
    collectASequenceOfBytes((char) => char === 32 || char === 9, input, position);
    let value;
    if (isExtended) {
      const headerValue = collectASequenceOfBytes((char) => char !== 32 && char !== 13 && char !== 10 && char !== 59, input, position);
      if (headerValue[0] !== 117 && headerValue[0] !== 85 || headerValue[1] !== 116 && headerValue[1] !== 84 || headerValue[2] !== 102 && headerValue[2] !== 70 || headerValue[3] !== 45 || headerValue[4] !== 56) {
        throw parsingError("unknown encoding, expected utf-8''");
      }
      value = decodeURIComponent(decoder.decode(headerValue.subarray(7)));
    } else if (input[position.position] === 34) {
      position.position++;
      const quotedValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 34, input, position);
      if (input[position.position] !== 34) {
        throw parsingError("Closing quote not found");
      }
      position.position++;
      value = decoder.decode(quotedValue).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"');
    } else {
      const tokenValue = collectASequenceOfBytes((char) => isToken(char) && char !== 59, input, position);
      value = decoder.decode(tokenValue);
    }
    return { name: attrNameStr, value };
  }
  function parseMultipartFormDataHeaders(input, position) {
    let name = null;
    let filename = null;
    let contentType = null;
    let encoding = null;
    while (true) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) {
        if (name === null) {
          throw parsingError("header name is null");
        }
        return { name, filename, contentType, encoding };
      }
      let headerName = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 58, input, position);
      headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
      if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
        throw parsingError("header name does not match the field-name token production");
      }
      if (input[position.position] !== 58) {
        throw parsingError("expected :");
      }
      position.position++;
      collectASequenceOfBytes((char) => char === 32 || char === 9, input, position);
      switch (bufferToLowerCasedHeaderName(headerName)) {
        case "content-disposition": {
          name = filename = null;
          const dispositionType = collectASequenceOfBytes((char) => isToken(char), input, position);
          if (dispositionType.toString("ascii").toLowerCase() !== "form-data") {
            throw parsingError("expected form-data for content-disposition header");
          }
          while (position.position < input.length && input[position.position] !== 13 && input[position.position + 1] !== 10) {
            const attribute = parseContentDispositionAttribute(input, position);
            if (!attribute) {
              break;
            }
            if (attribute.name === "name") {
              name = attribute.value;
            } else if (attribute.name === "filename") {
              filename = attribute.value;
            }
          }
          if (name === null) {
            throw parsingError("name attribute is required in content-disposition header");
          }
          break;
        }
        case "content-type": {
          let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          contentType = isomorphicDecode(headerValue);
          break;
        }
        case "content-transfer-encoding": {
          let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          encoding = isomorphicDecode(headerValue);
          break;
        }
        default: {
          collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
        }
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      } else {
        position.position += 2;
      }
    }
  }
  function collectASequenceOfBytes(condition, input, position) {
    let start = position.position;
    while (start < input.length && condition(input[start])) {
      ++start;
    }
    return input.subarray(position.position, position.position = start);
  }
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0;
    let trail = buf.length - 1;
    if (leading) {
      while (lead < buf.length && predicate(buf[lead]))
        lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(buf[trail]))
        trail--;
    }
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  function bufferStartsWith(buffer, start, position) {
    if (buffer.length < start.length) {
      return false;
    }
    for (let i = 0;i < start.length; i++) {
      if (start[i] !== buffer[position.position + i]) {
        return false;
      }
    }
    return true;
  }
  function parsingError(cause) {
    return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(cause) });
  }
  function isCTL(char) {
    return char <= 31 || char === 127;
  }
  function isTSpecial(char) {
    return char === 40 || char === 41 || char === 60 || char === 62 || char === 64 || char === 44 || char === 59 || char === 58 || char === 92 || char === 34 || char === 47 || char === 91 || char === 93 || char === 63 || char === 61;
  }
  function isToken(char) {
    return char <= 127 && char !== 32 && char !== 9 && !isCTL(char) && !isTSpecial(char);
  }
  module.exports = {
    multipartFormDataParser,
    validateBoundary
  };
});

// node_modules/undici/lib/util/promise.js
var require_promise = __commonJS((exports, module) => {
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  module.exports = {
    createDeferredPromise
  };
});

// node_modules/undici/lib/web/fetch/body.js
var require_body = __commonJS((exports, module) => {
  var util = require_util();
  var {
    ReadableStreamFrom,
    readableStreamClose,
    fullyReadBody,
    extractMimeType
  } = require_util2();
  var { FormData, setFormDataState } = require_formdata();
  var { webidl } = require_webidl();
  var assert = __require("node:assert");
  var { isErrored, isDisturbed } = __require("node:stream");
  var { isArrayBuffer } = __require("node:util/types");
  var { serializeAMimeType } = require_data_url();
  var { multipartFormDataParser } = require_formdata_parser();
  var { createDeferredPromise } = require_promise();
  var { parseJSONFromBytes } = require_infra();
  var { utf8DecodeBytes } = require_encoding();
  var { runtimeFeatures } = require_runtime_features();
  var random = runtimeFeatures.has("crypto") ? __require("node:crypto").randomInt : (max) => Math.floor(Math.random() * max);
  var textEncoder = new TextEncoder;
  function noop() {}
  var streamRegistry = new FinalizationRegistry((weakRef) => {
    const stream = weakRef.deref();
    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
      stream.cancel("Response object has been garbage collected").catch(noop);
    }
  });
  function extractBody(object, keepalive = false) {
    let stream = null;
    if (webidl.is.ReadableStream(object)) {
      stream = object;
    } else if (webidl.is.Blob(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream({
        pull(controller) {
          const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
          if (buffer.byteLength) {
            controller.enqueue(buffer);
          }
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {},
        type: "bytes"
      });
    }
    assert(webidl.is.ReadableStream(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (webidl.is.URLSearchParams(object)) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (webidl.is.BufferSource(object)) {
      source = isArrayBuffer(object) ? new Uint8Array(object.slice()) : new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (webidl.is.FormData(object)) {
      const boundary = `----formdata-undici-0${`${random(100000000000)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      const formdataEscape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`);
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${formdataEscape(normalizeLinefeeds(name))}"` + `\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${formdataEscape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${formdataEscape(value.name)}"` : "") + `\r
` + `Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--\r
`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = `multipart/form-data; boundary=${boundary}`;
    } else if (webidl.is.Blob(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util.isDisturbed(object) || object.locked) {
        throw new TypeError("Response body object should not be disturbed or locked");
      }
      stream = webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream({
        start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        pull(controller) {
          return iterator.next().then(({ value, done }) => {
            if (done) {
              queueMicrotask(() => {
                controller.close();
                controller.byobRequest?.respond(0);
              });
            } else {
              if (!isErrored(stream)) {
                const buffer = new Uint8Array(value);
                if (buffer.byteLength) {
                  controller.enqueue(buffer);
                }
              }
            }
            return controller.desiredSize > 0;
          });
        },
        cancel(reason) {
          return iterator.return();
        },
        type: "bytes"
      });
    }
    const body = { stream, source, length };
    return [body, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (webidl.is.ReadableStream(object)) {
      assert(!util.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  }
  function cloneBody(body) {
    const { 0: out1, 1: out2 } = body.stream.tee();
    body.stream = out1;
    return {
      stream: out2,
      length: body.length,
      source: body.source
    };
  }
  function bodyMixinMethods(instance, getInternalState) {
    const methods = {
      blob() {
        return consumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(getInternalState(this));
          if (mimeType === null) {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob([bytes], { type: mimeType });
        }, instance, getInternalState);
      },
      arrayBuffer() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance, getInternalState);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance, getInternalState);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance, getInternalState);
      },
      formData() {
        return consumeBody(this, (value) => {
          const mimeType = bodyMimeType(getInternalState(this));
          if (mimeType !== null) {
            switch (mimeType.essence) {
              case "multipart/form-data": {
                const parsed = multipartFormDataParser(value, mimeType);
                const fd = new FormData;
                setFormDataState(fd, parsed);
                return fd;
              }
              case "application/x-www-form-urlencoded": {
                const entries = new URLSearchParams(value.toString());
                const fd = new FormData;
                for (const [name, value2] of entries) {
                  fd.append(name, value2);
                }
                return fd;
              }
            }
          }
          throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
        }, instance, getInternalState);
      },
      bytes() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes);
        }, instance, getInternalState);
      }
    };
    return methods;
  }
  function mixinBody(prototype, getInternalState) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState));
  }
  function consumeBody(object, convertBytesToJSValue, instance, getInternalState) {
    try {
      webidl.brandCheck(object, instance);
    } catch (e) {
      return Promise.reject(e);
    }
    const state = getInternalState(object);
    if (bodyUnusable(state)) {
      return Promise.reject(new TypeError("Body is unusable: Body has already been read"));
    }
    if (state.aborted) {
      return Promise.reject(new DOMException("The operation was aborted.", "AbortError"));
    }
    const promise = createDeferredPromise();
    const errorSteps = promise.reject;
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (state.body == null) {
      successSteps(Buffer.allocUnsafe(0));
      return promise.promise;
    }
    fullyReadBody(state.body, successSteps, errorSteps);
    return promise.promise;
  }
  function bodyUnusable(object) {
    const body = object.body;
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  function bodyMimeType(requestOrResponse) {
    const headers = requestOrResponse.headersList;
    const mimeType = extractMimeType(headers);
    if (mimeType === "failure") {
      return null;
    }
    return mimeType;
  }
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody,
    streamRegistry,
    bodyUnusable
  };
});

// node_modules/undici/lib/dispatcher/client-h1.js
var require_client_h1 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var util = require_util();
  var { channels } = require_diagnostics();
  var timers = require_timers();
  var {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kClient,
    kParser,
    kBlocking,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kMaxRequests,
    kCounter,
    kMaxResponseSize,
    kOnError,
    kResume,
    kHTTPContext,
    kClosed
  } = require_symbols();
  var constants = require_constants2();
  var EMPTY_BUF = Buffer.alloc(0);
  var FastBuffer = Buffer[Symbol.species];
  var removeAllListeners = util.removeAllListeners;
  var extractBody;
  function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : undefined;
    let mod;
    let useWasmSIMD = process.arch !== "ppc64";
    if (process.env.UNDICI_NO_WASM_SIMD === "1") {
      useWasmSIMD = true;
    } else if (process.env.UNDICI_NO_WASM_SIMD === "0") {
      useWasmSIMD = false;
    }
    if (useWasmSIMD) {
      try {
        mod = new WebAssembly.Module(require_llhttp_simd_wasm());
      } catch {}
    }
    if (!mod) {
      mod = new WebAssembly.Module(llhttpWasmData || require_llhttp_wasm());
    }
    return new WebAssembly.Instance(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        wasm_on_message_begin: (p) => {
          assert(currentParser.ptr === p);
          return currentParser.onMessageBegin();
        },
        wasm_on_header_field: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        wasm_on_header_value: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert(currentParser.ptr === p);
          return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1);
        },
        wasm_on_body: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        wasm_on_message_complete: (p) => {
          assert(currentParser.ptr === p);
          return currentParser.onMessageComplete();
        }
      }
    });
  }
  var llhttpInstance = null;
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var USE_NATIVE_TIMER = 0;
  var USE_FAST_TIMER = 1;
  var TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
  var TIMEOUT_BODY = 4 | USE_FAST_TIMER;
  var TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      this.llhttp = exports2;
      this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = 0;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(delay, type) {
      if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
        if (this.timeout) {
          timers.clearTimeout(this.timeout);
          this.timeout = null;
        }
        if (delay) {
          if (type & USE_FAST_TIMER) {
            this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
          } else {
            this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
            this.timeout?.unref();
          }
        }
        this.timeoutValue = delay;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.timeoutType = type;
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser === null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(chunk) {
      assert(currentParser === null);
      assert(this.ptr != null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (chunk.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(chunk.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk);
      try {
        let ret;
        try {
          currentBufferRef = chunk;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk.length);
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        if (ret !== constants.ERROR.OK) {
          const data = chunk.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr);
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data);
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data);
          } else {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data);
          }
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(currentParser === null);
      assert(this.ptr != null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      this.timeout && timers.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
      return 0;
    }
    onMessageBegin() {
      const { socket, client } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      request.onResponseStarted();
      return 0;
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
      return 0;
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10) {
        const headerName = util.bufferToLowerCasedHeaderName(key);
        if (headerName === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (headerName === "connection") {
          this.connection += buf.toString();
        }
      } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
      return 0;
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util.destroy(this.socket, new HeadersOverflowError);
      }
    }
    onUpgrade(head) {
      const { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      assert(client[kSocket] === socket);
      assert(!socket.destroyed);
      assert(!this.paused);
      assert((headers.length & 1) === 0);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(request.upgrade || request.method === "CONNECT");
      this.statusCode = 0;
      this.statusText = "";
      this.shouldKeepAlive = false;
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      removeAllListeners(socket);
      client[kSocket] = null;
      client[kHTTPContext] = null;
      client[kQueue][client[kRunningIdx]++] = null;
      client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      client[kResume]();
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client, socket, headers, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request.upgrade) {
        util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
        return -1;
      }
      assert(this.timeoutType === TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request.method === "CONNECT") {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert((this.headers.length & 1) === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
      if (request.aborted) {
        return -1;
      }
      if (request.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        client[kResume]();
      }
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util.destroy(socket, new ResponseExceededMaxSizeError);
        return -1;
      }
      this.bytesRead += buf.length;
      if (request.onData(buf) === false) {
        return constants.ERROR.PAUSED;
      }
      return 0;
    }
    onMessageComplete() {
      const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return 0;
      }
      assert(statusCode >= 100);
      assert((this.headers.length & 1) === 0);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      this.statusCode = 0;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return 0;
      }
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util.destroy(socket, new ResponseContentLengthMismatchError);
        return -1;
      }
      request.onComplete(headers);
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert(client[kRunning] === 0);
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (socket[kReset] && client[kRunning] === 0) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (client[kPipelining] == null || client[kPipelining] === 1) {
        setImmediate(client[kResume]);
      } else {
        client[kResume]();
      }
      return 0;
    }
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client, paused } = parser.deref();
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
        assert(!paused, "cannot be paused while waiting for headers");
        util.destroy(socket, new HeadersTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!paused) {
        util.destroy(socket, new BodyTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
      util.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  function connectH1(client, socket) {
    client[kSocket] = socket;
    if (!llhttpInstance) {
      llhttpInstance = lazyllhttp();
    }
    if (socket.errored) {
      throw socket.errored;
    }
    if (socket.destroyed) {
      throw new SocketError("destroyed");
    }
    socket[kNoRef] = false;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kBlocking] = false;
    socket[kParser] = new Parser(client, socket, llhttpInstance);
    util.addListener(socket, "error", onHttpSocketError);
    util.addListener(socket, "readable", onHttpSocketReadable);
    util.addListener(socket, "end", onHttpSocketEnd);
    util.addListener(socket, "close", onHttpSocketClose);
    socket[kClosed] = false;
    socket.on("close", onSocketClose);
    return {
      version: "h1",
      defaultPipelining: 1,
      write(request) {
        return writeH1(client, request);
      },
      resume() {
        resumeH1(client);
      },
      destroy(err, callback) {
        if (socket[kClosed]) {
          queueMicrotask(callback);
        } else {
          socket.on("close", callback);
          socket.destroy(err);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy(request) {
        if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return true;
        }
        if (request) {
          if (client[kRunning] > 0 && !request.idempotent) {
            return true;
          }
          if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
            return true;
          }
          if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {
            return true;
          }
        }
        return false;
      }
    };
  }
  function onHttpSocketError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    const parser = this[kParser];
    if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    this[kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttpSocketReadable() {
    this[kParser]?.readMore();
  }
  function onHttpSocketEnd() {
    const parser = this[kParser];
    if (parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  }
  function onHttpSocketClose() {
    const parser = this[kParser];
    if (parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
    }
    const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    const client = this[kClient];
    client[kSocket] = null;
    client[kHTTPContext] = null;
    if (client.destroyed) {
      assert(client[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        util.errorRequest(client, request, err);
      }
    } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      util.errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    client[kResume]();
  }
  function onSocketClose() {
    this[kClosed] = true;
  }
  function resumeH1(client) {
    const socket = client[kSocket];
    if (socket && !socket.destroyed) {
      if (client[kSize] === 0) {
        if (!socket[kNoRef] && socket.unref) {
          socket.unref();
          socket[kNoRef] = true;
        }
      } else if (socket[kNoRef] && socket.ref) {
        socket.ref();
        socket[kNoRef] = false;
      }
      if (client[kSize] === 0) {
        if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
        }
      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
          const request = client[kQueue][client[kRunningIdx]];
          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];
          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
        }
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH1(client, request) {
    const { method, path, host, upgrade, blocking, reset } = request;
    let { body, headers, contentLength } = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
    if (util.isFormDataLike(body)) {
      if (!extractBody) {
        extractBody = require_body().extractBody;
      }
      const [bodyStream, contentType] = extractBody(body);
      if (request.contentType == null) {
        headers.push("content-type", contentType);
      }
      body = bodyStream.stream;
      contentLength = bodyStream.length;
    } else if (util.isBlobLike(body) && request.contentType == null && body.type) {
      headers.push("content-type", body.type);
    }
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    const bodyLength = util.bodyLength(body);
    contentLength = bodyLength ?? contentLength;
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        util.errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    const socket = client[kSocket];
    const abort = (err) => {
      if (request.aborted || request.completed) {
        return;
      }
      util.errorRequest(client, request, err || new RequestAbortedError);
      util.destroy(body);
      util.destroy(socket, new InformationalError("aborted"));
    };
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path} HTTP/1.1\r
`;
    if (typeof host === "string") {
      header += `host: ${host}\r
`;
    } else {
      header += client[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client[kPipelining] && !socket[kReset]) {
      header += `connection: keep-alive\r
`;
    } else {
      header += `connection: close\r
`;
    }
    if (Array.isArray(headers)) {
      for (let n = 0;n < headers.length; n += 2) {
        const key = headers[n + 0];
        const val = headers[n + 1];
        if (Array.isArray(val)) {
          for (let i = 0;i < val.length; i++) {
            header += `${key}: ${val[i]}\r
`;
          }
        } else {
          header += `${key}: ${val}\r
`;
        }
      }
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request, headers: header, socket });
    }
    if (!body || bodyLength === 0) {
      writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isBuffer(body)) {
      writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === "function") {
        writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);
      } else {
        writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);
      }
    } else if (util.isStream(body)) {
      writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isIterable(body)) {
      writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else {
      assert(false);
    }
    return true;
  }
  function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    let finished = false;
    const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body.resume) {
        body.resume();
      }
    };
    const onClose = function() {
      queueMicrotask(() => {
        body.removeListener("error", onFinished);
      });
      if (!finished) {
        const err = new RequestAbortedError;
        queueMicrotask(() => onFinished(err));
      }
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util.destroy(body, err);
      } else {
        util.destroy(body);
      }
    };
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
    if (body.resume) {
      body.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
    if (body.errorEmitted ?? body.errored) {
      setImmediate(onFinished, body.errored);
    } else if (body.endEmitted ?? body.readableEnded) {
      setImmediate(onFinished, null);
    }
    if (body.closeEmitted ?? body.closed) {
      setImmediate(onClose);
    }
  }
  function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    try {
      if (!body) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
      }
      request.onRequestSent();
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(buffer);
      socket.uncork();
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload && request.reset !== false) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }

  class AsyncWriter {
    constructor({ abort, socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket;
      this.request = request;
      this.contentLength = contentLength;
      this.client = client;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      this.abort = abort;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        }
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      request.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write(`\r
0\r
\r
`, "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        } else {
          process.emitWarning(new RequestContentLengthMismatchError);
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      client[kResume]();
    }
    destroy(err) {
      const { socket, client, abort } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client[kRunning] <= 1, "pipeline should only contain this request");
        abort(err);
      }
    }
  }
  module.exports = connectH1;
});

// node_modules/undici/lib/dispatcher/client-h2.js
var require_client_h2 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { pipeline } = __require("node:stream");
  var util = require_util();
  var {
    RequestContentLengthMismatchError,
    RequestAbortedError,
    SocketError,
    InformationalError,
    InvalidArgumentError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kClient,
    kRunning,
    kPending,
    kQueue,
    kPendingIdx,
    kRunningIdx,
    kError,
    kSocket,
    kStrictContentLength,
    kOnError,
    kMaxConcurrentStreams,
    kHTTP2Session,
    kHTTP2InitialWindowSize,
    kHTTP2ConnectionWindowSize,
    kResume,
    kSize,
    kHTTPContext,
    kClosed,
    kBodyTimeout,
    kEnableConnectProtocol,
    kRemoteSettings,
    kHTTP2Stream
  } = require_symbols();
  var { channels } = require_diagnostics();
  var kOpenStreams = Symbol("open streams");
  var extractBody;
  var http2;
  try {
    http2 = __require("node:http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_PROTOCOL,
      NGHTTP2_REFUSED_STREAM,
      NGHTTP2_CANCEL
    }
  } = http2;
  function parseH2Headers(headers) {
    const result2 = [];
    for (const [name, value] of Object.entries(headers)) {
      if (Array.isArray(value)) {
        for (const subvalue of value) {
          result2.push(Buffer.from(name), Buffer.from(subvalue));
        }
      } else {
        result2.push(Buffer.from(name), Buffer.from(value));
      }
    }
    return result2;
  }
  function connectH2(client, socket) {
    client[kSocket] = socket;
    const http2InitialWindowSize = client[kHTTP2InitialWindowSize];
    const http2ConnectionWindowSize = client[kHTTP2ConnectionWindowSize];
    const session = http2.connect(client[kUrl], {
      createConnection: () => socket,
      peerMaxConcurrentStreams: client[kMaxConcurrentStreams],
      settings: {
        enablePush: false,
        ...http2InitialWindowSize != null ? { initialWindowSize: http2InitialWindowSize } : null
      }
    });
    session[kOpenStreams] = 0;
    session[kClient] = client;
    session[kSocket] = socket;
    session[kHTTP2Session] = null;
    session[kEnableConnectProtocol] = false;
    session[kRemoteSettings] = false;
    if (http2ConnectionWindowSize) {
      util.addListener(session, "connect", applyConnectionWindowSize.bind(session, http2ConnectionWindowSize));
    }
    util.addListener(session, "error", onHttp2SessionError);
    util.addListener(session, "frameError", onHttp2FrameError);
    util.addListener(session, "end", onHttp2SessionEnd);
    util.addListener(session, "goaway", onHttp2SessionGoAway);
    util.addListener(session, "close", onHttp2SessionClose);
    util.addListener(session, "remoteSettings", onHttp2RemoteSettings);
    session.unref();
    client[kHTTP2Session] = session;
    socket[kHTTP2Session] = session;
    util.addListener(socket, "error", onHttp2SocketError);
    util.addListener(socket, "end", onHttp2SocketEnd);
    util.addListener(socket, "close", onHttp2SocketClose);
    socket[kClosed] = false;
    socket.on("close", onSocketClose);
    return {
      version: "h2",
      defaultPipelining: Infinity,
      write(request) {
        return writeH2(client, request);
      },
      resume() {
        resumeH2(client);
      },
      destroy(err, callback) {
        if (socket[kClosed]) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy(request) {
        if (request != null) {
          if (client[kRunning] > 0) {
            if (request.idempotent === false)
              return true;
            if ((request.upgrade === "websocket" || request.method === "CONNECT") && session[kRemoteSettings] === false)
              return true;
            if (util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body)))
              return true;
          } else {
            return (request.upgrade === "websocket" || request.method === "CONNECT") && session[kRemoteSettings] === false;
          }
        }
        return false;
      }
    };
  }
  function resumeH2(client) {
    const socket = client[kSocket];
    if (socket?.destroyed === false) {
      if (client[kSize] === 0 || client[kMaxConcurrentStreams] === 0) {
        socket.unref();
        client[kHTTP2Session].unref();
      } else {
        socket.ref();
        client[kHTTP2Session].ref();
      }
    }
  }
  function applyConnectionWindowSize(connectionWindowSize) {
    try {
      if (typeof this.setLocalWindowSize === "function") {
        this.setLocalWindowSize(connectionWindowSize);
      }
    } catch {}
  }
  function onHttp2RemoteSettings(settings) {
    this[kClient][kMaxConcurrentStreams] = settings.maxConcurrentStreams ?? this[kClient][kMaxConcurrentStreams];
    if (this[kRemoteSettings] === true && this[kEnableConnectProtocol] === true && settings.enableConnectProtocol === false) {
      const err = new InformationalError("HTTP/2: Server disabled extended CONNECT protocol against RFC-8441");
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
      return;
    }
    this[kEnableConnectProtocol] = settings.enableConnectProtocol ?? this[kEnableConnectProtocol];
    this[kRemoteSettings] = true;
    this[kClient][kResume]();
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttp2FrameError(type, code, id) {
    if (id === 0) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
  }
  function onHttp2SessionEnd() {
    const err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
    this.destroy(err);
    util.destroy(this[kSocket], err);
  }
  function onHttp2SessionGoAway(errorCode) {
    const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${errorCode}`, util.getSocketInfo(this[kSocket]));
    const client = this[kClient];
    client[kSocket] = null;
    client[kHTTPContext] = null;
    this.close();
    this[kHTTP2Session] = null;
    util.destroy(this[kSocket], err);
    if (client[kRunningIdx] < client[kQueue].length) {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      util.errorRequest(client, request, err);
      client[kPendingIdx] = client[kRunningIdx];
    }
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    client.emit("connectionError", client[kUrl], [client], err);
    client[kResume]();
  }
  function onHttp2SessionClose() {
    const { [kClient]: client } = this;
    const { [kSocket]: socket } = client;
    const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket));
    client[kSocket] = null;
    client[kHTTPContext] = null;
    if (client.destroyed) {
      assert(client[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        util.errorRequest(client, request, err);
      }
    }
  }
  function onHttp2SocketClose() {
    const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    const client = this[kHTTP2Session][kClient];
    client[kSocket] = null;
    client[kHTTPContext] = null;
    if (this[kHTTP2Session] !== null) {
      this[kHTTP2Session].destroy(err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    client[kResume]();
  }
  function onHttp2SocketError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttp2SocketEnd() {
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  }
  function onSocketClose() {
    this[kClosed] = true;
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH2(client, request) {
    const requestTimeout = request.bodyTimeout ?? client[kBodyTimeout];
    const session = client[kHTTP2Session];
    const { method, path, host, upgrade, expectContinue, signal, protocol, headers: reqHeaders } = request;
    let { body } = request;
    if (upgrade != null && upgrade !== "websocket") {
      util.errorRequest(client, request, new InvalidArgumentError(`Custom upgrade "${upgrade}" not supported over HTTP/2`));
      return false;
    }
    const headers = {};
    for (let n = 0;n < reqHeaders.length; n += 2) {
      const key = reqHeaders[n + 0];
      const val = reqHeaders[n + 1];
      if (key === "cookie") {
        if (headers[key] != null) {
          headers[key] = Array.isArray(headers[key]) ? (headers[key].push(val), headers[key]) : [headers[key], val];
        } else {
          headers[key] = val;
        }
        continue;
      }
      if (Array.isArray(val)) {
        for (let i = 0;i < val.length; i++) {
          if (headers[key]) {
            headers[key] += `, ${val[i]}`;
          } else {
            headers[key] = val[i];
          }
        }
      } else if (headers[key]) {
        headers[key] += `, ${val}`;
      } else {
        headers[key] = val;
      }
    }
    let stream = null;
    const { hostname, port } = client[kUrl];
    headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
    headers[HTTP2_HEADER_METHOD] = method;
    const abort = (err) => {
      if (request.aborted || request.completed) {
        return;
      }
      err = err || new RequestAbortedError;
      util.errorRequest(client, request, err);
      if (stream != null) {
        stream.removeAllListeners("data");
        stream.close();
        client[kOnError](err);
        client[kResume]();
      }
      util.destroy(body, err);
    };
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (upgrade || method === "CONNECT") {
      session.ref();
      if (upgrade === "websocket") {
        if (session[kEnableConnectProtocol] === false) {
          util.errorRequest(client, request, new InformationalError("HTTP/2: Extended CONNECT protocol not supported by server"));
          session.unref();
          return false;
        }
        headers[HTTP2_HEADER_METHOD] = "CONNECT";
        headers[HTTP2_HEADER_PROTOCOL] = "websocket";
        headers[HTTP2_HEADER_PATH] = path;
        if (protocol === "ws:" || protocol === "wss:") {
          headers[HTTP2_HEADER_SCHEME] = protocol === "ws:" ? "http" : "https";
        } else {
          headers[HTTP2_HEADER_SCHEME] = protocol === "http:" ? "http" : "https";
        }
        stream = session.request(headers, { endStream: false, signal });
        stream[kHTTP2Stream] = true;
        stream.once("response", (headers2, _flags) => {
          const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
          request.onUpgrade(statusCode, parseH2Headers(realHeaders), stream);
          ++session[kOpenStreams];
          client[kQueue][client[kRunningIdx]++] = null;
        });
        stream.on("error", () => {
          if (stream.rstCode === NGHTTP2_REFUSED_STREAM || stream.rstCode === NGHTTP2_CANCEL) {
            abort(new InformationalError(`HTTP/2: "stream error" received - code ${stream.rstCode}`));
          }
        });
        stream.once("close", () => {
          session[kOpenStreams] -= 1;
          if (session[kOpenStreams] === 0)
            session.unref();
        });
        stream.setTimeout(requestTimeout);
        return true;
      }
      stream = session.request(headers, { endStream: false, signal });
      stream[kHTTP2Stream] = true;
      stream.on("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        request.onUpgrade(statusCode, parseH2Headers(realHeaders), stream);
        ++session[kOpenStreams];
        client[kQueue][client[kRunningIdx]++] = null;
      });
      stream.once("close", () => {
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0)
          session.unref();
      });
      stream.setTimeout(requestTimeout);
      return true;
    }
    headers[HTTP2_HEADER_PATH] = path;
    headers[HTTP2_HEADER_SCHEME] = protocol === "http:" ? "http" : "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (util.isFormDataLike(body)) {
      extractBody ??= require_body().extractBody;
      const [bodyStream, contentType] = extractBody(body);
      headers["content-type"] = contentType;
      body = bodyStream.stream;
      contentLength = bodyStream.length;
    }
    if (contentLength == null) {
      contentLength = request.contentLength;
    }
    if (!expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        util.errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null) {
      assert(body || contentLength === 0, "no body must not have content length");
      headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    if (channels.sendHeaders.hasSubscribers) {
      let header = "";
      for (const key in headers) {
        header += `${key}: ${headers[key]}\r
`;
      }
      channels.sendHeaders.publish({ request, headers: header, socket: session[kSocket] });
    }
    const shouldEndStream = method === "GET" || method === "HEAD" || body === null;
    if (expectContinue) {
      headers[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers, { endStream: shouldEndStream, signal });
      stream[kHTTP2Stream] = true;
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      });
      stream[kHTTP2Stream] = true;
      writeBodyH2();
    }
    ++session[kOpenStreams];
    stream.setTimeout(requestTimeout);
    stream.once("response", (headers2) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
      request.onResponseStarted();
      if (request.aborted) {
        stream.removeAllListeners("data");
        return;
      }
      if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
    });
    stream.on("data", (chunk) => {
      if (request.onData(chunk) === false) {
        stream.pause();
      }
    });
    stream.once("end", (err) => {
      stream.removeAllListeners("data");
      if (stream.state?.state == null || stream.state.state < 6) {
        if (!request.aborted && !request.completed) {
          request.onComplete({});
        }
        client[kQueue][client[kRunningIdx]++] = null;
        client[kResume]();
      } else {
        --session[kOpenStreams];
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
        abort(err ?? new InformationalError("HTTP/2: stream half-closed (remote)"));
        client[kQueue][client[kRunningIdx]++] = null;
        client[kPendingIdx] = client[kRunningIdx];
        client[kResume]();
      }
    });
    stream.once("close", () => {
      stream.removeAllListeners("data");
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
    });
    stream.once("error", function(err) {
      stream.removeAllListeners("data");
      abort(err);
    });
    stream.once("frameError", (type, code) => {
      stream.removeAllListeners("data");
      abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
    });
    stream.on("aborted", () => {
      stream.removeAllListeners("data");
    });
    stream.on("timeout", () => {
      const err = new InformationalError(`HTTP/2: "stream timeout after ${requestTimeout}"`);
      stream.removeAllListeners("data");
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
      abort(err);
    });
    stream.once("trailers", (trailers) => {
      if (request.aborted || request.completed) {
        return;
      }
      request.onComplete(trailers);
    });
    return true;
    function writeBodyH2() {
      if (!body || contentLength === 0) {
        writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload);
      } else if (util.isBuffer(body)) {
        writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload);
        } else {
          writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
        }
      } else if (util.isStream(body)) {
        writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength);
      } else if (util.isIterable(body)) {
        writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
      } else {
        assert(false);
      }
    }
  }
  function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    try {
      if (body != null && util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        h2stream.cork();
        h2stream.write(body);
        h2stream.uncork();
        h2stream.end();
        request.onBodySent(body);
      }
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      request.onRequestSent();
      client[kResume]();
    } catch (error2) {
      abort(error2);
    }
  }
  function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    const pipe = pipeline(body, h2stream, (err) => {
      if (err) {
        util.destroy(pipe, err);
        abort(err);
      } else {
        util.removeAllListeners(pipe);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      }
    });
    util.addListener(pipe, "data", onPipeData);
    function onPipeData(chunk) {
      request.onBodySent(chunk);
    }
  }
  async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      h2stream.cork();
      h2stream.write(buffer);
      h2stream.uncork();
      h2stream.end();
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    h2stream.on("close", onDrain).on("drain", onDrain);
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        const res = h2stream.write(chunk);
        request.onBodySent(chunk);
        if (!res) {
          await waitForDrain();
        }
      }
      h2stream.end();
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    } finally {
      h2stream.off("close", onDrain).off("drain", onDrain);
    }
  }
  module.exports = connectH2;
});

// node_modules/undici/lib/dispatcher/client.js
var require_client = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var net = __require("node:net");
  var http = __require("node:http");
  var util = require_util();
  var { ClientStats } = require_stats();
  var { channels } = require_diagnostics();
  var Request = require_request();
  var DispatcherBase = require_dispatcher_base();
  var {
    InvalidArgumentError,
    InformationalError,
    ClientDestroyedError
  } = require_errors();
  var buildConnector = require_connect();
  var {
    kUrl,
    kServerName,
    kClient,
    kBusy,
    kConnect,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kLocalAddress,
    kMaxResponseSize,
    kOnError,
    kHTTPContext,
    kMaxConcurrentStreams,
    kHTTP2InitialWindowSize,
    kHTTP2ConnectionWindowSize,
    kResume
  } = require_symbols();
  var connectH1 = require_client_h1();
  var connectH2 = require_client_h2();
  var kClosedResolve = Symbol("kClosedResolve");
  var getDefaultNodeMaxHeaderSize = http && http.maxHeaderSize && Number.isInteger(http.maxHeaderSize) && http.maxHeaderSize > 0 ? () => http.maxHeaderSize : () => {
    throw new InvalidArgumentError("http module not available or http.maxHeaderSize invalid");
  };
  var noop = () => {};
  function getPipelining(client) {
    return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;
  }

  class Client extends DispatcherBase {
    constructor(url, {
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      maxConcurrentStreams,
      allowH2,
      useH2c,
      initialWindowSize,
      connectionWindowSize
    } = {}) {
      if (keepAlive !== undefined) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null) {
        if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
      } else {
        maxHeaderSize = getDefaultNodeMaxHeaderSize();
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
      }
      if (useH2c != null && typeof useH2c !== "boolean") {
        throw new InvalidArgumentError("useH2c must be a valid boolean value");
      }
      if (initialWindowSize != null && (!Number.isInteger(initialWindowSize) || initialWindowSize < 1)) {
        throw new InvalidArgumentError("initialWindowSize must be a positive integer, greater than 0");
      }
      if (connectionWindowSize != null && (!Number.isInteger(connectionWindowSize) || connectionWindowSize < 1)) {
        throw new InvalidArgumentError("connectionWindowSize must be a positive integer, greater than 0");
      }
      super();
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          useH2c,
          socketPath,
          timeout: connectTimeout,
          ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect2
        });
      }
      this[kUrl] = util.parseOrigin(url);
      this[kConnector] = connect2;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2000 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
      this[kHTTP2InitialWindowSize] = initialWindowSize != null ? initialWindowSize : 262144;
      this[kHTTP2ConnectionWindowSize] = connectionWindowSize != null ? connectionWindowSize : 524288;
      this[kHTTPContext] = null;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
      this[kResume] = (sync) => resume(this, sync);
      this[kOnError] = (err) => onError(this, err);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      this[kResume](true);
    }
    get stats() {
      return new ClientStats(this);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy]() {
      return Boolean(this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const request = new Request(this[kUrl].origin, opts, handler);
      this[kQueue].push(request);
      if (this[kResuming]) {} else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
        this[kResuming] = 1;
        queueMicrotask(() => resume(this));
      } else {
        this[kResume](true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    [kClose]() {
      return new Promise((resolve) => {
        if (this[kSize]) {
          this[kClosedResolve] = resolve;
        } else {
          resolve(null);
        }
      });
    }
    [kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(this, request, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve(null);
        };
        if (this[kHTTPContext]) {
          this[kHTTPContext].destroy(err, callback);
          this[kHTTPContext] = null;
        } else {
          queueMicrotask(callback);
        }
        this[kResume]();
      });
    }
  }
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        util.errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  function connect(client) {
    assert(!client[kConnecting]);
    assert(!client[kHTTPContext]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert(net.isIPv6(ip));
      hostname = ip;
    }
    client[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client[kHTTPContext]?.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    }
    client[kConnector]({
      host,
      hostname,
      protocol,
      port,
      servername: client[kServerName],
      localAddress: client[kLocalAddress]
    }, (err, socket) => {
      if (err) {
        handleConnectError(client, err, { host, hostname, protocol, port });
        client[kResume]();
        return;
      }
      if (client.destroyed) {
        util.destroy(socket.on("error", noop), new ClientDestroyedError);
        client[kResume]();
        return;
      }
      assert(socket);
      try {
        client[kHTTPContext] = socket.alpnProtocol === "h2" ? connectH2(client, socket) : connectH1(client, socket);
      } catch (err2) {
        socket.destroy().on("error", noop);
        handleConnectError(client, err2, { host, hostname, protocol, port });
        client[kResume]();
        return;
      }
      client[kConnecting] = false;
      socket[kCounter] = 0;
      socket[kMaxRequests] = client[kMaxRequests];
      socket[kClient] = client;
      socket[kError] = null;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      }
      client.emit("connect", client[kUrl], [client]);
      client[kResume]();
    });
  }
  function handleConnectError(client, err, { host, hostname, protocol, port }) {
    if (client.destroyed) {
      return;
    }
    client[kConnecting] = false;
    if (channels.connectError.hasSubscribers) {
      channels.connectError.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client[kHTTPContext]?.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector],
        error: err
      });
    }
    if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
      assert(client[kRunning] === 0);
      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
        const request = client[kQueue][client[kPendingIdx]++];
        util.errorRequest(client, request, err);
      }
    } else {
      onError(client, err);
    }
    client.emit("connectionError", client[kUrl], [client], err);
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain", client[kUrl], [client]);
  }
  function resume(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync) {
    while (true) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve]();
        client[kClosedResolve] = null;
        return;
      }
      if (client[kHTTPContext]) {
        client[kHTTPContext].resume();
      }
      if (client[kBusy]) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          queueMicrotask(() => emitDrain(client));
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (client[kPending] === 0) {
        return;
      }
      if (client[kRunning] >= (getPipelining(client) || 1)) {
        return;
      }
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) {
          return;
        }
        client[kServerName] = request.servername;
        client[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
          client[kHTTPContext] = null;
          resume(client);
        });
      }
      if (client[kConnecting]) {
        return;
      }
      if (!client[kHTTPContext]) {
        connect(client);
        return;
      }
      if (client[kHTTPContext].destroyed) {
        return;
      }
      if (client[kHTTPContext].busy(request)) {
        return;
      }
      if (!request.aborted && client[kHTTPContext].write(request)) {
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  module.exports = Client;
});

// node_modules/undici/lib/dispatcher/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  var kSize = 2048;
  var kMask = kSize - 1;

  class FixedCircularBuffer {
    bottom = 0;
    top = 0;
    list = new Array(kSize).fill(undefined);
    next = null;
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === undefined) {
        return null;
      }
      this.list[this.bottom] = undefined;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  module.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer;
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
        tail.next = null;
      }
      return next;
    }
  };
});

// node_modules/undici/lib/dispatcher/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var { PoolStats } = require_stats();
  var DispatcherBase = require_dispatcher_base();
  var FixedQueue = require_fixed_queue();
  var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kGetDispatcher = Symbol("get dispatcher");
  var kAddClient = Symbol("add client");
  var kRemoveClient = Symbol("remove client");

  class PoolBase extends DispatcherBase {
    [kQueue] = new FixedQueue;
    [kQueued] = 0;
    [kClients] = [];
    [kNeedDrain] = false;
    [kOnDrain](client, origin, targets) {
      const queue = this[kQueue];
      let needDrain = false;
      while (!needDrain) {
        const item = queue.shift();
        if (!item) {
          break;
        }
        this[kQueued]--;
        needDrain = !client.dispatch(item.opts, item.handler);
      }
      client[kNeedDrain] = needDrain;
      if (!needDrain && this[kNeedDrain]) {
        this[kNeedDrain] = false;
        this.emit("drain", origin, [this, ...targets]);
      }
      if (this[kClosedResolve] && queue.isEmpty()) {
        const closeAll = new Array(this[kClients].length);
        for (let i = 0;i < this[kClients].length; i++) {
          closeAll[i] = this[kClients][i].close();
        }
        return Promise.all(closeAll).then(this[kClosedResolve]);
      }
    }
    [kOnConnect] = (origin, targets) => {
      this.emit("connect", origin, [this, ...targets]);
    };
    [kOnDisconnect] = (origin, targets, err) => {
      this.emit("disconnect", origin, [this, ...targets], err);
    };
    [kOnConnectionError] = (origin, targets, err) => {
      this.emit("connectionError", origin, [this, ...targets], err);
    };
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      let ret = 0;
      for (const { [kConnected]: connected } of this[kClients]) {
        ret += connected;
      }
      return ret;
    }
    get [kFree]() {
      let ret = 0;
      for (const { [kConnected]: connected, [kNeedDrain]: needDrain } of this[kClients]) {
        ret += connected && !needDrain;
      }
      return ret;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return new PoolStats(this);
    }
    [kClose]() {
      if (this[kQueue].isEmpty()) {
        const closeAll = new Array(this[kClients].length);
        for (let i = 0;i < this[kClients].length; i++) {
          closeAll[i] = this[kClients][i].close();
        }
        return Promise.all(closeAll);
      } else {
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    [kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      const destroyAll = new Array(this[kClients].length);
      for (let i = 0;i < this[kClients].length; i++) {
        destroyAll[i] = this[kClients][i].destroy(err);
      }
      return Promise.all(destroyAll);
    }
    [kDispatch](opts, handler) {
      const dispatcher = this[kGetDispatcher]();
      if (!dispatcher) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher.dispatch(opts, handler)) {
        dispatcher[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      client.on("drain", this[kOnDrain].bind(this, client)).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client);
      if (this[kNeedDrain]) {
        queueMicrotask(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client, client[kUrl], [client, this]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        const idx = this[kClients].indexOf(client);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/dispatcher/pool.js
var require_pool = __commonJS((exports, module) => {
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher,
    kRemoveClient
  } = require_pool_base();
  var Client = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      clientTtl,
      ...options
    } = {}) {
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      super();
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kFactory] = factory;
      this.on("connect", (origin2, targets) => {
        if (clientTtl != null && clientTtl > 0) {
          for (const target of targets) {
            Object.assign(target, { ttl: Date.now() });
          }
        }
      });
      this.on("connectionError", (origin2, targets, error2) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      const clientTtlOption = this[kOptions].clientTtl;
      for (const client of this[kClients]) {
        if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && Date.now() - client.ttl > clientTtlOption) {
          this[kRemoveClient](client);
        } else if (!client[kNeedDrain]) {
          return client;
        }
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
        return dispatcher;
      }
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/dispatcher/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors();
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base();
  var Pool = require_pool();
  var { kUrl } = require_symbols();
  var { parseOrigin } = require_util();
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  var kCurrentWeight = Symbol("kCurrentWeight");
  var kIndex = Symbol("kIndex");
  var kWeight = Symbol("kWeight");
  var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  var kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (a === 0)
      return b;
    while (b !== 0) {
      const t = b;
      b = a % b;
      a = t;
    }
    return a;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
        return this;
      }
      const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool);
      pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      });
      pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client of this[kClients]) {
        client[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      let result2 = 0;
      for (let i = 0;i < this[kClients].length; i++) {
        result2 = getGreatestCommonDivisor(this[kClients][i][kWeight], result2);
      }
      this[kGreatestCommonDivisor] = result2;
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
      if (pool) {
        this[kRemoveClient](pool);
      }
      return this;
    }
    getUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      return this[kClients].find((pool) => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError;
      }
      const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
      if (!dispatcher) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
          return pool;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/dispatcher/round-robin-pool.js
var require_round_robin_pool = __commonJS((exports, module) => {
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher,
    kRemoveClient
  } = require_pool_base();
  var Client = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");
  var kIndex = Symbol("index");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }

  class RoundRobinPool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      clientTtl,
      ...options
    } = {}) {
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      super();
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kFactory] = factory;
      this[kIndex] = -1;
      this.on("connect", (origin2, targets) => {
        if (clientTtl != null && clientTtl > 0) {
          for (const target of targets) {
            Object.assign(target, { ttl: Date.now() });
          }
        }
      });
      this.on("connectionError", (origin2, targets, error2) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      const clientTtlOption = this[kOptions].clientTtl;
      const clientsLength = this[kClients].length;
      if (clientsLength === 0) {
        const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
        return dispatcher;
      }
      let checked = 0;
      while (checked < clientsLength) {
        this[kIndex] = (this[kIndex] + 1) % clientsLength;
        const client = this[kClients][this[kIndex]];
        if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && Date.now() - client.ttl > clientTtlOption) {
          this[kRemoveClient](client);
          checked++;
          continue;
        }
        if (!client[kNeedDrain]) {
          return client;
        }
        checked++;
      }
      if (!this[kConnections] || clientsLength < this[kConnections]) {
        const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
        return dispatcher;
      }
    }
  }
  module.exports = RoundRobinPool;
});

// node_modules/undici/lib/dispatcher/agent.js
var require_agent = __commonJS((exports, module) => {
  var { InvalidArgumentError, MaxOriginsReachedError } = require_errors();
  var { kClients, kRunning, kClose, kDestroy, kDispatch, kUrl } = require_symbols();
  var DispatcherBase = require_dispatcher_base();
  var Pool = require_pool();
  var Client = require_client();
  var util = require_util();
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kOrigins = Symbol("origins");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxOrigins = Infinity, connect, ...options } = {}) {
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof maxOrigins !== "number" || Number.isNaN(maxOrigins) || maxOrigins <= 0) {
        throw new InvalidArgumentError("maxOrigins must be a number greater than 0");
      }
      super();
      if (connect && typeof connect !== "function") {
        connect = { ...connect };
      }
      this[kOptions] = { ...util.deepClone(options), maxOrigins, connect };
      this[kFactory] = factory;
      this[kClients] = new Map;
      this[kOrigins] = new Set;
      this[kOnDrain] = (origin, targets) => {
        this.emit("drain", origin, [this, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        this.emit("connect", origin, [this, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        this.emit("disconnect", origin, [this, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        this.emit("connectionError", origin, [this, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const { dispatcher } of this[kClients].values()) {
        ret += dispatcher[kRunning];
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      if (this[kOrigins].size >= this[kOptions].maxOrigins && !this[kOrigins].has(key)) {
        throw new MaxOriginsReachedError;
      }
      const result2 = this[kClients].get(key);
      let dispatcher = result2 && result2.dispatcher;
      if (!dispatcher) {
        const closeClientIfUnused = (connected) => {
          const result3 = this[kClients].get(key);
          if (result3) {
            if (connected)
              result3.count -= 1;
            if (result3.count <= 0) {
              this[kClients].delete(key);
              result3.dispatcher.close();
            }
            this[kOrigins].delete(key);
          }
        };
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", (origin, targets) => {
          const result3 = this[kClients].get(key);
          if (result3) {
            result3.count += 1;
          }
          this[kOnConnect](origin, targets);
        }).on("disconnect", (origin, targets, err) => {
          closeClientIfUnused(true);
          this[kOnDisconnect](origin, targets, err);
        }).on("connectionError", (origin, targets, err) => {
          closeClientIfUnused(false);
          this[kOnConnectionError](origin, targets, err);
        });
        this[kClients].set(key, { count: 0, dispatcher });
        this[kOrigins].add(key);
      }
      return dispatcher.dispatch(opts, handler);
    }
    [kClose]() {
      const closePromises = [];
      for (const { dispatcher } of this[kClients].values()) {
        closePromises.push(dispatcher.close());
      }
      this[kClients].clear();
      return Promise.all(closePromises);
    }
    [kDestroy](err) {
      const destroyPromises = [];
      for (const { dispatcher } of this[kClients].values()) {
        destroyPromises.push(dispatcher.destroy(err));
      }
      this[kClients].clear();
      return Promise.all(destroyPromises);
    }
    get stats() {
      const allClientStats = {};
      for (const { dispatcher } of this[kClients].values()) {
        if (dispatcher.stats) {
          allClientStats[dispatcher[kUrl].origin] = dispatcher.stats;
        }
      }
      return allClientStats;
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/dispatcher/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  var { kProxy, kClose, kDestroy, kDispatch } = require_symbols();
  var Agent = require_agent();
  var Pool = require_pool();
  var DispatcherBase = require_dispatcher_base();
  var { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require_errors();
  var buildConnector = require_connect();
  var Client = require_client();
  var { channels } = require_diagnostics();
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");
  var kTunnelProxy = Symbol("tunnel proxy");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  var noop = () => {};
  function defaultAgentFactory(origin, opts) {
    if (opts.connections === 1) {
      return new Client(origin, opts);
    }
    return new Pool(origin, opts);
  }

  class Http1ProxyWrapper extends DispatcherBase {
    #client;
    constructor(proxyUrl, { headers = {}, connect, factory }) {
      if (!proxyUrl) {
        throw new InvalidArgumentError("Proxy URL is mandatory");
      }
      super();
      this[kProxyHeaders] = headers;
      if (factory) {
        this.#client = factory(proxyUrl, { connect });
      } else {
        this.#client = new Client(proxyUrl, { connect });
      }
    }
    [kDispatch](opts, handler) {
      const onHeaders = handler.onHeaders;
      handler.onHeaders = function(statusCode, data, resume) {
        if (statusCode === 407) {
          if (typeof handler.onError === "function") {
            handler.onError(new InvalidArgumentError("Proxy Authentication Required (407)"));
          }
          return;
        }
        if (onHeaders)
          onHeaders.call(this, statusCode, data, resume);
      };
      const {
        origin,
        path = "/",
        headers = {}
      } = opts;
      opts.path = origin + path;
      if (!("host" in headers) && !("Host" in headers)) {
        const { host } = new URL(origin);
        headers.host = host;
      }
      opts.headers = { ...this[kProxyHeaders], ...headers };
      return this.#client[kDispatch](opts, handler);
    }
    [kClose]() {
      return this.#client.close();
    }
    [kDestroy](err) {
      return this.#client.destroy(err);
    }
  }

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      if (!opts || typeof opts === "object" && !(opts instanceof URL) && !opts.uri) {
        throw new InvalidArgumentError("Proxy uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      const { proxyTunnel = true } = opts;
      super();
      const url = this.#getUrl(opts);
      const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
      this[kProxy] = { uri: href, protocol };
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      this[kTunnelProxy] = proxyTunnel;
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      const agentFactory = opts.factory || defaultAgentFactory;
      const factory = (origin2, options) => {
        const { protocol: protocol2 } = new URL(origin2);
        if (!this[kTunnelProxy] && protocol2 === "http:" && this[kProxy].protocol === "http:") {
          return new Http1ProxyWrapper(this[kProxy].uri, {
            headers: this[kProxyHeaders],
            connect,
            factory: agentFactory
          });
        }
        return agentFactory(origin2, options);
      };
      this[kClient] = clientFactory(url, { connect });
      this[kAgent] = new Agent({
        ...opts,
        factory,
        connect: async (opts2, callback) => {
          let requestedPath = opts2.host;
          if (!opts2.port) {
            requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const connectParams = {
              origin,
              port,
              path: requestedPath,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host: opts2.host,
                ...opts2.connections == null || opts2.connections > 0 ? { "proxy-connection": "keep-alive" } : {}
              },
              servername: this[kProxyTls]?.servername || proxyHostname
            };
            const { socket, statusCode } = await this[kClient].connect(connectParams);
            if (statusCode !== 200) {
              socket.on("error", noop).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              return;
            }
            if (channels.proxyConnected.hasSubscribers) {
              channels.proxyConnected.publish({
                socket,
                connectParams
              });
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
              callback(new SecureProxyConnectionError(err));
            } else {
              callback(err);
            }
          }
        }
      });
    }
    dispatch(opts, handler) {
      const headers = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers);
      if (headers && !("host" in headers) && !("Host" in headers)) {
        const { host } = new URL(opts.origin);
        headers.host = host;
      }
      return this[kAgent].dispatch({
        ...opts,
        headers
      }, handler);
    }
    #getUrl(opts) {
      if (typeof opts === "string") {
        return new URL(opts);
      } else if (opts instanceof URL) {
        return opts;
      } else {
        return new URL(opts.uri);
      }
    }
    [kClose]() {
      return Promise.all([
        this[kAgent].close(),
        this[kClient].close()
      ]);
    }
    [kDestroy]() {
      return Promise.all([
        this[kAgent].destroy(),
        this[kClient].destroy()
      ]);
    }
  }
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      const headersPair = {};
      for (let i = 0;i < headers.length; i += 2) {
        headersPair[headers[i]] = headers[i + 1];
      }
      return headersPair;
    }
    return headers;
  }
  function throwIfProxyAuthIsSent(headers) {
    const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/dispatcher/env-http-proxy-agent.js
var require_env_http_proxy_agent = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require_symbols();
  var ProxyAgent = require_proxy_agent();
  var Agent = require_agent();
  var DEFAULT_PORTS = {
    "http:": 80,
    "https:": 443
  };

  class EnvHttpProxyAgent extends DispatcherBase {
    #noProxyValue = null;
    #noProxyEntries = null;
    #opts = null;
    constructor(opts = {}) {
      super();
      this.#opts = opts;
      const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
      this[kNoProxyAgent] = new Agent(agentOpts);
      const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
      if (HTTP_PROXY) {
        this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
      } else {
        this[kHttpProxyAgent] = this[kNoProxyAgent];
      }
      const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
      if (HTTPS_PROXY) {
        this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
      } else {
        this[kHttpsProxyAgent] = this[kHttpProxyAgent];
      }
      this.#parseNoProxy();
    }
    [kDispatch](opts, handler) {
      const url = new URL(opts.origin);
      const agent = this.#getProxyAgentForUrl(url);
      return agent.dispatch(opts, handler);
    }
    [kClose]() {
      return Promise.all([
        this[kNoProxyAgent].close(),
        !this[kHttpProxyAgent][kClosed] && this[kHttpProxyAgent].close(),
        !this[kHttpsProxyAgent][kClosed] && this[kHttpsProxyAgent].close()
      ]);
    }
    [kDestroy](err) {
      return Promise.all([
        this[kNoProxyAgent].destroy(err),
        !this[kHttpProxyAgent][kDestroyed] && this[kHttpProxyAgent].destroy(err),
        !this[kHttpsProxyAgent][kDestroyed] && this[kHttpsProxyAgent].destroy(err)
      ]);
    }
    #getProxyAgentForUrl(url) {
      let { protocol, host: hostname, port } = url;
      hostname = hostname.replace(/:\d*$/, "").toLowerCase();
      port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
      if (!this.#shouldProxy(hostname, port)) {
        return this[kNoProxyAgent];
      }
      if (protocol === "https:") {
        return this[kHttpsProxyAgent];
      }
      return this[kHttpProxyAgent];
    }
    #shouldProxy(hostname, port) {
      if (this.#noProxyChanged) {
        this.#parseNoProxy();
      }
      if (this.#noProxyEntries.length === 0) {
        return true;
      }
      if (this.#noProxyValue === "*") {
        return false;
      }
      for (let i = 0;i < this.#noProxyEntries.length; i++) {
        const entry = this.#noProxyEntries[i];
        if (entry.port && entry.port !== port) {
          continue;
        }
        if (!/^[.*]/.test(entry.hostname)) {
          if (hostname === entry.hostname) {
            return false;
          }
        } else {
          if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
            return false;
          }
        }
      }
      return true;
    }
    #parseNoProxy() {
      const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
      const noProxySplit = noProxyValue.split(/[,\s]/);
      const noProxyEntries = [];
      for (let i = 0;i < noProxySplit.length; i++) {
        const entry = noProxySplit[i];
        if (!entry) {
          continue;
        }
        const parsed = entry.match(/^(.+):(\d+)$/);
        noProxyEntries.push({
          hostname: (parsed ? parsed[1] : entry).toLowerCase(),
          port: parsed ? Number.parseInt(parsed[2], 10) : 0
        });
      }
      this.#noProxyValue = noProxyValue;
      this.#noProxyEntries = noProxyEntries;
    }
    get #noProxyChanged() {
      if (this.#opts.noProxy !== undefined) {
        return false;
      }
      return this.#noProxyValue !== this.#noProxyEnv;
    }
    get #noProxyEnv() {
      return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
    }
  }
  module.exports = EnvHttpProxyAgent;
});

// node_modules/undici/lib/handler/retry-handler.js
var require_retry_handler = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { kRetryHandlerDefaultRetry } = require_symbols();
  var { RequestRetryError } = require_errors();
  var WrapHandler = require_wrap_handler();
  var {
    isDisturbed,
    parseRangeHeader,
    wrapRequestBody
  } = require_util();
  function calculateRetryAfterHeader(retryAfter) {
    const retryTime = new Date(retryAfter).getTime();
    return isNaN(retryTime) ? 0 : retryTime - Date.now();
  }

  class RetryHandler {
    constructor(opts, { dispatch, handler }) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        methods,
        errorCodes,
        retryAfter,
        statusCodes,
        throwOnError
      } = retryOptions ?? {};
      this.error = null;
      this.dispatch = dispatch;
      this.handler = WrapHandler.wrap(handler);
      this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
      this.retryOpts = {
        throwOnError: throwOnError ?? true,
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1000,
        minTimeout: minTimeout ?? 500,
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE",
          "UND_ERR_SOCKET"
        ]
      };
      this.retryCount = 0;
      this.retryCountCheckpoint = 0;
      this.headersSent = false;
      this.start = 0;
      this.end = null;
      this.etag = null;
    }
    onResponseStartWithRetry(controller, statusCode, headers, statusMessage, err) {
      if (this.retryOpts.throwOnError) {
        if (this.retryOpts.statusCodes.includes(statusCode) === false) {
          this.headersSent = true;
          this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
        } else {
          this.error = err;
        }
        return;
      }
      if (isDisturbed(this.opts.body)) {
        this.headersSent = true;
        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
        return;
      }
      function shouldRetry(passedErr) {
        if (passedErr) {
          this.headersSent = true;
          this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
          controller.resume();
          return;
        }
        this.error = err;
        controller.resume();
      }
      controller.pause();
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, shouldRetry.bind(this));
    }
    onRequestStart(controller, context) {
      if (!this.headersSent) {
        this.handler.onRequestStart?.(controller, context);
      }
    }
    onRequestUpgrade(controller, statusCode, headers, socket) {
      this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      const { statusCode, code, headers } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        minTimeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions;
      const { counter } = state;
      if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers?.["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(headers["retry-after"]) : retryAfterHeader * 1000;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
      setTimeout(() => cb(null), retryTimeout);
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      this.error = null;
      this.retryCount += 1;
      if (statusCode >= 300) {
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          data: {
            count: this.retryCount
          }
        });
        this.onResponseStartWithRetry(controller, statusCode, headers, statusMessage, err);
        return;
      }
      if (this.headersSent) {
        if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
          throw new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
            headers,
            data: { count: this.retryCount }
          });
        }
        const contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange) {
          throw new RequestRetryError("Content-Range mismatch", statusCode, {
            headers,
            data: { count: this.retryCount }
          });
        }
        if (this.etag != null && this.etag !== headers.etag) {
          throw new RequestRetryError("ETag mismatch", statusCode, {
            headers,
            data: { count: this.retryCount }
          });
        }
        const { start, size, end = size ? size - 1 : null } = contentRange;
        assert(this.start === start, "content-range mismatch");
        assert(this.end == null || this.end === end, "content-range mismatch");
        return;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range = parseRangeHeader(headers["content-range"]);
          if (range == null) {
            this.headersSent = true;
            this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
            return;
          }
          const { start, size, end = size ? size - 1 : null } = range;
          assert(start != null && Number.isFinite(start), "content-range mismatch");
          assert(end != null && Number.isFinite(end), "invalid content-length");
          this.start = start;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) - 1 : null;
        }
        assert(Number.isFinite(this.start));
        assert(this.end == null || Number.isFinite(this.end), "invalid content-length");
        this.resume = true;
        this.etag = headers.etag != null ? headers.etag : null;
        if (this.etag != null && this.etag[0] === "W" && this.etag[1] === "/") {
          this.etag = null;
        }
        this.headersSent = true;
        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
      } else {
        throw new RequestRetryError("Request failed", statusCode, {
          headers,
          data: { count: this.retryCount }
        });
      }
    }
    onResponseData(controller, chunk) {
      if (this.error) {
        return;
      }
      this.start += chunk.length;
      this.handler.onResponseData?.(controller, chunk);
    }
    onResponseEnd(controller, trailers) {
      if (this.error && this.retryOpts.throwOnError) {
        throw this.error;
      }
      if (!this.error) {
        this.retryCount = 0;
        return this.handler.onResponseEnd?.(controller, trailers);
      }
      this.retry(controller);
    }
    retry(controller) {
      if (this.start !== 0) {
        const headers = { range: `bytes=${this.start}-${this.end ?? ""}` };
        if (this.etag != null) {
          headers["if-match"] = this.etag;
        }
        this.opts = {
          ...this.opts,
          headers: {
            ...this.opts.headers,
            ...headers
          }
        };
      }
      try {
        this.retryCountCheckpoint = this.retryCount;
        this.dispatch(this.opts, this);
      } catch (err) {
        this.handler.onResponseError?.(controller, err);
      }
    }
    onResponseError(controller, err) {
      if (controller?.aborted || isDisturbed(this.opts.body)) {
        this.handler.onResponseError?.(controller, err);
        return;
      }
      function shouldRetry(returnedErr) {
        if (!returnedErr) {
          this.retry(controller);
          return;
        }
        this.handler?.onResponseError?.(controller, returnedErr);
      }
      if (this.retryCount - this.retryCountCheckpoint > 0) {
        this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
      } else {
        this.retryCount += 1;
      }
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, shouldRetry.bind(this));
    }
  }
  module.exports = RetryHandler;
});

// node_modules/undici/lib/dispatcher/retry-agent.js
var require_retry_agent = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var RetryHandler = require_retry_handler();

  class RetryAgent extends Dispatcher {
    #agent = null;
    #options = null;
    constructor(agent, options = {}) {
      super(options);
      this.#agent = agent;
      this.#options = options;
    }
    dispatch(opts, handler) {
      const retry = new RetryHandler({
        ...opts,
        retryOptions: this.#options
      }, {
        dispatch: this.#agent.dispatch.bind(this.#agent),
        handler
      });
      return this.#agent.dispatch(opts, retry);
    }
    close() {
      return this.#agent.close();
    }
    destroy() {
      return this.#agent.destroy();
    }
  }
  module.exports = RetryAgent;
});

// node_modules/undici/lib/dispatcher/h2c-client.js
var require_h2c_client = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors();
  var Client = require_client();

  class H2CClient extends Client {
    constructor(origin, clientOpts) {
      if (typeof origin === "string") {
        origin = new URL(origin);
      }
      if (origin.protocol !== "http:") {
        throw new InvalidArgumentError("h2c-client: Only h2c protocol is supported");
      }
      const { connect, maxConcurrentStreams, pipelining, ...opts } = clientOpts ?? {};
      let defaultMaxConcurrentStreams = 100;
      let defaultPipelining = 100;
      if (maxConcurrentStreams != null && Number.isInteger(maxConcurrentStreams) && maxConcurrentStreams > 0) {
        defaultMaxConcurrentStreams = maxConcurrentStreams;
      }
      if (pipelining != null && Number.isInteger(pipelining) && pipelining > 0) {
        defaultPipelining = pipelining;
      }
      if (defaultPipelining > defaultMaxConcurrentStreams) {
        throw new InvalidArgumentError("h2c-client: pipelining cannot be greater than maxConcurrentStreams");
      }
      super(origin, {
        ...opts,
        maxConcurrentStreams: defaultMaxConcurrentStreams,
        pipelining: defaultPipelining,
        allowH2: true,
        useH2c: true
      });
    }
  }
  module.exports = H2CClient;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { Readable } = __require("node:stream");
  var { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require_errors();
  var util = require_util();
  var { ReadableStreamFrom } = require_util();
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("kAbort");
  var kContentType = Symbol("kContentType");
  var kContentLength = Symbol("kContentLength");
  var kUsed = Symbol("kUsed");
  var kBytesRead = Symbol("kBytesRead");
  var noop = () => {};

  class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      contentLength,
      highWaterMark = 64 * 1024
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBytesRead] = 0;
      this[kBody] = null;
      this[kUsed] = false;
      this[kContentType] = contentType;
      this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null;
      this[kReading] = false;
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      if (err) {
        this[kAbort]();
      }
      if (!this[kUsed]) {
        setImmediate(callback, err);
      } else {
        callback(err);
      }
    }
    on(event, listener) {
      if (event === "data" || event === "readable") {
        this[kReading] = true;
        this[kUsed] = true;
      }
      return super.on(event, listener);
    }
    addListener(event, listener) {
      return this.on(event, listener);
    }
    off(event, listener) {
      const ret = super.off(event, listener);
      if (event === "data" || event === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(event, listener) {
      return this.off(event, listener);
    }
    push(chunk) {
      if (chunk) {
        this[kBytesRead] += chunk.length;
        if (this[kConsume]) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
      }
      return super.push(chunk);
    }
    text() {
      return consume(this, "text");
    }
    json() {
      return consume(this, "json");
    }
    blob() {
      return consume(this, "blob");
    }
    bytes() {
      return consume(this, "bytes");
    }
    arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    dump(opts) {
      const signal = opts?.signal;
      if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
        return Promise.reject(new InvalidArgumentError("signal must be an AbortSignal"));
      }
      const limit = opts?.limit && Number.isFinite(opts.limit) ? opts.limit : 128 * 1024;
      if (signal?.aborted) {
        return Promise.reject(signal.reason ?? new AbortError);
      }
      if (this._readableState.closeEmitted) {
        return Promise.resolve(null);
      }
      return new Promise((resolve, reject) => {
        if (this[kContentLength] && this[kContentLength] > limit || this[kBytesRead] > limit) {
          this.destroy(new AbortError);
        }
        if (signal) {
          const onAbort = () => {
            this.destroy(signal.reason ?? new AbortError);
          };
          signal.addEventListener("abort", onAbort);
          this.on("close", function() {
            signal.removeEventListener("abort", onAbort);
            if (signal.aborted) {
              reject(signal.reason ?? new AbortError);
            } else {
              resolve(null);
            }
          });
        } else {
          this.on("close", resolve);
        }
        this.on("error", noop).on("data", () => {
          if (this[kBytesRead] > limit) {
            this.destroy();
          }
        }).resume();
      });
    }
    setEncoding(encoding) {
      if (Buffer.isEncoding(encoding)) {
        this._readableState.encoding = encoding;
      }
      return this;
    }
  }
  function isLocked(bodyReadable) {
    return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null;
  }
  function isUnusable(bodyReadable) {
    return util.isDisturbed(bodyReadable) || isLocked(bodyReadable);
  }
  function consume(stream, type) {
    assert(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      if (isUnusable(stream)) {
        const rState = stream._readableState;
        if (rState.destroyed && rState.closeEmitted === false) {
          stream.on("error", reject).on("close", () => {
            reject(new TypeError("unusable"));
          });
        } else {
          reject(rState.errored ?? new TypeError("unusable"));
        }
      } else {
        queueMicrotask(() => {
          stream[kConsume] = {
            type,
            stream,
            resolve,
            reject,
            length: 0,
            body: []
          };
          stream.on("error", function(err) {
            consumeFinish(this[kConsume], err);
          }).on("close", function() {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError);
            }
          });
          consumeStart(stream[kConsume]);
        });
      }
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    if (state.bufferIndex) {
      const start = state.bufferIndex;
      const end = state.buffer.length;
      for (let n = start;n < end; n++) {
        consumePush(consume2, state.buffer[n]);
      }
    } else {
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume], this._readableState.encoding);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume], this._readableState.encoding);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {}
  }
  function chunksDecode(chunks, length, encoding) {
    if (chunks.length === 0 || length === 0) {
      return "";
    }
    const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
    const bufferLength = buffer.length;
    const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
    if (!encoding || encoding === "utf8" || encoding === "utf-8") {
      return buffer.utf8Slice(start, bufferLength);
    } else {
      return buffer.subarray(start, bufferLength).toString(encoding);
    }
  }
  function chunksConcat(chunks, length) {
    if (chunks.length === 0 || length === 0) {
      return new Uint8Array(0);
    }
    if (chunks.length === 1) {
      return new Uint8Array(chunks[0]);
    }
    const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
    let offset = 0;
    for (let i = 0;i < chunks.length; ++i) {
      const chunk = chunks[i];
      buffer.set(chunk, offset);
      offset += chunk.length;
    }
    return buffer;
  }
  function consumeEnd(consume2, encoding) {
    const { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(chunksDecode(body, length, encoding));
      } else if (type === "json") {
        resolve(JSON.parse(chunksDecode(body, length, encoding)));
      } else if (type === "arrayBuffer") {
        resolve(chunksConcat(body, length).buffer);
      } else if (type === "blob") {
        resolve(new Blob(body, { type: stream[kContentType] }));
      } else if (type === "bytes") {
        resolve(chunksConcat(body, length));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
  module.exports = {
    Readable: BodyReadable,
    chunksDecode
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { AsyncResource } = __require("node:async_hooks");
  var { Readable } = require_readable();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var util = require_util();
  function noop() {}

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", noop), err);
        }
        throw err;
      }
      this.method = method;
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.highWaterMark = highWaterMark;
      this.reason = null;
      this.removeAbortListener = null;
      if (signal?.aborted) {
        this.reason = signal.reason ?? new RequestAbortedError;
      } else if (signal) {
        this.removeAbortListener = util.addAbortListener(signal, () => {
          this.reason = signal.reason ?? new RequestAbortedError;
          if (this.res) {
            util.destroy(this.res.on("error", noop), this.reason);
          } else if (this.abort) {
            this.abort(this.reason);
          }
        });
      }
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
      const contentType = parsedHeaders["content-type"];
      const contentLength = parsedHeaders["content-length"];
      const res = new Readable({
        resume,
        abort,
        contentType,
        contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
        highWaterMark
      });
      if (this.removeAbortListener) {
        res.on("close", this.removeAbortListener);
        this.removeAbortListener = null;
      }
      this.callback = null;
      this.res = res;
      if (callback !== null) {
        try {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body: res,
            context
          });
        } catch (err) {
          this.res = null;
          util.destroy(res.on("error", noop), err);
          queueMicrotask(() => {
            throw err;
          });
        }
      }
    }
    onData(chunk) {
      return this.res.push(chunk);
    }
    onComplete(trailers) {
      util.parseHeaders(trailers, this.trailers);
      this.res.push(null);
    }
    onError(err) {
      const { res, callback, body, opaque } = this;
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util.destroy(res.on("error", noop), err);
        });
      }
      if (body) {
        this.body = null;
        if (util.isStream(body)) {
          body.on("error", noop);
          util.destroy(body, err);
        }
      }
      if (this.removeAbortListener) {
        this.removeAbortListener();
        this.removeAbortListener = null;
      }
    }
  }
  function request(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const handler = new RequestHandler(opts, callback);
      this.dispatch(opts, handler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  var { addAbortListener } = require_util();
  var { RequestAbortedError } = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(self) {
    if (self.abort) {
      self.abort(self[kSignal]?.reason);
    } else {
      self.reason = self[kSignal]?.reason ?? new RequestAbortedError;
    }
    removeSignal(self);
  }
  function addSignal(self, signal) {
    self.reason = null;
    self[kSignal] = null;
    self[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self);
      return;
    }
    self[kSignal] = signal;
    self[kListener] = () => {
      abort(self);
    };
    addAbortListener(self[kSignal], self[kListener]);
  }
  function removeSignal(self) {
    if (!self[kSignal]) {
      return;
    }
    if ("removeEventListener" in self[kSignal]) {
      self[kSignal].removeEventListener("abort", self[kListener]);
    } else {
      self[kSignal].removeListener("abort", self[kListener]);
    }
    self[kSignal] = null;
    self[kListener] = null;
  }
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { finished } = __require("node:stream");
  var { AsyncResource } = __require("node:async_hooks");
  var { InvalidArgumentError, InvalidReturnValueError } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  function noop() {}

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", noop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body;
      this.onInfo = onInfo || null;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, responseHeaders } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.factory = null;
      if (factory === null) {
        return;
      }
      const res = this.runInAsyncScope(factory, null, {
        statusCode,
        headers,
        opaque,
        context
      });
      if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
        throw new InvalidReturnValueError("expected Writable");
      }
      finished(res, { readable: false }, (err) => {
        const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
        this.res = null;
        if (err || !res2?.readable) {
          util.destroy(res2, err);
        }
        this.callback = null;
        this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
        if (err) {
          abort();
        }
      });
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState?.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  function stream(opts, factory, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const handler = new StreamHandler(opts, factory, callback);
      this.dispatch(opts, handler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = stream;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("node:stream");
  var assert = __require("node:assert");
  var { AsyncResource } = __require("node:async_hooks");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  function noop() {}
  var kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", noop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body } = this;
          if (body?.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError;
          }
          if (abort && err) {
            abort();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { res } = this;
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(!res, "pipeline cannot be retried");
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", noop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError);
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  }
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module.exports = pipeline;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  var { InvalidArgumentError, SocketError } = require_errors();
  var { AsyncResource } = __require("node:async_hooks");
  var assert = __require("node:assert");
  var util = require_util();
  var { kHTTP2Stream } = require_symbols();
  var { addSignal, removeSignal } = require_abort_signal();

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      assert(socket[kHTTP2Stream] === true ? statusCode === 200 : statusCode === 101);
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function upgrade(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      const upgradeOpts = {
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      };
      this.dispatch(upgradeOpts, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { AsyncResource } = __require("node:async_hooks");
  var { InvalidArgumentError, SocketError } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers = rawHeaders;
      if (headers != null) {
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function connect(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      const connectOptions = { ...opts, method: "CONNECT" };
      this.dispatch(connectOptions, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();
  var kMockNotMatchedError = Symbol.for("undici.error.UND_MOCK_ERR_MOCK_NOT_MATCHED");

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kMockNotMatchedError] === true;
    }
    get [kMockNotMatchedError]() {
      return true;
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOriginalDispatch: Symbol("original dispatch"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected"),
    kIgnoreTrailingSlash: Symbol("ignore trailing slash"),
    kMockAgentMockCallHistoryInstance: Symbol("mock agent mock call history name"),
    kMockAgentRegisterCallHistory: Symbol("mock agent register mock call history"),
    kMockAgentAddCallHistoryLog: Symbol("mock agent add call history log"),
    kMockAgentIsCallHistoryEnabled: Symbol("mock agent is call history enabled"),
    kMockAgentAcceptsNonStandardSearchParameters: Symbol("mock agent accepts non standard search parameters"),
    kMockCallHistoryAddLog: Symbol("mock call history add log")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  var { MockNotMatchedError } = require_mock_errors();
  var {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols();
  var { serializePathWithQuery } = require_util();
  var { STATUS_CODES } = __require("node:http");
  var {
    types: {
      isPromise
    }
  } = __require("node:util");
  var { InvalidArgumentError } = require_errors();
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  }
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers[i + 1];
        }
      }
      return;
    } else if (typeof headers.get === "function") {
      return headers.get(key);
    } else {
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers) {
    const clone = headers.slice();
    const entries = [];
    for (let index = 0;index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers)) {
        headers = buildHeadersFromArray(headers);
      }
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function normalizeSearchParams(query) {
    if (typeof query !== "string") {
      return query;
    }
    const originalQp = new URLSearchParams(query);
    const normalizedQp = new URLSearchParams;
    for (let [key, value] of originalQp.entries()) {
      key = key.replace("[]", "");
      const valueRepresentsString = /^(['"]).*\1$/.test(value);
      if (valueRepresentsString) {
        normalizedQp.append(key, value);
        continue;
      }
      if (value.includes(",")) {
        const values = value.split(",");
        for (const v of values) {
          normalizedQp.append(key, v);
        }
        continue;
      }
      normalizedQp.append(key, value);
    }
    return normalizedQp;
  }
  function safeUrl(path) {
    if (typeof path !== "string") {
      return path;
    }
    const pathSegments = path.split("?", 3);
    if (pathSegments.length !== 2) {
      return path;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path, method, body, headers }) {
    const pathMatch = matchValue(mockDispatch2.path, path);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (data instanceof Uint8Array) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else if (data) {
      return data.toString();
    } else {
      return "";
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath);
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path, ignoreTrailingSlash }) => {
      return ignoreTrailingSlash ? matchValue(removeTrailingSlash(safeUrl(path)), resolvedPathWithoutTrailingSlash) : matchValue(safeUrl(path), resolvedPath);
    });
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      const headers = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data, opts) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function removeTrailingSlash(path) {
    while (path.endsWith("/")) {
      path = path.slice(0, -1);
    }
    if (path.length === 0) {
      path = "/";
    }
    return path;
  }
  function buildKey(opts) {
    const { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  }
  function generateKeyValues(data) {
    const keys = Object.keys(data);
    const result2 = [];
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      const value = data[key];
      const name = Buffer.from(`${key}`);
      if (Array.isArray(value)) {
        for (let j = 0;j < value.length; ++j) {
          result2.push(name, Buffer.from(`${value[j]}`));
        }
      } else {
        result2.push(name, Buffer.from(`${value}`));
      }
    }
    return result2;
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body) {
    const buffers = [];
    for await (const data of body) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers, trailers, error: error2 }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error2 !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error2);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        return body.then((newData) => handleReply(mockDispatches, newData));
      }
      const responseData = getResponseData(body);
      const responseHeaders = generateKeyValues(headers);
      const responseTrailers = generateKeyValues(trailers);
      handler.onConnect?.((err) => handler.onError(err), null);
      handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData?.(Buffer.from(responseData));
      handler.onComplete?.(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {}
    return true;
  }
  function buildMockDispatch() {
    const agent = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error2) {
          if (error2.code === "UND_MOCK_ERR_MOCK_NOT_MATCHED") {
            const netConnect = agent[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error2;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function normalizeOrigin(origin) {
    if (typeof origin !== "string" && !(origin instanceof URL)) {
      return origin;
    }
    if (origin instanceof URL) {
      return origin.origin;
    }
    return origin.toLowerCase();
  }
  function buildAndValidateMockOptions(opts) {
    const { agent, ...mockOptions } = opts;
    if ("enableCallHistory" in mockOptions && typeof mockOptions.enableCallHistory !== "boolean") {
      throw new InvalidArgumentError("options.enableCallHistory must to be a boolean");
    }
    if ("acceptNonStandardSearchParameters" in mockOptions && typeof mockOptions.acceptNonStandardSearchParameters !== "boolean") {
      throw new InvalidArgumentError("options.acceptNonStandardSearchParameters must to be a boolean");
    }
    if ("ignoreTrailingSlash" in mockOptions && typeof mockOptions.ignoreTrailingSlash !== "boolean") {
      throw new InvalidArgumentError("options.ignoreTrailingSlash must to be a boolean");
    }
    return mockOptions;
  }
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildAndValidateMockOptions,
    getHeaderByName,
    buildHeadersFromArray,
    normalizeSearchParams,
    normalizeOrigin
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch,
    kIgnoreTrailingSlash
  } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  var { serializePathWithQuery } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = serializePathWithQuery(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData({ statusCode, data, responseOptions }) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(replyParameters) {
      if (typeof replyParameters.statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    reply(replyOptionsCallbackOrStatusCode) {
      if (typeof replyOptionsCallbackOrStatusCode === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyOptionsCallbackOrStatusCode(opts);
          if (typeof resolvedData !== "object" || resolvedData === null) {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
          this.validateReplyParameters(replyParameters2);
          return {
            ...this.createMockScopeDispatchData(replyParameters2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch2);
      }
      const replyParameters = {
        statusCode: replyOptionsCallbackOrStatusCode,
        data: arguments[1] === undefined ? "" : arguments[1],
        responseOptions: arguments[2] === undefined ? {} : arguments[2]
      };
      this.validateReplyParameters(replyParameters);
      const dispatchData = this.createMockScopeDispatchData(replyParameters);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
      return new MockScope(newMockDispatch);
    }
    replyWithError(error2) {
      if (typeof error2 === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers;
      return this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify } = __require("node:util");
  var Client = require_client();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected,
    kIgnoreTrailingSlash
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockClient extends Client {
    constructor(origin, opts) {
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      super(origin, opts);
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts }, this[kDispatches]);
    }
    cleanMocks() {
      this[kDispatches] = [];
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-call-history.js
var require_mock_call_history = __commonJS((exports, module) => {
  var { kMockCallHistoryAddLog } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  function handleFilterCallsWithOptions(criteria, options, handler, store) {
    switch (options.operator) {
      case "OR":
        store.push(...handler(criteria));
        return store;
      case "AND":
        return handler.call({ logs: store }, criteria);
      default:
        throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
    }
  }
  function buildAndValidateFilterCallsOptions(options = {}) {
    const finalOptions = {};
    if ("operator" in options) {
      if (typeof options.operator !== "string" || options.operator.toUpperCase() !== "OR" && options.operator.toUpperCase() !== "AND") {
        throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
      }
      return {
        ...finalOptions,
        operator: options.operator.toUpperCase()
      };
    }
    return finalOptions;
  }
  function makeFilterCalls(parameterName) {
    return (parameterValue) => {
      if (typeof parameterValue === "string" || parameterValue == null) {
        return this.logs.filter((log) => {
          return log[parameterName] === parameterValue;
        });
      }
      if (parameterValue instanceof RegExp) {
        return this.logs.filter((log) => {
          return parameterValue.test(log[parameterName]);
        });
      }
      throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`);
    };
  }
  function computeUrlWithMaybeSearchParameters(requestInit) {
    try {
      const url = new URL(requestInit.path, requestInit.origin);
      if (url.search.length !== 0) {
        return url;
      }
      url.search = new URLSearchParams(requestInit.query).toString();
      return url;
    } catch (error2) {
      throw new InvalidArgumentError("An error occurred when computing MockCallHistoryLog.url", { cause: error2 });
    }
  }

  class MockCallHistoryLog {
    constructor(requestInit = {}) {
      this.body = requestInit.body;
      this.headers = requestInit.headers;
      this.method = requestInit.method;
      const url = computeUrlWithMaybeSearchParameters(requestInit);
      this.fullUrl = url.toString();
      this.origin = url.origin;
      this.path = url.pathname;
      this.searchParams = Object.fromEntries(url.searchParams);
      this.protocol = url.protocol;
      this.host = url.host;
      this.port = url.port;
      this.hash = url.hash;
    }
    toMap() {
      return new Map([
        ["protocol", this.protocol],
        ["host", this.host],
        ["port", this.port],
        ["origin", this.origin],
        ["path", this.path],
        ["hash", this.hash],
        ["searchParams", this.searchParams],
        ["fullUrl", this.fullUrl],
        ["method", this.method],
        ["body", this.body],
        ["headers", this.headers]
      ]);
    }
    toString() {
      const options = { betweenKeyValueSeparator: "->", betweenPairSeparator: "|" };
      let result2 = "";
      this.toMap().forEach((value, key) => {
        if (typeof value === "string" || value === undefined || value === null) {
          result2 = `${result2}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`;
        }
        if (typeof value === "object" && value !== null || Array.isArray(value)) {
          result2 = `${result2}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`;
        }
      });
      return result2.slice(0, -1);
    }
  }

  class MockCallHistory {
    logs = [];
    calls() {
      return this.logs;
    }
    firstCall() {
      return this.logs.at(0);
    }
    lastCall() {
      return this.logs.at(-1);
    }
    nthCall(number) {
      if (typeof number !== "number") {
        throw new InvalidArgumentError("nthCall must be called with a number");
      }
      if (!Number.isInteger(number)) {
        throw new InvalidArgumentError("nthCall must be called with an integer");
      }
      if (Math.sign(number) !== 1) {
        throw new InvalidArgumentError("nthCall must be called with a positive value. use firstCall or lastCall instead");
      }
      return this.logs.at(number - 1);
    }
    filterCalls(criteria, options) {
      if (this.logs.length === 0) {
        return this.logs;
      }
      if (typeof criteria === "function") {
        return this.logs.filter(criteria);
      }
      if (criteria instanceof RegExp) {
        return this.logs.filter((log) => {
          return criteria.test(log.toString());
        });
      }
      if (typeof criteria === "object" && criteria !== null) {
        if (Object.keys(criteria).length === 0) {
          return this.logs;
        }
        const finalOptions = { operator: "OR", ...buildAndValidateFilterCallsOptions(options) };
        let maybeDuplicatedLogsFiltered = [];
        if ("protocol" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered);
        }
        if ("host" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered);
        }
        if ("port" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered);
        }
        if ("origin" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered);
        }
        if ("path" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered);
        }
        if ("hash" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered);
        }
        if ("fullUrl" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered);
        }
        if ("method" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered);
        }
        const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)];
        return uniqLogsFiltered;
      }
      throw new InvalidArgumentError("criteria parameter should be one of function, regexp, or object");
    }
    filterCallsByProtocol = makeFilterCalls.call(this, "protocol");
    filterCallsByHost = makeFilterCalls.call(this, "host");
    filterCallsByPort = makeFilterCalls.call(this, "port");
    filterCallsByOrigin = makeFilterCalls.call(this, "origin");
    filterCallsByPath = makeFilterCalls.call(this, "path");
    filterCallsByHash = makeFilterCalls.call(this, "hash");
    filterCallsByFullUrl = makeFilterCalls.call(this, "fullUrl");
    filterCallsByMethod = makeFilterCalls.call(this, "method");
    clear() {
      this.logs = [];
    }
    [kMockCallHistoryAddLog](requestInit) {
      const log = new MockCallHistoryLog(requestInit);
      this.logs.push(log);
      return log;
    }
    *[Symbol.iterator]() {
      for (const log of this.calls()) {
        yield log;
      }
    }
  }
  exports.MockCallHistory = MockCallHistory;
  exports.MockCallHistoryLog = MockCallHistoryLog;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify } = __require("node:util");
  var Pool = require_pool();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected,
    kIgnoreTrailingSlash
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      super(origin, opts);
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts }, this[kDispatches]);
    }
    cleanMocks() {
      this[kDispatches] = [];
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var { Console } = __require("node:console");
  var PERSISTENT = process.versions.icu ? "" : "Y ";
  var NOT_PERSISTENT = process.versions.icu ? "" : "N ";
  module.exports = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }));
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols();
  var Agent = require_agent();
  var {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory,
    kMockAgentRegisterCallHistory,
    kMockAgentIsCallHistoryEnabled,
    kMockAgentAddCallHistoryLog,
    kMockAgentMockCallHistoryInstance,
    kMockAgentAcceptsNonStandardSearchParameters,
    kMockCallHistoryAddLog,
    kIgnoreTrailingSlash
  } = require_mock_symbols();
  var MockClient = require_mock_client();
  var MockPool = require_mock_pool();
  var { matchValue, normalizeSearchParams, buildAndValidateMockOptions, normalizeOrigin } = require_mock_utils();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var Dispatcher = require_dispatcher();
  var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
  var { MockCallHistory } = require_mock_call_history();

  class MockAgent extends Dispatcher {
    constructor(opts = {}) {
      super(opts);
      const mockOptions = buildAndValidateMockOptions(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      this[kMockAgentIsCallHistoryEnabled] = mockOptions.enableCallHistory ?? false;
      this[kMockAgentAcceptsNonStandardSearchParameters] = mockOptions.acceptNonStandardSearchParameters ?? false;
      this[kIgnoreTrailingSlash] = mockOptions.ignoreTrailingSlash ?? false;
      if (opts?.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent = opts?.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent;
      this[kClients] = agent[kClients];
      this[kOptions] = mockOptions;
      if (this[kMockAgentIsCallHistoryEnabled]) {
        this[kMockAgentRegisterCallHistory]();
      }
    }
    get(origin) {
      const normalizedOrigin = normalizeOrigin(origin);
      const originKey = this[kIgnoreTrailingSlash] ? normalizedOrigin.replace(/\/$/, "") : normalizedOrigin;
      let dispatcher = this[kMockAgentGet](originKey);
      if (!dispatcher) {
        dispatcher = this[kFactory](originKey);
        this[kMockAgentSet](originKey, dispatcher);
      }
      return dispatcher;
    }
    dispatch(opts, handler) {
      opts.origin = normalizeOrigin(opts.origin);
      this.get(opts.origin);
      this[kMockAgentAddCallHistoryLog](opts);
      const acceptNonStandardSearchParameters = this[kMockAgentAcceptsNonStandardSearchParameters];
      const dispatchOpts = { ...opts };
      if (acceptNonStandardSearchParameters && dispatchOpts.path) {
        const [path, searchParams] = dispatchOpts.path.split("?");
        const normalizedSearchParams = normalizeSearchParams(searchParams, acceptNonStandardSearchParameters);
        dispatchOpts.path = `${path}?${normalizedSearchParams}`;
      }
      return this[kAgent].dispatch(dispatchOpts, handler);
    }
    async close() {
      this.clearCallHistory();
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    enableCallHistory() {
      this[kMockAgentIsCallHistoryEnabled] = true;
      return this;
    }
    disableCallHistory() {
      this[kMockAgentIsCallHistoryEnabled] = false;
      return this;
    }
    getCallHistory() {
      return this[kMockAgentMockCallHistoryInstance];
    }
    clearCallHistory() {
      if (this[kMockAgentMockCallHistoryInstance] !== undefined) {
        this[kMockAgentMockCallHistoryInstance].clear();
      }
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentRegisterCallHistory]() {
      if (this[kMockAgentMockCallHistoryInstance] === undefined) {
        this[kMockAgentMockCallHistoryInstance] = new MockCallHistory;
      }
    }
    [kMockAgentAddCallHistoryLog](opts) {
      if (this[kMockAgentIsCallHistoryEnabled]) {
        this[kMockAgentRegisterCallHistory]();
        this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts);
      }
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, { count: 0, dispatcher });
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const result2 = this[kClients].get(origin);
      if (result2?.dispatcher) {
        return result2.dispatcher;
      }
      if (typeof origin !== "string") {
        const dispatcher = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher);
        return dispatcher;
      }
      for (const [keyMatcher, result3] of Array.from(this[kClients])) {
        if (result3 && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
          dispatcher[kDispatches] = result3.dispatcher[kDispatches];
          return dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, result2]) => result2.dispatcher[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      throw new UndiciError(pending.length === 1 ? `1 interceptor is pending:

${pendingInterceptorsFormatter.format(pending)}`.trim() : `${pending.length} interceptors are pending:

${pendingInterceptorsFormatter.format(pending)}`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/mock/snapshot-utils.js
var require_snapshot_utils = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors();
  var { runtimeFeatures } = require_runtime_features();
  function createHeaderFilters(matchOptions = {}) {
    const { ignoreHeaders = [], excludeHeaders = [], matchHeaders = [], caseSensitive = false } = matchOptions;
    return {
      ignore: new Set(ignoreHeaders.map((header) => caseSensitive ? header : header.toLowerCase())),
      exclude: new Set(excludeHeaders.map((header) => caseSensitive ? header : header.toLowerCase())),
      match: new Set(matchHeaders.map((header) => caseSensitive ? header : header.toLowerCase()))
    };
  }
  var crypto = runtimeFeatures.has("crypto") ? __require("node:crypto") : null;
  var hashId = crypto?.hash ? (value) => crypto.hash("sha256", value, "base64url") : (value) => Buffer.from(value).toString("base64url");
  function isUndiciHeaders(headers) {
    return Array.isArray(headers) && (headers.length & 1) === 0;
  }
  function isUrlExcludedFactory(excludePatterns = []) {
    if (excludePatterns.length === 0) {
      return () => false;
    }
    return function isUrlExcluded(url) {
      let urlLowerCased;
      for (const pattern of excludePatterns) {
        if (typeof pattern === "string") {
          if (!urlLowerCased) {
            urlLowerCased = url.toLowerCase();
          }
          if (urlLowerCased.includes(pattern.toLowerCase())) {
            return true;
          }
        } else if (pattern instanceof RegExp) {
          if (pattern.test(url)) {
            return true;
          }
        }
      }
      return false;
    };
  }
  function normalizeHeaders(headers) {
    const normalizedHeaders = {};
    if (!headers)
      return normalizedHeaders;
    if (isUndiciHeaders(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        const key = headers[i];
        const value = headers[i + 1];
        if (key && value !== undefined) {
          const keyStr = Buffer.isBuffer(key) ? key.toString() : key;
          const valueStr = Buffer.isBuffer(value) ? value.toString() : value;
          normalizedHeaders[keyStr.toLowerCase()] = valueStr;
        }
      }
      return normalizedHeaders;
    }
    if (headers && typeof headers === "object") {
      for (const [key, value] of Object.entries(headers)) {
        if (key && typeof key === "string") {
          normalizedHeaders[key.toLowerCase()] = Array.isArray(value) ? value.join(", ") : String(value);
        }
      }
    }
    return normalizedHeaders;
  }
  var validSnapshotModes = ["record", "playback", "update"];
  function validateSnapshotMode(mode) {
    if (!validSnapshotModes.includes(mode)) {
      throw new InvalidArgumentError(`Invalid snapshot mode: ${mode}. Must be one of: ${validSnapshotModes.join(", ")}`);
    }
  }
  module.exports = {
    createHeaderFilters,
    hashId,
    isUndiciHeaders,
    normalizeHeaders,
    isUrlExcludedFactory,
    validateSnapshotMode
  };
});

// node_modules/undici/lib/mock/snapshot-recorder.js
var require_snapshot_recorder = __commonJS((exports, module) => {
  var { writeFile, readFile, mkdir } = __require("node:fs/promises");
  var { dirname, resolve } = __require("node:path");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { InvalidArgumentError, UndiciError } = require_errors();
  var { hashId, isUrlExcludedFactory, normalizeHeaders, createHeaderFilters } = require_snapshot_utils();
  function formatRequestKey(opts, headerFilters, matchOptions = {}) {
    const url = new URL(opts.path, opts.origin);
    const normalized = opts._normalizedHeaders || normalizeHeaders(opts.headers);
    if (!opts._normalizedHeaders) {
      opts._normalizedHeaders = normalized;
    }
    return {
      method: opts.method || "GET",
      url: matchOptions.matchQuery !== false ? url.toString() : `${url.origin}${url.pathname}`,
      headers: filterHeadersForMatching(normalized, headerFilters, matchOptions),
      body: matchOptions.matchBody !== false && opts.body ? String(opts.body) : ""
    };
  }
  function filterHeadersForMatching(headers, headerFilters, matchOptions = {}) {
    if (!headers || typeof headers !== "object")
      return {};
    const {
      caseSensitive = false
    } = matchOptions;
    const filtered = {};
    const { ignore, exclude, match } = headerFilters;
    for (const [key, value] of Object.entries(headers)) {
      const headerKey = caseSensitive ? key : key.toLowerCase();
      if (exclude.has(headerKey))
        continue;
      if (ignore.has(headerKey))
        continue;
      if (match.size !== 0) {
        if (!match.has(headerKey))
          continue;
      }
      filtered[headerKey] = value;
    }
    return filtered;
  }
  function filterHeadersForStorage(headers, headerFilters, matchOptions = {}) {
    if (!headers || typeof headers !== "object")
      return {};
    const {
      caseSensitive = false
    } = matchOptions;
    const filtered = {};
    const { exclude: excludeSet } = headerFilters;
    for (const [key, value] of Object.entries(headers)) {
      const headerKey = caseSensitive ? key : key.toLowerCase();
      if (excludeSet.has(headerKey))
        continue;
      filtered[headerKey] = value;
    }
    return filtered;
  }
  function createRequestHash(formattedRequest) {
    const parts = [
      formattedRequest.method,
      formattedRequest.url
    ];
    if (formattedRequest.headers && typeof formattedRequest.headers === "object") {
      const headerKeys = Object.keys(formattedRequest.headers).sort();
      for (const key of headerKeys) {
        const values = Array.isArray(formattedRequest.headers[key]) ? formattedRequest.headers[key] : [formattedRequest.headers[key]];
        parts.push(key);
        for (const value of values.sort()) {
          parts.push(String(value));
        }
      }
    }
    parts.push(formattedRequest.body);
    const content = parts.join("|");
    return hashId(content);
  }

  class SnapshotRecorder {
    #flushTimeout;
    #isUrlExcluded;
    #snapshots = new Map;
    #snapshotPath;
    #maxSnapshots = Infinity;
    #autoFlush = false;
    #headerFilters;
    constructor(options = {}) {
      this.#snapshotPath = options.snapshotPath;
      this.#maxSnapshots = options.maxSnapshots || Infinity;
      this.#autoFlush = options.autoFlush || false;
      this.flushInterval = options.flushInterval || 30000;
      this._flushTimer = null;
      this.matchOptions = {
        matchHeaders: options.matchHeaders || [],
        ignoreHeaders: options.ignoreHeaders || [],
        excludeHeaders: options.excludeHeaders || [],
        matchBody: options.matchBody !== false,
        matchQuery: options.matchQuery !== false,
        caseSensitive: options.caseSensitive || false
      };
      this.#headerFilters = createHeaderFilters(this.matchOptions);
      this.shouldRecord = options.shouldRecord || (() => true);
      this.shouldPlayback = options.shouldPlayback || (() => true);
      this.#isUrlExcluded = isUrlExcludedFactory(options.excludeUrls);
      if (this.#autoFlush && this.#snapshotPath) {
        this.#startAutoFlush();
      }
    }
    async record(requestOpts, response) {
      if (!this.shouldRecord(requestOpts)) {
        return;
      }
      if (this.isUrlExcluded(requestOpts)) {
        return;
      }
      const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request);
      const normalizedHeaders = normalizeHeaders(response.headers);
      const responseData = {
        statusCode: response.statusCode,
        headers: filterHeadersForStorage(normalizedHeaders, this.#headerFilters, this.matchOptions),
        body: Buffer.isBuffer(response.body) ? response.body.toString("base64") : Buffer.from(String(response.body || "")).toString("base64"),
        trailers: response.trailers
      };
      if (this.#snapshots.size >= this.#maxSnapshots && !this.#snapshots.has(hash)) {
        const oldestKey = this.#snapshots.keys().next().value;
        this.#snapshots.delete(oldestKey);
      }
      const existingSnapshot = this.#snapshots.get(hash);
      if (existingSnapshot && existingSnapshot.responses) {
        existingSnapshot.responses.push(responseData);
        existingSnapshot.timestamp = new Date().toISOString();
      } else {
        this.#snapshots.set(hash, {
          request,
          responses: [responseData],
          callCount: 0,
          timestamp: new Date().toISOString()
        });
      }
      if (this.#autoFlush && this.#snapshotPath) {
        this.#scheduleFlush();
      }
    }
    isUrlExcluded(requestOpts) {
      const url = new URL(requestOpts.path, requestOpts.origin).toString();
      return this.#isUrlExcluded(url);
    }
    findSnapshot(requestOpts) {
      if (!this.shouldPlayback(requestOpts)) {
        return;
      }
      if (this.isUrlExcluded(requestOpts)) {
        return;
      }
      const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request);
      const snapshot = this.#snapshots.get(hash);
      if (!snapshot)
        return;
      const currentCallCount = snapshot.callCount || 0;
      const responseIndex = Math.min(currentCallCount, snapshot.responses.length - 1);
      snapshot.callCount = currentCallCount + 1;
      return {
        ...snapshot,
        response: snapshot.responses[responseIndex]
      };
    }
    async loadSnapshots(filePath) {
      const path = filePath || this.#snapshotPath;
      if (!path) {
        throw new InvalidArgumentError("Snapshot path is required");
      }
      try {
        const data = await readFile(resolve(path), "utf8");
        const parsed = JSON.parse(data);
        if (Array.isArray(parsed)) {
          this.#snapshots.clear();
          for (const { hash, snapshot } of parsed) {
            this.#snapshots.set(hash, snapshot);
          }
        } else {
          this.#snapshots = new Map(Object.entries(parsed));
        }
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this.#snapshots.clear();
        } else {
          throw new UndiciError(`Failed to load snapshots from ${path}`, { cause: error2 });
        }
      }
    }
    async saveSnapshots(filePath) {
      const path = filePath || this.#snapshotPath;
      if (!path) {
        throw new InvalidArgumentError("Snapshot path is required");
      }
      const resolvedPath = resolve(path);
      await mkdir(dirname(resolvedPath), { recursive: true });
      const data = Array.from(this.#snapshots.entries()).map(([hash, snapshot]) => ({
        hash,
        snapshot
      }));
      await writeFile(resolvedPath, JSON.stringify(data, null, 2), { flush: true });
    }
    clear() {
      this.#snapshots.clear();
    }
    getSnapshots() {
      return Array.from(this.#snapshots.values());
    }
    size() {
      return this.#snapshots.size;
    }
    resetCallCounts() {
      for (const snapshot of this.#snapshots.values()) {
        snapshot.callCount = 0;
      }
    }
    deleteSnapshot(requestOpts) {
      const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request);
      return this.#snapshots.delete(hash);
    }
    getSnapshotInfo(requestOpts) {
      const request = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request);
      const snapshot = this.#snapshots.get(hash);
      if (!snapshot)
        return null;
      return {
        hash,
        request: snapshot.request,
        responseCount: snapshot.responses ? snapshot.responses.length : snapshot.response ? 1 : 0,
        callCount: snapshot.callCount || 0,
        timestamp: snapshot.timestamp
      };
    }
    replaceSnapshots(snapshotData) {
      this.#snapshots.clear();
      if (Array.isArray(snapshotData)) {
        for (const { hash, snapshot } of snapshotData) {
          this.#snapshots.set(hash, snapshot);
        }
      } else if (snapshotData && typeof snapshotData === "object") {
        this.#snapshots = new Map(Object.entries(snapshotData));
      }
    }
    #startAutoFlush() {
      return this.#scheduleFlush();
    }
    #stopAutoFlush() {
      if (this.#flushTimeout) {
        clearTimeout2(this.#flushTimeout);
        this.saveSnapshots().catch(() => {});
        this.#flushTimeout = null;
      }
    }
    #scheduleFlush() {
      this.#flushTimeout = setTimeout2(() => {
        this.saveSnapshots().catch(() => {});
        if (this.#autoFlush) {
          this.#flushTimeout?.refresh();
        } else {
          this.#flushTimeout = null;
        }
      }, 1000);
    }
    destroy() {
      this.#stopAutoFlush();
      if (this.#flushTimeout) {
        clearTimeout2(this.#flushTimeout);
        this.#flushTimeout = null;
      }
    }
    async close() {
      if (this.#snapshotPath && this.#snapshots.size !== 0) {
        await this.saveSnapshots();
      }
      this.destroy();
    }
  }
  module.exports = { SnapshotRecorder, formatRequestKey, createRequestHash, filterHeadersForMatching, filterHeadersForStorage, createHeaderFilters };
});

// node_modules/undici/lib/mock/snapshot-agent.js
var require_snapshot_agent = __commonJS((exports, module) => {
  var Agent = require_agent();
  var MockAgent = require_mock_agent();
  var { SnapshotRecorder } = require_snapshot_recorder();
  var WrapHandler = require_wrap_handler();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var { validateSnapshotMode } = require_snapshot_utils();
  var kSnapshotRecorder = Symbol("kSnapshotRecorder");
  var kSnapshotMode = Symbol("kSnapshotMode");
  var kSnapshotPath = Symbol("kSnapshotPath");
  var kSnapshotLoaded = Symbol("kSnapshotLoaded");
  var kRealAgent = Symbol("kRealAgent");
  var warningEmitted = false;

  class SnapshotAgent extends MockAgent {
    constructor(opts = {}) {
      if (!warningEmitted) {
        process.emitWarning("SnapshotAgent is experimental and subject to change", "ExperimentalWarning");
        warningEmitted = true;
      }
      const {
        mode = "record",
        snapshotPath = null,
        ...mockAgentOpts
      } = opts;
      super(mockAgentOpts);
      validateSnapshotMode(mode);
      if ((mode === "playback" || mode === "update") && !snapshotPath) {
        throw new InvalidArgumentError(`snapshotPath is required when mode is '${mode}'`);
      }
      this[kSnapshotMode] = mode;
      this[kSnapshotPath] = snapshotPath;
      this[kSnapshotRecorder] = new SnapshotRecorder({
        snapshotPath: this[kSnapshotPath],
        mode: this[kSnapshotMode],
        maxSnapshots: opts.maxSnapshots,
        autoFlush: opts.autoFlush,
        flushInterval: opts.flushInterval,
        matchHeaders: opts.matchHeaders,
        ignoreHeaders: opts.ignoreHeaders,
        excludeHeaders: opts.excludeHeaders,
        matchBody: opts.matchBody,
        matchQuery: opts.matchQuery,
        caseSensitive: opts.caseSensitive,
        shouldRecord: opts.shouldRecord,
        shouldPlayback: opts.shouldPlayback,
        excludeUrls: opts.excludeUrls
      });
      this[kSnapshotLoaded] = false;
      if (this[kSnapshotMode] === "record" || this[kSnapshotMode] === "update" || this[kSnapshotMode] === "playback" && opts.excludeUrls && opts.excludeUrls.length > 0) {
        this[kRealAgent] = new Agent(opts);
      }
      if ((this[kSnapshotMode] === "playback" || this[kSnapshotMode] === "update") && this[kSnapshotPath]) {
        this.loadSnapshots().catch(() => {});
      }
    }
    dispatch(opts, handler) {
      handler = WrapHandler.wrap(handler);
      const mode = this[kSnapshotMode];
      if (this[kSnapshotRecorder].isUrlExcluded(opts)) {
        return this[kRealAgent].dispatch(opts, handler);
      }
      if (mode === "playback" || mode === "update") {
        if (!this[kSnapshotLoaded]) {
          return this.#asyncDispatch(opts, handler);
        }
        const snapshot = this[kSnapshotRecorder].findSnapshot(opts);
        if (snapshot) {
          return this.#replaySnapshot(snapshot, handler);
        } else if (mode === "update") {
          return this.#recordAndReplay(opts, handler);
        } else {
          const error2 = new UndiciError(`No snapshot found for ${opts.method || "GET"} ${opts.path}`);
          if (handler.onError) {
            handler.onError(error2);
            return;
          }
          throw error2;
        }
      } else if (mode === "record") {
        return this.#recordAndReplay(opts, handler);
      }
    }
    async#asyncDispatch(opts, handler) {
      await this.loadSnapshots();
      return this.dispatch(opts, handler);
    }
    #recordAndReplay(opts, handler) {
      const responseData = {
        statusCode: null,
        headers: {},
        trailers: {},
        body: []
      };
      const self = this;
      const recordingHandler = {
        onRequestStart(controller, context) {
          return handler.onRequestStart(controller, { ...context, history: this.history });
        },
        onRequestUpgrade(controller, statusCode, headers, socket) {
          return handler.onRequestUpgrade(controller, statusCode, headers, socket);
        },
        onResponseStart(controller, statusCode, headers, statusMessage) {
          responseData.statusCode = statusCode;
          responseData.headers = headers;
          return handler.onResponseStart(controller, statusCode, headers, statusMessage);
        },
        onResponseData(controller, chunk) {
          responseData.body.push(chunk);
          return handler.onResponseData(controller, chunk);
        },
        onResponseEnd(controller, trailers) {
          responseData.trailers = trailers;
          const responseBody = Buffer.concat(responseData.body);
          self[kSnapshotRecorder].record(opts, {
            statusCode: responseData.statusCode,
            headers: responseData.headers,
            body: responseBody,
            trailers: responseData.trailers
          }).then(() => handler.onResponseEnd(controller, trailers)).catch((error2) => handler.onResponseError(controller, error2));
        }
      };
      const agent = this[kRealAgent];
      return agent.dispatch(opts, recordingHandler);
    }
    #replaySnapshot(snapshot, handler) {
      try {
        const { response } = snapshot;
        const controller = {
          pause() {},
          resume() {},
          abort(reason) {
            this.aborted = true;
            this.reason = reason;
          },
          aborted: false,
          paused: false
        };
        handler.onRequestStart(controller);
        handler.onResponseStart(controller, response.statusCode, response.headers);
        const body = Buffer.from(response.body, "base64");
        handler.onResponseData(controller, body);
        handler.onResponseEnd(controller, response.trailers);
      } catch (error2) {
        handler.onError?.(error2);
      }
    }
    async loadSnapshots(filePath) {
      await this[kSnapshotRecorder].loadSnapshots(filePath || this[kSnapshotPath]);
      this[kSnapshotLoaded] = true;
      if (this[kSnapshotMode] === "playback") {
        this.#setupMockInterceptors();
      }
    }
    async saveSnapshots(filePath) {
      return this[kSnapshotRecorder].saveSnapshots(filePath || this[kSnapshotPath]);
    }
    #setupMockInterceptors() {
      for (const snapshot of this[kSnapshotRecorder].getSnapshots()) {
        const { request, responses, response } = snapshot;
        const url = new URL(request.url);
        const mockPool = this.get(url.origin);
        const responseData = responses ? responses[0] : response;
        if (!responseData)
          continue;
        mockPool.intercept({
          path: url.pathname + url.search,
          method: request.method,
          headers: request.headers,
          body: request.body
        }).reply(responseData.statusCode, responseData.body, {
          headers: responseData.headers,
          trailers: responseData.trailers
        }).persist();
      }
    }
    getRecorder() {
      return this[kSnapshotRecorder];
    }
    getMode() {
      return this[kSnapshotMode];
    }
    clearSnapshots() {
      this[kSnapshotRecorder].clear();
    }
    resetCallCounts() {
      this[kSnapshotRecorder].resetCallCounts();
    }
    deleteSnapshot(requestOpts) {
      return this[kSnapshotRecorder].deleteSnapshot(requestOpts);
    }
    getSnapshotInfo(requestOpts) {
      return this[kSnapshotRecorder].getSnapshotInfo(requestOpts);
    }
    replaceSnapshots(snapshotData) {
      this[kSnapshotRecorder].replaceSnapshots(snapshotData);
    }
    async close() {
      await this[kSnapshotRecorder].close();
      await this[kRealAgent]?.close();
      await super.close();
    }
  }
  module.exports = SnapshotAgent;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError } = require_errors();
  var Agent = require_agent();
  if (getGlobalDispatcher() === undefined) {
    setGlobalDispatcher(new Agent);
  }
  function setGlobalDispatcher(agent) {
    if (!agent || typeof agent.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  var installedExports = [
    "fetch",
    "Headers",
    "Response",
    "Request",
    "FormData",
    "WebSocket",
    "CloseEvent",
    "ErrorEvent",
    "MessageEvent",
    "EventSource"
  ];
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher,
    installedExports
  };
});

// node_modules/undici/lib/handler/decorator-handler.js
var require_decorator_handler = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var WrapHandler = require_wrap_handler();
  module.exports = class DecoratorHandler {
    #handler;
    #onCompleteCalled = false;
    #onErrorCalled = false;
    #onResponseStartCalled = false;
    constructor(handler) {
      if (typeof handler !== "object" || handler === null) {
        throw new TypeError("handler must be an object");
      }
      this.#handler = WrapHandler.wrap(handler);
    }
    onRequestStart(...args) {
      this.#handler.onRequestStart?.(...args);
    }
    onRequestUpgrade(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      return this.#handler.onRequestUpgrade?.(...args);
    }
    onResponseStart(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      assert(!this.#onResponseStartCalled);
      this.#onResponseStartCalled = true;
      return this.#handler.onResponseStart?.(...args);
    }
    onResponseData(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      return this.#handler.onResponseData?.(...args);
    }
    onResponseEnd(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      this.#onCompleteCalled = true;
      return this.#handler.onResponseEnd?.(...args);
    }
    onResponseError(...args) {
      this.#onErrorCalled = true;
      return this.#handler.onResponseError?.(...args);
    }
    onBodySent() {}
  };
});

// node_modules/undici/lib/handler/redirect-handler.js
var require_redirect_handler = __commonJS((exports, module) => {
  var util = require_util();
  var { kBodyUsed } = require_symbols();
  var assert = __require("node:assert");
  var { InvalidArgumentError } = require_errors();
  var EE = __require("node:events");
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody = Symbol("body");
  var noop = () => {};

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }

  class RedirectHandler {
    static buildDispatch(dispatcher, maxRedirections) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      const dispatch = dispatcher.dispatch.bind(dispatcher);
      return (opts, originalHandler) => dispatch(opts, new RedirectHandler(dispatch, maxRedirections, opts, originalHandler));
    }
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      this.dispatch = dispatch;
      this.location = null;
      const { maxRedirections: _, ...cleanOpts } = opts;
      this.opts = cleanOpts;
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      if (util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body) && !util.isFormDataLike(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onRequestStart(controller, context) {
      this.handler.onRequestStart?.(controller, { ...context, history: this.history });
    }
    onRequestUpgrade(controller, statusCode, headers, socket) {
      this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        throw new Error("max redirects");
      }
      if ((statusCode === 301 || statusCode === 302) && this.opts.method === "POST") {
        this.opts.method = "GET";
        if (util.isStream(this.opts.body)) {
          util.destroy(this.opts.body.on("error", noop));
        }
        this.opts.body = null;
      }
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        if (util.isStream(this.opts.body)) {
          util.destroy(this.opts.body.on("error", noop));
        }
        this.opts.body = null;
      }
      this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1 ? null : headers.location;
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
        return;
      }
      const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path = search ? `${pathname}${search}` : pathname;
      const redirectUrlString = `${origin}${path}`;
      for (const historyUrl of this.history) {
        if (historyUrl.toString() === redirectUrlString) {
          throw new InvalidArgumentError(`Redirect loop detected. Cannot redirect to ${origin}. This typically happens when using a Client or Pool with cross-origin redirects. Use an Agent for cross-origin redirects.`);
        }
      }
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path;
      this.opts.origin = origin;
      this.opts.query = null;
    }
    onResponseData(controller, chunk) {
      if (this.location) {} else {
        this.handler.onResponseData?.(controller, chunk);
      }
    }
    onResponseEnd(controller, trailers) {
      if (this.location) {
        this.dispatch(this.opts, this);
      } else {
        this.handler.onResponseEnd(controller, trailers);
      }
    }
    onResponseError(controller, error2) {
      this.handler.onResponseError?.(controller, error2);
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util.headerNameToString(header) === "host";
    }
    if (removeContent && util.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
          ret.push(headers[i], headers[i + 1]);
        }
      }
    } else if (headers && typeof headers === "object") {
      const entries = typeof headers[Symbol.iterator] === "function" ? headers : Object.entries(headers);
      for (const [key, value] of entries) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, value);
        }
      }
    } else {
      assert(headers == null, "headers must be an object or an array");
    }
    return ret;
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirect.js
var require_redirect = __commonJS((exports, module) => {
  var RedirectHandler = require_redirect_handler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections } = {}) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections, ...rest } = opts;
        if (maxRedirections == null || maxRedirections === 0) {
          return dispatch(opts, handler);
        }
        const dispatchOpts = { ...rest };
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler);
        return dispatch(dispatchOpts, redirectHandler);
      };
    };
  }
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/interceptor/response-error.js
var require_response_error = __commonJS((exports, module) => {
  var DecoratorHandler = require_decorator_handler();
  var { ResponseError } = require_errors();

  class ResponseErrorHandler extends DecoratorHandler {
    #statusCode;
    #contentType;
    #decoder;
    #headers;
    #body;
    constructor(_opts, { handler }) {
      super(handler);
    }
    #checkContentType(contentType) {
      return (this.#contentType ?? "").indexOf(contentType) === 0;
    }
    onRequestStart(controller, context) {
      this.#statusCode = 0;
      this.#contentType = null;
      this.#decoder = null;
      this.#headers = null;
      this.#body = "";
      return super.onRequestStart(controller, context);
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      this.#statusCode = statusCode;
      this.#headers = headers;
      this.#contentType = headers["content-type"];
      if (this.#statusCode < 400) {
        return super.onResponseStart(controller, statusCode, headers, statusMessage);
      }
      if (this.#checkContentType("application/json") || this.#checkContentType("text/plain")) {
        this.#decoder = new TextDecoder("utf-8");
      }
    }
    onResponseData(controller, chunk) {
      if (this.#statusCode < 400) {
        return super.onResponseData(controller, chunk);
      }
      this.#body += this.#decoder?.decode(chunk, { stream: true }) ?? "";
    }
    onResponseEnd(controller, trailers) {
      if (this.#statusCode >= 400) {
        this.#body += this.#decoder?.decode(undefined, { stream: false }) ?? "";
        if (this.#checkContentType("application/json")) {
          try {
            this.#body = JSON.parse(this.#body);
          } catch {}
        }
        let err;
        const stackTraceLimit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        try {
          err = new ResponseError("Response Error", this.#statusCode, {
            body: this.#body,
            headers: this.#headers
          });
        } finally {
          Error.stackTraceLimit = stackTraceLimit;
        }
        super.onResponseError(controller, err);
      } else {
        super.onResponseEnd(controller, trailers);
      }
    }
    onResponseError(controller, err) {
      super.onResponseError(controller, err);
    }
  }
  module.exports = () => {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        return dispatch(opts, new ResponseErrorHandler(opts, { handler }));
      };
    };
  };
});

// node_modules/undici/lib/interceptor/retry.js
var require_retry = __commonJS((exports, module) => {
  var RetryHandler = require_retry_handler();
  module.exports = (globalOpts) => {
    return (dispatch) => {
      return function retryInterceptor(opts, handler) {
        return dispatch(opts, new RetryHandler({ ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } }, {
          handler,
          dispatch
        }));
      };
    };
  };
});

// node_modules/undici/lib/interceptor/dump.js
var require_dump = __commonJS((exports, module) => {
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var DecoratorHandler = require_decorator_handler();

  class DumpHandler extends DecoratorHandler {
    #maxSize = 1024 * 1024;
    #dumped = false;
    #size = 0;
    #controller = null;
    aborted = false;
    reason = false;
    constructor({ maxSize, signal }, handler) {
      if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
        throw new InvalidArgumentError("maxSize must be a number greater than 0");
      }
      super(handler);
      this.#maxSize = maxSize ?? this.#maxSize;
    }
    #abort(reason) {
      this.aborted = true;
      this.reason = reason;
    }
    onRequestStart(controller, context) {
      controller.abort = this.#abort.bind(this);
      this.#controller = controller;
      return super.onRequestStart(controller, context);
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      const contentLength = headers["content-length"];
      if (contentLength != null && contentLength > this.#maxSize) {
        throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${this.#maxSize})`);
      }
      if (this.aborted === true) {
        return true;
      }
      return super.onResponseStart(controller, statusCode, headers, statusMessage);
    }
    onResponseError(controller, err) {
      if (this.#dumped) {
        return;
      }
      err = this.#controller?.reason ?? err;
      super.onResponseError(controller, err);
    }
    onResponseData(controller, chunk) {
      this.#size = this.#size + chunk.length;
      if (this.#size >= this.#maxSize) {
        this.#dumped = true;
        if (this.aborted === true) {
          super.onResponseError(controller, this.reason);
        } else {
          super.onResponseEnd(controller, {});
        }
      }
      return true;
    }
    onResponseEnd(controller, trailers) {
      if (this.#dumped) {
        return;
      }
      if (this.#controller.aborted === true) {
        super.onResponseError(controller, this.reason);
        return;
      }
      super.onResponseEnd(controller, trailers);
    }
  }
  function createDumpInterceptor({ maxSize: defaultMaxSize } = {
    maxSize: 1024 * 1024
  }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { dumpMaxSize = defaultMaxSize } = opts;
        const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler);
        return dispatch(opts, dumpHandler);
      };
    };
  }
  module.exports = createDumpInterceptor;
});

// node_modules/undici/lib/interceptor/dns.js
var require_dns = __commonJS((exports, module) => {
  var { isIP } = __require("node:net");
  var { lookup } = __require("node:dns");
  var DecoratorHandler = require_decorator_handler();
  var { InvalidArgumentError, InformationalError } = require_errors();
  var maxInt = Math.pow(2, 31) - 1;

  class DNSStorage {
    #maxItems = 0;
    #records = new Map;
    constructor(opts) {
      this.#maxItems = opts.maxItems;
    }
    get size() {
      return this.#records.size;
    }
    get(hostname) {
      return this.#records.get(hostname) ?? null;
    }
    set(hostname, records) {
      this.#records.set(hostname, records);
    }
    delete(hostname) {
      this.#records.delete(hostname);
    }
    full() {
      return this.size >= this.#maxItems;
    }
  }

  class DNSInstance {
    #maxTTL = 0;
    #maxItems = 0;
    dualStack = true;
    affinity = null;
    lookup = null;
    pick = null;
    storage = null;
    constructor(opts) {
      this.#maxTTL = opts.maxTTL;
      this.#maxItems = opts.maxItems;
      this.dualStack = opts.dualStack;
      this.affinity = opts.affinity;
      this.lookup = opts.lookup ?? this.#defaultLookup;
      this.pick = opts.pick ?? this.#defaultPick;
      this.storage = opts.storage ?? new DNSStorage(opts);
    }
    runLookup(origin, opts, cb) {
      const ips = this.storage.get(origin.hostname);
      if (ips == null && this.storage.full()) {
        cb(null, origin);
        return;
      }
      const newOpts = {
        affinity: this.affinity,
        dualStack: this.dualStack,
        lookup: this.lookup,
        pick: this.pick,
        ...opts.dns,
        maxTTL: this.#maxTTL,
        maxItems: this.#maxItems
      };
      if (ips == null) {
        this.lookup(origin, newOpts, (err, addresses) => {
          if (err || addresses == null || addresses.length === 0) {
            cb(err ?? new InformationalError("No DNS entries found"));
            return;
          }
          this.setRecords(origin, addresses);
          const records = this.storage.get(origin.hostname);
          const ip = this.pick(origin, records, newOpts.affinity);
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (origin.port !== "") {
            port = `:${origin.port}`;
          } else {
            port = "";
          }
          cb(null, new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`));
        });
      } else {
        const ip = this.pick(origin, ips, newOpts.affinity);
        if (ip == null) {
          this.storage.delete(origin.hostname);
          this.runLookup(origin, opts, cb);
          return;
        }
        let port;
        if (typeof ip.port === "number") {
          port = `:${ip.port}`;
        } else if (origin.port !== "") {
          port = `:${origin.port}`;
        } else {
          port = "";
        }
        cb(null, new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`));
      }
    }
    #defaultLookup(origin, opts, cb) {
      lookup(origin.hostname, {
        all: true,
        family: this.dualStack === false ? this.affinity : 0,
        order: "ipv4first"
      }, (err, addresses) => {
        if (err) {
          return cb(err);
        }
        const results = new Map;
        for (const addr of addresses) {
          results.set(`${addr.address}:${addr.family}`, addr);
        }
        cb(null, results.values());
      });
    }
    #defaultPick(origin, hostnameRecords, affinity) {
      let ip = null;
      const { records, offset } = hostnameRecords;
      let family;
      if (this.dualStack) {
        if (affinity == null) {
          if (offset == null || offset === maxInt) {
            hostnameRecords.offset = 0;
            affinity = 4;
          } else {
            hostnameRecords.offset++;
            affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
          }
        }
        if (records[affinity] != null && records[affinity].ips.length > 0) {
          family = records[affinity];
        } else {
          family = records[affinity === 4 ? 6 : 4];
        }
      } else {
        family = records[affinity];
      }
      if (family == null || family.ips.length === 0) {
        return ip;
      }
      if (family.offset == null || family.offset === maxInt) {
        family.offset = 0;
      } else {
        family.offset++;
      }
      const position = family.offset % family.ips.length;
      ip = family.ips[position] ?? null;
      if (ip == null) {
        return ip;
      }
      if (Date.now() - ip.timestamp > ip.ttl) {
        family.ips.splice(position, 1);
        return this.pick(origin, hostnameRecords, affinity);
      }
      return ip;
    }
    pickFamily(origin, ipFamily) {
      const records = this.storage.get(origin.hostname)?.records;
      if (!records) {
        return null;
      }
      const family = records[ipFamily];
      if (!family) {
        return null;
      }
      if (family.offset == null || family.offset === maxInt) {
        family.offset = 0;
      } else {
        family.offset++;
      }
      const position = family.offset % family.ips.length;
      const ip = family.ips[position] ?? null;
      if (ip == null) {
        return ip;
      }
      if (Date.now() - ip.timestamp > ip.ttl) {
        family.ips.splice(position, 1);
      }
      return ip;
    }
    setRecords(origin, addresses) {
      const timestamp = Date.now();
      const records = { records: { 4: null, 6: null } };
      let minTTL = this.#maxTTL;
      for (const record of addresses) {
        record.timestamp = timestamp;
        if (typeof record.ttl === "number") {
          record.ttl = Math.min(record.ttl, this.#maxTTL);
          minTTL = Math.min(minTTL, record.ttl);
        } else {
          record.ttl = this.#maxTTL;
        }
        const familyRecords = records.records[record.family] ?? { ips: [] };
        familyRecords.ips.push(record);
        records.records[record.family] = familyRecords;
      }
      this.storage.set(origin.hostname, records, { ttl: minTTL });
    }
    deleteRecords(origin) {
      this.storage.delete(origin.hostname);
    }
    getHandler(meta, opts) {
      return new DNSDispatchHandler(this, meta, opts);
    }
  }

  class DNSDispatchHandler extends DecoratorHandler {
    #state = null;
    #opts = null;
    #dispatch = null;
    #origin = null;
    #controller = null;
    #newOrigin = null;
    #firstTry = true;
    constructor(state, { origin, handler, dispatch, newOrigin }, opts) {
      super(handler);
      this.#origin = origin;
      this.#newOrigin = newOrigin;
      this.#opts = { ...opts };
      this.#state = state;
      this.#dispatch = dispatch;
    }
    onResponseError(controller, err) {
      switch (err.code) {
        case "ETIMEDOUT":
        case "ECONNREFUSED": {
          if (this.#state.dualStack) {
            if (!this.#firstTry) {
              super.onResponseError(controller, err);
              return;
            }
            this.#firstTry = false;
            const otherFamily = this.#newOrigin.hostname[0] === "[" ? 4 : 6;
            const ip = this.#state.pickFamily(this.#origin, otherFamily);
            if (ip == null) {
              super.onResponseError(controller, err);
              return;
            }
            let port;
            if (typeof ip.port === "number") {
              port = `:${ip.port}`;
            } else if (this.#origin.port !== "") {
              port = `:${this.#origin.port}`;
            } else {
              port = "";
            }
            const dispatchOpts = {
              ...this.#opts,
              origin: `${this.#origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
            };
            this.#dispatch(dispatchOpts, this);
            return;
          }
          super.onResponseError(controller, err);
          break;
        }
        case "ENOTFOUND":
          this.#state.deleteRecords(this.#origin);
          super.onResponseError(controller, err);
          break;
        default:
          super.onResponseError(controller, err);
          break;
      }
    }
  }
  module.exports = (interceptorOpts) => {
    if (interceptorOpts?.maxTTL != null && (typeof interceptorOpts?.maxTTL !== "number" || interceptorOpts?.maxTTL < 0)) {
      throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
    }
    if (interceptorOpts?.maxItems != null && (typeof interceptorOpts?.maxItems !== "number" || interceptorOpts?.maxItems < 1)) {
      throw new InvalidArgumentError("Invalid maxItems. Must be a positive number and greater than zero");
    }
    if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) {
      throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
    }
    if (interceptorOpts?.dualStack != null && typeof interceptorOpts?.dualStack !== "boolean") {
      throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
    }
    if (interceptorOpts?.lookup != null && typeof interceptorOpts?.lookup !== "function") {
      throw new InvalidArgumentError("Invalid lookup. Must be a function");
    }
    if (interceptorOpts?.pick != null && typeof interceptorOpts?.pick !== "function") {
      throw new InvalidArgumentError("Invalid pick. Must be a function");
    }
    if (interceptorOpts?.storage != null && (typeof interceptorOpts?.storage?.get !== "function" || typeof interceptorOpts?.storage?.set !== "function" || typeof interceptorOpts?.storage?.full !== "function" || typeof interceptorOpts?.storage?.delete !== "function")) {
      throw new InvalidArgumentError("Invalid storage. Must be a object with methods: { get, set, full, delete }");
    }
    const dualStack = interceptorOpts?.dualStack ?? true;
    let affinity;
    if (dualStack) {
      affinity = interceptorOpts?.affinity ?? null;
    } else {
      affinity = interceptorOpts?.affinity ?? 4;
    }
    const opts = {
      maxTTL: interceptorOpts?.maxTTL ?? 1e4,
      lookup: interceptorOpts?.lookup ?? null,
      pick: interceptorOpts?.pick ?? null,
      dualStack,
      affinity,
      maxItems: interceptorOpts?.maxItems ?? Infinity,
      storage: interceptorOpts?.storage
    };
    const instance = new DNSInstance(opts);
    return (dispatch) => {
      return function dnsInterceptor(origDispatchOpts, handler) {
        const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
        if (isIP(origin.hostname) !== 0) {
          return dispatch(origDispatchOpts, handler);
        }
        instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
          if (err) {
            return handler.onResponseError(null, err);
          }
          const dispatchOpts = {
            ...origDispatchOpts,
            servername: origin.hostname,
            origin: newOrigin.origin,
            headers: {
              host: origin.host,
              ...origDispatchOpts.headers
            }
          };
          dispatch(dispatchOpts, instance.getHandler({ origin, dispatch, handler, newOrigin }, origDispatchOpts));
        });
        return true;
      };
    };
  };
});

// node_modules/undici/lib/util/cache.js
var require_cache = __commonJS((exports, module) => {
  var {
    safeHTTPMethods,
    pathHasQueryOrFragment
  } = require_util();
  var { serializePathWithQuery } = require_util();
  function makeCacheKey(opts) {
    if (!opts.origin) {
      throw new Error("opts.origin is undefined");
    }
    let fullPath = opts.path || "/";
    if (opts.query && !pathHasQueryOrFragment(opts.path)) {
      fullPath = serializePathWithQuery(fullPath, opts.query);
    }
    return {
      origin: opts.origin.toString(),
      method: opts.method,
      path: fullPath,
      headers: opts.headers
    };
  }
  function normalizeHeaders(opts) {
    let headers;
    if (opts.headers == null) {
      headers = {};
    } else if (typeof opts.headers[Symbol.iterator] === "function") {
      headers = {};
      for (const x of opts.headers) {
        if (!Array.isArray(x)) {
          throw new Error("opts.headers is not a valid header map");
        }
        const [key, val] = x;
        if (typeof key !== "string" || typeof val !== "string") {
          throw new Error("opts.headers is not a valid header map");
        }
        headers[key.toLowerCase()] = val;
      }
    } else if (typeof opts.headers === "object") {
      headers = {};
      for (const key of Object.keys(opts.headers)) {
        headers[key.toLowerCase()] = opts.headers[key];
      }
    } else {
      throw new Error("opts.headers is not an object");
    }
    return headers;
  }
  function assertCacheKey(key) {
    if (typeof key !== "object") {
      throw new TypeError(`expected key to be object, got ${typeof key}`);
    }
    for (const property of ["origin", "method", "path"]) {
      if (typeof key[property] !== "string") {
        throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`);
      }
    }
    if (key.headers !== undefined && typeof key.headers !== "object") {
      throw new TypeError(`expected headers to be object, got ${typeof key}`);
    }
  }
  function assertCacheValue(value) {
    if (typeof value !== "object") {
      throw new TypeError(`expected value to be object, got ${typeof value}`);
    }
    for (const property of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) {
      if (typeof value[property] !== "number") {
        throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`);
      }
    }
    if (typeof value.statusMessage !== "string") {
      throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`);
    }
    if (value.headers != null && typeof value.headers !== "object") {
      throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`);
    }
    if (value.vary !== undefined && typeof value.vary !== "object") {
      throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`);
    }
    if (value.etag !== undefined && typeof value.etag !== "string") {
      throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`);
    }
  }
  function parseCacheControlHeader(header) {
    const output = {};
    let directives;
    if (Array.isArray(header)) {
      directives = [];
      for (const directive of header) {
        directives.push(...directive.split(","));
      }
    } else {
      directives = header.split(",");
    }
    for (let i = 0;i < directives.length; i++) {
      const directive = directives[i].toLowerCase();
      const keyValueDelimiter = directive.indexOf("=");
      let key;
      let value;
      if (keyValueDelimiter !== -1) {
        key = directive.substring(0, keyValueDelimiter).trimStart();
        value = directive.substring(keyValueDelimiter + 1);
      } else {
        key = directive.trim();
      }
      switch (key) {
        case "min-fresh":
        case "max-stale":
        case "max-age":
        case "s-maxage":
        case "stale-while-revalidate":
        case "stale-if-error": {
          if (value === undefined || value[0] === " ") {
            continue;
          }
          if (value.length >= 2 && value[0] === '"' && value[value.length - 1] === '"') {
            value = value.substring(1, value.length - 1);
          }
          const parsedValue = parseInt(value, 10);
          if (parsedValue !== parsedValue) {
            continue;
          }
          if (key === "max-age" && key in output && output[key] >= parsedValue) {
            continue;
          }
          output[key] = parsedValue;
          break;
        }
        case "private":
        case "no-cache": {
          if (value) {
            if (value[0] === '"') {
              const headers = [value.substring(1)];
              let foundEndingQuote = value[value.length - 1] === '"';
              if (!foundEndingQuote) {
                for (let j = i + 1;j < directives.length; j++) {
                  const nextPart = directives[j];
                  const nextPartLength = nextPart.length;
                  headers.push(nextPart.trim());
                  if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '"') {
                    foundEndingQuote = true;
                    break;
                  }
                }
              }
              if (foundEndingQuote) {
                let lastHeader = headers[headers.length - 1];
                if (lastHeader[lastHeader.length - 1] === '"') {
                  lastHeader = lastHeader.substring(0, lastHeader.length - 1);
                  headers[headers.length - 1] = lastHeader;
                }
                if (key in output) {
                  output[key] = output[key].concat(headers);
                } else {
                  output[key] = headers;
                }
              }
            } else {
              if (key in output) {
                output[key] = output[key].concat(value);
              } else {
                output[key] = [value];
              }
            }
            break;
          }
        }
        case "public":
        case "no-store":
        case "must-revalidate":
        case "proxy-revalidate":
        case "immutable":
        case "no-transform":
        case "must-understand":
        case "only-if-cached":
          if (value) {
            continue;
          }
          output[key] = true;
          break;
        default:
          continue;
      }
    }
    return output;
  }
  function parseVaryHeader(varyHeader, headers) {
    if (typeof varyHeader === "string" && varyHeader.includes("*")) {
      return headers;
    }
    const output = {};
    const varyingHeaders = typeof varyHeader === "string" ? varyHeader.split(",") : varyHeader;
    for (const header of varyingHeaders) {
      const trimmedHeader = header.trim().toLowerCase();
      output[trimmedHeader] = headers[trimmedHeader] ?? null;
    }
    return output;
  }
  function isEtagUsable(etag) {
    if (etag.length <= 2) {
      return false;
    }
    if (etag[0] === '"' && etag[etag.length - 1] === '"') {
      return !(etag[1] === '"' || etag.startsWith('"W/'));
    }
    if (etag.startsWith('W/"') && etag[etag.length - 1] === '"') {
      return etag.length !== 4;
    }
    return false;
  }
  function assertCacheStore(store, name = "CacheStore") {
    if (typeof store !== "object" || store === null) {
      throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? "null" : typeof store}`);
    }
    for (const fn of ["get", "createWriteStream", "delete"]) {
      if (typeof store[fn] !== "function") {
        throw new TypeError(`${name} needs to have a \`${fn}()\` function`);
      }
    }
  }
  function assertCacheMethods(methods, name = "CacheMethods") {
    if (!Array.isArray(methods)) {
      throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? "null" : typeof methods}`);
    }
    if (methods.length === 0) {
      throw new TypeError(`${name} needs to have at least one method`);
    }
    for (const method of methods) {
      if (!safeHTTPMethods.includes(method)) {
        throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(", ")}, got ${method}`);
      }
    }
  }
  function makeDeduplicationKey(cacheKey, excludeHeaders) {
    let key = `${cacheKey.origin}:${cacheKey.method}:${cacheKey.path}`;
    if (cacheKey.headers) {
      const sortedHeaders = Object.keys(cacheKey.headers).sort();
      for (const header of sortedHeaders) {
        if (excludeHeaders?.has(header.toLowerCase())) {
          continue;
        }
        const value = cacheKey.headers[header];
        key += `:${header}=${Array.isArray(value) ? value.join(",") : value}`;
      }
    }
    return key;
  }
  module.exports = {
    makeCacheKey,
    normalizeHeaders,
    assertCacheKey,
    assertCacheValue,
    parseCacheControlHeader,
    parseVaryHeader,
    isEtagUsable,
    assertCacheMethods,
    assertCacheStore,
    makeDeduplicationKey
  };
});

// node_modules/undici/lib/util/date.js
var require_date = __commonJS((exports, module) => {
  function parseHttpDate(date) {
    switch (date[3]) {
      case ",":
        return parseImfDate(date);
      case " ":
        return parseAscTimeDate(date);
      default:
        return parseRfc850Date(date);
    }
  }
  function parseImfDate(date) {
    if (date.length !== 29 || date[4] !== " " || date[7] !== " " || date[11] !== " " || date[16] !== " " || date[19] !== ":" || date[22] !== ":" || date[25] !== " " || date[26] !== "G" || date[27] !== "M" || date[28] !== "T") {
      return;
    }
    let weekday = -1;
    if (date[0] === "S" && date[1] === "u" && date[2] === "n") {
      weekday = 0;
    } else if (date[0] === "M" && date[1] === "o" && date[2] === "n") {
      weekday = 1;
    } else if (date[0] === "T" && date[1] === "u" && date[2] === "e") {
      weekday = 2;
    } else if (date[0] === "W" && date[1] === "e" && date[2] === "d") {
      weekday = 3;
    } else if (date[0] === "T" && date[1] === "h" && date[2] === "u") {
      weekday = 4;
    } else if (date[0] === "F" && date[1] === "r" && date[2] === "i") {
      weekday = 5;
    } else if (date[0] === "S" && date[1] === "a" && date[2] === "t") {
      weekday = 6;
    } else {
      return;
    }
    let day = 0;
    if (date[5] === "0") {
      const code = date.charCodeAt(6);
      if (code < 49 || code > 57) {
        return;
      }
      day = code - 48;
    } else {
      const code1 = date.charCodeAt(5);
      if (code1 < 49 || code1 > 51) {
        return;
      }
      const code2 = date.charCodeAt(6);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      day = (code1 - 48) * 10 + (code2 - 48);
    }
    let monthIdx = -1;
    if (date[8] === "J" && date[9] === "a" && date[10] === "n") {
      monthIdx = 0;
    } else if (date[8] === "F" && date[9] === "e" && date[10] === "b") {
      monthIdx = 1;
    } else if (date[8] === "M" && date[9] === "a") {
      if (date[10] === "r") {
        monthIdx = 2;
      } else if (date[10] === "y") {
        monthIdx = 4;
      } else {
        return;
      }
    } else if (date[8] === "J") {
      if (date[9] === "a" && date[10] === "n") {
        monthIdx = 0;
      } else if (date[9] === "u") {
        if (date[10] === "n") {
          monthIdx = 5;
        } else if (date[10] === "l") {
          monthIdx = 6;
        } else {
          return;
        }
      } else {
        return;
      }
    } else if (date[8] === "A") {
      if (date[9] === "p" && date[10] === "r") {
        monthIdx = 3;
      } else if (date[9] === "u" && date[10] === "g") {
        monthIdx = 7;
      } else {
        return;
      }
    } else if (date[8] === "S" && date[9] === "e" && date[10] === "p") {
      monthIdx = 8;
    } else if (date[8] === "O" && date[9] === "c" && date[10] === "t") {
      monthIdx = 9;
    } else if (date[8] === "N" && date[9] === "o" && date[10] === "v") {
      monthIdx = 10;
    } else if (date[8] === "D" && date[9] === "e" && date[10] === "c") {
      monthIdx = 11;
    } else {
      return;
    }
    const yearDigit1 = date.charCodeAt(12);
    if (yearDigit1 < 48 || yearDigit1 > 57) {
      return;
    }
    const yearDigit2 = date.charCodeAt(13);
    if (yearDigit2 < 48 || yearDigit2 > 57) {
      return;
    }
    const yearDigit3 = date.charCodeAt(14);
    if (yearDigit3 < 48 || yearDigit3 > 57) {
      return;
    }
    const yearDigit4 = date.charCodeAt(15);
    if (yearDigit4 < 48 || yearDigit4 > 57) {
      return;
    }
    const year = (yearDigit1 - 48) * 1000 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48);
    let hour = 0;
    if (date[17] === "0") {
      const code = date.charCodeAt(18);
      if (code < 48 || code > 57) {
        return;
      }
      hour = code - 48;
    } else {
      const code1 = date.charCodeAt(17);
      if (code1 < 48 || code1 > 50) {
        return;
      }
      const code2 = date.charCodeAt(18);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      if (code1 === 50 && code2 > 51) {
        return;
      }
      hour = (code1 - 48) * 10 + (code2 - 48);
    }
    let minute = 0;
    if (date[20] === "0") {
      const code = date.charCodeAt(21);
      if (code < 48 || code > 57) {
        return;
      }
      minute = code - 48;
    } else {
      const code1 = date.charCodeAt(20);
      if (code1 < 48 || code1 > 53) {
        return;
      }
      const code2 = date.charCodeAt(21);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      minute = (code1 - 48) * 10 + (code2 - 48);
    }
    let second = 0;
    if (date[23] === "0") {
      const code = date.charCodeAt(24);
      if (code < 48 || code > 57) {
        return;
      }
      second = code - 48;
    } else {
      const code1 = date.charCodeAt(23);
      if (code1 < 48 || code1 > 53) {
        return;
      }
      const code2 = date.charCodeAt(24);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      second = (code1 - 48) * 10 + (code2 - 48);
    }
    const result2 = new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    return result2.getUTCDay() === weekday ? result2 : undefined;
  }
  function parseAscTimeDate(date) {
    if (date.length !== 24 || date[7] !== " " || date[10] !== " " || date[19] !== " ") {
      return;
    }
    let weekday = -1;
    if (date[0] === "S" && date[1] === "u" && date[2] === "n") {
      weekday = 0;
    } else if (date[0] === "M" && date[1] === "o" && date[2] === "n") {
      weekday = 1;
    } else if (date[0] === "T" && date[1] === "u" && date[2] === "e") {
      weekday = 2;
    } else if (date[0] === "W" && date[1] === "e" && date[2] === "d") {
      weekday = 3;
    } else if (date[0] === "T" && date[1] === "h" && date[2] === "u") {
      weekday = 4;
    } else if (date[0] === "F" && date[1] === "r" && date[2] === "i") {
      weekday = 5;
    } else if (date[0] === "S" && date[1] === "a" && date[2] === "t") {
      weekday = 6;
    } else {
      return;
    }
    let monthIdx = -1;
    if (date[4] === "J" && date[5] === "a" && date[6] === "n") {
      monthIdx = 0;
    } else if (date[4] === "F" && date[5] === "e" && date[6] === "b") {
      monthIdx = 1;
    } else if (date[4] === "M" && date[5] === "a") {
      if (date[6] === "r") {
        monthIdx = 2;
      } else if (date[6] === "y") {
        monthIdx = 4;
      } else {
        return;
      }
    } else if (date[4] === "J") {
      if (date[5] === "a" && date[6] === "n") {
        monthIdx = 0;
      } else if (date[5] === "u") {
        if (date[6] === "n") {
          monthIdx = 5;
        } else if (date[6] === "l") {
          monthIdx = 6;
        } else {
          return;
        }
      } else {
        return;
      }
    } else if (date[4] === "A") {
      if (date[5] === "p" && date[6] === "r") {
        monthIdx = 3;
      } else if (date[5] === "u" && date[6] === "g") {
        monthIdx = 7;
      } else {
        return;
      }
    } else if (date[4] === "S" && date[5] === "e" && date[6] === "p") {
      monthIdx = 8;
    } else if (date[4] === "O" && date[5] === "c" && date[6] === "t") {
      monthIdx = 9;
    } else if (date[4] === "N" && date[5] === "o" && date[6] === "v") {
      monthIdx = 10;
    } else if (date[4] === "D" && date[5] === "e" && date[6] === "c") {
      monthIdx = 11;
    } else {
      return;
    }
    let day = 0;
    if (date[8] === " ") {
      const code = date.charCodeAt(9);
      if (code < 49 || code > 57) {
        return;
      }
      day = code - 48;
    } else {
      const code1 = date.charCodeAt(8);
      if (code1 < 49 || code1 > 51) {
        return;
      }
      const code2 = date.charCodeAt(9);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      day = (code1 - 48) * 10 + (code2 - 48);
    }
    let hour = 0;
    if (date[11] === "0") {
      const code = date.charCodeAt(12);
      if (code < 48 || code > 57) {
        return;
      }
      hour = code - 48;
    } else {
      const code1 = date.charCodeAt(11);
      if (code1 < 48 || code1 > 50) {
        return;
      }
      const code2 = date.charCodeAt(12);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      if (code1 === 50 && code2 > 51) {
        return;
      }
      hour = (code1 - 48) * 10 + (code2 - 48);
    }
    let minute = 0;
    if (date[14] === "0") {
      const code = date.charCodeAt(15);
      if (code < 48 || code > 57) {
        return;
      }
      minute = code - 48;
    } else {
      const code1 = date.charCodeAt(14);
      if (code1 < 48 || code1 > 53) {
        return;
      }
      const code2 = date.charCodeAt(15);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      minute = (code1 - 48) * 10 + (code2 - 48);
    }
    let second = 0;
    if (date[17] === "0") {
      const code = date.charCodeAt(18);
      if (code < 48 || code > 57) {
        return;
      }
      second = code - 48;
    } else {
      const code1 = date.charCodeAt(17);
      if (code1 < 48 || code1 > 53) {
        return;
      }
      const code2 = date.charCodeAt(18);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      second = (code1 - 48) * 10 + (code2 - 48);
    }
    const yearDigit1 = date.charCodeAt(20);
    if (yearDigit1 < 48 || yearDigit1 > 57) {
      return;
    }
    const yearDigit2 = date.charCodeAt(21);
    if (yearDigit2 < 48 || yearDigit2 > 57) {
      return;
    }
    const yearDigit3 = date.charCodeAt(22);
    if (yearDigit3 < 48 || yearDigit3 > 57) {
      return;
    }
    const yearDigit4 = date.charCodeAt(23);
    if (yearDigit4 < 48 || yearDigit4 > 57) {
      return;
    }
    const year = (yearDigit1 - 48) * 1000 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48);
    const result2 = new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    return result2.getUTCDay() === weekday ? result2 : undefined;
  }
  function parseRfc850Date(date) {
    let commaIndex = -1;
    let weekday = -1;
    if (date[0] === "S") {
      if (date[1] === "u" && date[2] === "n" && date[3] === "d" && date[4] === "a" && date[5] === "y") {
        weekday = 0;
        commaIndex = 6;
      } else if (date[1] === "a" && date[2] === "t" && date[3] === "u" && date[4] === "r" && date[5] === "d" && date[6] === "a" && date[7] === "y") {
        weekday = 6;
        commaIndex = 8;
      }
    } else if (date[0] === "M" && date[1] === "o" && date[2] === "n" && date[3] === "d" && date[4] === "a" && date[5] === "y") {
      weekday = 1;
      commaIndex = 6;
    } else if (date[0] === "T") {
      if (date[1] === "u" && date[2] === "e" && date[3] === "s" && date[4] === "d" && date[5] === "a" && date[6] === "y") {
        weekday = 2;
        commaIndex = 7;
      } else if (date[1] === "h" && date[2] === "u" && date[3] === "r" && date[4] === "s" && date[5] === "d" && date[6] === "a" && date[7] === "y") {
        weekday = 4;
        commaIndex = 8;
      }
    } else if (date[0] === "W" && date[1] === "e" && date[2] === "d" && date[3] === "n" && date[4] === "e" && date[5] === "s" && date[6] === "d" && date[7] === "a" && date[8] === "y") {
      weekday = 3;
      commaIndex = 9;
    } else if (date[0] === "F" && date[1] === "r" && date[2] === "i" && date[3] === "d" && date[4] === "a" && date[5] === "y") {
      weekday = 5;
      commaIndex = 6;
    } else {
      return;
    }
    if (date[commaIndex] !== "," || date.length - commaIndex - 1 !== 23 || date[commaIndex + 1] !== " " || date[commaIndex + 4] !== "-" || date[commaIndex + 8] !== "-" || date[commaIndex + 11] !== " " || date[commaIndex + 14] !== ":" || date[commaIndex + 17] !== ":" || date[commaIndex + 20] !== " " || date[commaIndex + 21] !== "G" || date[commaIndex + 22] !== "M" || date[commaIndex + 23] !== "T") {
      return;
    }
    let day = 0;
    if (date[commaIndex + 2] === "0") {
      const code = date.charCodeAt(commaIndex + 3);
      if (code < 49 || code > 57) {
        return;
      }
      day = code - 48;
    } else {
      const code1 = date.charCodeAt(commaIndex + 2);
      if (code1 < 49 || code1 > 51) {
        return;
      }
      const code2 = date.charCodeAt(commaIndex + 3);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      day = (code1 - 48) * 10 + (code2 - 48);
    }
    let monthIdx = -1;
    if (date[commaIndex + 5] === "J" && date[commaIndex + 6] === "a" && date[commaIndex + 7] === "n") {
      monthIdx = 0;
    } else if (date[commaIndex + 5] === "F" && date[commaIndex + 6] === "e" && date[commaIndex + 7] === "b") {
      monthIdx = 1;
    } else if (date[commaIndex + 5] === "M" && date[commaIndex + 6] === "a" && date[commaIndex + 7] === "r") {
      monthIdx = 2;
    } else if (date[commaIndex + 5] === "A" && date[commaIndex + 6] === "p" && date[commaIndex + 7] === "r") {
      monthIdx = 3;
    } else if (date[commaIndex + 5] === "M" && date[commaIndex + 6] === "a" && date[commaIndex + 7] === "y") {
      monthIdx = 4;
    } else if (date[commaIndex + 5] === "J" && date[commaIndex + 6] === "u" && date[commaIndex + 7] === "n") {
      monthIdx = 5;
    } else if (date[commaIndex + 5] === "J" && date[commaIndex + 6] === "u" && date[commaIndex + 7] === "l") {
      monthIdx = 6;
    } else if (date[commaIndex + 5] === "A" && date[commaIndex + 6] === "u" && date[commaIndex + 7] === "g") {
      monthIdx = 7;
    } else if (date[commaIndex + 5] === "S" && date[commaIndex + 6] === "e" && date[commaIndex + 7] === "p") {
      monthIdx = 8;
    } else if (date[commaIndex + 5] === "O" && date[commaIndex + 6] === "c" && date[commaIndex + 7] === "t") {
      monthIdx = 9;
    } else if (date[commaIndex + 5] === "N" && date[commaIndex + 6] === "o" && date[commaIndex + 7] === "v") {
      monthIdx = 10;
    } else if (date[commaIndex + 5] === "D" && date[commaIndex + 6] === "e" && date[commaIndex + 7] === "c") {
      monthIdx = 11;
    } else {
      return;
    }
    const yearDigit1 = date.charCodeAt(commaIndex + 9);
    if (yearDigit1 < 48 || yearDigit1 > 57) {
      return;
    }
    const yearDigit2 = date.charCodeAt(commaIndex + 10);
    if (yearDigit2 < 48 || yearDigit2 > 57) {
      return;
    }
    let year = (yearDigit1 - 48) * 10 + (yearDigit2 - 48);
    year += year < 70 ? 2000 : 1900;
    let hour = 0;
    if (date[commaIndex + 12] === "0") {
      const code = date.charCodeAt(commaIndex + 13);
      if (code < 48 || code > 57) {
        return;
      }
      hour = code - 48;
    } else {
      const code1 = date.charCodeAt(commaIndex + 12);
      if (code1 < 48 || code1 > 50) {
        return;
      }
      const code2 = date.charCodeAt(commaIndex + 13);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      if (code1 === 50 && code2 > 51) {
        return;
      }
      hour = (code1 - 48) * 10 + (code2 - 48);
    }
    let minute = 0;
    if (date[commaIndex + 15] === "0") {
      const code = date.charCodeAt(commaIndex + 16);
      if (code < 48 || code > 57) {
        return;
      }
      minute = code - 48;
    } else {
      const code1 = date.charCodeAt(commaIndex + 15);
      if (code1 < 48 || code1 > 53) {
        return;
      }
      const code2 = date.charCodeAt(commaIndex + 16);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      minute = (code1 - 48) * 10 + (code2 - 48);
    }
    let second = 0;
    if (date[commaIndex + 18] === "0") {
      const code = date.charCodeAt(commaIndex + 19);
      if (code < 48 || code > 57) {
        return;
      }
      second = code - 48;
    } else {
      const code1 = date.charCodeAt(commaIndex + 18);
      if (code1 < 48 || code1 > 53) {
        return;
      }
      const code2 = date.charCodeAt(commaIndex + 19);
      if (code2 < 48 || code2 > 57) {
        return;
      }
      second = (code1 - 48) * 10 + (code2 - 48);
    }
    const result2 = new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    return result2.getUTCDay() === weekday ? result2 : undefined;
  }
  module.exports = {
    parseHttpDate
  };
});

// node_modules/undici/lib/handler/cache-handler.js
var require_cache_handler = __commonJS((exports, module) => {
  var util = require_util();
  var {
    parseCacheControlHeader,
    parseVaryHeader,
    isEtagUsable
  } = require_cache();
  var { parseHttpDate } = require_date();
  function noop() {}
  var HEURISTICALLY_CACHEABLE_STATUS_CODES = [
    200,
    203,
    204,
    206,
    300,
    301,
    308,
    404,
    405,
    410,
    414,
    501
  ];
  var NOT_UNDERSTOOD_STATUS_CODES = [
    206
  ];
  var MAX_RESPONSE_AGE = 2147483647000;

  class CacheHandler {
    #cacheKey;
    #cacheType;
    #cacheByDefault;
    #store;
    #handler;
    #writeStream;
    constructor({ store, type, cacheByDefault }, cacheKey, handler) {
      this.#store = store;
      this.#cacheType = type;
      this.#cacheByDefault = cacheByDefault;
      this.#cacheKey = cacheKey;
      this.#handler = handler;
    }
    onRequestStart(controller, context) {
      this.#writeStream?.destroy();
      this.#writeStream = undefined;
      this.#handler.onRequestStart?.(controller, context);
    }
    onRequestUpgrade(controller, statusCode, headers, socket) {
      this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
    }
    onResponseStart(controller, statusCode, resHeaders, statusMessage) {
      const downstreamOnHeaders = () => this.#handler.onResponseStart?.(controller, statusCode, resHeaders, statusMessage);
      const handler = this;
      if (!util.safeHTTPMethods.includes(this.#cacheKey.method) && statusCode >= 200 && statusCode <= 399) {
        try {
          this.#store.delete(this.#cacheKey)?.catch?.(noop);
        } catch {}
        return downstreamOnHeaders();
      }
      const cacheControlHeader = resHeaders["cache-control"];
      const heuristicallyCacheable = resHeaders["last-modified"] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode);
      if (!cacheControlHeader && !resHeaders["expires"] && !heuristicallyCacheable && !this.#cacheByDefault) {
        return downstreamOnHeaders();
      }
      const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {};
      if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {
        return downstreamOnHeaders();
      }
      const now = Date.now();
      const resAge = resHeaders.age ? getAge(resHeaders.age) : undefined;
      if (resAge && resAge >= MAX_RESPONSE_AGE) {
        return downstreamOnHeaders();
      }
      const resDate = typeof resHeaders.date === "string" ? parseHttpDate(resHeaders.date) : undefined;
      const staleAt = determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ?? this.#cacheByDefault;
      if (staleAt === undefined || resAge && resAge > staleAt) {
        return downstreamOnHeaders();
      }
      const baseTime = resDate ? resDate.getTime() : now;
      const absoluteStaleAt = staleAt + baseTime;
      if (now >= absoluteStaleAt) {
        return downstreamOnHeaders();
      }
      let varyDirectives;
      if (this.#cacheKey.headers && resHeaders.vary) {
        varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers);
        if (!varyDirectives) {
          return downstreamOnHeaders();
        }
      }
      const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt);
      const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives);
      const value = {
        statusCode,
        statusMessage,
        headers: strippedHeaders,
        vary: varyDirectives,
        cacheControlDirectives,
        cachedAt: resAge ? now - resAge : now,
        staleAt: absoluteStaleAt,
        deleteAt
      };
      if (statusCode === 304) {
        const cachedValue = this.#store.get(this.#cacheKey);
        if (!cachedValue) {
          return downstreamOnHeaders();
        }
        value.statusCode = cachedValue.statusCode;
        value.statusMessage = cachedValue.statusMessage;
        value.etag = cachedValue.etag;
        value.headers = { ...cachedValue.headers, ...strippedHeaders };
        downstreamOnHeaders();
        this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value);
        if (!this.#writeStream || !cachedValue?.body) {
          return;
        }
        const bodyIterator = cachedValue.body.values();
        const streamCachedBody = () => {
          for (const chunk of bodyIterator) {
            const full = this.#writeStream.write(chunk) === false;
            this.#handler.onResponseData?.(controller, chunk);
            if (full) {
              break;
            }
          }
        };
        this.#writeStream.on("error", function() {
          handler.#writeStream = undefined;
          handler.#store.delete(handler.#cacheKey);
        }).on("drain", () => {
          streamCachedBody();
        }).on("close", function() {
          if (handler.#writeStream === this) {
            handler.#writeStream = undefined;
          }
        });
        streamCachedBody();
      } else {
        if (typeof resHeaders.etag === "string" && isEtagUsable(resHeaders.etag)) {
          value.etag = resHeaders.etag;
        }
        this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value);
        if (!this.#writeStream) {
          return downstreamOnHeaders();
        }
        this.#writeStream.on("drain", () => controller.resume()).on("error", function() {
          handler.#writeStream = undefined;
          handler.#store.delete(handler.#cacheKey);
        }).on("close", function() {
          if (handler.#writeStream === this) {
            handler.#writeStream = undefined;
          }
          controller.resume();
        });
        downstreamOnHeaders();
      }
    }
    onResponseData(controller, chunk) {
      if (this.#writeStream?.write(chunk) === false) {
        controller.pause();
      }
      this.#handler.onResponseData?.(controller, chunk);
    }
    onResponseEnd(controller, trailers) {
      this.#writeStream?.end();
      this.#handler.onResponseEnd?.(controller, trailers);
    }
    onResponseError(controller, err) {
      this.#writeStream?.destroy(err);
      this.#writeStream = undefined;
      this.#handler.onResponseError?.(controller, err);
    }
  }
  function canCacheResponse(cacheType, statusCode, resHeaders, cacheControlDirectives) {
    if (statusCode < 200 || NOT_UNDERSTOOD_STATUS_CODES.includes(statusCode)) {
      return false;
    }
    if (!HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode) && !resHeaders["expires"] && !cacheControlDirectives.public && cacheControlDirectives["max-age"] === undefined && !(cacheControlDirectives.private && cacheType === "private") && !(cacheControlDirectives["s-maxage"] !== undefined && cacheType === "shared")) {
      return false;
    }
    if (cacheControlDirectives["no-store"]) {
      return false;
    }
    if (cacheType === "shared" && cacheControlDirectives.private === true) {
      return false;
    }
    if (resHeaders.vary?.includes("*")) {
      return false;
    }
    if (resHeaders.authorization) {
      if (!cacheControlDirectives.public || typeof resHeaders.authorization !== "string") {
        return false;
      }
      if (Array.isArray(cacheControlDirectives["no-cache"]) && cacheControlDirectives["no-cache"].includes("authorization")) {
        return false;
      }
      if (Array.isArray(cacheControlDirectives["private"]) && cacheControlDirectives["private"].includes("authorization")) {
        return false;
      }
    }
    return true;
  }
  function getAge(ageHeader) {
    const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader);
    return isNaN(age) ? undefined : age * 1000;
  }
  function determineStaleAt(cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {
    if (cacheType === "shared") {
      const sMaxAge = cacheControlDirectives["s-maxage"];
      if (sMaxAge !== undefined) {
        return sMaxAge > 0 ? sMaxAge * 1000 : undefined;
      }
    }
    const maxAge = cacheControlDirectives["max-age"];
    if (maxAge !== undefined) {
      return maxAge > 0 ? maxAge * 1000 : undefined;
    }
    if (typeof resHeaders.expires === "string") {
      const expiresDate = parseHttpDate(resHeaders.expires);
      if (expiresDate) {
        if (now >= expiresDate.getTime()) {
          return;
        }
        if (responseDate) {
          if (responseDate >= expiresDate) {
            return;
          }
          if (age !== undefined && age > expiresDate - responseDate) {
            return;
          }
        }
        return expiresDate.getTime() - now;
      }
    }
    if (typeof resHeaders["last-modified"] === "string") {
      const lastModified = new Date(resHeaders["last-modified"]);
      if (isValidDate(lastModified)) {
        if (lastModified.getTime() >= now) {
          return;
        }
        const responseAge = now - lastModified.getTime();
        return responseAge * 0.1;
      }
    }
    if (cacheControlDirectives.immutable) {
      return 31536000;
    }
    return;
  }
  function determineDeleteAt(now, cacheControlDirectives, staleAt) {
    let staleWhileRevalidate = -Infinity;
    let staleIfError = -Infinity;
    let immutable = -Infinity;
    if (cacheControlDirectives["stale-while-revalidate"]) {
      staleWhileRevalidate = staleAt + cacheControlDirectives["stale-while-revalidate"] * 1000;
    }
    if (cacheControlDirectives["stale-if-error"]) {
      staleIfError = staleAt + cacheControlDirectives["stale-if-error"] * 1000;
    }
    if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {
      immutable = now + 31536000000;
    }
    return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable);
  }
  function stripNecessaryHeaders(resHeaders, cacheControlDirectives) {
    const headersToRemove = [
      "connection",
      "proxy-authenticate",
      "proxy-authentication-info",
      "proxy-authorization",
      "proxy-connection",
      "te",
      "transfer-encoding",
      "upgrade",
      "age"
    ];
    if (resHeaders["connection"]) {
      if (Array.isArray(resHeaders["connection"])) {
        headersToRemove.push(...resHeaders["connection"].map((header) => header.trim()));
      } else {
        headersToRemove.push(...resHeaders["connection"].split(",").map((header) => header.trim()));
      }
    }
    if (Array.isArray(cacheControlDirectives["no-cache"])) {
      headersToRemove.push(...cacheControlDirectives["no-cache"]);
    }
    if (Array.isArray(cacheControlDirectives["private"])) {
      headersToRemove.push(...cacheControlDirectives["private"]);
    }
    let strippedHeaders;
    for (const headerName of headersToRemove) {
      if (resHeaders[headerName]) {
        strippedHeaders ??= { ...resHeaders };
        delete strippedHeaders[headerName];
      }
    }
    return strippedHeaders ?? resHeaders;
  }
  function isValidDate(date) {
    return date instanceof Date && Number.isFinite(date.valueOf());
  }
  module.exports = CacheHandler;
});

// node_modules/undici/lib/cache/memory-cache-store.js
var require_memory_cache_store = __commonJS((exports, module) => {
  var { Writable } = __require("node:stream");
  var { EventEmitter } = __require("node:events");
  var { assertCacheKey, assertCacheValue } = require_cache();

  class MemoryCacheStore extends EventEmitter {
    #maxCount = 1024;
    #maxSize = 104857600;
    #maxEntrySize = 5242880;
    #size = 0;
    #count = 0;
    #entries = new Map;
    #hasEmittedMaxSizeEvent = false;
    constructor(opts) {
      super();
      if (opts) {
        if (typeof opts !== "object") {
          throw new TypeError("MemoryCacheStore options must be an object");
        }
        if (opts.maxCount !== undefined) {
          if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
            throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
          }
          this.#maxCount = opts.maxCount;
        }
        if (opts.maxSize !== undefined) {
          if (typeof opts.maxSize !== "number" || !Number.isInteger(opts.maxSize) || opts.maxSize < 0) {
            throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
          }
          this.#maxSize = opts.maxSize;
        }
        if (opts.maxEntrySize !== undefined) {
          if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
            throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
          }
          this.#maxEntrySize = opts.maxEntrySize;
        }
      }
    }
    get size() {
      return this.#size;
    }
    isFull() {
      return this.#size >= this.#maxSize || this.#count >= this.#maxCount;
    }
    get(key) {
      assertCacheKey(key);
      const topLevelKey = `${key.origin}:${key.path}`;
      const now = Date.now();
      const entries = this.#entries.get(topLevelKey);
      const entry = entries ? findEntry(key, entries, now) : null;
      return entry == null ? undefined : {
        statusMessage: entry.statusMessage,
        statusCode: entry.statusCode,
        headers: entry.headers,
        body: entry.body,
        vary: entry.vary ? entry.vary : undefined,
        etag: entry.etag,
        cacheControlDirectives: entry.cacheControlDirectives,
        cachedAt: entry.cachedAt,
        staleAt: entry.staleAt,
        deleteAt: entry.deleteAt
      };
    }
    createWriteStream(key, val) {
      assertCacheKey(key);
      assertCacheValue(val);
      const topLevelKey = `${key.origin}:${key.path}`;
      const store = this;
      const entry = { ...key, ...val, body: [], size: 0 };
      return new Writable({
        write(chunk, encoding, callback) {
          if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
          }
          entry.size += chunk.byteLength;
          if (entry.size >= store.#maxEntrySize) {
            this.destroy();
          } else {
            entry.body.push(chunk);
          }
          callback(null);
        },
        final(callback) {
          let entries = store.#entries.get(topLevelKey);
          if (!entries) {
            entries = [];
            store.#entries.set(topLevelKey, entries);
          }
          const previousEntry = findEntry(key, entries, Date.now());
          if (previousEntry) {
            const index = entries.indexOf(previousEntry);
            entries.splice(index, 1, entry);
            store.#size -= previousEntry.size;
          } else {
            entries.push(entry);
            store.#count += 1;
          }
          store.#size += entry.size;
          if (store.#size > store.#maxSize || store.#count > store.#maxCount) {
            if (!store.#hasEmittedMaxSizeEvent) {
              store.emit("maxSizeExceeded", {
                size: store.#size,
                maxSize: store.#maxSize,
                count: store.#count,
                maxCount: store.#maxCount
              });
              store.#hasEmittedMaxSizeEvent = true;
            }
            for (const [key2, entries2] of store.#entries) {
              for (const entry2 of entries2.splice(0, entries2.length / 2)) {
                store.#size -= entry2.size;
                store.#count -= 1;
              }
              if (entries2.length === 0) {
                store.#entries.delete(key2);
              }
            }
            if (store.#size < store.#maxSize && store.#count < store.#maxCount) {
              store.#hasEmittedMaxSizeEvent = false;
            }
          }
          callback(null);
        }
      });
    }
    delete(key) {
      if (typeof key !== "object") {
        throw new TypeError(`expected key to be object, got ${typeof key}`);
      }
      const topLevelKey = `${key.origin}:${key.path}`;
      for (const entry of this.#entries.get(topLevelKey) ?? []) {
        this.#size -= entry.size;
        this.#count -= 1;
      }
      this.#entries.delete(topLevelKey);
    }
  }
  function findEntry(key, entries, now) {
    return entries.find((entry) => entry.deleteAt > now && entry.method === key.method && (entry.vary == null || Object.keys(entry.vary).every((headerName) => {
      if (entry.vary[headerName] === null) {
        return key.headers[headerName] === undefined;
      }
      return entry.vary[headerName] === key.headers[headerName];
    })));
  }
  module.exports = MemoryCacheStore;
});

// node_modules/undici/lib/handler/cache-revalidation-handler.js
var require_cache_revalidation_handler = __commonJS((exports, module) => {
  var assert = __require("node:assert");

  class CacheRevalidationHandler {
    #successful = false;
    #callback;
    #handler;
    #context;
    #allowErrorStatusCodes;
    constructor(callback, handler, allowErrorStatusCodes) {
      if (typeof callback !== "function") {
        throw new TypeError("callback must be a function");
      }
      this.#callback = callback;
      this.#handler = handler;
      this.#allowErrorStatusCodes = allowErrorStatusCodes;
    }
    onRequestStart(_, context) {
      this.#successful = false;
      this.#context = context;
    }
    onRequestUpgrade(controller, statusCode, headers, socket) {
      this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      assert(this.#callback != null);
      this.#successful = statusCode === 304 || this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504;
      this.#callback(this.#successful, this.#context);
      this.#callback = null;
      if (this.#successful) {
        return true;
      }
      this.#handler.onRequestStart?.(controller, this.#context);
      this.#handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
    }
    onResponseData(controller, chunk) {
      if (this.#successful) {
        return;
      }
      return this.#handler.onResponseData?.(controller, chunk);
    }
    onResponseEnd(controller, trailers) {
      if (this.#successful) {
        return;
      }
      this.#handler.onResponseEnd?.(controller, trailers);
    }
    onResponseError(controller, err) {
      if (this.#successful) {
        return;
      }
      if (this.#callback) {
        this.#callback(false);
        this.#callback = null;
      }
      if (typeof this.#handler.onResponseError === "function") {
        this.#handler.onResponseError(controller, err);
      } else {
        throw err;
      }
    }
  }
  module.exports = CacheRevalidationHandler;
});

// node_modules/undici/lib/interceptor/cache.js
var require_cache2 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { Readable } = __require("node:stream");
  var util = require_util();
  var CacheHandler = require_cache_handler();
  var MemoryCacheStore = require_memory_cache_store();
  var CacheRevalidationHandler = require_cache_revalidation_handler();
  var { assertCacheStore, assertCacheMethods, makeCacheKey, normalizeHeaders, parseCacheControlHeader } = require_cache();
  var { AbortError } = require_errors();
  function assertCacheOrigins(origins, name) {
    if (origins === undefined)
      return;
    if (!Array.isArray(origins)) {
      throw new TypeError(`expected ${name} to be an array or undefined, got ${typeof origins}`);
    }
    for (let i = 0;i < origins.length; i++) {
      const origin = origins[i];
      if (typeof origin !== "string" && !(origin instanceof RegExp)) {
        throw new TypeError(`expected ${name}[${i}] to be a string or RegExp, got ${typeof origin}`);
      }
    }
  }
  var nop = () => {};
  function needsRevalidation(result2, cacheControlDirectives, { headers = {} }) {
    if (cacheControlDirectives?.["no-cache"]) {
      return true;
    }
    if (result2.cacheControlDirectives?.["no-cache"] && !Array.isArray(result2.cacheControlDirectives["no-cache"])) {
      return true;
    }
    if (headers["if-modified-since"] || headers["if-none-match"]) {
      return true;
    }
    return false;
  }
  function isStale(result2, cacheControlDirectives) {
    const now = Date.now();
    if (now > result2.staleAt) {
      if (cacheControlDirectives?.["max-stale"]) {
        const gracePeriod = result2.staleAt + cacheControlDirectives["max-stale"] * 1000;
        return now > gracePeriod;
      }
      return true;
    }
    if (cacheControlDirectives?.["min-fresh"]) {
      const timeLeftTillStale = result2.staleAt - now;
      const threshold = cacheControlDirectives["min-fresh"] * 1000;
      return timeLeftTillStale <= threshold;
    }
    return false;
  }
  function withinStaleWhileRevalidateWindow(result2) {
    const staleWhileRevalidate = result2.cacheControlDirectives?.["stale-while-revalidate"];
    if (!staleWhileRevalidate) {
      return false;
    }
    const now = Date.now();
    const staleWhileRevalidateExpiry = result2.staleAt + staleWhileRevalidate * 1000;
    return now <= staleWhileRevalidateExpiry;
  }
  function handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl) {
    if (reqCacheControl?.["only-if-cached"]) {
      let aborted = false;
      try {
        if (typeof handler.onConnect === "function") {
          handler.onConnect(() => {
            aborted = true;
          });
          if (aborted) {
            return;
          }
        }
        if (typeof handler.onHeaders === "function") {
          handler.onHeaders(504, [], nop, "Gateway Timeout");
          if (aborted) {
            return;
          }
        }
        if (typeof handler.onComplete === "function") {
          handler.onComplete([]);
        }
      } catch (err) {
        if (typeof handler.onError === "function") {
          handler.onError(err);
        }
      }
      return true;
    }
    return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
  }
  function sendCachedValue(handler, opts, result2, age, context, isStale2) {
    const stream = util.isStream(result2.body) ? result2.body : Readable.from(result2.body ?? []);
    assert(!stream.destroyed, "stream should not be destroyed");
    assert(!stream.readableDidRead, "stream should not be readableDidRead");
    const controller = {
      resume() {
        stream.resume();
      },
      pause() {
        stream.pause();
      },
      get paused() {
        return stream.isPaused();
      },
      get aborted() {
        return stream.destroyed;
      },
      get reason() {
        return stream.errored;
      },
      abort(reason) {
        stream.destroy(reason ?? new AbortError);
      }
    };
    stream.on("error", function(err) {
      if (!this.readableEnded) {
        if (typeof handler.onResponseError === "function") {
          handler.onResponseError(controller, err);
        } else {
          throw err;
        }
      }
    }).on("close", function() {
      if (!this.errored) {
        handler.onResponseEnd?.(controller, {});
      }
    });
    handler.onRequestStart?.(controller, context);
    if (stream.destroyed) {
      return;
    }
    const headers = { ...result2.headers, age: String(age) };
    if (isStale2) {
      headers.warning = '110 - "response is stale"';
    }
    handler.onResponseStart?.(controller, result2.statusCode, headers, result2.statusMessage);
    if (opts.method === "HEAD") {
      stream.destroy();
    } else {
      stream.on("data", function(chunk) {
        handler.onResponseData?.(controller, chunk);
      });
    }
  }
  function handleResult(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl, result2) {
    if (!result2) {
      return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl);
    }
    const now = Date.now();
    if (now > result2.deleteAt) {
      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
    }
    const age = Math.round((now - result2.cachedAt) / 1000);
    if (reqCacheControl?.["max-age"] && age >= reqCacheControl["max-age"]) {
      return dispatch(opts, handler);
    }
    const stale = isStale(result2, reqCacheControl);
    const revalidate = needsRevalidation(result2, reqCacheControl, opts);
    if (stale || revalidate) {
      if (util.isStream(opts.body) && util.bodyLength(opts.body) !== 0) {
        return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
      }
      if (!revalidate && withinStaleWhileRevalidateWindow(result2)) {
        sendCachedValue(handler, opts, result2, age, null, true);
        queueMicrotask(() => {
          let headers2 = {
            ...opts.headers,
            "if-modified-since": new Date(result2.cachedAt).toUTCString()
          };
          if (result2.etag) {
            headers2["if-none-match"] = result2.etag;
          }
          if (result2.vary) {
            headers2 = {
              ...headers2,
              ...result2.vary
            };
          }
          dispatch({
            ...opts,
            headers: headers2
          }, new CacheHandler(globalOpts, cacheKey, {
            onRequestStart() {},
            onRequestUpgrade() {},
            onResponseStart() {},
            onResponseData() {},
            onResponseEnd() {},
            onResponseError() {}
          }));
        });
        return true;
      }
      let withinStaleIfErrorThreshold = false;
      const staleIfErrorExpiry = result2.cacheControlDirectives["stale-if-error"] ?? reqCacheControl?.["stale-if-error"];
      if (staleIfErrorExpiry) {
        withinStaleIfErrorThreshold = now < result2.staleAt + staleIfErrorExpiry * 1000;
      }
      let headers = {
        ...opts.headers,
        "if-modified-since": new Date(result2.cachedAt).toUTCString()
      };
      if (result2.etag) {
        headers["if-none-match"] = result2.etag;
      }
      if (result2.vary) {
        headers = {
          ...headers,
          ...result2.vary
        };
      }
      return dispatch({
        ...opts,
        headers
      }, new CacheRevalidationHandler((success, context) => {
        if (success) {
          sendCachedValue(handler, opts, result2, age, context, stale);
        } else if (util.isStream(result2.body)) {
          result2.body.on("error", nop).destroy();
        }
      }, new CacheHandler(globalOpts, cacheKey, handler), withinStaleIfErrorThreshold));
    }
    if (util.isStream(opts.body)) {
      opts.body.on("error", nop).destroy();
    }
    sendCachedValue(handler, opts, result2, age, null, false);
  }
  module.exports = (opts = {}) => {
    const {
      store = new MemoryCacheStore,
      methods = ["GET"],
      cacheByDefault = undefined,
      type = "shared",
      origins = undefined
    } = opts;
    if (typeof opts !== "object" || opts === null) {
      throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
    }
    assertCacheStore(store, "opts.store");
    assertCacheMethods(methods, "opts.methods");
    assertCacheOrigins(origins, "opts.origins");
    if (typeof cacheByDefault !== "undefined" && typeof cacheByDefault !== "number") {
      throw new TypeError(`expected opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`);
    }
    if (typeof type !== "undefined" && type !== "shared" && type !== "private") {
      throw new TypeError(`expected opts.type to be shared, private, or undefined, got ${typeof type}`);
    }
    const globalOpts = {
      store,
      methods,
      cacheByDefault,
      type
    };
    const safeMethodsToNotCache = util.safeHTTPMethods.filter((method) => methods.includes(method) === false);
    return (dispatch) => {
      return (opts2, handler) => {
        if (!opts2.origin || safeMethodsToNotCache.includes(opts2.method)) {
          return dispatch(opts2, handler);
        }
        if (origins !== undefined) {
          const requestOrigin = opts2.origin.toString().toLowerCase();
          let isAllowed = false;
          for (let i = 0;i < origins.length; i++) {
            const allowed = origins[i];
            if (typeof allowed === "string") {
              if (allowed.toLowerCase() === requestOrigin) {
                isAllowed = true;
                break;
              }
            } else if (allowed.test(requestOrigin)) {
              isAllowed = true;
              break;
            }
          }
          if (!isAllowed) {
            return dispatch(opts2, handler);
          }
        }
        opts2 = {
          ...opts2,
          headers: normalizeHeaders(opts2)
        };
        const reqCacheControl = opts2.headers?.["cache-control"] ? parseCacheControlHeader(opts2.headers["cache-control"]) : undefined;
        if (reqCacheControl?.["no-store"]) {
          return dispatch(opts2, handler);
        }
        const cacheKey = makeCacheKey(opts2);
        const result2 = store.get(cacheKey);
        if (result2 && typeof result2.then === "function") {
          return result2.then((result3) => handleResult(dispatch, globalOpts, cacheKey, handler, opts2, reqCacheControl, result3));
        } else {
          return handleResult(dispatch, globalOpts, cacheKey, handler, opts2, reqCacheControl, result2);
        }
      };
    };
  };
});

// node_modules/undici/lib/interceptor/decompress.js
var require_decompress = __commonJS((exports, module) => {
  var { createInflate, createGunzip, createBrotliDecompress, createZstdDecompress } = __require("node:zlib");
  var { pipeline } = __require("node:stream");
  var DecoratorHandler = require_decorator_handler();
  var { runtimeFeatures } = require_runtime_features();
  var supportedEncodings = {
    gzip: createGunzip,
    "x-gzip": createGunzip,
    br: createBrotliDecompress,
    deflate: createInflate,
    compress: createInflate,
    "x-compress": createInflate,
    ...runtimeFeatures.has("zstd") ? { zstd: createZstdDecompress } : {}
  };
  var defaultSkipStatusCodes = [204, 304];
  var warningEmitted = false;

  class DecompressHandler extends DecoratorHandler {
    #decompressors = [];
    #pipelineStream;
    #skipStatusCodes;
    #skipErrorResponses;
    constructor(handler, { skipStatusCodes = defaultSkipStatusCodes, skipErrorResponses = true } = {}) {
      super(handler);
      this.#skipStatusCodes = skipStatusCodes;
      this.#skipErrorResponses = skipErrorResponses;
    }
    #shouldSkipDecompression(contentEncoding, statusCode) {
      if (!contentEncoding || statusCode < 200)
        return true;
      if (this.#skipStatusCodes.includes(statusCode))
        return true;
      if (this.#skipErrorResponses && statusCode >= 400)
        return true;
      return false;
    }
    #createDecompressionChain(encodings) {
      const parts = encodings.split(",");
      const maxContentEncodings = 5;
      if (parts.length > maxContentEncodings) {
        throw new Error(`too many content-encodings in response: ${parts.length}, maximum allowed is ${maxContentEncodings}`);
      }
      const decompressors = [];
      for (let i = parts.length - 1;i >= 0; i--) {
        const encoding = parts[i].trim();
        if (!encoding)
          continue;
        if (!supportedEncodings[encoding]) {
          decompressors.length = 0;
          return decompressors;
        }
        decompressors.push(supportedEncodings[encoding]());
      }
      return decompressors;
    }
    #setupDecompressorEvents(decompressor, controller) {
      decompressor.on("readable", () => {
        let chunk;
        while ((chunk = decompressor.read()) !== null) {
          const result2 = super.onResponseData(controller, chunk);
          if (result2 === false) {
            break;
          }
        }
      });
      decompressor.on("error", (error2) => {
        super.onResponseError(controller, error2);
      });
    }
    #setupSingleDecompressor(controller) {
      const decompressor = this.#decompressors[0];
      this.#setupDecompressorEvents(decompressor, controller);
      decompressor.on("end", () => {
        super.onResponseEnd(controller, {});
      });
    }
    #setupMultipleDecompressors(controller) {
      const lastDecompressor = this.#decompressors[this.#decompressors.length - 1];
      this.#setupDecompressorEvents(lastDecompressor, controller);
      this.#pipelineStream = pipeline(this.#decompressors, (err) => {
        if (err) {
          super.onResponseError(controller, err);
          return;
        }
        super.onResponseEnd(controller, {});
      });
    }
    #cleanupDecompressors() {
      this.#decompressors.length = 0;
      this.#pipelineStream = null;
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      const contentEncoding = headers["content-encoding"];
      if (this.#shouldSkipDecompression(contentEncoding, statusCode)) {
        return super.onResponseStart(controller, statusCode, headers, statusMessage);
      }
      const decompressors = this.#createDecompressionChain(contentEncoding.toLowerCase());
      if (decompressors.length === 0) {
        this.#cleanupDecompressors();
        return super.onResponseStart(controller, statusCode, headers, statusMessage);
      }
      this.#decompressors = decompressors;
      const { "content-encoding": _, "content-length": __, ...newHeaders } = headers;
      if (this.#decompressors.length === 1) {
        this.#setupSingleDecompressor(controller);
      } else {
        this.#setupMultipleDecompressors(controller);
      }
      super.onResponseStart(controller, statusCode, newHeaders, statusMessage);
    }
    onResponseData(controller, chunk) {
      if (this.#decompressors.length > 0) {
        this.#decompressors[0].write(chunk);
        return;
      }
      super.onResponseData(controller, chunk);
    }
    onResponseEnd(controller, trailers) {
      if (this.#decompressors.length > 0) {
        this.#decompressors[0].end();
        this.#cleanupDecompressors();
        return;
      }
      super.onResponseEnd(controller, trailers);
    }
    onResponseError(controller, err) {
      if (this.#decompressors.length > 0) {
        for (const decompressor of this.#decompressors) {
          decompressor.destroy(err);
        }
        this.#cleanupDecompressors();
      }
      super.onResponseError(controller, err);
    }
  }
  function createDecompressInterceptor(options = {}) {
    if (!warningEmitted) {
      process.emitWarning("DecompressInterceptor is experimental and subject to change", "ExperimentalWarning");
      warningEmitted = true;
    }
    return (dispatch) => {
      return (opts, handler) => {
        const decompressHandler = new DecompressHandler(handler, options);
        return dispatch(opts, decompressHandler);
      };
    };
  }
  module.exports = createDecompressInterceptor;
});

// node_modules/undici/lib/handler/deduplication-handler.js
var require_deduplication_handler = __commonJS((exports, module) => {
  class DeduplicationHandler {
    #primaryHandler;
    #waitingHandlers = [];
    #chunks = [];
    #statusCode = 0;
    #headers = {};
    #statusMessage = "";
    #aborted = false;
    #controller = null;
    #onComplete = null;
    constructor(primaryHandler, onComplete) {
      this.#primaryHandler = primaryHandler;
      this.#onComplete = onComplete;
    }
    addWaitingHandler(handler) {
      this.#waitingHandlers.push(handler);
    }
    onRequestStart(controller, context) {
      this.#controller = controller;
      this.#primaryHandler.onRequestStart?.(controller, context);
    }
    onRequestUpgrade(controller, statusCode, headers, socket) {
      this.#primaryHandler.onRequestUpgrade?.(controller, statusCode, headers, socket);
    }
    onResponseStart(controller, statusCode, headers, statusMessage) {
      this.#statusCode = statusCode;
      this.#headers = headers;
      this.#statusMessage = statusMessage;
      this.#primaryHandler.onResponseStart?.(controller, statusCode, headers, statusMessage);
    }
    onResponseData(controller, chunk) {
      this.#chunks.push(Buffer.from(chunk));
      this.#primaryHandler.onResponseData?.(controller, chunk);
    }
    onResponseEnd(controller, trailers) {
      this.#primaryHandler.onResponseEnd?.(controller, trailers);
      this.#notifyWaitingHandlers();
      this.#onComplete?.();
    }
    onResponseError(controller, err) {
      this.#aborted = true;
      this.#primaryHandler.onResponseError?.(controller, err);
      this.#notifyWaitingHandlersError(err);
      this.#onComplete?.();
    }
    #notifyWaitingHandlers() {
      const body = Buffer.concat(this.#chunks);
      for (const handler of this.#waitingHandlers) {
        const waitingController = {
          resume() {},
          pause() {},
          get paused() {
            return false;
          },
          get aborted() {
            return false;
          },
          get reason() {
            return null;
          },
          abort() {}
        };
        try {
          handler.onRequestStart?.(waitingController, null);
          if (waitingController.aborted) {
            continue;
          }
          handler.onResponseStart?.(waitingController, this.#statusCode, this.#headers, this.#statusMessage);
          if (waitingController.aborted) {
            continue;
          }
          if (body.length > 0) {
            handler.onResponseData?.(waitingController, body);
          }
          handler.onResponseEnd?.(waitingController, {});
        } catch {}
      }
      this.#waitingHandlers = [];
      this.#chunks = [];
    }
    #notifyWaitingHandlersError(err) {
      for (const handler of this.#waitingHandlers) {
        const waitingController = {
          resume() {},
          pause() {},
          get paused() {
            return false;
          },
          get aborted() {
            return true;
          },
          get reason() {
            return err;
          },
          abort() {}
        };
        try {
          handler.onRequestStart?.(waitingController, null);
          handler.onResponseError?.(waitingController, err);
        } catch {}
      }
      this.#waitingHandlers = [];
      this.#chunks = [];
    }
  }
  module.exports = DeduplicationHandler;
});

// node_modules/undici/lib/interceptor/deduplicate.js
var require_deduplicate = __commonJS((exports, module) => {
  var diagnosticsChannel = __require("node:diagnostics_channel");
  var util = require_util();
  var DeduplicationHandler = require_deduplication_handler();
  var { normalizeHeaders, makeCacheKey, makeDeduplicationKey } = require_cache();
  var pendingRequestsChannel = diagnosticsChannel.channel("undici:request:pending-requests");
  module.exports = (opts = {}) => {
    const {
      methods = ["GET"],
      skipHeaderNames = [],
      excludeHeaderNames = []
    } = opts;
    if (typeof opts !== "object" || opts === null) {
      throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
    }
    if (!Array.isArray(methods)) {
      throw new TypeError(`expected opts.methods to be an array, got ${typeof methods}`);
    }
    for (const method of methods) {
      if (!util.safeHTTPMethods.includes(method)) {
        throw new TypeError(`expected opts.methods to only contain safe HTTP methods, got ${method}`);
      }
    }
    if (!Array.isArray(skipHeaderNames)) {
      throw new TypeError(`expected opts.skipHeaderNames to be an array, got ${typeof skipHeaderNames}`);
    }
    if (!Array.isArray(excludeHeaderNames)) {
      throw new TypeError(`expected opts.excludeHeaderNames to be an array, got ${typeof excludeHeaderNames}`);
    }
    const skipHeaderNamesSet = new Set(skipHeaderNames.map((name) => name.toLowerCase()));
    const excludeHeaderNamesSet = new Set(excludeHeaderNames.map((name) => name.toLowerCase()));
    const safeMethodsToNotDeduplicate = util.safeHTTPMethods.filter((method) => methods.includes(method) === false);
    const pendingRequests = new Map;
    return (dispatch) => {
      return (opts2, handler) => {
        if (!opts2.origin || safeMethodsToNotDeduplicate.includes(opts2.method)) {
          return dispatch(opts2, handler);
        }
        opts2 = {
          ...opts2,
          headers: normalizeHeaders(opts2)
        };
        if (skipHeaderNamesSet.size > 0) {
          for (const headerName of Object.keys(opts2.headers)) {
            if (skipHeaderNamesSet.has(headerName.toLowerCase())) {
              return dispatch(opts2, handler);
            }
          }
        }
        const cacheKey = makeCacheKey(opts2);
        const dedupeKey = makeDeduplicationKey(cacheKey, excludeHeaderNamesSet);
        const pendingHandler = pendingRequests.get(dedupeKey);
        if (pendingHandler) {
          pendingHandler.addWaitingHandler(handler);
          return true;
        }
        const deduplicationHandler = new DeduplicationHandler(handler, () => {
          pendingRequests.delete(dedupeKey);
          if (pendingRequestsChannel.hasSubscribers) {
            pendingRequestsChannel.publish({ size: pendingRequests.size, key: dedupeKey, type: "removed" });
          }
        });
        pendingRequests.set(dedupeKey, deduplicationHandler);
        if (pendingRequestsChannel.hasSubscribers) {
          pendingRequestsChannel.publish({ size: pendingRequests.size, key: dedupeKey, type: "added" });
        }
        return dispatch(opts2, deduplicationHandler);
      };
    };
  };
});

// node_modules/undici/lib/cache/sqlite-cache-store.js
var require_sqlite_cache_store = __commonJS((exports, module) => {
  var { Writable } = __require("node:stream");
  var { assertCacheKey, assertCacheValue } = require_cache();
  var DatabaseSync;
  var VERSION = 3;
  var MAX_ENTRY_SIZE = 2 * 1000 * 1000 * 1000;
  module.exports = class SqliteCacheStore {
    #maxEntrySize = MAX_ENTRY_SIZE;
    #maxCount = Infinity;
    #db;
    #getValuesQuery;
    #updateValueQuery;
    #insertValueQuery;
    #deleteExpiredValuesQuery;
    #deleteByUrlQuery;
    #countEntriesQuery;
    #deleteOldValuesQuery;
    constructor(opts) {
      if (opts) {
        if (typeof opts !== "object") {
          throw new TypeError("SqliteCacheStore options must be an object");
        }
        if (opts.maxEntrySize !== undefined) {
          if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
            throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
          }
          if (opts.maxEntrySize > MAX_ENTRY_SIZE) {
            throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
          }
          this.#maxEntrySize = opts.maxEntrySize;
        }
        if (opts.maxCount !== undefined) {
          if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
            throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
          }
          this.#maxCount = opts.maxCount;
        }
      }
      if (!DatabaseSync) {
        DatabaseSync = __require("node:sqlite").DatabaseSync;
      }
      this.#db = new DatabaseSync(opts?.location ?? ":memory:");
      this.#db.exec(`
      PRAGMA journal_mode = WAL;
      PRAGMA synchronous = NORMAL;
      PRAGMA temp_store = memory;
      PRAGMA optimize;

      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_getValuesQuery ON cacheInterceptorV${VERSION}(url, method, deleteAt);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_deleteByUrlQuery ON cacheInterceptorV${VERSION}(deleteAt);
    `);
      this.#getValuesQuery = this.#db.prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${VERSION}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `);
      this.#updateValueQuery = this.#db.prepare(`
      UPDATE cacheInterceptorV${VERSION} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `);
      this.#insertValueQuery = this.#db.prepare(`
      INSERT INTO cacheInterceptorV${VERSION} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
      this.#deleteByUrlQuery = this.#db.prepare(`DELETE FROM cacheInterceptorV${VERSION} WHERE url = ?`);
      this.#countEntriesQuery = this.#db.prepare(`SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION}`);
      this.#deleteExpiredValuesQuery = this.#db.prepare(`DELETE FROM cacheInterceptorV${VERSION} WHERE deleteAt <= ?`);
      this.#deleteOldValuesQuery = this.#maxCount === Infinity ? null : this.#db.prepare(`
        DELETE FROM cacheInterceptorV${VERSION}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${VERSION}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `);
    }
    close() {
      this.#db.close();
    }
    get(key) {
      assertCacheKey(key);
      const value = this.#findValue(key);
      return value ? {
        body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : undefined,
        statusCode: value.statusCode,
        statusMessage: value.statusMessage,
        headers: value.headers ? JSON.parse(value.headers) : undefined,
        etag: value.etag ? value.etag : undefined,
        vary: value.vary ? JSON.parse(value.vary) : undefined,
        cacheControlDirectives: value.cacheControlDirectives ? JSON.parse(value.cacheControlDirectives) : undefined,
        cachedAt: value.cachedAt,
        staleAt: value.staleAt,
        deleteAt: value.deleteAt
      } : undefined;
    }
    set(key, value) {
      assertCacheKey(key);
      const url = this.#makeValueUrl(key);
      const body = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body;
      const size = body?.byteLength;
      if (size && size > this.#maxEntrySize) {
        return;
      }
      const existingValue = this.#findValue(key, true);
      if (existingValue) {
        this.#updateValueQuery.run(body, value.deleteAt, value.statusCode, value.statusMessage, value.headers ? JSON.stringify(value.headers) : null, value.etag ? value.etag : null, value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null, value.cachedAt, value.staleAt, existingValue.id);
      } else {
        this.#prune();
        this.#insertValueQuery.run(url, key.method, body, value.deleteAt, value.statusCode, value.statusMessage, value.headers ? JSON.stringify(value.headers) : null, value.etag ? value.etag : null, value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null, value.vary ? JSON.stringify(value.vary) : null, value.cachedAt, value.staleAt);
      }
    }
    createWriteStream(key, value) {
      assertCacheKey(key);
      assertCacheValue(value);
      let size = 0;
      const body = [];
      const store = this;
      return new Writable({
        decodeStrings: true,
        write(chunk, encoding, callback) {
          size += chunk.byteLength;
          if (size < store.#maxEntrySize) {
            body.push(chunk);
          } else {
            this.destroy();
          }
          callback();
        },
        final(callback) {
          store.set(key, { ...value, body });
          callback();
        }
      });
    }
    delete(key) {
      if (typeof key !== "object") {
        throw new TypeError(`expected key to be object, got ${typeof key}`);
      }
      this.#deleteByUrlQuery.run(this.#makeValueUrl(key));
    }
    #prune() {
      if (Number.isFinite(this.#maxCount) && this.size <= this.#maxCount) {
        return 0;
      }
      {
        const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes;
        if (removed) {
          return removed;
        }
      }
      {
        const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes;
        if (removed) {
          return removed;
        }
      }
      return 0;
    }
    get size() {
      const { total } = this.#countEntriesQuery.get();
      return total;
    }
    #makeValueUrl(key) {
      return `${key.origin}/${key.path}`;
    }
    #findValue(key, canBeExpired = false) {
      const url = this.#makeValueUrl(key);
      const { headers, method } = key;
      const values = this.#getValuesQuery.all(url, method);
      if (values.length === 0) {
        return;
      }
      const now = Date.now();
      for (const value of values) {
        if (now >= value.deleteAt && !canBeExpired) {
          return;
        }
        let matches = true;
        if (value.vary) {
          const vary = JSON.parse(value.vary);
          for (const header in vary) {
            if (!headerValueEquals(headers[header], vary[header])) {
              matches = false;
              break;
            }
          }
        }
        if (matches) {
          return value;
        }
      }
      return;
    }
  };
  function headerValueEquals(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return true;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (Array.isArray(lhs) && Array.isArray(rhs)) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      return lhs.every((x, i) => x === rhs[i]);
    }
    return lhs === rhs;
  }
});

// node_modules/undici/lib/web/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols();
  var { kEnumerableProperty } = require_util();
  var {
    iteratorMixin,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2();
  var { webidl } = require_webidl();
  var assert = __require("node:assert");
  var util = __require("node:util");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
      --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
      ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers, object) {
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; ++i) {
        const header = object[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i = 0;i < keys.length; ++i) {
        appendHeader(headers, keys[i], object[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (getHeadersGuard(headers) === "immutable") {
      throw new TypeError("immutable");
    }
    return getHeadersList(headers).append(name, value, false);
  }
  function headersListSortAndCombine(target) {
    const headersList = getHeadersList(target);
    if (!headersList) {
      return [];
    }
    if (headersList.sortedMap) {
      return headersList.sortedMap;
    }
    const headers = [];
    const names = headersList.toSortedArray();
    const cookies = headersList.cookies;
    if (cookies === null || cookies.length === 1) {
      return headersList.sortedMap = names;
    }
    for (let i = 0;i < names.length; ++i) {
      const { 0: name, 1: value } = names[i];
      if (name === "set-cookie") {
        for (let j = 0;j < cookies.length; ++j) {
          headers.push([name, cookies[j]]);
        }
      } else {
        headers.push([name, value]);
      }
    }
    return headersList.sortedMap = headers;
  }
  function compareHeaderName(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }

  class HeadersList {
    cookies = null;
    sortedMap;
    headersMap;
    constructor(init) {
      if (init instanceof HeadersList) {
        this.headersMap = new Map(init.headersMap);
        this.sortedMap = init.sortedMap;
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this.headersMap = new Map(init);
        this.sortedMap = null;
      }
    }
    contains(name, isLowerCase) {
      return this.headersMap.has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this.headersMap.clear();
      this.sortedMap = null;
      this.cookies = null;
    }
    append(name, value, isLowerCase) {
      this.sortedMap = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      const exists = this.headersMap.get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this.headersMap.set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this.headersMap.set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        (this.cookies ??= []).push(value);
      }
    }
    set(name, value, isLowerCase) {
      this.sortedMap = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this.headersMap.set(lowercaseName, { name, value });
    }
    delete(name, isLowerCase) {
      this.sortedMap = null;
      if (!isLowerCase)
        name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this.headersMap.delete(name);
    }
    get(name, isLowerCase) {
      return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: name, 1: { value } } of this.headersMap) {
        yield [name, value];
      }
    }
    get entries() {
      const headers = {};
      if (this.headersMap.size !== 0) {
        for (const { name, value } of this.headersMap.values()) {
          headers[name] = value;
        }
      }
      return headers;
    }
    rawValues() {
      return this.headersMap.values();
    }
    get entriesList() {
      const headers = [];
      if (this.headersMap.size !== 0) {
        for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {
          if (lowerName === "set-cookie") {
            for (const cookie of this.cookies) {
              headers.push([name, cookie]);
            }
          } else {
            headers.push([name, value]);
          }
        }
      }
      return headers;
    }
    toSortedArray() {
      const size = this.headersMap.size;
      const array = new Array(size);
      if (size <= 32) {
        if (size === 0) {
          return array;
        }
        const iterator = this.headersMap[Symbol.iterator]();
        const firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value];
        assert(firstValue[1].value !== null);
        for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;i < size; ++i) {
          value = iterator.next().value;
          x = array[i] = [value[0], value[1].value];
          assert(x[1] !== null);
          left = 0;
          right = i;
          while (left < right) {
            pivot = left + (right - left >> 1);
            if (array[pivot][0] <= x[0]) {
              left = pivot + 1;
            } else {
              right = pivot;
            }
          }
          if (i !== pivot) {
            j = i;
            while (j > left) {
              array[j] = array[--j];
            }
            array[left] = x;
          }
        }
        if (!iterator.next().done) {
          throw new TypeError("Unreachable");
        }
        return array;
      } else {
        let i = 0;
        for (const { 0: name, 1: { value } } of this.headersMap) {
          array[i++] = [name, value];
          assert(value !== null);
        }
        return array.sort(compareHeaderName);
      }
    }
  }

  class Headers {
    #guard;
    #headersList;
    constructor(init = undefined) {
      webidl.util.markAsUncloneable(this);
      if (init === kConstruct) {
        return;
      }
      this.#headersList = new HeadersList;
      this.#guard = "none";
      if (init !== undefined) {
        init = webidl.converters.HeadersInit(init, "Headers constructor", "init");
        fill(this, init);
      }
    }
    append(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.append");
      const prefix = "Headers.append";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      return appendHeader(this, name, value);
    }
    delete(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
      const prefix = "Headers.delete";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      if (!this.#headersList.contains(name, false)) {
        return;
      }
      this.#headersList.delete(name, false);
    }
    get(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.get");
      const prefix = "Headers.get";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.get(name, false);
    }
    has(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.has");
      const prefix = "Headers.has";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.contains(name, false);
    }
    set(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.set");
      const prefix = "Headers.set";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value,
          type: "header value"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      this.#headersList.set(name, value, false);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      const list = this.#headersList.cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    [util.inspect.custom](depth, options) {
      options.depth ??= depth;
      return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;
    }
    static getHeadersGuard(o) {
      return o.#guard;
    }
    static setHeadersGuard(o, guard) {
      o.#guard = guard;
    }
    static getHeadersList(o) {
      return o.#headersList;
    }
    static setHeadersList(target, list) {
      target.#headersList = list;
    }
  }
  var { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
  Reflect.deleteProperty(Headers, "getHeadersGuard");
  Reflect.deleteProperty(Headers, "setHeadersGuard");
  Reflect.deleteProperty(Headers, "getHeadersList");
  Reflect.deleteProperty(Headers, "setHeadersList");
  iteratorMixin("Headers", Headers, headersListSortAndCombine, 0, 1);
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V, prefix, argument) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
      const iterator = Reflect.get(V, Symbol.iterator);
      if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) {
        try {
          return getHeadersList(V).entriesList;
        } catch {}
      }
      if (typeof iterator === "function") {
        return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
      }
      return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    compareHeaderName,
    Headers,
    HeadersList,
    getHeadersGuard,
    setHeadersGuard,
    setHeadersList,
    getHeadersList
  };
});

// node_modules/undici/lib/web/fetch/response.js
var require_response = __commonJS((exports, module) => {
  var { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require_headers();
  var { extractBody, cloneBody, mixinBody, streamRegistry, bodyUnusable } = require_body();
  var util = require_util();
  var nodeUtil = __require("node:util");
  var { kEnumerableProperty } = util;
  var {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isErrorLike,
    environmentSettingsObject: relevantRealm
  } = require_util2();
  var {
    redirectStatusSet,
    nullBodyStatus
  } = require_constants3();
  var { webidl } = require_webidl();
  var { URLSerializer } = require_data_url();
  var { kConstruct } = require_symbols();
  var assert = __require("node:assert");
  var { isomorphicEncode, serializeJavascriptValueToJSONString } = require_infra();
  var textEncoder = new TextEncoder("utf-8");

  class Response {
    #headers;
    #state;
    static error() {
      const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
      return responseObject;
    }
    static json(data, init = undefined) {
      webidl.argumentLengthCheck(arguments, 1, "Response.json");
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
      const body = extractBody(bytes);
      const responseObject = fromInnerResponse(makeResponse({}), "response");
      initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
      return responseObject;
    }
    static redirect(url, status = 302) {
      webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
      } catch (err) {
        throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError(`Invalid status code ${status}`);
      }
      const responseObject = fromInnerResponse(makeResponse({}), "immutable");
      responseObject.#state.status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject.#state.headersList.append("location", value, true);
      return responseObject;
    }
    constructor(body = null, init = undefined) {
      webidl.util.markAsUncloneable(this);
      if (body === kConstruct) {
        return;
      }
      if (body !== null) {
        body = webidl.converters.BodyInit(body, "Response", "body");
      }
      init = webidl.converters.ResponseInit(init);
      this.#state = makeResponse({});
      this.#headers = new Headers(kConstruct);
      setHeadersGuard(this.#headers, "response");
      setHeadersList(this.#headers, this.#state.headersList);
      let bodyWithType = null;
      if (body != null) {
        const [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      webidl.brandCheck(this, Response);
      return this.#state.type;
    }
    get url() {
      webidl.brandCheck(this, Response);
      const urlList = this.#state.urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    get redirected() {
      webidl.brandCheck(this, Response);
      return this.#state.urlList.length > 1;
    }
    get status() {
      webidl.brandCheck(this, Response);
      return this.#state.status;
    }
    get ok() {
      webidl.brandCheck(this, Response);
      return this.#state.status >= 200 && this.#state.status <= 299;
    }
    get statusText() {
      webidl.brandCheck(this, Response);
      return this.#state.statusText;
    }
    get headers() {
      webidl.brandCheck(this, Response);
      return this.#headers;
    }
    get body() {
      webidl.brandCheck(this, Response);
      return this.#state.body ? this.#state.body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response);
      return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
    }
    clone() {
      webidl.brandCheck(this, Response);
      if (bodyUnusable(this.#state)) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this.#state);
      if (this.#state.body?.stream) {
        streamRegistry.register(this, new WeakRef(this.#state.body.stream));
      }
      return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
    }
    static getResponseHeaders(response) {
      return response.#headers;
    }
    static setResponseHeaders(response, newHeaders) {
      response.#headers = newHeaders;
    }
    static getResponseState(response) {
      return response.#state;
    }
    static setResponseState(response, newState) {
      response.#state = newState;
    }
  }
  var { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response;
  Reflect.deleteProperty(Response, "getResponseHeaders");
  Reflect.deleteProperty(Response, "setResponseHeaders");
  Reflect.deleteProperty(Response, "getResponseState");
  Reflect.deleteProperty(Response, "setResponseState");
  mixinBody(Response, getResponseState);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response) {
    if (response.internalResponse) {
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    }
    const newResponse = makeResponse({ ...response, body: null });
    if (response.body != null) {
      newResponse.body = cloneBody(response.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList,
      urlList: init?.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function isNetworkError(response) {
    return response.type === "error" && response.status === 0;
  }
  function makeFilteredResponse(response, state) {
    state = {
      internalResponse: response,
      ...state
    };
    return new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response, type) {
    if (type === "basic") {
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: [],
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      getResponseState(response).status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      getResponseState(response).statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(getResponseHeaders(response), init.headers);
    }
    if (body) {
      if (nullBodyStatus.includes(response.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${response.status}`
        });
      }
      getResponseState(response).body = body.body;
      if (body.type != null && !getResponseState(response).headersList.contains("content-type", true)) {
        getResponseState(response).headersList.append("content-type", body.type, true);
      }
    }
  }
  function fromInnerResponse(innerResponse, guard) {
    const response = new Response(kConstruct);
    setResponseState(response, innerResponse);
    const headers = new Headers(kConstruct);
    setResponseHeaders(response, headers);
    setHeadersList(headers, innerResponse.headersList);
    setHeadersGuard(headers, guard);
    if (innerResponse.urlList.length !== 0 && innerResponse.body?.stream) {
      streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
    }
    return response;
  }
  webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, name);
    }
    if (webidl.is.Blob(V)) {
      return V;
    }
    if (webidl.is.BufferSource(V)) {
      return V;
    }
    if (webidl.is.FormData(V)) {
      return V;
    }
    if (webidl.is.URLSearchParams(V)) {
      return V;
    }
    return webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function(V, prefix, argument) {
    if (webidl.is.ReadableStream(V)) {
      return V;
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  webidl.is.Response = webidl.util.MakeTypeAssertion(Response);
  module.exports = {
    isNetworkError,
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse,
    fromInnerResponse,
    getResponseState
  };
});

// node_modules/undici/lib/web/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  var { extractBody, mixinBody, cloneBody, bodyUnusable } = require_body();
  var { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require_headers();
  var util = require_util();
  var nodeUtil = __require("node:util");
  var {
    isValidHTTPToken,
    sameOrigin,
    environmentSettingsObject
  } = require_util2();
  var {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants3();
  var { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
  var { webidl } = require_webidl();
  var { URLSerializer } = require_data_url();
  var { kConstruct } = require_symbols();
  var assert = __require("node:assert");
  var { getMaxListeners, setMaxListeners, defaultMaxListeners } = __require("node:events");
  var kAbortController = Symbol("abortController");
  var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });
  var dependentControllerMap = new WeakMap;
  var abortSignalHasEventHandlerLeakWarning;
  try {
    abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0;
  } catch {
    abortSignalHasEventHandlerLeakWarning = false;
  }
  function buildAbort(acRef) {
    return abort;
    function abort() {
      const ac = acRef.deref();
      if (ac !== undefined) {
        requestFinalizer.unregister(abort);
        this.removeEventListener("abort", abort);
        ac.abort(this.reason);
        const controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== undefined) {
          if (controllerList.size !== 0) {
            for (const ref of controllerList) {
              const ctrl = ref.deref();
              if (ctrl !== undefined) {
                ctrl.abort(this.reason);
              }
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  var patchMethodWarning = false;

  class Request {
    #signal;
    #dispatcher;
    #headers;
    #state;
    constructor(input, init = undefined) {
      webidl.util.markAsUncloneable(this);
      if (input === kConstruct) {
        return;
      }
      const prefix = "Request constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      input = webidl.converters.RequestInfo(input);
      init = webidl.converters.RequestInit(init);
      let request = null;
      let fallbackMode = null;
      const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        this.#dispatcher = init.dispatcher;
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        }
        request = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert(webidl.is.Request(input));
        request = input.#state;
        signal = input.#signal;
        this.#dispatcher = init.dispatcher || input.#dispatcher;
      }
      const origin = environmentSettingsObject.settingsObject.origin;
      let window = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
        window = request.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window}' must be null`);
      }
      if ("window" in init) {
        window = "no-window";
      }
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: environmentSettingsObject.settingsObject,
        window,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request.mode === "navigate") {
          request.mode = "same-origin";
        }
        request.reloadNavigation = false;
        request.historyNavigation = false;
        request.origin = "client";
        request.referrer = "client";
        request.referrerPolicy = "";
        request.url = request.urlList[request.urlList.length - 1];
        request.urlList = [request.url];
      }
      if (init.referrer !== undefined) {
        const referrer = init.referrer;
        if (referrer === "") {
          request.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
            request.referrer = "client";
          } else {
            request.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== undefined) {
        request.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== undefined) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request.mode = mode;
      }
      if (init.credentials !== undefined) {
        request.credentials = init.credentials;
      }
      if (init.cache !== undefined) {
        request.cache = init.cache;
      }
      if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
        throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      }
      if (init.redirect !== undefined) {
        request.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request.integrity = String(init.integrity);
      }
      if (init.keepalive !== undefined) {
        request.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== undefined) {
        let method = init.method;
        const mayBeNormalized = normalizedMethodRecords[method];
        if (mayBeNormalized !== undefined) {
          request.method = mayBeNormalized;
        } else {
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          const upperCase = method.toUpperCase();
          if (forbiddenMethodsSet.has(upperCase)) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizedMethodRecordsBase[upperCase] ?? method;
          request.method = method;
        }
        if (!patchMethodWarning && request.method === "patch") {
          process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          });
          patchMethodWarning = true;
        }
      }
      if (init.signal !== undefined) {
        signal = init.signal;
      }
      this.#state = request;
      const ac = new AbortController;
      this.#signal = ac.signal;
      if (signal != null) {
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = buildAbort(acRef);
          if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {
            setMaxListeners(1500, signal);
          }
          util.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort }, abort);
        }
      }
      this.#headers = new Headers(kConstruct);
      setHeadersList(this.#headers, request.headersList);
      setHeadersGuard(this.#headers, "request");
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method)) {
          throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
        }
        setHeadersGuard(this.#headers, "request-no-cors");
      }
      if (initHasKey) {
        const headersList = getHeadersList(this.#headers);
        const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers instanceof HeadersList) {
          for (const { name, value } of headers.rawValues()) {
            headersList.append(name, value, false);
          }
          headersList.cookies = headers.cookies;
        } else {
          fillHeaders(this.#headers, headers);
        }
      }
      const inputBody = webidl.is.Request(input) ? input.#state.body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        initBody = extractedBody;
        if (contentType && !getHeadersList(this.#headers).contains("content-type", true)) {
          this.#headers.append("content-type", contentType, true);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request.mode !== "same-origin" && request.mode !== "cors") {
          throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        }
        request.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (bodyUnusable(input.#state)) {
          throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
        }
        const identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this.#state.body = finalBody;
    }
    get method() {
      webidl.brandCheck(this, Request);
      return this.#state.method;
    }
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this.#state.url);
    }
    get headers() {
      webidl.brandCheck(this, Request);
      return this.#headers;
    }
    get destination() {
      webidl.brandCheck(this, Request);
      return this.#state.destination;
    }
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this.#state.referrer === "no-referrer") {
        return "";
      }
      if (this.#state.referrer === "client") {
        return "about:client";
      }
      return this.#state.referrer.toString();
    }
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this.#state.referrerPolicy;
    }
    get mode() {
      webidl.brandCheck(this, Request);
      return this.#state.mode;
    }
    get credentials() {
      webidl.brandCheck(this, Request);
      return this.#state.credentials;
    }
    get cache() {
      webidl.brandCheck(this, Request);
      return this.#state.cache;
    }
    get redirect() {
      webidl.brandCheck(this, Request);
      return this.#state.redirect;
    }
    get integrity() {
      webidl.brandCheck(this, Request);
      return this.#state.integrity;
    }
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this.#state.keepalive;
    }
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this.#state.reloadNavigation;
    }
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this.#state.historyNavigation;
    }
    get signal() {
      webidl.brandCheck(this, Request);
      return this.#signal;
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this.#state.body ? this.#state.body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    clone() {
      webidl.brandCheck(this, Request);
      if (bodyUnusable(this.#state)) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this.#state);
      const ac = new AbortController;
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        let list = dependentControllerMap.get(this.signal);
        if (list === undefined) {
          list = new Set;
          dependentControllerMap.set(this.signal, list);
        }
        const acRef = new WeakRef(ac);
        list.add(acRef);
        util.addAbortListener(ac.signal, buildAbort(acRef));
      }
      return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
    }
    static setRequestSignal(request, newSignal) {
      request.#signal = newSignal;
      return request;
    }
    static getRequestDispatcher(request) {
      return request.#dispatcher;
    }
    static setRequestDispatcher(request, newDispatcher) {
      request.#dispatcher = newDispatcher;
    }
    static setRequestHeaders(request, newHeaders) {
      request.#headers = newHeaders;
    }
    static getRequestState(request) {
      return request.#state;
    }
    static setRequestState(request, newState) {
      request.#state = newState;
    }
  }
  var { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request;
  Reflect.deleteProperty(Request, "setRequestSignal");
  Reflect.deleteProperty(Request, "getRequestDispatcher");
  Reflect.deleteProperty(Request, "setRequestDispatcher");
  Reflect.deleteProperty(Request, "setRequestHeaders");
  Reflect.deleteProperty(Request, "getRequestState");
  Reflect.deleteProperty(Request, "setRequestState");
  mixinBody(Request, getRequestState);
  function makeRequest(init) {
    return {
      method: init.method ?? "GET",
      localURLsOnly: init.localURLsOnly ?? false,
      unsafeRequest: init.unsafeRequest ?? false,
      body: init.body ?? null,
      client: init.client ?? null,
      reservedClient: init.reservedClient ?? null,
      replacesClientId: init.replacesClientId ?? "",
      window: init.window ?? "client",
      keepalive: init.keepalive ?? false,
      serviceWorkers: init.serviceWorkers ?? "all",
      initiator: init.initiator ?? "",
      destination: init.destination ?? "",
      priority: init.priority ?? null,
      origin: init.origin ?? "client",
      policyContainer: init.policyContainer ?? "client",
      referrer: init.referrer ?? "client",
      referrerPolicy: init.referrerPolicy ?? "",
      mode: init.mode ?? "no-cors",
      useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
      credentials: init.credentials ?? "same-origin",
      useCredentials: init.useCredentials ?? false,
      cache: init.cache ?? "default",
      redirect: init.redirect ?? "follow",
      integrity: init.integrity ?? "",
      cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: init.parserMetadata ?? "",
      reloadNavigation: init.reloadNavigation ?? false,
      historyNavigation: init.historyNavigation ?? false,
      userActivation: init.userActivation ?? false,
      taintedOrigin: init.taintedOrigin ?? false,
      redirectCount: init.redirectCount ?? 0,
      responseTainting: init.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
      done: init.done ?? false,
      timingAllowFailed: init.timingAllowFailed ?? false,
      useURLCredentials: init.useURLCredentials ?? undefined,
      traversableForUserPrompts: init.traversableForUserPrompts ?? "client",
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
  }
  function cloneRequest(request) {
    const newRequest = makeRequest({ ...request, body: null });
    if (request.body != null) {
      newRequest.body = cloneBody(request.body);
    }
    return newRequest;
  }
  function fromInnerRequest(innerRequest, dispatcher, signal, guard) {
    const request = new Request(kConstruct);
    setRequestState(request, innerRequest);
    setRequestDispatcher(request, dispatcher);
    setRequestSignal(request, signal);
    const headers = new Headers(kConstruct);
    setRequestHeaders(request, headers);
    setHeadersList(headers, innerRequest.headersList);
    setHeadersGuard(headers, guard);
    return request;
  }
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.is.Request = webidl.util.MakeTypeAssertion(Request);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (webidl.is.Request(V)) {
      return V;
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, "RequestInit", "signal"))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any
    },
    {
      key: "priority",
      converter: webidl.converters.DOMString,
      allowedValues: ["high", "low", "auto"],
      defaultValue: () => "auto"
    }
  ]);
  module.exports = {
    Request,
    makeRequest,
    fromInnerRequest,
    cloneRequest,
    getRequestDispatcher,
    getRequestState
  };
});

// node_modules/undici/lib/web/subresource-integrity/subresource-integrity.js
var require_subresource_integrity = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { runtimeFeatures } = require_runtime_features();
  var validSRIHashAlgorithmTokenSet = new Map([["sha256", 0], ["sha384", 1], ["sha512", 2]]);
  var crypto;
  if (runtimeFeatures.has("crypto")) {
    crypto = __require("node:crypto");
    const cryptoHashes = crypto.getHashes();
    if (cryptoHashes.length === 0) {
      validSRIHashAlgorithmTokenSet.clear();
    }
    for (const algorithm of validSRIHashAlgorithmTokenSet.keys()) {
      if (cryptoHashes.includes(algorithm) === false) {
        validSRIHashAlgorithmTokenSet.delete(algorithm);
      }
    }
  } else {
    validSRIHashAlgorithmTokenSet.clear();
  }
  var getSRIHashAlgorithmIndex = Map.prototype.get.bind(validSRIHashAlgorithmTokenSet);
  var isValidSRIHashAlgorithm = Map.prototype.has.bind(validSRIHashAlgorithmTokenSet);
  var bytesMatch = runtimeFeatures.has("crypto") === false || validSRIHashAlgorithmTokenSet.size === 0 ? () => true : (bytes, metadataList) => {
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata.length === 0) {
      return true;
    }
    const metadata = getStrongestMetadata(parsedMetadata);
    for (const item of metadata) {
      const algorithm = item.alg;
      const expectedValue = item.val;
      const actualValue = applyAlgorithmToBytes(algorithm, bytes);
      if (caseSensitiveMatch(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  };
  function getStrongestMetadata(metadataList) {
    const result2 = [];
    let strongest = null;
    for (const item of metadataList) {
      assert(isValidSRIHashAlgorithm(item.alg), "Invalid SRI hash algorithm token");
      if (result2.length === 0) {
        result2.push(item);
        strongest = item;
        continue;
      }
      const currentAlgorithm = strongest.alg;
      const currentAlgorithmIndex = getSRIHashAlgorithmIndex(currentAlgorithm);
      const newAlgorithm = item.alg;
      const newAlgorithmIndex = getSRIHashAlgorithmIndex(newAlgorithm);
      if (newAlgorithmIndex < currentAlgorithmIndex) {
        continue;
      } else if (newAlgorithmIndex > currentAlgorithmIndex) {
        strongest = item;
        result2[0] = item;
        result2.length = 1;
      } else {
        result2.push(item);
      }
    }
    return result2;
  }
  function parseMetadata(metadata) {
    const result2 = [];
    for (const item of metadata.split(" ")) {
      const expressionAndOptions = item.split("?", 1);
      const algorithmExpression = expressionAndOptions[0];
      let base64Value = "";
      const algorithmAndValue = [algorithmExpression.slice(0, 6), algorithmExpression.slice(7)];
      const algorithm = algorithmAndValue[0];
      if (!isValidSRIHashAlgorithm(algorithm)) {
        continue;
      }
      if (algorithmAndValue[1]) {
        base64Value = algorithmAndValue[1];
      }
      const metadata2 = {
        alg: algorithm,
        val: base64Value
      };
      result2.push(metadata2);
    }
    return result2;
  }
  var applyAlgorithmToBytes = (algorithm, bytes) => {
    return crypto.hash(algorithm, bytes, "base64");
  };
  function caseSensitiveMatch(actualValue, expectedValue) {
    let actualValueLength = actualValue.length;
    if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === "=") {
      actualValueLength -= 1;
    }
    if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === "=") {
      actualValueLength -= 1;
    }
    let expectedValueLength = expectedValue.length;
    if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === "=") {
      expectedValueLength -= 1;
    }
    if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === "=") {
      expectedValueLength -= 1;
    }
    if (actualValueLength !== expectedValueLength) {
      return false;
    }
    for (let i = 0;i < actualValueLength; ++i) {
      if (actualValue[i] === expectedValue[i] || actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
        continue;
      }
      return false;
    }
    return true;
  }
  module.exports = {
    applyAlgorithmToBytes,
    bytesMatch,
    caseSensitiveMatch,
    isValidSRIHashAlgorithm,
    getStrongestMetadata,
    parseMetadata
  };
});

// node_modules/undici/lib/web/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var {
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse,
    fromInnerResponse,
    getResponseState
  } = require_response();
  var { HeadersList } = require_headers();
  var { Request, cloneRequest, getRequestDispatcher, getRequestState } = require_request2();
  var zlib = __require("node:zlib");
  var {
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme,
    clampAndCoarsenConnectionTimingInfo,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType,
    hasAuthenticationEntry,
    includesCredentials,
    isTraversableNavigable
  } = require_util2();
  var assert = __require("node:assert");
  var { safelyExtractBody, extractBody } = require_body();
  var {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet
  } = require_constants3();
  var EE = __require("node:events");
  var { Readable, pipeline, finished, isErrored, isReadable } = __require("node:stream");
  var { addAbortListener, bufferToLowerCasedHeaderName } = require_util();
  var { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require_data_url();
  var { getGlobalDispatcher } = require_global2();
  var { webidl } = require_webidl();
  var { STATUS_CODES } = __require("node:http");
  var { bytesMatch } = require_subresource_integrity();
  var { createDeferredPromise } = require_promise();
  var { isomorphicEncode } = require_infra();
  var { runtimeFeatures } = require_runtime_features();
  var hasZstd = runtimeFeatures.has("zstd");
  var GET_OR_HEAD = ["GET", "HEAD"];
  var defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
  var resolveObjectURL;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    abort(error2) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error2) {
        error2 = new DOMException("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error2;
      this.connection?.destroy(error2);
      this.emit("terminated", error2);
    }
  }
  function handleFetchDone(response) {
    finalizeAndReportTiming(response, "fetch");
  }
  function fetch(input, init = undefined) {
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request = getRequestState(requestObject);
    if (requestObject.signal.aborted) {
      abortFetch(p, request, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request.serviceWorkers = "none";
    }
    let responseObject = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(requestObject.signal, () => {
      locallyAborted = true;
      assert(controller != null);
      controller.abort(requestObject.signal.reason);
      const realResponse = responseObject?.deref();
      abortFetch(p, request, realResponse, requestObject.signal.reason);
    });
    const processResponse = (response) => {
      if (locallyAborted) {
        return;
      }
      if (response.aborted) {
        abortFetch(p, request, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response.type === "error") {
        p.reject(new TypeError("fetch failed", { cause: response.error }));
        return;
      }
      responseObject = new WeakRef(fromInnerResponse(response, "immutable"));
      p.resolve(responseObject.deref());
      p = null;
    };
    controller = fetching({
      request,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: getRequestDispatcher(requestObject)
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted) {
      return;
    }
    if (!response.urlList?.length) {
      return;
    }
    const originalURL = response.urlList[0];
    let timingInfo = response.timingInfo;
    let cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response.timingInfo = timingInfo;
    markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState, "", response.status);
  }
  var markResourceTiming = performance.markResourceTiming;
  function abortFetch(p, request, responseObject, error2) {
    if (p) {
      p.reject(error2);
    }
    if (request.body?.stream != null && isReadable(request.body.stream)) {
      request.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response = getResponseState(responseObject);
    if (response.body?.stream != null && isReadable(response.body.stream)) {
      response.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher = getGlobalDispatcher()
  }) {
    assert(dispatcher);
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request.client != null) {
      taskDestination = request.client.globalObject;
      crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    }
    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currentTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request.body || request.body.stream);
    if (request.window === "client") {
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    }
    if (request.origin === "client") {
      request.origin = request.client.origin;
    }
    if (request.policyContainer === "client") {
      if (request.client != null) {
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      } else {
        request.policyContainer = makePolicyContainer();
      }
    }
    if (!request.headersList.contains("accept", true)) {
      const value = "*/*";
      request.headersList.append("accept", value, true);
    }
    if (!request.headersList.contains("accept-language", true)) {
      request.headersList.append("accept-language", "*", true);
    }
    if (request.priority === null) {}
    if (subresourceSet.has(request.destination)) {}
    mainFetch(fetchParams, false);
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive) {
    try {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
          request.responseTainting = "basic";
          response = await schemeFetch(fetchParams);
        } else if (request.mode === "same-origin") {
          response = makeNetworkError('request mode cannot be "same-origin"');
        } else if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            response = makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          } else {
            request.responseTainting = "opaque";
            response = await schemeFetch(fetchParams);
          }
        } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          response = makeNetworkError("URL scheme must be a HTTP(S) scheme");
        } else {
          request.responseTainting = "cors";
          response = await httpFetch(fetchParams);
        }
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {}
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range", true)) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    } catch (err) {
      fetchParams.controller.terminate(err);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = __require("node:buffer").resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blob = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !webidl.is.Blob(blob)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const response = makeResponse();
        const fullLength = blob.size;
        const serializedFullLength = isomorphicEncode(`${fullLength}`);
        const type = blob.type;
        if (!request.headersList.contains("range", true)) {
          const bodyWithType = extractBody(blob);
          response.statusText = "OK";
          response.body = bodyWithType[0];
          response.headersList.set("content-length", serializedFullLength, true);
          response.headersList.set("content-type", type, true);
        } else {
          response.rangeRequested = true;
          const rangeHeader = request.headersList.get("range", true);
          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
          if (rangeValue === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
          if (rangeStart === null) {
            rangeStart = fullLength - rangeEnd;
            rangeEnd = rangeStart + rangeEnd - 1;
          } else {
            if (rangeStart >= fullLength) {
              return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
            }
            if (rangeEnd === null || rangeEnd >= fullLength) {
              rangeEnd = fullLength - 1;
            }
          }
          const slicedBlob = blob.slice(rangeStart, rangeEnd + 1, type);
          const slicedBodyWithType = extractBody(slicedBlob);
          response.body = slicedBodyWithType[0];
          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
          response.status = 206;
          response.statusText = "Partial Content";
          response.headersList.set("content-length", serializedSlicedLength, true);
          response.headersList.set("content-type", type, true);
          response.headersList.set("content-range", contentRange, true);
        }
        return Promise.resolve(response);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response));
    }
  }
  function fetchFinale(fetchParams, response) {
    let timingInfo = fetchParams.timingInfo;
    const processResponseEndOfBody = () => {
      const unsafeEndTime = Date.now();
      if (fetchParams.request.destination === "document") {
        fetchParams.controller.fullTimingInfo = timingInfo;
      }
      fetchParams.controller.reportTimingSteps = () => {
        if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {
          return;
        }
        timingInfo.endTime = unsafeEndTime;
        let cacheState = response.cacheState;
        const bodyInfo = response.bodyInfo;
        if (!response.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo(timingInfo);
          cacheState = "";
        }
        let responseStatus = 0;
        if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
          responseStatus = response.status;
          const mimeType = extractMimeType(response.headersList);
          if (mimeType !== "failure") {
            bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
          }
        }
        if (fetchParams.request.initiatorType != null) {
          markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        }
      };
      const processResponseEndOfBodyTask = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
        if (fetchParams.request.initiatorType != null) {
          fetchParams.controller.reportTimingSteps();
        }
      };
      queueMicrotask(() => processResponseEndOfBodyTask());
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => {
        fetchParams.processResponse(response);
        fetchParams.processResponse = null;
      });
    }
    const internalResponse = response.type === "error" ? response : response.internalResponse ?? response;
    if (internalResponse.body == null) {
      processResponseEndOfBody();
    } else {
      finished(internalResponse.body.stream, () => {
        processResponseEndOfBody();
      });
    }
  }
  async function httpFetch(fetchParams) {
    const request = fetchParams.request;
    let response = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all") {}
    if (response === null) {
      if (request.redirect === "follow") {
        request.serviceWorkers = "none";
      }
      actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
      if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request, response) === "failure") {
        request.timingAllowFailed = true;
      }
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual") {
        fetchParams.controller.connection.destroy(undefined, false);
      }
      if (request.redirect === "error") {
        response = makeNetworkError("unexpected redirect");
      } else if (request.redirect === "manual") {
        response = actualResponse;
      } else if (request.redirect === "follow") {
        response = await httpRedirectFetch(fetchParams, response);
      } else {
        assert(false);
      }
    }
    response.timingInfo = timingInfo;
    return response;
  }
  function httpRedirectFetch(fetchParams, response) {
    const request = fetchParams.request;
    const actualResponse = response.internalResponse ? response.internalResponse : response;
    let locationURL;
    try {
      locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
      if (locationURL == null) {
        return response;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request.redirectCount += 1;
    if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    }
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET";
      request.body = null;
      for (const headerName of requestBodyHeader) {
        request.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL)) {
      request.headersList.delete("authorization", true);
      request.headersList.delete("proxy-authorization", true);
      request.headersList.delete("cookie", true);
      request.headersList.delete("host", true);
    }
    if (request.body != null) {
      assert(request.body.source != null);
      request.body = safelyExtractBody(request.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response = null;
    const httpCache = null;
    const revalidatingFlag = false;
    if (request.window === "no-window" && request.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request;
    } else {
      httpRequest = cloneRequest(request);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
    }
    if (contentLength != null && httpRequest.keepalive) {}
    if (webidl.is.URL(httpRequest.referrer)) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent", true)) {
      httpRequest.headersList.append("user-agent", defaultUserAgent, true);
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
      httpRequest.headersList.append("cache-control", "max-age=0", true);
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma", true)) {
        httpRequest.headersList.append("pragma", "no-cache", true);
      }
      if (!httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "no-cache", true);
      }
    }
    if (httpRequest.headersList.contains("range", true)) {
      httpRequest.headersList.append("accept-encoding", "identity", true);
    }
    if (!httpRequest.headersList.contains("accept-encoding", true)) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
      }
    }
    httpRequest.headersList.delete("host", true);
    if (includeCredentials) {
      if (!httpRequest.headersList.contains("authorization", true)) {
        let authorizationValue = null;
        if (hasAuthenticationEntry(httpRequest) && (httpRequest.useURLCredentials === undefined || !includesCredentials(requestCurrentURL(httpRequest)))) {} else if (includesCredentials(requestCurrentURL(httpRequest)) && isAuthenticationFetch) {
          const { username, password } = requestCurrentURL(httpRequest);
          authorizationValue = `Basic ${Buffer.from(`${username}:${password}`).toString("base64")}`;
        }
        if (authorizationValue !== null) {
          httpRequest.headersList.append("Authorization", authorizationValue, false);
        }
      }
    }
    if (httpCache == null) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") {}
    if (response == null) {
      if (httpRequest.cache === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
      if (revalidatingFlag && forwardResponse.status === 304) {}
      if (response == null) {
        response = forwardResponse;
      }
    }
    response.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range", true)) {
      response.rangeRequested = true;
    }
    response.requestIncludesCredentials = includeCredentials;
    if (response.status === 401 && httpRequest.responseTainting !== "cors" && includeCredentials && isTraversableNavigable(request.traversableForUserPrompts)) {
      if (request.body != null) {
        if (request.body.source == null) {
          return makeNetworkError("expected non-null body source");
        }
        request.body = safelyExtractBody(request.body.source)[0];
      }
      if (request.useURLCredentials === undefined || isAuthenticationFetch) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, true);
    }
    if (response.status === 407) {
      if (request.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
    }
    if (isAuthenticationFetch) {}
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err, abort = true) {
        if (!this.destroyed) {
          this.destroyed = true;
          if (abort) {
            this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      }
    };
    const request = fetchParams.request;
    let response = null;
    const timingInfo = fetchParams.timingInfo;
    const httpCache = null;
    if (httpCache == null) {
      request.cache = "no-store";
    }
    const newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket") {} else {}
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      return fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      if (!isCancelled(fetchParams)) {
        fetchParams.controller.abort(reason);
      }
    };
    const stream = new ReadableStream({
      start(controller) {
        fetchParams.controller.controller = controller;
      },
      pull: pullAlgorithm,
      cancel: cancelAlgorithm,
      type: "bytes"
    });
    response.body = { stream, source: null, length: null };
    if (!fetchParams.controller.resume) {
      fetchParams.controller.on("terminated", onAborted);
    }
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? undefined : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = undefined;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === undefined) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        const buffer = new Uint8Array(bytes);
        if (buffer.byteLength) {
          fetchParams.controller.controller.enqueue(buffer);
        }
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : undefined
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response;
    function dispatch({ body }) {
      const url = requestCurrentURL(request);
      const agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : undefined
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          const { connection } = fetchParams.controller;
          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
          if (connection.destroyed) {
            abort(new DOMException("The operation was aborted.", "AbortError"));
          } else {
            fetchParams.controller.on("terminated", abort);
            this.abort = connection.abort = abort;
          }
          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onResponseStarted() {
          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onHeaders(status, rawHeaders, resume, statusText) {
          if (status < 200) {
            return false;
          }
          const headersList = new HeadersList;
          for (let i = 0;i < rawHeaders.length; i += 2) {
            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
          }
          const location = headersList.get("location", true);
          this.body = new Readable({ read: resume });
          const willFollow = location && request.redirect === "follow" && redirectStatusSet.has(status);
          const decoders = [];
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
            const contentEncoding = headersList.get("content-encoding", true);
            const codings = contentEncoding ? contentEncoding.toLowerCase().split(",") : [];
            const maxContentEncodings = 5;
            if (codings.length > maxContentEncodings) {
              reject(new Error(`too many content-encodings in response: ${codings.length}, maximum allowed is ${maxContentEncodings}`));
              return true;
            }
            for (let i = codings.length - 1;i >= 0; --i) {
              const coding = codings[i].trim();
              if (coding === "x-gzip" || coding === "gzip") {
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "deflate") {
                decoders.push(createInflate({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress({
                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                }));
              } else if (coding === "zstd" && hasZstd) {
                decoders.push(zlib.createZstdDecompress({
                  flush: zlib.constants.ZSTD_e_continue,
                  finishFlush: zlib.constants.ZSTD_e_end
                }));
              } else {
                decoders.length = 0;
                break;
              }
            }
          }
          const onError = this.onError.bind(this);
          resolve({
            status,
            statusText,
            headersList,
            body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
              if (err) {
                this.onError(err);
              }
            }).on("error", onError) : this.body.on("error", onError)
          });
          return true;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) {
            return;
          }
          const bytes = chunk;
          timingInfo.encodedBodySize += bytes.byteLength;
          return this.body.push(bytes);
        },
        onComplete() {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          fetchParams.controller.ended = true;
          this.body.push(null);
        },
        onError(error2) {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          this.body?.destroy(error2);
          fetchParams.controller.terminate(error2);
          reject(error2);
        },
        onUpgrade(status, rawHeaders, socket) {
          if (socket.session != null && status !== 200 || socket.session == null && status !== 101) {
            return false;
          }
          const headersList = new HeadersList;
          for (let i = 0;i < rawHeaders.length; i += 2) {
            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
          }
          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList,
            socket
          });
          return true;
        }
      }));
    }
  }
  module.exports = {
    fetch,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/web/cache/util.js
var require_util3 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { URLSerializer } = require_data_url();
  var { isValidHeaderName } = require_util2();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function getFieldValues(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (isValidHeaderName(value)) {
        values.push(value);
      }
    }
    return values;
  }
  module.exports = {
    urlEquals,
    getFieldValues
  };
});

// node_modules/undici/lib/web/cache/cache.js
var require_cache3 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { kConstruct } = require_symbols();
  var { urlEquals, getFieldValues } = require_util3();
  var { kEnumerableProperty, isDisturbed } = require_util();
  var { webidl } = require_webidl();
  var { cloneResponse, fromInnerResponse, getResponseState } = require_response();
  var { Request, fromInnerRequest, getRequestState } = require_request2();
  var { fetching } = require_fetch();
  var { urlIsHttpHttpsScheme, readAllBytes } = require_util2();
  var { createDeferredPromise } = require_promise();

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.match";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      const p = this.#internalMatchAll(request, options, 1);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.matchAll";
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      return this.#internalMatchAll(request, options);
    }
    async add(request) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.add";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request);
      const requests = [request];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.addAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const responsePromises = [];
      const requestList = [];
      for (let request of requests) {
        if (request === undefined) {
          throw webidl.errors.conversionFailed({
            prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        }
        request = webidl.converters.RequestInfo(request);
        if (typeof request === "string") {
          continue;
        }
        const r = getRequestState(request);
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request of requests) {
        const r = getRequestState(new Request(request));
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response of responses) {
        const operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(undefined);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.put";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      request = webidl.converters.RequestInfo(request);
      response = webidl.converters.Response(response, prefix, "response");
      let innerRequest = null;
      if (webidl.is.Request(request)) {
        innerRequest = getRequestState(request);
      } else {
        innerRequest = getRequestState(new Request(request));
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = getResponseState(response);
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(undefined);
      }
      const operations = [];
      const operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (webidl.is.Request(request)) {
        r = getRequestState(request);
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request === "string");
        r = getRequestState(new Request(request));
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async keys(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.keys";
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request !== undefined) {
        if (webidl.is.Request(request)) {
          r = getRequestState(request);
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = getRequestState(new Request(request));
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request2 of requests) {
          const requestObject = fromInnerRequest(request2, undefined, new AbortController().signal, "immutable");
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    #batchCacheOperations(operations) {
      const cache = this.#relevantRequestResponseList;
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
    #internalMatchAll(request, options, maxResponses = Infinity) {
      let r = null;
      if (request !== undefined) {
        if (webidl.is.Request(request)) {
          r = getRequestState(request);
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = getRequestState(new Request(request));
        }
      }
      const responses = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = fromInnerResponse(cloneResponse(response), "immutable");
        responseList.push(responseObject);
        if (responseList.length >= maxResponses) {
          break;
        }
      }
      return Object.freeze(responseList);
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(webidl.is.Response, "Response");
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/web/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { Cache } = require_cache3();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { kConstruct } = require_symbols();

  class CacheStorage {
    #caches = new Map;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache = new Cache(kConstruct, cacheList);
          return await cache.match(request, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache = new Cache(kConstruct, cacheList);
          const response = await cache.match(request, options);
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.has(cacheName);
    }
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.open";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      if (this.#caches.has(cacheName)) {
        const cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      const cache = [];
      this.#caches.set(cacheName, cache);
      return new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.delete(cacheName);
    }
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/web/cookies/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var maxAttributeValueSize = 1024;
  var maxNameValuePairSize = 4096;
  module.exports = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
});

// node_modules/undici/lib/web/cookies/util.js
var require_util4 = __commonJS((exports, module) => {
  function isCTLExcludingHtab(value) {
    for (let i = 0;i < value.length; ++i) {
      const code = value.charCodeAt(i);
      if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
        return true;
      }
    }
    return false;
  }
  function validateCookieName(name) {
    for (let i = 0;i < name.length; ++i) {
      const code = name.charCodeAt(i);
      if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 60 || code === 62 || code === 64 || code === 44 || code === 59 || code === 58 || code === 92 || code === 47 || code === 91 || code === 93 || code === 63 || code === 61 || code === 123 || code === 125) {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    let len = value.length;
    let i = 0;
    if (value[0] === '"') {
      if (len === 1 || value[len - 1] !== '"') {
        throw new Error("Invalid cookie value");
      }
      --len;
      ++i;
    }
    while (i < len) {
      const code = value.charCodeAt(i++);
      if (code < 33 || code > 126 || code === 34 || code === 44 || code === 59 || code === 92) {
        throw new Error("Invalid cookie value");
      }
    }
  }
  function validateCookiePath(path) {
    for (let i = 0;i < path.length; ++i) {
      const code = path.charCodeAt(i);
      if (code < 32 || code === 127 || code === 59) {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  var IMFDays = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  var IMFMonths = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
  function toIMFDate(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  module.exports = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify
  };
});

// node_modules/undici/lib/web/cookies/parse.js
var require_parse = __commonJS((exports, module) => {
  var { collectASequenceOfCodePointsFast } = require_infra();
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
  var { isCTLExcludingHtab } = require_util4();
  var assert = __require("node:assert");
  var { unescape: qsUnescape } = __require("node:querystring");
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value: qsUnescape(value),
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/web/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var { parseSetCookie } = require_parse();
  var { stringify } = require_util4();
  var { webidl } = require_webidl();
  var { Headers } = require_headers();
  var brandChecks = webidl.brandCheckMultiple([Headers, globalThis.Headers].filter(Boolean));
  function getCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, "getCookies");
    brandChecks(headers);
    const cookie = headers.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers, name, attributes) {
    brandChecks(headers);
    const prefix = "deleteCookie";
    webidl.argumentLengthCheck(arguments, 2, prefix);
    name = webidl.converters.DOMString(name, prefix, "name");
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers, {
      name,
      value: "",
      expires: new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
    brandChecks(headers);
    const cookies = headers.getSetCookie();
    if (!cookies) {
      return [];
    }
    return cookies.map((pair) => parseSetCookie(pair));
  }
  function parseCookie(cookie) {
    cookie = webidl.converters.DOMString(cookie);
    return parseSetCookie(cookie);
  }
  function setCookie(headers, cookie) {
    webidl.argumentLengthCheck(arguments, 2, "setCookie");
    brandChecks(headers);
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers.append("set-cookie", str, true);
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: () => []
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie,
    parseCookie
  };
});

// node_modules/undici/lib/web/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { kConstruct } = require_symbols();

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      if (type === kConstruct) {
        super(arguments[1], arguments[2]);
        webidl.util.markAsUncloneable(this);
        return;
      }
      const prefix = "MessageEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
    static createFastMessageEvent(type, init) {
      const messageEvent = new MessageEvent(kConstruct, type, init);
      messageEvent.#eventInit = init;
      messageEvent.#eventInit.data ??= null;
      messageEvent.#eventInit.origin ??= "";
      messageEvent.#eventInit.lastEventId ??= "";
      messageEvent.#eventInit.source ??= null;
      messageEvent.#eventInit.ports ??= [];
      return messageEvent;
    }
  }
  var { createFastMessageEvent } = MessageEvent;
  delete MessageEvent.createFastMessageEvent;

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      const prefix = "CloseEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      const prefix = "ErrorEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      super(type, eventInitDict);
      webidl.util.markAsUncloneable(this);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(webidl.is.MessagePort, "MessagePort");
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      defaultValue: () => []
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent,
    createFastMessageEvent
  };
});

// node_modules/undici/lib/web/websocket/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  var states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  var sentCloseFrameState = {
    SENT: 1,
    RECEIVED: 2
  };
  var opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var maxUnsigned16Bit = 65535;
  var parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  var emptyBuffer = Buffer.allocUnsafe(0);
  var sendHints = {
    text: 1,
    typedArray: 2,
    arrayBuffer: 3,
    blob: 4
  };
  module.exports = {
    uid,
    sentCloseFrameState,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer,
    sendHints
  };
});

// node_modules/undici/lib/web/websocket/util.js
var require_util5 = __commonJS((exports, module) => {
  var { states, opcodes } = require_constants5();
  var { isUtf8 } = __require("node:buffer");
  var { removeHTTPWhitespace } = require_data_url();
  var { collectASequenceOfCodePointsFast } = require_infra();
  function isConnecting(readyState) {
    return readyState === states.CONNECTING;
  }
  function isEstablished(readyState) {
    return readyState === states.OPEN;
  }
  function isClosing(readyState) {
    return readyState === states.CLOSING;
  }
  function isClosed(readyState) {
    return readyState === states.CLOSED;
  }
  function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    const event = eventFactory(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(handler, type, data) {
    handler.onMessage(type, data);
  }
  function toArrayBuffer(buffer) {
    if (buffer.byteLength === buffer.buffer.byteLength) {
      return buffer.buffer;
    }
    return new Uint8Array(buffer).buffer;
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (let i = 0;i < protocol.length; ++i) {
      const code = protocol.charCodeAt(i);
      if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code === 58 || code === 59 || code === 60 || code === 61 || code === 62 || code === 63 || code === 64 || code === 91 || code === 92 || code === 93 || code === 123 || code === 125) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1000 && code < 1015) {
      return code !== 1004 && code !== 1005 && code !== 1006;
    }
    return code >= 3000 && code <= 4999;
  }
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  function parseExtensions(extensions) {
    const position = { position: 0 };
    const extensionList = new Map;
    while (position.position < extensions.length) {
      const pair = collectASequenceOfCodePointsFast(";", extensions, position);
      const [name, value = ""] = pair.split("=", 2);
      extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));
      position.position++;
    }
    return extensionList;
  }
  function isValidClientWindowBits(value) {
    for (let i = 0;i < value.length; i++) {
      const byte = value.charCodeAt(i);
      if (byte < 48 || byte > 57) {
        return false;
      }
    }
    return true;
  }
  function getURLRecord(url, baseURL) {
    let urlRecord;
    try {
      urlRecord = new URL(url, baseURL);
    } catch (e) {
      throw new DOMException(e, "SyntaxError");
    }
    if (urlRecord.protocol === "http:") {
      urlRecord.protocol = "ws:";
    } else if (urlRecord.protocol === "https:") {
      urlRecord.protocol = "wss:";
    }
    if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
      throw new DOMException("expected a ws: or wss: url", "SyntaxError");
    }
    if (urlRecord.hash.length || urlRecord.href.endsWith("#")) {
      throw new DOMException("hash", "SyntaxError");
    }
    return urlRecord;
  }
  function validateCloseCodeAndReason(code, reason) {
    if (code !== null) {
      if (code !== 1000 && (code < 3000 || code > 4999)) {
        throw new DOMException("invalid code", "InvalidAccessError");
      }
    }
    if (reason !== null) {
      const reasonBytesLength = Buffer.byteLength(reason);
      if (reasonBytesLength > 123) {
        throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, "SyntaxError");
      }
    }
  }
  var utf8Decode = (() => {
    if (typeof process.versions.icu === "string") {
      const fatalDecoder = new TextDecoder("utf-8", { fatal: true });
      return fatalDecoder.decode.bind(fatalDecoder);
    }
    return function(buffer) {
      if (isUtf8(buffer)) {
        return buffer.toString("utf-8");
      }
      throw new TypeError("Invalid utf-8 received.");
    };
  })();
  module.exports = {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isContinuationFrame,
    isTextBinaryFrame,
    isValidOpcode,
    parseExtensions,
    isValidClientWindowBits,
    toArrayBuffer,
    getURLRecord,
    validateCloseCodeAndReason
  };
});

// node_modules/undici/lib/web/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { runtimeFeatures } = require_runtime_features();
  var { maxUnsigned16Bit, opcodes } = require_constants5();
  var BUFFER_SIZE = 8 * 1024;
  var buffer = null;
  var bufIdx = BUFFER_SIZE;
  var randomFillSync = runtimeFeatures.has("crypto") ? __require("node:crypto").randomFillSync : function randomFillSync(buffer2, _offset, _size) {
    for (let i = 0;i < buffer2.length; ++i) {
      buffer2[i] = Math.random() * 255 | 0;
    }
    return buffer2;
  };
  function generateMask() {
    if (bufIdx === BUFFER_SIZE) {
      bufIdx = 0;
      randomFillSync(buffer ??= Buffer.allocUnsafeSlow(BUFFER_SIZE), 0, BUFFER_SIZE);
    }
    return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
  }

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data;
    }
    createFrame(opcode) {
      const frameData = this.frameData;
      const maskKey = generateMask();
      const bodyLength = frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
      buffer2[0] = buffer2[1] = 0;
      buffer2[0] |= 128;
      buffer2[0] = (buffer2[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer2[offset - 4] = maskKey[0];
      buffer2[offset - 3] = maskKey[1];
      buffer2[offset - 2] = maskKey[2];
      buffer2[offset - 1] = maskKey[3];
      buffer2[1] = payloadLength;
      if (payloadLength === 126) {
        buffer2.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer2[2] = buffer2[3] = 0;
        buffer2.writeUIntBE(bodyLength, 4, 6);
      }
      buffer2[1] |= 128;
      for (let i = 0;i < bodyLength; ++i) {
        buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
      }
      return buffer2;
    }
    static createFastTextFrame(buffer2) {
      const maskKey = generateMask();
      const bodyLength = buffer2.length;
      for (let i = 0;i < bodyLength; ++i) {
        buffer2[i] ^= maskKey[i & 3];
      }
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const head = Buffer.allocUnsafeSlow(offset);
      head[0] = 128 | opcodes.TEXT;
      head[1] = payloadLength | 128;
      head[offset - 4] = maskKey[0];
      head[offset - 3] = maskKey[1];
      head[offset - 2] = maskKey[2];
      head[offset - 1] = maskKey[3];
      if (payloadLength === 126) {
        head.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        head[2] = head[3] = 0;
        head.writeUIntBE(bodyLength, 4, 6);
      }
      return [head, buffer2];
    }
  }
  module.exports = {
    WebsocketFrameSend,
    generateMask
  };
});

// node_modules/undici/lib/web/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  var { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require_constants5();
  var { parseExtensions, isClosed, isClosing, isEstablished, isConnecting, validateCloseCodeAndReason } = require_util5();
  var { makeRequest } = require_request2();
  var { fetching } = require_fetch();
  var { Headers, getHeadersList } = require_headers();
  var { getDecodeSplit } = require_util2();
  var { WebsocketFrameSend } = require_frame();
  var assert = __require("node:assert");
  var { runtimeFeatures } = require_runtime_features();
  var crypto = runtimeFeatures.has("crypto") ? __require("node:crypto") : null;
  var warningEmitted = false;
  function establishWebSocketConnection(url, protocols, client, handler, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request = makeRequest({
      urlList: [requestURL],
      client,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error",
      useURLCredentials: true
    });
    if (options.headers) {
      const headersList = getHeadersList(new Headers(options.headers));
      request.headersList = headersList;
    }
    const keyValue = crypto.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue, true);
    request.headersList.append("sec-websocket-version", "13", true);
    for (const protocol of protocols) {
      request.headersList.append("sec-websocket-protocol", protocol, true);
    }
    const permessageDeflate = "permessage-deflate; client_max_window_bits";
    request.headersList.append("sec-websocket-extensions", permessageDeflate, true);
    const controller = fetching({
      request,
      useParallelQueue: true,
      dispatcher: options.dispatcher,
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          if (response.socket?.session == null) {
            failWebsocketConnection(handler, 1002, "Received network error or non-101 status code.", response.error);
            return;
          }
          if (response.status !== 200) {
            failWebsocketConnection(handler, 1002, "Received network error or non-200 status code.", response.error);
            return;
          }
        }
        if (warningEmitted === false && response.socket?.session != null) {
          process.emitWarning("WebSocket over HTTP2 is experimental, and subject to change.", "ExperimentalWarning");
          warningEmitted = true;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(handler, 1002, "Server did not respond with sent protocols.");
          return;
        }
        if (response.socket.session == null && response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.socket.session == null && response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(handler, 1002, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto.hash("sha1", keyValue + uid, "base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(handler, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        let extensions;
        if (secExtension !== null) {
          extensions = parseExtensions(secExtension);
          if (!extensions.has("permessage-deflate")) {
            failWebsocketConnection(handler, 1002, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
        }
        const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null) {
          const requestProtocols = getDecodeSplit("sec-websocket-protocol", request.headersList);
          if (!requestProtocols.includes(secProtocol)) {
            failWebsocketConnection(handler, 1002, "Protocol was not set in the opening handshake.");
            return;
          }
        }
        response.socket.on("data", handler.onSocketData);
        response.socket.on("close", handler.onSocketClose);
        response.socket.on("error", handler.onSocketError);
        handler.wasEverConnected = true;
        handler.onConnectionEstablished(response, extensions);
      }
    });
    return controller;
  }
  function closeWebSocketConnection(object, code, reason, validate = false) {
    code ??= null;
    reason ??= "";
    if (validate)
      validateCloseCodeAndReason(code, reason);
    if (isClosed(object.readyState) || isClosing(object.readyState)) {} else if (!isEstablished(object.readyState)) {
      failWebsocketConnection(object);
      object.readyState = states.CLOSING;
    } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {
      const frame = new WebsocketFrameSend;
      if (reason.length !== 0 && code === null) {
        code = 1000;
      }
      assert(code === null || Number.isInteger(code));
      if (code === null && reason.length === 0) {
        frame.frameData = emptyBuffer;
      } else if (code !== null && reason === null) {
        frame.frameData = Buffer.allocUnsafe(2);
        frame.frameData.writeUInt16BE(code, 0);
      } else if (code !== null && reason !== null) {
        frame.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason));
        frame.frameData.writeUInt16BE(code, 0);
        frame.frameData.write(reason, 2, "utf-8");
      } else {
        frame.frameData = emptyBuffer;
      }
      object.socket.write(frame.createFrame(opcodes.CLOSE));
      object.closeState.add(sentCloseFrameState.SENT);
      object.readyState = states.CLOSING;
    } else {
      object.readyState = states.CLOSING;
    }
  }
  function failWebsocketConnection(handler, code, reason, cause) {
    if (isEstablished(handler.readyState)) {
      closeWebSocketConnection(handler, code, reason, false);
    }
    handler.controller.abort();
    if (isConnecting(handler.readyState)) {
      handler.onSocketClose();
    } else if (handler.socket?.destroyed === false) {
      handler.socket.destroy();
    }
  }
  module.exports = {
    establishWebSocketConnection,
    failWebsocketConnection,
    closeWebSocketConnection
  };
});

// node_modules/undici/lib/web/websocket/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __require("node:zlib");
  var { isValidClientWindowBits } = require_util5();
  var tail = Buffer.from([0, 0, 255, 255]);
  var kBuffer = Symbol("kBuffer");
  var kLength = Symbol("kLength");

  class PerMessageDeflate {
    #inflate;
    #options = {};
    constructor(extensions) {
      this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
      this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
    }
    decompress(chunk, fin, callback) {
      if (!this.#inflate) {
        let windowBits = Z_DEFAULT_WINDOWBITS;
        if (this.#options.serverMaxWindowBits) {
          if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
            callback(new Error("Invalid server_max_window_bits"));
            return;
          }
          windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
        }
        this.#inflate = createInflateRaw({ windowBits });
        this.#inflate[kBuffer] = [];
        this.#inflate[kLength] = 0;
        this.#inflate.on("data", (data) => {
          this.#inflate[kBuffer].push(data);
          this.#inflate[kLength] += data.length;
        });
        this.#inflate.on("error", (err) => {
          this.#inflate = null;
          callback(err);
        });
      }
      this.#inflate.write(chunk);
      if (fin) {
        this.#inflate.write(tail);
      }
      this.#inflate.flush(() => {
        const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
        this.#inflate[kBuffer].length = 0;
        this.#inflate[kLength] = 0;
        callback(null, full);
      });
    }
  }
  module.exports = { PerMessageDeflate };
});

// node_modules/undici/lib/web/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("node:stream");
  var assert = __require("node:assert");
  var { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require_constants5();
  var {
    isValidStatusCode,
    isValidOpcode,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isTextBinaryFrame,
    isContinuationFrame
  } = require_util5();
  var { failWebsocketConnection } = require_connection();
  var { WebsocketFrameSend } = require_frame();
  var { PerMessageDeflate } = require_permessage_deflate();

  class ByteParser extends Writable {
    #buffers = [];
    #fragmentsBytes = 0;
    #byteOffset = 0;
    #loop = false;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    #extensions;
    #handler;
    constructor(handler, extensions) {
      super();
      this.#handler = handler;
      this.#extensions = extensions == null ? new Map : extensions;
      if (this.#extensions.has("permessage-deflate")) {
        this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
      }
    }
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.#loop = true;
      this.run(callback);
    }
    run(callback) {
      while (this.#loop) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          const fin = (buffer[0] & 128) !== 0;
          const opcode = buffer[0] & 15;
          const masked = (buffer[1] & 128) === 128;
          const fragmented = !fin && opcode !== opcodes.CONTINUATION;
          const payloadLength = buffer[1] & 127;
          const rsv1 = buffer[0] & 64;
          const rsv2 = buffer[0] & 32;
          const rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) {
            failWebsocketConnection(this.#handler, 1002, "Invalid opcode received");
            return callback();
          }
          if (masked) {
            failWebsocketConnection(this.#handler, 1002, "Frame cannot be masked");
            return callback();
          }
          if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
            failWebsocketConnection(this.#handler, 1002, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(this.#handler, 1002, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(this.#handler, 1002, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
            failWebsocketConnection(this.#handler, 1002, "Expected continuation frame");
            return;
          }
          if (this.#info.fragmented && fragmented) {
            failWebsocketConnection(this.#handler, 1002, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(this.#handler, 1002, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
            failWebsocketConnection(this.#handler, 1002, "Unexpected continuation frame");
            return;
          }
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (isTextBinaryFrame(opcode)) {
            this.#info.binaryType = opcode;
            this.#info.compressed = rsv1 !== 0;
          }
          this.#info.opcode = opcode;
          this.#info.masked = masked;
          this.#info.fin = fin;
          this.#info.fragmented = fragmented;
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.#handler, 1009, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          }
          const body = this.consume(this.#info.payloadLength);
          if (isControlFrame(this.#info.opcode)) {
            this.#loop = this.parseControlFrame(body);
            this.#state = parserStates.INFO;
          } else {
            if (!this.#info.compressed) {
              this.writeFragments(body);
              if (!this.#info.fragmented && this.#info.fin) {
                websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
              }
              this.#state = parserStates.INFO;
            } else {
              this.#extensions.get("permessage-deflate").decompress(body, this.#info.fin, (error2, data) => {
                if (error2) {
                  failWebsocketConnection(this.#handler, 1007, error2.message);
                  return;
                }
                this.writeFragments(data);
                if (!this.#info.fin) {
                  this.#state = parserStates.INFO;
                  this.#loop = true;
                  this.run(callback);
                  return;
                }
                websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                this.#loop = true;
                this.#state = parserStates.INFO;
                this.run(callback);
              });
              this.#loop = false;
              break;
            }
          }
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset) {
        throw new Error("Called consume() before buffers satiated.");
      } else if (n === 0) {
        return emptyBuffer;
      }
      this.#byteOffset -= n;
      const first = this.#buffers[0];
      if (first.length > n) {
        this.#buffers[0] = first.subarray(n, first.length);
        return first.subarray(0, n);
      } else if (first.length === n) {
        return this.#buffers.shift();
      } else {
        let offset = 0;
        const buffer = Buffer.allocUnsafeSlow(n);
        while (offset !== n) {
          const next = this.#buffers[0];
          const length = next.length;
          if (length + offset === n) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            this.#buffers[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += length;
          }
        }
        return buffer;
      }
    }
    writeFragments(fragment) {
      this.#fragmentsBytes += fragment.length;
      this.#fragments.push(fragment);
    }
    consumeFragments() {
      const fragments = this.#fragments;
      if (fragments.length === 1) {
        this.#fragmentsBytes = 0;
        return fragments.shift();
      }
      let offset = 0;
      const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes);
      for (let i = 0;i < fragments.length; ++i) {
        const buffer = fragments[i];
        output.set(buffer, offset);
        offset += buffer.length;
      }
      this.#fragments = [];
      this.#fragmentsBytes = 0;
      return output;
    }
    parseCloseBody(data) {
      assert(data.length !== 1);
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (code !== undefined && !isValidStatusCode(code)) {
        return { code: 1002, reason: "Invalid status code", error: true };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      try {
        reason = utf8Decode(reason);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: true };
      }
      return { code, reason, error: false };
    }
    parseControlFrame(body) {
      const { opcode, payloadLength } = this.#info;
      if (opcode === opcodes.CLOSE) {
        if (payloadLength === 1) {
          failWebsocketConnection(this.#handler, 1002, "Received close frame with a 1-byte body.");
          return false;
        }
        this.#info.closeInfo = this.parseCloseBody(body);
        if (this.#info.closeInfo.error) {
          const { code, reason } = this.#info.closeInfo;
          failWebsocketConnection(this.#handler, code, reason);
          return false;
        }
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          let body2 = emptyBuffer;
          if (this.#info.closeInfo.code) {
            body2 = Buffer.allocUnsafe(2);
            body2.writeUInt16BE(this.#info.closeInfo.code, 0);
          }
          const closeFrame = new WebsocketFrameSend(body2);
          this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE));
          this.#handler.closeState.add(sentCloseFrameState.SENT);
        }
        this.#handler.readyState = states.CLOSING;
        this.#handler.closeState.add(sentCloseFrameState.RECEIVED);
        return false;
      } else if (opcode === opcodes.PING) {
        if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          const frame = new WebsocketFrameSend(body);
          this.#handler.socket.write(frame.createFrame(opcodes.PONG));
          this.#handler.onPing(body);
        }
      } else if (opcode === opcodes.PONG) {
        this.#handler.onPong(body);
      }
      return true;
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/web/websocket/sender.js
var require_sender = __commonJS((exports, module) => {
  var { WebsocketFrameSend } = require_frame();
  var { opcodes, sendHints } = require_constants5();
  var FixedQueue = require_fixed_queue();

  class SendQueue {
    #queue = new FixedQueue;
    #running = false;
    #socket;
    constructor(socket) {
      this.#socket = socket;
    }
    add(item, cb, hint) {
      if (hint !== sendHints.blob) {
        if (!this.#running) {
          if (hint === sendHints.text) {
            const { 0: head, 1: body } = WebsocketFrameSend.createFastTextFrame(item);
            this.#socket.cork();
            this.#socket.write(head);
            this.#socket.write(body, cb);
            this.#socket.uncork();
          } else {
            this.#socket.write(createFrame(item, hint), cb);
          }
        } else {
          const node2 = {
            promise: null,
            callback: cb,
            frame: createFrame(item, hint)
          };
          this.#queue.push(node2);
        }
        return;
      }
      const node = {
        promise: item.arrayBuffer().then((ab) => {
          node.promise = null;
          node.frame = createFrame(ab, hint);
        }),
        callback: cb,
        frame: null
      };
      this.#queue.push(node);
      if (!this.#running) {
        this.#run();
      }
    }
    async#run() {
      this.#running = true;
      const queue = this.#queue;
      while (!queue.isEmpty()) {
        const node = queue.shift();
        if (node.promise !== null) {
          await node.promise;
        }
        this.#socket.write(node.frame, node.callback);
        node.callback = node.frame = null;
      }
      this.#running = false;
    }
  }
  function createFrame(data, hint) {
    return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY);
  }
  function toBuffer(data, hint) {
    switch (hint) {
      case sendHints.text:
      case sendHints.typedArray:
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      case sendHints.arrayBuffer:
      case sendHints.blob:
        return new Uint8Array(data);
    }
  }
  module.exports = { SendQueue };
});

// node_modules/undici/lib/web/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { isArrayBuffer } = __require("node:util/types");
  var { webidl } = require_webidl();
  var { URLSerializer } = require_data_url();
  var { environmentSettingsObject } = require_util2();
  var { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = require_constants5();
  var {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    isValidSubprotocol,
    fireEvent,
    utf8Decode,
    toArrayBuffer,
    getURLRecord
  } = require_util5();
  var { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = require_connection();
  var { ByteParser } = require_receiver();
  var { kEnumerableProperty } = require_util();
  var { getGlobalDispatcher } = require_global2();
  var { ErrorEvent, CloseEvent, createFastMessageEvent } = require_events();
  var { SendQueue } = require_sender();
  var { WebsocketFrameSend } = require_frame();
  var { channels } = require_diagnostics();

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    #sendQueue;
    #handler = {
      onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
      onMessage: (opcode, data) => this.#onMessage(opcode, data),
      onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
      onParserDrain: () => this.#onParserDrain(),
      onSocketData: (chunk) => {
        if (!this.#parser.write(chunk)) {
          this.#handler.socket.pause();
        }
      },
      onSocketError: (err) => {
        this.#handler.readyState = states.CLOSING;
        if (channels.socketError.hasSubscribers) {
          channels.socketError.publish(err);
        }
        this.#handler.socket.destroy();
      },
      onSocketClose: () => this.#onSocketClose(),
      onPing: (body) => {
        if (channels.ping.hasSubscribers) {
          channels.ping.publish({
            payload: body,
            websocket: this
          });
        }
      },
      onPong: (body) => {
        if (channels.pong.hasSubscribers) {
          channels.pong.publish({
            payload: body,
            websocket: this
          });
        }
      },
      readyState: states.CONNECTING,
      socket: null,
      closeState: new Set,
      controller: null,
      wasEverConnected: false
    };
    #url;
    #binaryType;
    #parser;
    constructor(url, protocols = []) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "WebSocket constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
      url = webidl.converters.USVString(url);
      protocols = options.protocols;
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      const urlRecord = getURLRecord(url, baseURL);
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this.#url = new URL(urlRecord.href);
      const client = environmentSettingsObject.settingsObject;
      this.#handler.controller = establishWebSocketConnection(urlRecord, protocols, client, this.#handler, options);
      this.#handler.readyState = WebSocket.CONNECTING;
      this.#binaryType = "blob";
    }
    close(code = undefined, reason = undefined) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.close";
      if (code !== undefined) {
        code = webidl.converters["unsigned short"](code, prefix, "code", webidl.attributes.Clamp);
      }
      if (reason !== undefined) {
        reason = webidl.converters.USVString(reason);
      }
      code ??= null;
      reason ??= "";
      closeWebSocketConnection(this.#handler, code, reason, true);
    }
    send(data) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.send";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      data = webidl.converters.WebSocketSendData(data, prefix, "data");
      if (isConnecting(this.#handler.readyState)) {
        throw new DOMException("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {
        return;
      }
      if (typeof data === "string") {
        const buffer = Buffer.from(data);
        this.#bufferedAmount += buffer.byteLength;
        this.#sendQueue.add(buffer, () => {
          this.#bufferedAmount -= buffer.byteLength;
        }, sendHints.text);
      } else if (isArrayBuffer(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.arrayBuffer);
      } else if (ArrayBuffer.isView(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.typedArray);
      } else if (webidl.is.Blob(data)) {
        this.#bufferedAmount += data.size;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.size;
        }, sendHints.blob);
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this.#handler.readyState;
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this.#url);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("open", listener);
        this.#events.open = fn;
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("error", listener);
        this.#events.error = fn;
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("close", listener);
        this.#events.close = fn;
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("message", listener);
        this.#events.message = fn;
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this.#binaryType;
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this.#binaryType = "blob";
      } else {
        this.#binaryType = type;
      }
    }
    #onConnectionEstablished(response, parsedExtensions) {
      this.#handler.socket = response.socket;
      const parser = new ByteParser(this.#handler, parsedExtensions);
      parser.on("drain", () => this.#handler.onParserDrain());
      parser.on("error", (err) => this.#handler.onParserError(err));
      this.#parser = parser;
      this.#sendQueue = new SendQueue(response.socket);
      this.#handler.readyState = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
      if (channels.open.hasSubscribers) {
        const headers = response.headersList.entries;
        channels.open.publish({
          address: response.socket.address(),
          protocol: this.#protocol,
          extensions: this.#extensions,
          websocket: this,
          handshakeResponse: {
            status: response.status,
            statusText: response.statusText,
            headers
          }
        });
      }
    }
    #onMessage(type, data) {
      if (this.#handler.readyState !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = utf8Decode(data);
        } catch {
          failWebsocketConnection(this.#handler, 1007, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (this.#binaryType === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = toArrayBuffer(data);
        }
      }
      fireEvent("message", this, createFastMessageEvent, {
        origin: this.#url.origin,
        data: dataForEvent
      });
    }
    #onParserDrain() {
      this.#handler.socket.resume();
    }
    #onSocketClose() {
      const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
      let code = 1005;
      let reason = "";
      const result2 = this.#parser?.closingInfo;
      if (result2 && !result2.error) {
        code = result2.code ?? 1005;
        reason = result2.reason;
      }
      this.#handler.readyState = states.CLOSED;
      if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
        code = 1006;
        fireEvent("error", this, (type, init) => new ErrorEvent(type, init), {
          error: new TypeError(reason)
        });
      }
      fireEvent("close", this, (type, init) => new CloseEvent(type, init), {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: this,
          code,
          reason
        });
      }
    }
    static ping(ws, buffer) {
      if (Buffer.isBuffer(buffer)) {
        if (buffer.length > 125) {
          throw new TypeError("A PING frame cannot have a body larger than 125 bytes.");
        }
      } else if (buffer !== undefined) {
        throw new TypeError("Expected buffer payload");
      }
      const readyState = ws.#handler.readyState;
      if (isEstablished(readyState) && !isClosing(readyState) && !isClosed(readyState)) {
        const frame = new WebsocketFrameSend(buffer);
        ws.#handler.socket.write(frame.createFrame(opcodes.PING));
      }
    }
  }
  var { ping } = WebSocket;
  Reflect.deleteProperty(WebSocket, "ping");
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => []
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any,
      defaultValue: () => getGlobalDispatcher()
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
      if (webidl.is.Blob(V)) {
        return V;
      }
      if (webidl.is.BufferSource(V)) {
        return V;
      }
    }
    return webidl.converters.USVString(V);
  };
  module.exports = {
    WebSocket,
    ping
  };
});

// node_modules/undici/lib/web/websocket/stream/websocketerror.js
var require_websocketerror = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { validateCloseCodeAndReason } = require_util5();
  var { kConstruct } = require_symbols();
  var { kEnumerableProperty } = require_util();
  function createInheritableDOMException() {

    class Test extends DOMException {
      get reason() {
        return "";
      }
    }
    if (new Test().reason !== undefined) {
      return DOMException;
    }
    return new Proxy(DOMException, {
      construct(target, args, newTarget) {
        const instance = Reflect.construct(target, args, target);
        Object.setPrototypeOf(instance, newTarget.prototype);
        return instance;
      }
    });
  }

  class WebSocketError extends createInheritableDOMException() {
    #closeCode;
    #reason;
    constructor(message = "", init = undefined) {
      message = webidl.converters.DOMString(message, "WebSocketError", "message");
      super(message, "WebSocketError");
      if (init === kConstruct) {
        return;
      } else if (init !== null) {
        init = webidl.converters.WebSocketCloseInfo(init);
      }
      let code = init.closeCode ?? null;
      const reason = init.reason ?? "";
      validateCloseCodeAndReason(code, reason);
      if (reason.length !== 0 && code === null) {
        code = 1000;
      }
      this.#closeCode = code;
      this.#reason = reason;
    }
    get closeCode() {
      return this.#closeCode;
    }
    get reason() {
      return this.#reason;
    }
    static createUnvalidatedWebSocketError(message, code, reason) {
      const error2 = new WebSocketError(message, kConstruct);
      error2.#closeCode = code;
      error2.#reason = reason;
      return error2;
    }
  }
  var { createUnvalidatedWebSocketError } = WebSocketError;
  delete WebSocketError.createUnvalidatedWebSocketError;
  Object.defineProperties(WebSocketError.prototype, {
    closeCode: kEnumerableProperty,
    reason: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocketError",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  webidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError);
  module.exports = { WebSocketError, createUnvalidatedWebSocketError };
});

// node_modules/undici/lib/web/websocket/stream/websocketstream.js
var require_websocketstream = __commonJS((exports, module) => {
  var { createDeferredPromise } = require_promise();
  var { environmentSettingsObject } = require_util2();
  var { states, opcodes, sentCloseFrameState } = require_constants5();
  var { webidl } = require_webidl();
  var { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = require_util5();
  var { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = require_connection();
  var { channels } = require_diagnostics();
  var { WebsocketFrameSend } = require_frame();
  var { ByteParser } = require_receiver();
  var { WebSocketError, createUnvalidatedWebSocketError } = require_websocketerror();
  var { kEnumerableProperty } = require_util();
  var { utf8DecodeBytes } = require_encoding();
  var emittedExperimentalWarning = false;

  class WebSocketStream {
    #url;
    #openedPromise;
    #closedPromise;
    #readableStream;
    #readableStreamController;
    #writableStream;
    #handshakeAborted = false;
    #handler = {
      onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
      onMessage: (opcode, data) => this.#onMessage(opcode, data),
      onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
      onParserDrain: () => this.#handler.socket.resume(),
      onSocketData: (chunk) => {
        if (!this.#parser.write(chunk)) {
          this.#handler.socket.pause();
        }
      },
      onSocketError: (err) => {
        this.#handler.readyState = states.CLOSING;
        if (channels.socketError.hasSubscribers) {
          channels.socketError.publish(err);
        }
        this.#handler.socket.destroy();
      },
      onSocketClose: () => this.#onSocketClose(),
      onPing: () => {},
      onPong: () => {},
      readyState: states.CONNECTING,
      socket: null,
      closeState: new Set,
      controller: null,
      wasEverConnected: false
    };
    #parser;
    constructor(url, options = undefined) {
      if (!emittedExperimentalWarning) {
        process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", {
          code: "UNDICI-WSS"
        });
        emittedExperimentalWarning = true;
      }
      webidl.argumentLengthCheck(arguments, 1, "WebSocket");
      url = webidl.converters.USVString(url);
      if (options !== null) {
        options = webidl.converters.WebSocketStreamOptions(options);
      }
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      const urlRecord = getURLRecord(url, baseURL);
      const protocols = options.protocols;
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this.#url = urlRecord.toString();
      this.#openedPromise = createDeferredPromise();
      this.#closedPromise = createDeferredPromise();
      if (options.signal != null) {
        const signal = options.signal;
        if (signal.aborted) {
          this.#openedPromise.reject(signal.reason);
          this.#closedPromise.reject(signal.reason);
          return;
        }
        signal.addEventListener("abort", () => {
          if (!isEstablished(this.#handler.readyState)) {
            failWebsocketConnection(this.#handler);
            this.#handler.readyState = states.CLOSING;
            this.#openedPromise.reject(signal.reason);
            this.#closedPromise.reject(signal.reason);
            this.#handshakeAborted = true;
          }
        }, { once: true });
      }
      const client = environmentSettingsObject.settingsObject;
      this.#handler.controller = establishWebSocketConnection(urlRecord, protocols, client, this.#handler, options);
    }
    get url() {
      return this.#url.toString();
    }
    get opened() {
      return this.#openedPromise.promise;
    }
    get closed() {
      return this.#closedPromise.promise;
    }
    close(closeInfo = undefined) {
      if (closeInfo !== null) {
        closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo);
      }
      const code = closeInfo.closeCode ?? null;
      const reason = closeInfo.reason;
      closeWebSocketConnection(this.#handler, code, reason, true);
    }
    #write(chunk) {
      chunk = webidl.converters.WebSocketStreamWrite(chunk);
      const promise = createDeferredPromise();
      let data = null;
      let opcode = null;
      if (webidl.is.BufferSource(chunk)) {
        data = new Uint8Array(ArrayBuffer.isView(chunk) ? new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength) : chunk.slice());
        opcode = opcodes.BINARY;
      } else {
        let string;
        try {
          string = webidl.converters.DOMString(chunk);
        } catch (e) {
          promise.reject(e);
          return promise.promise;
        }
        data = new TextEncoder().encode(string);
        opcode = opcodes.TEXT;
      }
      if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
        const frame = new WebsocketFrameSend(data);
        this.#handler.socket.write(frame.createFrame(opcode), () => {
          promise.resolve(undefined);
        });
      }
      return promise.promise;
    }
    #onConnectionEstablished(response, parsedExtensions) {
      this.#handler.socket = response.socket;
      const parser = new ByteParser(this.#handler, parsedExtensions);
      parser.on("drain", () => this.#handler.onParserDrain());
      parser.on("error", (err) => this.#handler.onParserError(err));
      this.#parser = parser;
      this.#handler.readyState = states.OPEN;
      const extensions = parsedExtensions ?? "";
      const protocol = response.headersList.get("sec-websocket-protocol") ?? "";
      const readable = new ReadableStream({
        start: (controller) => {
          this.#readableStreamController = controller;
        },
        pull(controller) {
          let chunk;
          while (controller.desiredSize > 0 && (chunk = response.socket.read()) !== null) {
            controller.enqueue(chunk);
          }
        },
        cancel: (reason) => this.#cancel(reason)
      });
      const writable = new WritableStream({
        write: (chunk) => this.#write(chunk),
        close: () => closeWebSocketConnection(this.#handler, null, null),
        abort: (reason) => this.#closeUsingReason(reason)
      });
      this.#readableStream = readable;
      this.#writableStream = writable;
      this.#openedPromise.resolve({
        extensions,
        protocol,
        readable,
        writable
      });
    }
    #onMessage(type, data) {
      if (this.#handler.readyState !== states.OPEN) {
        return;
      }
      let chunk;
      if (type === opcodes.TEXT) {
        try {
          chunk = utf8Decode(data);
        } catch {
          failWebsocketConnection(this.#handler, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        chunk = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      }
      this.#readableStreamController.enqueue(chunk);
    }
    #onSocketClose() {
      const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
      this.#handler.readyState = states.CLOSED;
      if (this.#handshakeAborted) {
        return;
      }
      if (!this.#handler.wasEverConnected) {
        this.#openedPromise.reject(new WebSocketError("Socket never opened"));
      }
      const result2 = this.#parser.closingInfo;
      let code = result2?.code ?? 1005;
      if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
        code = 1006;
      }
      const reason = result2?.reason == null ? "" : utf8DecodeBytes(Buffer.from(result2.reason));
      if (wasClean) {
        this.#readableStreamController.close();
        if (!this.#writableStream.locked) {
          this.#writableStream.abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError"));
        }
        this.#closedPromise.resolve({
          closeCode: code,
          reason
        });
      } else {
        const error2 = createUnvalidatedWebSocketError("unclean close", code, reason);
        this.#readableStreamController.error(error2);
        this.#writableStream.abort(error2);
        this.#closedPromise.reject(error2);
      }
    }
    #closeUsingReason(reason) {
      let code = null;
      let reasonString = "";
      if (webidl.is.WebSocketError(reason)) {
        code = reason.closeCode;
        reasonString = reason.reason;
      }
      closeWebSocketConnection(this.#handler, code, reasonString);
    }
    #cancel(reason) {
      this.#closeUsingReason(reason);
    }
  }
  Object.defineProperties(WebSocketStream.prototype, {
    url: kEnumerableProperty,
    opened: kEnumerableProperty,
    closed: kEnumerableProperty,
    close: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocketStream",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  webidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.sequenceConverter(webidl.converters.USVString),
      defaultValue: () => []
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(webidl.converters.AbortSignal),
      defaultValue: () => null
    }
  ]);
  webidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([
    {
      key: "closeCode",
      converter: (V) => webidl.converters["unsigned short"](V, webidl.attributes.EnforceRange)
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.WebSocketStreamWrite = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    return webidl.converters.BufferSource(V);
  };
  module.exports = { WebSocketStream };
});

// node_modules/undici/lib/web/eventsource/util.js
var require_util6 = __commonJS((exports, module) => {
  function isValidLastEventId(value) {
    return value.indexOf("\x00") === -1;
  }
  function isASCIINumber(value) {
    if (value.length === 0)
      return false;
    for (let i = 0;i < value.length; i++) {
      if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57)
        return false;
    }
    return true;
  }
  module.exports = {
    isValidLastEventId,
    isASCIINumber
  };
});

// node_modules/undici/lib/web/eventsource/eventsource-stream.js
var require_eventsource_stream = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var { isASCIINumber, isValidLastEventId } = require_util6();
  var BOM = [239, 187, 191];
  var LF = 10;
  var CR = 13;
  var COLON = 58;
  var SPACE = 32;

  class EventSourceStream extends Transform {
    state;
    checkBOM = true;
    crlfCheck = false;
    eventEndCheck = false;
    buffer = null;
    pos = 0;
    event = {
      data: undefined,
      event: undefined,
      id: undefined,
      retry: undefined
    };
    constructor(options = {}) {
      options.readableObjectMode = true;
      super(options);
      this.state = options.eventSourceSettings || {};
      if (options.push) {
        this.push = options.push;
      }
    }
    _transform(chunk, _encoding, callback) {
      if (chunk.length === 0) {
        callback();
        return;
      }
      if (this.buffer) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
      } else {
        this.buffer = chunk;
      }
      if (this.checkBOM) {
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = false;
            callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0);
              this.checkBOM = false;
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          default:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = this.buffer.subarray(3);
            }
            this.checkBOM = false;
            break;
        }
      }
      while (this.pos < this.buffer.length) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === LF) {
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              this.crlfCheck = false;
              continue;
            }
            this.crlfCheck = false;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            if (this.event.data !== undefined || this.event.event || this.event.id !== undefined || this.event.retry) {
              this.processEvent(this.event);
            }
            this.clearEvent();
            continue;
          }
          this.eventEndCheck = false;
          continue;
        }
        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true;
          }
          this.parseLine(this.buffer.subarray(0, this.pos), this.event);
          this.buffer = this.buffer.subarray(this.pos + 1);
          this.pos = 0;
          this.eventEndCheck = true;
          continue;
        }
        this.pos++;
      }
      callback();
    }
    parseLine(line, event) {
      if (line.length === 0) {
        return;
      }
      const colonPosition = line.indexOf(COLON);
      if (colonPosition === 0) {
        return;
      }
      let field = "";
      let value = "";
      if (colonPosition !== -1) {
        field = line.subarray(0, colonPosition).toString("utf8");
        let valueStart = colonPosition + 1;
        if (line[valueStart] === SPACE) {
          ++valueStart;
        }
        value = line.subarray(valueStart).toString("utf8");
      } else {
        field = line.toString("utf8");
        value = "";
      }
      switch (field) {
        case "data":
          if (event[field] === undefined) {
            event[field] = value;
          } else {
            event[field] += `
${value}`;
          }
          break;
        case "retry":
          if (isASCIINumber(value)) {
            event[field] = value;
          }
          break;
        case "id":
          if (isValidLastEventId(value)) {
            event[field] = value;
          }
          break;
        case "event":
          if (value.length > 0) {
            event[field] = value;
          }
          break;
      }
    }
    processEvent(event) {
      if (event.retry && isASCIINumber(event.retry)) {
        this.state.reconnectionTime = parseInt(event.retry, 10);
      }
      if (event.id !== undefined && isValidLastEventId(event.id)) {
        this.state.lastEventId = event.id;
      }
      if (event.data !== undefined) {
        this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
    }
    clearEvent() {
      this.event = {
        data: undefined,
        event: undefined,
        id: undefined,
        retry: undefined
      };
    }
  }
  module.exports = {
    EventSourceStream
  };
});

// node_modules/undici/lib/web/eventsource/eventsource.js
var require_eventsource = __commonJS((exports, module) => {
  var { pipeline } = __require("node:stream");
  var { fetching } = require_fetch();
  var { makeRequest } = require_request2();
  var { webidl } = require_webidl();
  var { EventSourceStream } = require_eventsource_stream();
  var { parseMIMEType } = require_data_url();
  var { createFastMessageEvent } = require_events();
  var { isNetworkError } = require_response();
  var { kEnumerableProperty } = require_util();
  var { environmentSettingsObject } = require_util2();
  var experimentalWarned = false;
  var defaultReconnectionTime = 3000;
  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSED = 2;
  var ANONYMOUS = "anonymous";
  var USE_CREDENTIALS = "use-credentials";

  class EventSource extends EventTarget {
    #events = {
      open: null,
      error: null,
      message: null
    };
    #url;
    #withCredentials = false;
    #readyState = CONNECTING;
    #request = null;
    #controller = null;
    #dispatcher;
    #state;
    constructor(url, eventSourceInitDict = {}) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "EventSource constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        });
      }
      url = webidl.converters.USVString(url);
      eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
      this.#dispatcher = eventSourceInitDict.node.dispatcher || eventSourceInitDict.dispatcher;
      this.#state = {
        lastEventId: "",
        reconnectionTime: eventSourceInitDict.node.reconnectionTime
      };
      const settings = environmentSettingsObject;
      let urlRecord;
      try {
        urlRecord = new URL(url, settings.settingsObject.baseUrl);
        this.#state.origin = urlRecord.origin;
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      this.#url = urlRecord.href;
      let corsAttributeState = ANONYMOUS;
      if (eventSourceInitDict.withCredentials === true) {
        corsAttributeState = USE_CREDENTIALS;
        this.#withCredentials = true;
      }
      const initRequest = {
        redirect: "follow",
        keepalive: true,
        mode: "cors",
        credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      initRequest.client = environmentSettingsObject.settingsObject;
      initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
      initRequest.cache = "no-store";
      initRequest.initiator = "other";
      initRequest.urlList = [new URL(this.#url)];
      this.#request = makeRequest(initRequest);
      this.#connect();
    }
    get readyState() {
      return this.#readyState;
    }
    get url() {
      return this.#url;
    }
    get withCredentials() {
      return this.#withCredentials;
    }
    #connect() {
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CONNECTING;
      const fetchParams = {
        request: this.#request,
        dispatcher: this.#dispatcher
      };
      const processEventSourceEndOfBody = (response) => {
        if (!isNetworkError(response)) {
          return this.#reconnect();
        }
      };
      fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
      fetchParams.processResponse = (response) => {
        if (isNetworkError(response)) {
          if (response.aborted) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          } else {
            this.#reconnect();
            return;
          }
        }
        const contentType = response.headersList.get("content-type", true);
        const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
        const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
        if (response.status !== 200 || contentTypeValid === false) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        }
        this.#readyState = OPEN;
        this.dispatchEvent(new Event("open"));
        this.#state.origin = response.urlList[response.urlList.length - 1].origin;
        const eventSourceStream = new EventSourceStream({
          eventSourceSettings: this.#state,
          push: (event) => {
            this.dispatchEvent(createFastMessageEvent(event.type, event.options));
          }
        });
        pipeline(response.body.stream, eventSourceStream, (error2) => {
          if (error2?.aborted === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
          }
        });
      };
      this.#controller = fetching(fetchParams);
    }
    #reconnect() {
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CONNECTING;
      this.dispatchEvent(new Event("error"));
      setTimeout(() => {
        if (this.#readyState !== CONNECTING)
          return;
        if (this.#state.lastEventId.length) {
          this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
        }
        this.#connect();
      }, this.#state.reconnectionTime)?.unref();
    }
    close() {
      webidl.brandCheck(this, EventSource);
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CLOSED;
      this.#controller.abort();
      this.#request = null;
    }
    get onopen() {
      return this.#events.open;
    }
    set onopen(fn) {
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("open", listener);
        this.#events.open = fn;
      } else {
        this.#events.open = null;
      }
    }
    get onmessage() {
      return this.#events.message;
    }
    set onmessage(fn) {
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("message", listener);
        this.#events.message = fn;
      } else {
        this.#events.message = null;
      }
    }
    get onerror() {
      return this.#events.error;
    }
    set onerror(fn) {
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("error", listener);
        this.#events.error = fn;
      } else {
        this.#events.error = null;
      }
    }
  }
  var constantsPropertyDescriptors = {
    CONNECTING: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CONNECTING,
      writable: false
    },
    OPEN: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: OPEN,
      writable: false
    },
    CLOSED: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CLOSED,
      writable: false
    }
  };
  Object.defineProperties(EventSource, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, {
    close: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    onopen: kEnumerableProperty,
    readyState: kEnumerableProperty,
    url: kEnumerableProperty,
    withCredentials: kEnumerableProperty
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
    {
      key: "withCredentials",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any
    },
    {
      key: "node",
      converter: webidl.dictionaryConverter([
        {
          key: "reconnectionTime",
          converter: webidl.converters["unsigned long"],
          defaultValue: () => defaultReconnectionTime
        },
        {
          key: "dispatcher",
          converter: webidl.converters.any
        }
      ]),
      defaultValue: () => ({})
    }
  ]);
  module.exports = {
    EventSource,
    defaultReconnectionTime
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  var Client = require_client();
  var Dispatcher = require_dispatcher();
  var Pool = require_pool();
  var BalancedPool = require_balanced_pool();
  var RoundRobinPool = require_round_robin_pool();
  var Agent = require_agent();
  var ProxyAgent = require_proxy_agent();
  var EnvHttpProxyAgent = require_env_http_proxy_agent();
  var RetryAgent = require_retry_agent();
  var H2CClient = require_h2c_client();
  var errors = require_errors();
  var util = require_util();
  var { InvalidArgumentError } = errors;
  var api = require_api();
  var buildConnector = require_connect();
  var MockClient = require_mock_client();
  var { MockCallHistory, MockCallHistoryLog } = require_mock_call_history();
  var MockAgent = require_mock_agent();
  var MockPool = require_mock_pool();
  var SnapshotAgent = require_snapshot_agent();
  var mockErrors = require_mock_errors();
  var RetryHandler = require_retry_handler();
  var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
  var DecoratorHandler = require_decorator_handler();
  var RedirectHandler = require_redirect_handler();
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.RoundRobinPool = RoundRobinPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
  exports.RetryAgent = RetryAgent;
  exports.H2CClient = H2CClient;
  exports.RetryHandler = RetryHandler;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.interceptors = {
    redirect: require_redirect(),
    responseError: require_response_error(),
    retry: require_retry(),
    dump: require_dump(),
    dns: require_dns(),
    cache: require_cache2(),
    decompress: require_decompress(),
    deduplicate: require_deduplicate()
  };
  exports.cacheStores = {
    MemoryCacheStore: require_memory_cache_store()
  };
  var SqliteCacheStore = require_sqlite_cache_store();
  exports.cacheStores.SqliteCacheStore = SqliteCacheStore;
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  exports.util = {
    parseHeaders: util.parseHeaders,
    headerNameToString: util.headerNameToString
  };
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path = opts.path;
        if (!opts.path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util.parseURL(url);
      }
      const { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  var fetchImpl = require_fetch().fetch;
  exports.fetch = function fetch(init, options = undefined) {
    return fetchImpl(init, options).catch((err) => {
      if (err && typeof err === "object") {
        Error.captureStackTrace(err);
      }
      throw err;
    });
  };
  exports.Headers = require_headers().Headers;
  exports.Response = require_response().Response;
  exports.Request = require_request2().Request;
  exports.FormData = require_formdata().FormData;
  var { setGlobalOrigin, getGlobalOrigin } = require_global();
  exports.setGlobalOrigin = setGlobalOrigin;
  exports.getGlobalOrigin = getGlobalOrigin;
  var { CacheStorage } = require_cachestorage();
  var { kConstruct } = require_symbols();
  exports.caches = new CacheStorage(kConstruct);
  var { deleteCookie, getCookies, getSetCookies, setCookie, parseCookie } = require_cookies();
  exports.deleteCookie = deleteCookie;
  exports.getCookies = getCookies;
  exports.getSetCookies = getSetCookies;
  exports.setCookie = setCookie;
  exports.parseCookie = parseCookie;
  var { parseMIMEType, serializeAMimeType } = require_data_url();
  exports.parseMIMEType = parseMIMEType;
  exports.serializeAMimeType = serializeAMimeType;
  var { CloseEvent, ErrorEvent, MessageEvent } = require_events();
  var { WebSocket, ping } = require_websocket();
  exports.WebSocket = WebSocket;
  exports.CloseEvent = CloseEvent;
  exports.ErrorEvent = ErrorEvent;
  exports.MessageEvent = MessageEvent;
  exports.ping = ping;
  exports.WebSocketStream = require_websocketstream().WebSocketStream;
  exports.WebSocketError = require_websocketerror().WebSocketError;
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockCallHistory = MockCallHistory;
  exports.MockCallHistoryLog = MockCallHistoryLog;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.SnapshotAgent = SnapshotAgent;
  exports.mockErrors = mockErrors;
  var { EventSource } = require_eventsource();
  exports.EventSource = EventSource;
  function install() {
    globalThis.fetch = exports.fetch;
    globalThis.Headers = exports.Headers;
    globalThis.Response = exports.Response;
    globalThis.Request = exports.Request;
    globalThis.FormData = exports.FormData;
    globalThis.WebSocket = exports.WebSocket;
    globalThis.CloseEvent = exports.CloseEvent;
    globalThis.ErrorEvent = exports.ErrorEvent;
    globalThis.MessageEvent = exports.MessageEvent;
    globalThis.EventSource = exports.EventSource;
  }
  exports.install = install;
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpClient = exports.HttpClientResponse = exports.HttpClientError = exports.MediaTypes = exports.Headers = exports.HttpCodes = undefined;
  exports.getProxyUrl = getProxyUrl;
  exports.isHttps = isHttps;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var pm = __importStar(require_proxy());
  var tunnel = __importStar(require_tunnel());
  var undici_1 = require_undici();
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  var HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  var ExponentialBackoffCeiling = 10;
  var ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          });
          this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          const chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          });
          this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = this._getUserAgentWithOrchestrationId(userAgent);
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    getJson(requestUrl_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        const res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, undefined, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        const parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response;
        do {
          response = yield this.requestRaw(info, data);
          if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (const handler of this.handlers) {
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info, data);
            } else {
              return response;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            const parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (const header in headers) {
                if (header.toLowerCase() === "authorization") {
                  delete headers[header];
                }
              }
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers);
            response = yield this.requestRaw(info, data);
            redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
            return response;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    requestRaw(info, data) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err) {
              reject(err);
            } else if (!res) {
              reject(new Error("Unknown error"));
            } else {
              resolve(res);
            }
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers) {
          info.options.headers = {};
        }
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      function handleResult(err, res) {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      }
      const req = info.httpModule.request(info.options, (msg) => {
        const res = new HttpClientResponse(msg);
        handleResult(undefined, res);
      });
      let socket;
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 60000, () => {
        if (socket) {
          socket.end();
        }
        handleResult(new Error(`Request timeout: ${info.options.path}`));
      });
      req.on("error", function(err) {
        handleResult(err);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    getAgent(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (!useProxy) {
        return;
      }
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      const info = {};
      info.parsedUrl = requestUrl;
      const usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info.options = {};
      info.options.host = info.parsedUrl.hostname;
      info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
      info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
      info.options.method = method;
      info.options.headers = this._mergeHeaders(headers);
      if (this.userAgent != null) {
        info.options.headers["user-agent"] = this.userAgent;
      }
      info.options.agent = this._getAgent(info.parsedUrl);
      if (this.handlers) {
        for (const handler of this.handlers) {
          handler.prepareRequest(info.options);
        }
      }
      return info;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      }
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        const headerValue = lowercaseKeys(this.requestOptions.headers)[header];
        if (headerValue) {
          clientHeader = typeof headerValue === "number" ? headerValue.toString() : headerValue;
        }
      }
      const additionalValue = additionalHeaders[header];
      if (additionalValue !== undefined) {
        return typeof additionalValue === "number" ? additionalValue.toString() : additionalValue;
      }
      if (clientHeader !== undefined) {
        return clientHeader;
      }
      return _default;
    }
    _getExistingOrDefaultContentTypeHeader(additionalHeaders, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        const headerValue = lowercaseKeys(this.requestOptions.headers)[Headers.ContentType];
        if (headerValue) {
          if (typeof headerValue === "number") {
            clientHeader = String(headerValue);
          } else if (Array.isArray(headerValue)) {
            clientHeader = headerValue.join(", ");
          } else {
            clientHeader = headerValue;
          }
        }
      }
      const additionalValue = additionalHeaders[Headers.ContentType];
      if (additionalValue !== undefined) {
        if (typeof additionalValue === "number") {
          return String(additionalValue);
        } else if (Array.isArray(additionalValue)) {
          return additionalValue.join(", ");
        } else {
          return additionalValue;
        }
      }
      if (clientHeader !== undefined) {
        return clientHeader;
      }
      return _default;
    }
    _getAgent(parsedUrl) {
      let agent;
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent = this._proxyAgent;
      }
      if (!useProxy) {
        agent = this._agent;
      }
      if (agent) {
        return agent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (proxyUrl && proxyUrl.hostname) {
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        }
        agent = tunnelAgent(agentOptions);
        this._proxyAgent = agent;
      }
      if (!agent) {
        const options = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
        this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError) {
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive) {
        proxyAgent = this._proxyAgentDispatcher;
      }
      if (proxyAgent) {
        return proxyAgent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      }));
      this._proxyAgentDispatcher = proxyAgent;
      if (usingSsl && this._ignoreSslError) {
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: false
        });
      }
      return proxyAgent;
    }
    _getUserAgentWithOrchestrationId(userAgent) {
      const baseUserAgent = userAgent || "actions/http-client";
      const orchId = process.env["ACTIONS_ORCHESTRATION_ID"];
      if (orchId) {
        const sanitizedId = orchId.replace(/[^a-z0-9_.-]/gi, "_");
        return `${baseUserAgent} actions_orchestration_id/${sanitizedId}`;
      }
      return baseUserAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, undefined, undefined, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
          const statusCode = res.message.statusCode || 0;
          const response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound) {
            resolve(response);
          }
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              const a = new Date(value);
              if (!isNaN(a.valueOf())) {
                return a;
              }
            }
            return value;
          }
          let obj;
          let contents;
          try {
            contents = yield res.readBody();
            if (contents && contents.length > 0) {
              if (options && options.deserializeDates) {
                obj = JSON.parse(contents, dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {}
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = `Failed request: (${statusCode})`;
            }
            const err = new HttpClientError(msg, statusCode);
            err.result = response.result;
            reject(err);
          } else {
            resolve(response);
          }
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = undefined;

  class BasicCredentialHandler {
    constructor(username, password) {
      this.username = username;
      this.password = password;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BasicCredentialHandler = BasicCredentialHandler;

  class BearerCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Bearer ${this.token}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BearerCredentialHandler = BearerCredentialHandler;

  class PersonalAccessTokenCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OidcClient = undefined;
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var core_1 = require_core();

  class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
      const requestOptions = {
        allowRetries: allowRetry,
        maxRetries: maxRetry
      };
      return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
      const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
      if (!token) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      }
      return token;
    }
    static getIDTokenUrl() {
      const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
      if (!runtimeUrl) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      }
      return runtimeUrl;
    }
    static getCall(id_token_url) {
      return __awaiter(this, undefined, undefined, function* () {
        var _a;
        const httpclient = OidcClient.createHttpClient();
        const res = yield httpclient.getJson(id_token_url).catch((error2) => {
          throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error2.statusCode}
 
        Error Message: ${error2.message}`);
        });
        const id_token = (_a = res.result) === null || _a === undefined ? undefined : _a.value;
        if (!id_token) {
          throw new Error("Response json body do not have ID Token field");
        }
        return id_token;
      });
    }
    static getIDToken(audience) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          let id_token_url = OidcClient.getIDTokenUrl();
          if (audience) {
            const encodedAudience = encodeURIComponent(audience);
            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
          }
          (0, core_1.debug)(`ID token url is ${id_token_url}`);
          const id_token = yield OidcClient.getCall(id_token_url);
          (0, core_1.setSecret)(id_token);
          return id_token;
        } catch (error2) {
          throw new Error(`Error message: ${error2.message}`);
        }
      });
    }
  }
  exports.OidcClient = OidcClient;
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = undefined;
  var os_1 = __require("os");
  var fs_1 = __require("fs");
  var { access, appendFile, writeFile } = fs_1.promises;
  exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
  exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";

  class Summary {
    constructor() {
      this._buffer = "";
    }
    filePath() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._filePath) {
          return this._filePath;
        }
        const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
        if (!pathFromEnv) {
          throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
        }
        try {
          yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
        } catch (_a) {
          throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
        }
        this._filePath = pathFromEnv;
        return this._filePath;
      });
    }
    wrap(tag, content, attrs = {}) {
      const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
      if (!content) {
        return `<${tag}${htmlAttrs}>`;
      }
      return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    write(options) {
      return __awaiter(this, undefined, undefined, function* () {
        const overwrite = !!(options === null || options === undefined ? undefined : options.overwrite);
        const filePath = yield this.filePath();
        const writeFunc = overwrite ? writeFile : appendFile;
        yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
        return this.emptyBuffer();
      });
    }
    clear() {
      return __awaiter(this, undefined, undefined, function* () {
        return this.emptyBuffer().write({ overwrite: true });
      });
    }
    stringify() {
      return this._buffer;
    }
    isEmptyBuffer() {
      return this._buffer.length === 0;
    }
    emptyBuffer() {
      this._buffer = "";
      return this;
    }
    addRaw(text, addEOL = false) {
      this._buffer += text;
      return addEOL ? this.addEOL() : this;
    }
    addEOL() {
      return this.addRaw(os_1.EOL);
    }
    addCodeBlock(code, lang) {
      const attrs = Object.assign({}, lang && { lang });
      const element = this.wrap("pre", this.wrap("code", code), attrs);
      return this.addRaw(element).addEOL();
    }
    addList(items, ordered = false) {
      const tag = ordered ? "ol" : "ul";
      const listItems = items.map((item) => this.wrap("li", item)).join("");
      const element = this.wrap(tag, listItems);
      return this.addRaw(element).addEOL();
    }
    addTable(rows) {
      const tableBody = rows.map((row) => {
        const cells = row.map((cell) => {
          if (typeof cell === "string") {
            return this.wrap("td", cell);
          }
          const { header, data, colspan, rowspan } = cell;
          const tag = header ? "th" : "td";
          const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
          return this.wrap(tag, data, attrs);
        }).join("");
        return this.wrap("tr", cells);
      }).join("");
      const element = this.wrap("table", tableBody);
      return this.addRaw(element).addEOL();
    }
    addDetails(label, content) {
      const element = this.wrap("details", this.wrap("summary", label) + content);
      return this.addRaw(element).addEOL();
    }
    addImage(src, alt, options) {
      const { width, height } = options || {};
      const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
      const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
      return this.addRaw(element).addEOL();
    }
    addHeading(text, level) {
      const tag = `h${level}`;
      const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
      const element = this.wrap(allowedTag, text);
      return this.addRaw(element).addEOL();
    }
    addSeparator() {
      const element = this.wrap("hr", null);
      return this.addRaw(element).addEOL();
    }
    addBreak() {
      const element = this.wrap("br", null);
      return this.addRaw(element).addEOL();
    }
    addQuote(text, cite) {
      const attrs = Object.assign({}, cite && { cite });
      const element = this.wrap("blockquote", text, attrs);
      return this.addRaw(element).addEOL();
    }
    addLink(text, href) {
      const element = this.wrap("a", text, { href });
      return this.addRaw(element).addEOL();
    }
  }
  var _summary = new Summary;
  exports.markdownSummary = _summary;
  exports.summary = _summary;
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toPosixPath = toPosixPath;
  exports.toWin32Path = toWin32Path;
  exports.toPlatformPath = toPlatformPath;
  var path = __importStar(__require("path"));
  function toPosixPath(pth) {
    return pth.replace(/[\\]/g, "/");
  }
  function toWin32Path(pth) {
    return pth.replace(/[/]/g, "\\");
  }
  function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
  }
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = undefined;
  exports.readlink = readlink;
  exports.exists = exists;
  exports.isDirectory = isDirectory;
  exports.isRooted = isRooted;
  exports.tryGetExecutablePath = tryGetExecutablePath;
  exports.getCmdPath = getCmdPath;
  var fs = __importStar(__require("fs"));
  var path = __importStar(__require("path"));
  _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
  exports.IS_WINDOWS = process.platform === "win32";
  function readlink(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      const result2 = yield fs.promises.readlink(fsPath);
      if (exports.IS_WINDOWS && !result2.endsWith("\\")) {
        return `${result2}\\`;
      }
      return result2;
    });
  }
  exports.UV_FS_O_EXLOCK = 268435456;
  exports.READONLY = fs.constants.O_RDONLY;
  function exists(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      try {
        yield (0, exports.stat)(fsPath);
      } catch (err) {
        if (err.code === "ENOENT") {
          return false;
        }
        throw err;
      }
      return true;
    });
  }
  function isDirectory(fsPath_1) {
    return __awaiter(this, arguments, undefined, function* (fsPath, useStat = false) {
      const stats = useStat ? yield (0, exports.stat)(fsPath) : yield (0, exports.lstat)(fsPath);
      return stats.isDirectory();
    });
  }
  function isRooted(p) {
    p = normalizeSeparators(p);
    if (!p) {
      throw new Error('isRooted() parameter "p" cannot be empty');
    }
    if (exports.IS_WINDOWS) {
      return p.startsWith("\\") || /^[A-Z]:/i.test(p);
    }
    return p.startsWith("/");
  }
  function tryGetExecutablePath(filePath, extensions) {
    return __awaiter(this, undefined, undefined, function* () {
      let stats = undefined;
      try {
        stats = yield (0, exports.stat)(filePath);
      } catch (err) {
        if (err.code !== "ENOENT") {
          console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
      }
      if (stats && stats.isFile()) {
        if (exports.IS_WINDOWS) {
          const upperExt = path.extname(filePath).toUpperCase();
          if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
            return filePath;
          }
        } else {
          if (isUnixExecutable(stats)) {
            return filePath;
          }
        }
      }
      const originalFilePath = filePath;
      for (const extension of extensions) {
        filePath = originalFilePath + extension;
        stats = undefined;
        try {
          stats = yield (0, exports.stat)(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            try {
              const directory = path.dirname(filePath);
              const upperName = path.basename(filePath).toUpperCase();
              for (const actualName of yield (0, exports.readdir)(directory)) {
                if (upperName === actualName.toUpperCase()) {
                  filePath = path.join(directory, actualName);
                  break;
                }
              }
            } catch (err) {
              console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
            }
            return filePath;
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
      }
      return "";
    });
  }
  function normalizeSeparators(p) {
    p = p || "";
    if (exports.IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      return p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  function isUnixExecutable(stats) {
    return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && process.getgid !== undefined && stats.gid === process.getgid() || (stats.mode & 64) > 0 && process.getuid !== undefined && stats.uid === process.getuid();
  }
  function getCmdPath() {
    var _a2;
    return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== undefined ? _a2 : `cmd.exe`;
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cp = cp;
  exports.mv = mv;
  exports.rmRF = rmRF;
  exports.mkdirP = mkdirP;
  exports.which = which;
  exports.findInPath = findInPath;
  var assert_1 = __require("assert");
  var path = __importStar(__require("path"));
  var ioUtil = __importStar(require_io_util());
  function cp(source_1, dest_1) {
    return __awaiter(this, arguments, undefined, function* (source, dest, options = {}) {
      const { force, recursive, copySourceDirectory } = readCopyOptions(options);
      const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
      if (destStat && destStat.isFile() && !force) {
        return;
      }
      const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
      if (!(yield ioUtil.exists(source))) {
        throw new Error(`no such file or directory: ${source}`);
      }
      const sourceStat = yield ioUtil.stat(source);
      if (sourceStat.isDirectory()) {
        if (!recursive) {
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        } else {
          yield cpDirRecursive(source, newDest, 0, force);
        }
      } else {
        if (path.relative(source, newDest) === "") {
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        }
        yield copyFile(source, newDest, force);
      }
    });
  }
  function mv(source_1, dest_1) {
    return __awaiter(this, arguments, undefined, function* (source, dest, options = {}) {
      if (yield ioUtil.exists(dest)) {
        let destExists = true;
        if (yield ioUtil.isDirectory(dest)) {
          dest = path.join(dest, path.basename(source));
          destExists = yield ioUtil.exists(dest);
        }
        if (destExists) {
          if (options.force == null || options.force) {
            yield rmRF(dest);
          } else {
            throw new Error("Destination already exists");
          }
        }
      }
      yield mkdirP(path.dirname(dest));
      yield ioUtil.rename(source, dest);
    });
  }
  function rmRF(inputPath) {
    return __awaiter(this, undefined, undefined, function* () {
      if (ioUtil.IS_WINDOWS) {
        if (/[*"<>|]/.test(inputPath)) {
          throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
        }
      }
      try {
        yield ioUtil.rm(inputPath, {
          force: true,
          maxRetries: 3,
          recursive: true,
          retryDelay: 300
        });
      } catch (err) {
        throw new Error(`File was unable to be removed ${err}`);
      }
    });
  }
  function mkdirP(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      (0, assert_1.ok)(fsPath, "a path argument must be provided");
      yield ioUtil.mkdir(fsPath, { recursive: true });
    });
  }
  function which(tool, check) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      if (check) {
        const result2 = yield which(tool, false);
        if (!result2) {
          if (ioUtil.IS_WINDOWS) {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          } else {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          }
        }
        return result2;
      }
      const matches = yield findInPath(tool);
      if (matches && matches.length > 0) {
        return matches[0];
      }
      return "";
    });
  }
  function findInPath(tool) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      const extensions = [];
      if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
        for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
          if (extension) {
            extensions.push(extension);
          }
        }
      }
      if (ioUtil.isRooted(tool)) {
        const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
        if (filePath) {
          return [filePath];
        }
        return [];
      }
      if (tool.includes(path.sep)) {
        return [];
      }
      const directories = [];
      if (process.env.PATH) {
        for (const p of process.env.PATH.split(path.delimiter)) {
          if (p) {
            directories.push(p);
          }
        }
      }
      const matches = [];
      for (const directory of directories) {
        const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
        if (filePath) {
          matches.push(filePath);
        }
      }
      return matches;
    });
  }
  function readCopyOptions(options) {
    const force = options.force == null ? true : options.force;
    const recursive = Boolean(options.recursive);
    const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++;
      yield mkdirP(destDir);
      const files = yield ioUtil.readdir(sourceDir);
      for (const fileName of files) {
        const srcFile = `${sourceDir}/${fileName}`;
        const destFile = `${destDir}/${fileName}`;
        const srcFileStat = yield ioUtil.lstat(srcFile);
        if (srcFileStat.isDirectory()) {
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        } else {
          yield copyFile(srcFile, destFile, force);
        }
      }
      yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil.lstat(destFile);
          yield ioUtil.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM") {
            yield ioUtil.chmod(destFile, "0666");
            yield ioUtil.unlink(destFile);
          }
        }
        const symlinkFull = yield ioUtil.readlink(srcFile);
        yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil.exists(destFile)) || force) {
        yield ioUtil.copyFile(srcFile, destFile);
      }
    });
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ToolRunner = undefined;
  exports.argStringToArray = argStringToArray;
  var os = __importStar(__require("os"));
  var events = __importStar(__require("events"));
  var child = __importStar(__require("child_process"));
  var path = __importStar(__require("path"));
  var io = __importStar(require_io());
  var ioUtil = __importStar(require_io_util());
  var timers_1 = __require("timers");
  var IS_WINDOWS = process.platform === "win32";

  class ToolRunner extends events.EventEmitter {
    constructor(toolPath, args, options) {
      super();
      if (!toolPath) {
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      }
      this.toolPath = toolPath;
      this.args = args || [];
      this.options = options || {};
    }
    _debug(message) {
      if (this.options.listeners && this.options.listeners.debug) {
        this.options.listeners.debug(message);
      }
    }
    _getCommandString(options, noPrefix) {
      const toolPath = this._getSpawnFileName();
      const args = this._getSpawnArgs(options);
      let cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else if (options.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (const a of args) {
            cmd += ` ${this._windowsQuoteCmdArg(a)}`;
          }
        }
      } else {
        cmd += toolPath;
        for (const a of args) {
          cmd += ` ${a}`;
        }
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString();
        let n = s.indexOf(os.EOL);
        while (n > -1) {
          const line = s.substring(0, n);
          onLine(line);
          s = s.substring(n + os.EOL.length);
          n = s.indexOf(os.EOL);
        }
        return s;
      } catch (err) {
        this._debug(`error processing line. Failed with error ${err}`);
        return "";
      }
    }
    _getSpawnFileName() {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          return process.env["COMSPEC"] || "cmd.exe";
        }
      }
      return this.toolPath;
    }
    _getSpawnArgs(options) {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (const a of this.args) {
            argline += " ";
            argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
          }
          argline += '"';
          return [argline];
        }
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      const upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile()) {
        return this._uvQuoteCmdArg(arg);
      }
      if (!arg) {
        return '""';
      }
      const cmdSpecialChars = [
        " ",
        "\t",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ];
      let needsQuotes = false;
      for (const char of arg) {
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = true;
          break;
        }
      }
      if (!needsQuotes) {
        return arg;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length;i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += '"';
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg) {
        return '""';
      }
      if (!arg.includes(" ") && !arg.includes("\t") && !arg.includes('"')) {
        return arg;
      }
      if (!arg.includes('"') && !arg.includes("\\")) {
        return `"${arg}"`;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length;i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += "\\";
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options) {
      options = options || {};
      const result2 = {
        cwd: options.cwd || process.cwd(),
        env: options.env || process.env,
        silent: options.silent || false,
        windowsVerbatimArguments: options.windowsVerbatimArguments || false,
        failOnStdErr: options.failOnStdErr || false,
        ignoreReturnCode: options.ignoreReturnCode || false,
        delay: options.delay || 1e4
      };
      result2.outStream = options.outStream || process.stdout;
      result2.errStream = options.errStream || process.stderr;
      return result2;
    }
    _getSpawnOptions(options, toolPath) {
      options = options || {};
      const result2 = {};
      result2.cwd = options.cwd;
      result2.env = options.env;
      result2["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
      if (options.windowsVerbatimArguments) {
        result2.argv0 = `"${toolPath}"`;
      }
      return result2;
    }
    exec() {
      return __awaiter(this, undefined, undefined, function* () {
        if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
          this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
        }
        this.toolPath = yield io.which(this.toolPath, true);
        return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
          this._debug(`exec tool: ${this.toolPath}`);
          this._debug("arguments:");
          for (const arg of this.args) {
            this._debug(`   ${arg}`);
          }
          const optionsNonNull = this._cloneExecOptions(this.options);
          if (!optionsNonNull.silent && optionsNonNull.outStream) {
            optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
          }
          const state = new ExecState(optionsNonNull, this.toolPath);
          state.on("debug", (message) => {
            this._debug(message);
          });
          if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
            return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
          }
          const fileName = this._getSpawnFileName();
          const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
          let stdbuffer = "";
          if (cp.stdout) {
            cp.stdout.on("data", (data) => {
              if (this.options.listeners && this.options.listeners.stdout) {
                this.options.listeners.stdout(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.outStream) {
                optionsNonNull.outStream.write(data);
              }
              stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.stdline) {
                  this.options.listeners.stdline(line);
                }
              });
            });
          }
          let errbuffer = "";
          if (cp.stderr) {
            cp.stderr.on("data", (data) => {
              state.processStderr = true;
              if (this.options.listeners && this.options.listeners.stderr) {
                this.options.listeners.stderr(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                s.write(data);
              }
              errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.errline) {
                  this.options.listeners.errline(line);
                }
              });
            });
          }
          cp.on("error", (err) => {
            state.processError = err.message;
            state.processExited = true;
            state.processClosed = true;
            state.CheckComplete();
          });
          cp.on("exit", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          cp.on("close", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            state.processClosed = true;
            this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          state.on("done", (error2, exitCode) => {
            if (stdbuffer.length > 0) {
              this.emit("stdline", stdbuffer);
            }
            if (errbuffer.length > 0) {
              this.emit("errline", errbuffer);
            }
            cp.removeAllListeners();
            if (error2) {
              reject(error2);
            } else {
              resolve(exitCode);
            }
          });
          if (this.options.input) {
            if (!cp.stdin) {
              throw new Error("child process missing stdin");
            }
            cp.stdin.end(this.options.input);
          }
        }));
      });
    }
  }
  exports.ToolRunner = ToolRunner;
  function argStringToArray(argString) {
    const args = [];
    let inQuotes = false;
    let escaped = false;
    let arg = "";
    function append(c) {
      if (escaped && c !== '"') {
        arg += "\\";
      }
      arg += c;
      escaped = false;
    }
    for (let i = 0;i < argString.length; i++) {
      const c = argString.charAt(i);
      if (c === '"') {
        if (!escaped) {
          inQuotes = !inQuotes;
        } else {
          append(c);
        }
        continue;
      }
      if (c === "\\" && escaped) {
        append(c);
        continue;
      }
      if (c === "\\" && inQuotes) {
        escaped = true;
        continue;
      }
      if (c === " " && !inQuotes) {
        if (arg.length > 0) {
          args.push(arg);
          arg = "";
        }
        continue;
      }
      append(c);
    }
    if (arg.length > 0) {
      args.push(arg.trim());
    }
    return args;
  }

  class ExecState extends events.EventEmitter {
    constructor(options, toolPath) {
      super();
      this.processClosed = false;
      this.processError = "";
      this.processExitCode = 0;
      this.processExited = false;
      this.processStderr = false;
      this.delay = 1e4;
      this.done = false;
      this.timeout = null;
      if (!toolPath) {
        throw new Error("toolPath must not be empty");
      }
      this.options = options;
      this.toolPath = toolPath;
      if (options.delay) {
        this.delay = options.delay;
      }
    }
    CheckComplete() {
      if (this.done) {
        return;
      }
      if (this.processClosed) {
        this._setResult();
      } else if (this.processExited) {
        this.timeout = (0, timers_1.setTimeout)(ExecState.HandleTimeout, this.delay, this);
      }
    }
    _debug(message) {
      this.emit("debug", message);
    }
    _setResult() {
      let error2;
      if (this.processExited) {
        if (this.processError) {
          error2 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
        } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
          error2 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
        } else if (this.processStderr && this.options.failOnStdErr) {
          error2 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
        }
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      this.done = true;
      this.emit("done", error2, this.processExitCode);
    }
    static HandleTimeout(state) {
      if (state.done) {
        return;
      }
      if (!state.processClosed && state.processExited) {
        const message = `The STDIO streams did not close within ${state.delay / 1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        state._debug(message);
      }
      state._setResult();
    }
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exec = exec;
  exports.getExecOutput = getExecOutput;
  var string_decoder_1 = __require("string_decoder");
  var tr = __importStar(require_toolrunner());
  function exec(commandLine, args, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0) {
        throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
      }
      const toolPath = commandArgs[0];
      args = commandArgs.slice(1).concat(args || []);
      const runner = new tr.ToolRunner(toolPath, args, options);
      return runner.exec();
    });
  }
  function getExecOutput(commandLine, args, options) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a, _b;
      let stdout = "";
      let stderr = "";
      const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
      const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
      const originalStdoutListener = (_a = options === null || options === undefined ? undefined : options.listeners) === null || _a === undefined ? undefined : _a.stdout;
      const originalStdErrListener = (_b = options === null || options === undefined ? undefined : options.listeners) === null || _b === undefined ? undefined : _b.stderr;
      const stdErrListener = (data) => {
        stderr += stderrDecoder.write(data);
        if (originalStdErrListener) {
          originalStdErrListener(data);
        }
      };
      const stdOutListener = (data) => {
        stdout += stdoutDecoder.write(data);
        if (originalStdoutListener) {
          originalStdoutListener(data);
        }
      };
      const listeners = Object.assign(Object.assign({}, options === null || options === undefined ? undefined : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
      const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
      stdout += stdoutDecoder.end();
      stderr += stderrDecoder.end();
      return {
        exitCode,
        stdout,
        stderr
      };
    });
  }
});

// node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = undefined;
  exports.getDetails = getDetails;
  var os_1 = __importDefault(__require("os"));
  var exec = __importStar(require_exec());
  var getWindowsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', undefined, {
      silent: true
    });
    const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', undefined, {
      silent: true
    });
    return {
      name: name.trim(),
      version: version.trim()
    };
  });
  var getMacOsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    var _a, _b, _c, _d;
    const { stdout } = yield exec.getExecOutput("sw_vers", undefined, {
      silent: true
    });
    const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === undefined ? undefined : _a[1]) !== null && _b !== undefined ? _b : "";
    const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === undefined ? undefined : _c[1]) !== null && _d !== undefined ? _d : "";
    return {
      name,
      version
    };
  });
  var getLinuxInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    const { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
      silent: true
    });
    const [name, version] = stdout.trim().split(`
`);
    return {
      name,
      version
    };
  });
  exports.platform = os_1.default.platform();
  exports.arch = os_1.default.arch();
  exports.isWindows = exports.platform === "win32";
  exports.isMacOS = exports.platform === "darwin";
  exports.isLinux = exports.platform === "linux";
  function getDetails() {
    return __awaiter(this, undefined, undefined, function* () {
      return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
        platform: exports.platform,
        arch: exports.arch,
        isWindows: exports.isWindows,
        isMacOS: exports.isMacOS,
        isLinux: exports.isLinux
      });
    });
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.ExitCode = undefined;
  exports.exportVariable = exportVariable;
  exports.setSecret = setSecret;
  exports.addPath = addPath;
  exports.getInput = getInput;
  exports.getMultilineInput = getMultilineInput;
  exports.getBooleanInput = getBooleanInput;
  exports.setOutput = setOutput;
  exports.setCommandEcho = setCommandEcho;
  exports.setFailed = setFailed;
  exports.isDebug = isDebug;
  exports.debug = debug;
  exports.error = error2;
  exports.warning = warning;
  exports.notice = notice;
  exports.info = info;
  exports.startGroup = startGroup;
  exports.endGroup = endGroup;
  exports.group = group;
  exports.saveState = saveState;
  exports.getState = getState;
  exports.getIDToken = getIDToken;
  var command_1 = require_command();
  var file_command_1 = require_file_command();
  var utils_1 = require_utils();
  var os = __importStar(__require("os"));
  var path = __importStar(__require("path"));
  var oidc_utils_1 = require_oidc_utils();
  var ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2["Success"] = 0] = "Success";
    ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
  })(ExitCode || (exports.ExitCode = ExitCode = {}));
  function exportVariable(name, val) {
    const convertedVal = (0, utils_1.toCommandValue)(val);
    process.env[name] = convertedVal;
    const filePath = process.env["GITHUB_ENV"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
    }
    (0, command_1.issueCommand)("set-env", { name }, convertedVal);
  }
  function setSecret(secret) {
    (0, command_1.issueCommand)("add-mask", {}, secret);
  }
  function addPath(inputPath) {
    const filePath = process.env["GITHUB_PATH"] || "";
    if (filePath) {
      (0, file_command_1.issueFileCommand)("PATH", inputPath);
    } else {
      (0, command_1.issueCommand)("add-path", {}, inputPath);
    }
    process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
  }
  function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options && options.required && !val) {
      throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
      return val;
    }
    return val.trim();
  }
  function getMultilineInput(name, options) {
    const inputs = getInput(name, options).split(`
`).filter((x) => x !== "");
    if (options && options.trimWhitespace === false) {
      return inputs;
    }
    return inputs.map((input) => input.trim());
  }
  function getBooleanInput(name, options) {
    const trueValue = ["true", "True", "TRUE"];
    const falseValue = ["false", "False", "FALSE"];
    const val = getInput(name, options);
    if (trueValue.includes(val))
      return true;
    if (falseValue.includes(val))
      return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
` + `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
  }
  function setOutput(name, value) {
    const filePath = process.env["GITHUB_OUTPUT"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
    }
    process.stdout.write(os.EOL);
    (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
  }
  function setCommandEcho(enabled) {
    (0, command_1.issue)("echo", enabled ? "on" : "off");
  }
  function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error2(message);
  }
  function isDebug() {
    return process.env["RUNNER_DEBUG"] === "1";
  }
  function debug(message) {
    (0, command_1.issueCommand)("debug", {}, message);
  }
  function error2(message, properties = {}) {
    (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function warning(message, properties = {}) {
    (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function notice(message, properties = {}) {
    (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function info(message) {
    process.stdout.write(message + os.EOL);
  }
  function startGroup(name) {
    (0, command_1.issue)("group", name);
  }
  function endGroup() {
    (0, command_1.issue)("endgroup");
  }
  function group(name, fn) {
    return __awaiter(this, undefined, undefined, function* () {
      startGroup(name);
      let result2;
      try {
        result2 = yield fn();
      } finally {
        endGroup();
      }
      return result2;
    });
  }
  function saveState(name, value) {
    const filePath = process.env["GITHUB_STATE"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
    }
    (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
  }
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  function getIDToken(aud) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
  }
  var summary_1 = require_summary();
  Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
    return summary_1.summary;
  } });
  var summary_2 = require_summary();
  Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
    return summary_2.markdownSummary;
  } });
  var path_utils_1 = require_path_utils();
  Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
    return path_utils_1.toPosixPath;
  } });
  Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
    return path_utils_1.toWin32Path;
  } });
  Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
    return path_utils_1.toPlatformPath;
  } });
  exports.platform = __importStar(require_platform());
});

// node_modules/systeminformation/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "systeminformation",
    version: "5.30.6",
    description: "Advanced, lightweight system and OS information library",
    license: "MIT",
    author: "Sebastian Hildebrandt <hildebrandt@plus-innovations.com> (https://plus-innovations.com)",
    homepage: "https://systeminformation.io",
    main: "./lib/index.js",
    type: "commonjs",
    bin: {
      systeminformation: "lib/cli.js"
    },
    types: "./lib/index.d.ts",
    scripts: {
      test: "node ./test/test.js",
      testDeno: "deno run -A ./test/test.js"
    },
    files: [
      "lib/"
    ],
    keywords: [
      "system information",
      "sysinfo",
      "monitor",
      "monitoring",
      "os",
      "linux",
      "osx",
      "windows",
      "freebsd",
      "openbsd",
      "netbsd",
      "cpu",
      "cpuload",
      "physical cores",
      "logical cores",
      "processor",
      "cores",
      "threads",
      "socket type",
      "memory",
      "file system",
      "fsstats",
      "diskio",
      "block devices",
      "netstats",
      "network",
      "network interfaces",
      "network connections",
      "network stats",
      "iface",
      "printer",
      "processes",
      "users",
      "internet",
      "battery",
      "docker",
      "docker stats",
      "docker processes",
      "graphics",
      "graphic card",
      "graphic controller",
      "gpu",
      "display",
      "smart",
      "disk layout",
      "usb",
      "audio",
      "bluetooth",
      "wifi",
      "wifinetworks",
      "virtual box",
      "virtualbox",
      "vm",
      "backend",
      "hardware",
      "BIOS",
      "chassis"
    ],
    repository: {
      type: "git",
      url: "git+https://github.com/sebhildebrandt/systeminformation.git"
    },
    funding: {
      type: "Buy me a coffee",
      url: "https://www.buymeacoffee.com/systeminfo"
    },
    os: [
      "darwin",
      "linux",
      "win32",
      "freebsd",
      "openbsd",
      "netbsd",
      "sunos",
      "android"
    ],
    engines: {
      node: ">=8.0.0"
    }
  };
});

// node_modules/systeminformation/lib/util.js
var require_util7 = __commonJS((exports) => {
  var os = __require("os");
  var fs = __require("fs");
  var path = __require("path");
  var spawn = __require("child_process").spawn;
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = __require("util");
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _cores = 0;
  var codepage = "";
  var _smartMonToolsInstalled = null;
  var _rpi_cpuinfo = null;
  var WINDIR = process.env.WINDIR || "C:\\Windows";
  var _psChild;
  var _psResult = "";
  var _psCmds = [];
  var _psPersistent = false;
  var _powerShell = "";
  var _psToUTF8 = "$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ";
  var _psCmdStart = "--###START###--";
  var _psError = "--ERROR--";
  var _psCmdSeperator = "--###ENDCMD###--";
  var _psIdSeperator = "--##ID##--";
  var execOptsWin = {
    windowsHide: true,
    maxBuffer: 1024 * 102400,
    encoding: "UTF-8",
    env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
  };
  var execOptsLinux = {
    maxBuffer: 1024 * 102400,
    encoding: "UTF-8",
    stdio: ["pipe", "pipe", "ignore"]
  };
  function toInt(value) {
    let result2 = parseInt(value, 10);
    if (isNaN(result2)) {
      result2 = 0;
    }
    return result2;
  }
  function splitByNumber(str) {
    let numberStarted = false;
    let num = "";
    let cpart = "";
    for (const c of str) {
      if (c >= "0" && c <= "9" || numberStarted) {
        numberStarted = true;
        num += c;
      } else {
        cpart += c;
      }
    }
    return [cpart, num];
  }
  var stringObj = new String;
  var stringReplace = new String().replace;
  var stringToLower = new String().toLowerCase;
  var stringToString = new String().toString;
  var stringSubstr = new String().substr;
  var stringSubstring = new String().substring;
  var stringTrim = new String().trim;
  var stringStartWith = new String().startsWith;
  var mathMin = Math.min;
  function isFunction(functionToCheck) {
    let getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
  }
  function unique(obj) {
    const uniques = [];
    const stringify = {};
    for (let i = 0;i < obj.length; i++) {
      let keys = Object.keys(obj[i]);
      keys.sort((a, b) => {
        return a - b;
      });
      let str = "";
      for (let j = 0;j < keys.length; j++) {
        str += JSON.stringify(keys[j]);
        str += JSON.stringify(obj[i][keys[j]]);
      }
      if (!{}.hasOwnProperty.call(stringify, str)) {
        uniques.push(obj[i]);
        stringify[str] = true;
      }
    }
    return uniques;
  }
  function sortByKey(array, keys) {
    return array.sort((a, b) => {
      let x = "";
      let y = "";
      keys.forEach((key) => {
        x = x + a[key];
        y = y + b[key];
      });
      return x < y ? -1 : x > y ? 1 : 0;
    });
  }
  function cores() {
    if (_cores === 0) {
      _cores = os.cpus().length;
    }
    return _cores;
  }
  function getValue(lines, property, separator, trimmed, lineMatch) {
    separator = separator || ":";
    property = property.toLowerCase();
    trimmed = trimmed || false;
    lineMatch = lineMatch || false;
    let result2 = "";
    lines.some((line) => {
      let lineLower = line.toLowerCase().replace(/\t/g, "");
      if (trimmed) {
        lineLower = lineLower.trim();
      }
      if (lineLower.startsWith(property) && (lineMatch ? lineLower.match(property + separator) || lineLower.match(property + " " + separator) : true)) {
        const parts = trimmed ? line.trim().split(separator) : line.split(separator);
        if (parts.length >= 2) {
          parts.shift();
          result2 = parts.join(separator).trim();
          return true;
        }
      }
      return false;
    });
    return result2;
  }
  function decodeEscapeSequence(str, base) {
    base = base || 16;
    return str.replace(/\\x([0-9A-Fa-f]{2})/g, function() {
      return String.fromCharCode(parseInt(arguments[1], base));
    });
  }
  function detectSplit(str) {
    let seperator = "";
    let part = 0;
    str.split("").forEach((element) => {
      if (element >= "0" && element <= "9") {
        if (part === 1) {
          part++;
        }
      } else {
        if (part === 0) {
          part++;
        }
        if (part === 1) {
          seperator += element;
        }
      }
    });
    return seperator;
  }
  function parseTime(t, pmDesignator) {
    pmDesignator = pmDesignator || "";
    t = t.toUpperCase();
    let hour = 0;
    let min = 0;
    const splitter = detectSplit(t);
    const parts = t.split(splitter);
    if (parts.length >= 2) {
      if (parts[2]) {
        parts[1] += parts[2];
      }
      let isPM = parts[1] && parts[1].toLowerCase().indexOf("pm") > -1 || parts[1].toLowerCase().indexOf("p.m.") > -1 || parts[1].toLowerCase().indexOf("p. m.") > -1 || parts[1].toLowerCase().indexOf("n") > -1 || parts[1].toLowerCase().indexOf("ch") > -1 || parts[1].toLowerCase().indexOf("s") > -1 || pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1;
      hour = parseInt(parts[0], 10);
      min = parseInt(parts[1], 10);
      hour = isPM && hour < 12 ? hour + 12 : hour;
      return ("0" + hour).substr(-2) + ":" + ("0" + min).substr(-2);
    }
  }
  function parseDateTime(dt, culture) {
    const result2 = {
      date: "",
      time: ""
    };
    culture = culture || {};
    const dateFormat = (culture.dateFormat || "").toLowerCase();
    const pmDesignator = culture.pmDesignator || "";
    const parts = dt.split(" ");
    if (parts[0]) {
      if (parts[0].indexOf("/") >= 0) {
        const dtparts = parts[0].split("/");
        if (dtparts.length === 3) {
          if (dtparts[0].length === 4) {
            result2.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
          } else if (dtparts[2].length === 2) {
            if (dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) {
              result2.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            } else {
              result2.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            }
          } else {
            const isEN = dt.toLowerCase().indexOf("pm") > -1 || dt.toLowerCase().indexOf("p.m.") > -1 || dt.toLowerCase().indexOf("p. m.") > -1 || dt.toLowerCase().indexOf("am") > -1 || dt.toLowerCase().indexOf("a.m.") > -1 || dt.toLowerCase().indexOf("a. m.") > -1;
            if ((isEN || dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) && dateFormat.indexOf("dd/") !== 0) {
              result2.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
            } else {
              result2.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            }
          }
        }
      }
      if (parts[0].indexOf(".") >= 0) {
        const dtparts = parts[0].split(".");
        if (dtparts.length === 3) {
          if (dateFormat.indexOf(".d.") > -1 || dateFormat.indexOf(".dd.") > -1) {
            result2.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
          } else {
            result2.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
          }
        }
      }
      if (parts[0].indexOf("-") >= 0) {
        const dtparts = parts[0].split("-");
        if (dtparts.length === 3) {
          result2.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
        }
      }
    }
    if (parts[1]) {
      parts.shift();
      const time = parts.join(" ");
      result2.time = parseTime(time, pmDesignator);
    }
    return result2;
  }
  function parseHead(head, rights) {
    let space = rights > 0;
    let count = 1;
    let from = 0;
    let to = 0;
    const result2 = [];
    for (let i = 0;i < head.length; i++) {
      if (count <= rights) {
        if (/\s/.test(head[i]) && !space) {
          to = i - 1;
          result2.push({
            from,
            to: to + 1,
            cap: head.substring(from, to + 1)
          });
          from = to + 2;
          count++;
        }
        space = head[i] === " ";
      } else {
        if (!/\s/.test(head[i]) && space) {
          to = i - 1;
          if (from < to) {
            result2.push({
              from,
              to,
              cap: head.substring(from, to)
            });
          }
          from = to + 1;
          count++;
        }
        space = head[i] === " ";
      }
    }
    to = 5000;
    result2.push({
      from,
      to,
      cap: head.substring(from, to)
    });
    let len = result2.length;
    for (let i = 0;i < len; i++) {
      if (result2[i].cap.replace(/\s/g, "").length === 0) {
        if (i + 1 < len) {
          result2[i].to = result2[i + 1].to;
          result2[i].cap = result2[i].cap + result2[i + 1].cap;
          result2.splice(i + 1, 1);
          len = len - 1;
        }
      }
    }
    return result2;
  }
  function findObjectByKey(array, key, value) {
    for (let i = 0;i < array.length; i++) {
      if (array[i][key] === value) {
        return i;
      }
    }
    return -1;
  }
  function getPowershell() {
    _powerShell = "powershell.exe";
    if (_windows) {
      const defaultPath = `${WINDIR}\\system32\\WindowsPowerShell\\v1.0\\powershell.exe`;
      if (fs.existsSync(defaultPath)) {
        _powerShell = defaultPath;
      }
    }
  }
  function getVboxmanage() {
    return _windows ? `"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\VBoxManage.exe"` : "vboxmanage";
  }
  function powerShellProceedResults(data) {
    let id = "";
    let parts;
    let res = "";
    if (data.indexOf(_psCmdStart) >= 0) {
      parts = data.split(_psCmdStart);
      const parts2 = parts[1].split(_psIdSeperator);
      id = parts2[0];
      if (parts2.length > 1) {
        data = parts2.slice(1).join(_psIdSeperator);
      }
    }
    if (data.indexOf(_psCmdSeperator) >= 0) {
      parts = data.split(_psCmdSeperator);
      res = parts[0];
    }
    let remove = -1;
    for (let i = 0;i < _psCmds.length; i++) {
      if (_psCmds[i].id === id) {
        remove = i;
        _psCmds[i].callback(res);
      }
    }
    if (remove >= 0) {
      _psCmds.splice(remove, 1);
    }
  }
  function powerShellStart() {
    if (!_psChild) {
      _psChild = spawn(_powerShell, ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-Command", "-"], {
        stdio: "pipe",
        windowsHide: true,
        maxBuffer: 1024 * 102400,
        encoding: "UTF-8",
        env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
      });
      if (_psChild && _psChild.pid) {
        _psPersistent = true;
        _psChild.stdout.on("data", (data) => {
          _psResult = _psResult + data.toString("utf8");
          if (data.indexOf(_psCmdSeperator) >= 0) {
            powerShellProceedResults(_psResult);
            _psResult = "";
          }
        });
        _psChild.stderr.on("data", () => {
          powerShellProceedResults(_psResult + _psError);
        });
        _psChild.on("error", () => {
          powerShellProceedResults(_psResult + _psError);
        });
        _psChild.on("close", () => {
          if (_psChild) {
            _psChild.kill();
          }
        });
      }
    }
  }
  function powerShellRelease() {
    try {
      if (_psChild) {
        _psChild.stdin.write("exit" + os.EOL);
        _psChild.stdin.end();
      }
    } catch {
      if (_psChild) {
        _psChild.kill();
      }
    }
    _psPersistent = false;
    _psChild = null;
  }
  function powerShell(cmd) {
    if (_psPersistent) {
      const id = Math.random().toString(36).substring(2, 12);
      return new Promise((resolve) => {
        process.nextTick(() => {
          function callback(data) {
            resolve(data);
          }
          _psCmds.push({
            id,
            cmd,
            callback,
            start: new Date
          });
          try {
            if (_psChild && _psChild.pid) {
              _psChild.stdin.write(_psToUTF8 + "echo " + _psCmdStart + id + _psIdSeperator + "; " + os.EOL + cmd + os.EOL + "echo " + _psCmdSeperator + os.EOL);
            }
          } catch {
            resolve("");
          }
        });
      });
    } else {
      let result2 = "";
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            const osVersion = os.release().split(".").map(Number);
            const spanOptions = osVersion[0] < 10 ? ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-ExecutionPolicy", "Unrestricted", "-Command", "-"] : ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-ExecutionPolicy", "Unrestricted", "-Command", _psToUTF8 + cmd];
            const child = spawn(_powerShell, spanOptions, {
              stdio: "pipe",
              windowsHide: true,
              maxBuffer: 1024 * 102400,
              encoding: "UTF-8",
              env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
            });
            if (child && !child.pid) {
              child.on("error", () => {
                resolve(result2);
              });
            }
            if (child && child.pid) {
              child.stdout.on("data", (data) => {
                result2 = result2 + data.toString("utf8");
              });
              child.stderr.on("data", () => {
                child.kill();
                resolve(result2);
              });
              child.on("close", () => {
                child.kill();
                resolve(result2);
              });
              child.on("error", () => {
                child.kill();
                resolve(result2);
              });
              if (osVersion[0] < 10) {
                try {
                  child.stdin.write(_psToUTF8 + cmd + os.EOL);
                  child.stdin.write("exit" + os.EOL);
                  child.stdin.end();
                } catch {
                  child.kill();
                  resolve(result2);
                }
              }
            } else {
              resolve(result2);
            }
          } catch {
            resolve(result2);
          }
        });
      });
    }
  }
  function execSafe(cmd, args, options) {
    let result2 = "";
    options = options || {};
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          const child = spawn(cmd, args, options);
          if (child && !child.pid) {
            child.on("error", () => {
              resolve(result2);
            });
          }
          if (child && child.pid) {
            child.stdout.on("data", (data) => {
              result2 += data.toString();
            });
            child.on("close", () => {
              child.kill();
              resolve(result2);
            });
            child.on("error", () => {
              child.kill();
              resolve(result2);
            });
          } else {
            resolve(result2);
          }
        } catch {
          resolve(result2);
        }
      });
    });
  }
  function getCodepage() {
    if (_windows) {
      if (!codepage) {
        try {
          const stdout = execSync("chcp", execOptsWin);
          const lines = stdout.toString().split(`\r
`);
          const parts = lines[0].split(":");
          codepage = parts.length > 1 ? parts[1].replace(".", "").trim() : "";
        } catch {
          codepage = "437";
        }
      }
      return codepage;
    }
    if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
      if (!codepage) {
        try {
          const stdout = execSync("echo $LANG", execOptsLinux);
          const lines = stdout.toString().split(`\r
`);
          const parts = lines[0].split(".");
          codepage = parts.length > 1 ? parts[1].trim() : "";
          if (!codepage) {
            codepage = "UTF-8";
          }
        } catch {
          codepage = "UTF-8";
        }
      }
      return codepage;
    }
  }
  function smartMonToolsInstalled() {
    if (_smartMonToolsInstalled !== null) {
      return _smartMonToolsInstalled;
    }
    _smartMonToolsInstalled = false;
    if (_windows) {
      try {
        const pathArray = execSync("WHERE smartctl 2>nul", execOptsWin).toString().split(`\r
`);
        if (pathArray && pathArray.length) {
          _smartMonToolsInstalled = pathArray[0].indexOf(":\\") >= 0;
        } else {
          _smartMonToolsInstalled = false;
        }
      } catch {
        _smartMonToolsInstalled = false;
      }
    }
    if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
      try {
        const pathArray = execSync("which smartctl 2>/dev/null", execOptsLinux).toString().split(`\r
`);
        _smartMonToolsInstalled = pathArray.length > 0;
      } catch {
        util.noop();
      }
    }
    return _smartMonToolsInstalled;
  }
  function isRaspberry(cpuinfo) {
    const PI_MODEL_NO = ["BCM2708", "BCM2709", "BCM2710", "BCM2711", "BCM2712", "BCM2835", "BCM2836", "BCM2837", "BCM2837B0"];
    if (_rpi_cpuinfo !== null) {
      cpuinfo = _rpi_cpuinfo;
    } else if (cpuinfo === undefined) {
      try {
        cpuinfo = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split(`
`);
        _rpi_cpuinfo = cpuinfo;
      } catch {
        return false;
      }
    }
    const hardware = getValue(cpuinfo, "hardware");
    const model = getValue(cpuinfo, "model");
    return hardware && PI_MODEL_NO.indexOf(hardware) > -1 || model && model.indexOf("Raspberry Pi") > -1;
  }
  function isRaspbian() {
    let osrelease = [];
    try {
      osrelease = fs.readFileSync("/etc/os-release", { encoding: "utf8" }).toString().split(`
`);
    } catch {
      return false;
    }
    const id = getValue(osrelease, "id", "=");
    return id && id.indexOf("raspbian") > -1;
  }
  function execWin(cmd, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = execOptsWin;
    }
    let newCmd = "chcp 65001 > nul && cmd /C " + cmd + " && chcp " + codepage + " > nul";
    exec(newCmd, opts, (error2, stdout) => {
      callback(error2, stdout);
    });
  }
  function darwinXcodeExists() {
    const cmdLineToolsExists = fs.existsSync("/Library/Developer/CommandLineTools/usr/bin/");
    const xcodeAppExists = fs.existsSync("/Applications/Xcode.app/Contents/Developer/Tools");
    const xcodeExists = fs.existsSync("/Library/Developer/Xcode/");
    return cmdLineToolsExists || xcodeExists || xcodeAppExists;
  }
  function nanoSeconds() {
    const time = process.hrtime();
    if (!Array.isArray(time) || time.length !== 2) {
      return 0;
    }
    return +time[0] * 1e9 + +time[1];
  }
  function countUniqueLines(lines, startingWith) {
    startingWith = startingWith || "";
    const uniqueLines = [];
    lines.forEach((line) => {
      if (line.startsWith(startingWith)) {
        if (uniqueLines.indexOf(line) === -1) {
          uniqueLines.push(line);
        }
      }
    });
    return uniqueLines.length;
  }
  function countLines(lines, startingWith) {
    startingWith = startingWith || "";
    const uniqueLines = [];
    lines.forEach((line) => {
      if (line.startsWith(startingWith)) {
        uniqueLines.push(line);
      }
    });
    return uniqueLines.length;
  }
  function sanitizeShellString(str, strict) {
    if (typeof strict === "undefined") {
      strict = false;
    }
    const s = str || "";
    let result2 = "";
    const l = mathMin(s.length, 2000);
    for (let i = 0;i <= l; i++) {
      if (!(s[i] === undefined || s[i] === ">" || s[i] === "<" || s[i] === "*" || s[i] === "?" || s[i] === "[" || s[i] === "]" || s[i] === "|" || s[i] === "" || s[i] === "$" || s[i] === ";" || s[i] === "&" || s[i] === "]" || s[i] === "#" || s[i] === "\\" || s[i] === "\t" || s[i] === `
` || s[i] === "\r" || s[i] === "'" || s[i] === "`" || s[i] === '"' || s[i].length > 1 || strict && s[i] === "(" || strict && s[i] === ")" || strict && s[i] === "@" || strict && s[i] === " " || strict && s[i] === "{" || strict && s[i] === ";" || strict && s[i] === "}")) {
        result2 = result2 + s[i];
      }
    }
    return result2;
  }
  function isPrototypePolluted() {
    const s = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let notPolluted = true;
    let st = "";
    try {
      st.__proto__.replace = stringReplace;
      st.__proto__.toLowerCase = stringToLower;
      st.__proto__.toString = stringToString;
      st.__proto__.substr = stringSubstr;
      st.__proto__.substring = stringSubstring;
      st.__proto__.trim = stringTrim;
      st.__proto__.startsWith = stringStartWith;
    } catch (e) {
      Object.setPrototypeOf(st, stringObj);
    }
    notPolluted = notPolluted || s.length !== 62;
    const ms = Date.now();
    if (typeof ms === "number" && ms > 1600000000000) {
      const l = ms % 100 + 15;
      for (let i = 0;i < l; i++) {
        const r = Math.random() * 61.99999999 + 1;
        const rs = parseInt(Math.floor(r).toString(), 10);
        const rs2 = parseInt(r.toString().split(".")[0], 10);
        const q = Math.random() * 61.99999999 + 1;
        const qs = parseInt(Math.floor(q).toString(), 10);
        const qs2 = parseInt(q.toString().split(".")[0], 10);
        notPolluted = notPolluted && r !== q;
        notPolluted = notPolluted && rs === rs2 && qs === qs2;
        st += s[rs - 1];
      }
      notPolluted = notPolluted && st.length === l;
      let p = Math.random() * l * 0.9999999999;
      let stm = st.substr(0, p) + " " + st.substr(p, 2000);
      try {
        stm.__proto__.replace = stringReplace;
      } catch (e) {
        Object.setPrototypeOf(stm, stringObj);
      }
      let sto = stm.replace(/ /g, "");
      notPolluted = notPolluted && st === sto;
      p = Math.random() * l * 0.9999999999;
      stm = st.substr(0, p) + "{" + st.substr(p, 2000);
      sto = stm.replace(/{/g, "");
      notPolluted = notPolluted && st === sto;
      p = Math.random() * l * 0.9999999999;
      stm = st.substr(0, p) + "*" + st.substr(p, 2000);
      sto = stm.replace(/\*/g, "");
      notPolluted = notPolluted && st === sto;
      p = Math.random() * l * 0.9999999999;
      stm = st.substr(0, p) + "$" + st.substr(p, 2000);
      sto = stm.replace(/\$/g, "");
      notPolluted = notPolluted && st === sto;
      const stl = st.toLowerCase();
      notPolluted = notPolluted && stl.length === l && stl[l - 1] && !stl[l];
      for (let i = 0;i < l; i++) {
        const s1 = st[i];
        try {
          s1.__proto__.toLowerCase = stringToLower;
        } catch {
          Object.setPrototypeOf(st, stringObj);
        }
        const s2 = stl ? stl[i] : "";
        const s1l = s1.toLowerCase();
        notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !s1l[1];
      }
    }
    return !notPolluted;
  }
  function hex2bin(hex) {
    return ("00000000" + parseInt(hex, 16).toString(2)).substr(-8);
  }
  function getFilesInPath(source) {
    const lstatSync = fs.lstatSync;
    const readdirSync = fs.readdirSync;
    const join = path.join;
    function isDirectory(source2) {
      return lstatSync(source2).isDirectory();
    }
    function isFile(source2) {
      return lstatSync(source2).isFile();
    }
    function getDirectories(source2) {
      return readdirSync(source2).map((name) => {
        return join(source2, name);
      }).filter(isDirectory);
    }
    function getFiles(source2) {
      return readdirSync(source2).map((name) => {
        return join(source2, name);
      }).filter(isFile);
    }
    function getFilesRecursively(source2) {
      try {
        const dirs = getDirectories(source2);
        const files = dirs.map((dir) => {
          return getFilesRecursively(dir);
        }).reduce((a, b) => {
          return a.concat(b);
        }, []);
        return files.concat(getFiles(source2));
      } catch {
        return [];
      }
    }
    if (fs.existsSync(source)) {
      return getFilesRecursively(source);
    } else {
      return [];
    }
  }
  function decodePiCpuinfo(lines) {
    if (_rpi_cpuinfo === null) {
      _rpi_cpuinfo = lines;
    } else if (lines === undefined) {
      lines = _rpi_cpuinfo;
    }
    const oldRevisionCodes = {
      "0002": {
        type: "B",
        revision: "1.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0003": {
        type: "B",
        revision: "1.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0004": {
        type: "B",
        revision: "2.0",
        memory: 256,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0005": {
        type: "B",
        revision: "2.0",
        memory: 256,
        manufacturer: "Qisda",
        processor: "BCM2835"
      },
      "0006": {
        type: "B",
        revision: "2.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0007": {
        type: "A",
        revision: "2.0",
        memory: 256,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0008": {
        type: "A",
        revision: "2.0",
        memory: 256,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0009": {
        type: "A",
        revision: "2.0",
        memory: 256,
        manufacturer: "Qisda",
        processor: "BCM2835"
      },
      "000d": {
        type: "B",
        revision: "2.0",
        memory: 512,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "000e": {
        type: "B",
        revision: "2.0",
        memory: 512,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "000f": {
        type: "B",
        revision: "2.0",
        memory: 512,
        manufacturer: "Egoman",
        processor: "BCM2835"
      },
      "0010": {
        type: "B+",
        revision: "1.2",
        memory: 512,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0011": {
        type: "CM1",
        revision: "1.0",
        memory: 512,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0012": {
        type: "A+",
        revision: "1.1",
        memory: 256,
        manufacturer: "Sony UK",
        processor: "BCM2835"
      },
      "0013": {
        type: "B+",
        revision: "1.2",
        memory: 512,
        manufacturer: "Embest",
        processor: "BCM2835"
      },
      "0014": {
        type: "CM1",
        revision: "1.0",
        memory: 512,
        manufacturer: "Embest",
        processor: "BCM2835"
      },
      "0015": {
        type: "A+",
        revision: "1.1",
        memory: 256,
        manufacturer: "512MB\tEmbest",
        processor: "BCM2835"
      }
    };
    const processorList = ["BCM2835", "BCM2836", "BCM2837", "BCM2711", "BCM2712"];
    const manufacturerList = ["Sony UK", "Egoman", "Embest", "Sony Japan", "Embest", "Stadium"];
    const typeList = {
      "00": "A",
      "01": "B",
      "02": "A+",
      "03": "B+",
      "04": "2B",
      "05": "Alpha (early prototype)",
      "06": "CM1",
      "08": "3B",
      "09": "Zero",
      "0a": "CM3",
      "0c": "Zero W",
      "0d": "3B+",
      "0e": "3A+",
      "0f": "Internal use only",
      10: "CM3+",
      11: "4B",
      12: "Zero 2 W",
      13: "400",
      14: "CM4",
      15: "CM4S",
      16: "Internal use only",
      17: "5",
      18: "CM5",
      19: "500/500+",
      "1a": "CM5 Lite"
    };
    const revisionCode = getValue(lines, "revision", ":", true);
    const model = getValue(lines, "model:", ":", true);
    const serial = getValue(lines, "serial", ":", true);
    let result2 = {};
    if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {
      result2 = {
        model,
        serial,
        revisionCode,
        memory: oldRevisionCodes[revisionCode].memory,
        manufacturer: oldRevisionCodes[revisionCode].manufacturer,
        processor: oldRevisionCodes[revisionCode].processor,
        type: oldRevisionCodes[revisionCode].type,
        revision: oldRevisionCodes[revisionCode].revision
      };
    } else {
      const revision = ("00000000" + getValue(lines, "revision", ":", true).toLowerCase()).substr(-8);
      const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;
      const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];
      const processor = processorList[parseInt(revision.substr(4, 1), 10)];
      const typeCode = revision.substr(5, 2);
      result2 = {
        model,
        serial,
        revisionCode,
        memory: 256 * Math.pow(2, memSizeCode),
        manufacturer,
        processor,
        type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : "",
        revision: "1." + revision.substr(7, 1)
      };
    }
    return result2;
  }
  function getRpiGpu(cpuinfo) {
    if (_rpi_cpuinfo === null && cpuinfo !== undefined) {
      _rpi_cpuinfo = cpuinfo;
    } else if (cpuinfo === undefined && _rpi_cpuinfo !== null) {
      cpuinfo = _rpi_cpuinfo;
    } else {
      try {
        cpuinfo = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split(`
`);
        _rpi_cpuinfo = cpuinfo;
      } catch {
        return false;
      }
    }
    const rpi = decodePiCpuinfo(cpuinfo);
    if (rpi.type === "4B" || rpi.type === "CM4" || rpi.type === "CM4S" || rpi.type === "400") {
      return "VideoCore VI";
    }
    if (rpi.type === "5" || rpi.type === "500") {
      return "VideoCore VII";
    }
    return "VideoCore IV";
  }
  function promiseAll(promises) {
    const resolvingPromises = promises.map((promise) => new Promise((resolve) => {
      const payload = new Array(2);
      promise.then((result2) => {
        payload[0] = result2;
      }).catch((error2) => {
        payload[1] = error2;
      }).then(() => {
        resolve(payload);
      });
    }));
    const errors = [];
    const results = [];
    return Promise.all(resolvingPromises).then((items) => {
      items.forEach((payload) => {
        if (payload[1]) {
          errors.push(payload[1]);
          results.push(null);
        } else {
          errors.push(null);
          results.push(payload[0]);
        }
      });
      return {
        errors,
        results
      };
    });
  }
  function promisify(nodeStyleFunction) {
    return () => {
      const args = Array.prototype.slice.call(arguments);
      return new Promise((resolve, reject) => {
        args.push((err, data) => {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
        nodeStyleFunction.apply(null, args);
      });
    };
  }
  function promisifySave(nodeStyleFunction) {
    return () => {
      const args = Array.prototype.slice.call(arguments);
      return new Promise((resolve) => {
        args.push((err, data) => {
          resolve(data);
        });
        nodeStyleFunction.apply(null, args);
      });
    };
  }
  function linuxVersion() {
    let result2 = "";
    if (_linux) {
      try {
        result2 = execSync("uname -v", execOptsLinux).toString();
      } catch {
        result2 = "";
      }
    }
    return result2;
  }
  function plistParser(xmlStr) {
    const tags = ["array", "dict", "key", "string", "integer", "date", "real", "data", "boolean", "arrayEmpty"];
    const startStr = "<plist version";
    let pos = xmlStr.indexOf(startStr);
    let len = xmlStr.length;
    while (xmlStr[pos] !== ">" && pos < len) {
      pos++;
    }
    let depth = 0;
    let inTagStart = false;
    let inTagContent = false;
    let inTagEnd = false;
    let metaData = [{ tagStart: "", tagEnd: "", tagContent: "", key: "", data: null }];
    let c = "";
    let cn = xmlStr[pos];
    while (pos < len) {
      c = cn;
      if (pos + 1 < len) {
        cn = xmlStr[pos + 1];
      }
      if (c === "<") {
        inTagContent = false;
        if (cn === "/") {
          inTagEnd = true;
        } else if (metaData[depth].tagStart) {
          metaData[depth].tagContent = "";
          if (!metaData[depth].data) {
            metaData[depth].data = metaData[depth].tagStart === "array" ? [] : {};
          }
          depth++;
          metaData.push({ tagStart: "", tagEnd: "", tagContent: "", key: null, data: null });
          inTagStart = true;
          inTagContent = false;
        } else if (!inTagStart) {
          inTagStart = true;
        }
      } else if (c === ">") {
        if (metaData[depth].tagStart === "true/") {
          inTagStart = false;
          inTagEnd = true;
          metaData[depth].tagStart = "";
          metaData[depth].tagEnd = "/boolean";
          metaData[depth].data = true;
        }
        if (metaData[depth].tagStart === "false/") {
          inTagStart = false;
          inTagEnd = true;
          metaData[depth].tagStart = "";
          metaData[depth].tagEnd = "/boolean";
          metaData[depth].data = false;
        }
        if (metaData[depth].tagStart === "array/") {
          inTagStart = false;
          inTagEnd = true;
          metaData[depth].tagStart = "";
          metaData[depth].tagEnd = "/arrayEmpty";
          metaData[depth].data = [];
        }
        if (inTagContent) {
          inTagContent = false;
        }
        if (inTagStart) {
          inTagStart = false;
          inTagContent = true;
          if (metaData[depth].tagStart === "array") {
            metaData[depth].data = [];
          }
          if (metaData[depth].tagStart === "dict") {
            metaData[depth].data = {};
          }
        }
        if (inTagEnd) {
          inTagEnd = false;
          if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {
            if (metaData[depth].tagEnd === "/dict" || metaData[depth].tagEnd === "/array") {
              if (depth > 1 && metaData[depth - 2].tagStart === "array") {
                metaData[depth - 2].data.push(metaData[depth - 1].data);
              }
              if (depth > 1 && metaData[depth - 2].tagStart === "dict") {
                metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;
              }
              depth--;
              metaData.pop();
              metaData[depth].tagContent = "";
              metaData[depth].tagStart = "";
              metaData[depth].tagEnd = "";
            } else {
              if (metaData[depth].tagEnd === "/key" && metaData[depth].tagContent) {
                metaData[depth].key = metaData[depth].tagContent;
              } else {
                if (metaData[depth].tagEnd === "/real" && metaData[depth].tagContent) {
                  metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0;
                }
                if (metaData[depth].tagEnd === "/integer" && metaData[depth].tagContent) {
                  metaData[depth].data = parseInt(metaData[depth].tagContent) || 0;
                }
                if (metaData[depth].tagEnd === "/string" && metaData[depth].tagContent) {
                  metaData[depth].data = metaData[depth].tagContent || "";
                }
                if (metaData[depth].tagEnd === "/boolean") {
                  metaData[depth].data = metaData[depth].tagContent || false;
                }
                if (metaData[depth].tagEnd === "/arrayEmpty") {
                  metaData[depth].data = metaData[depth].tagContent || [];
                }
                if (depth > 0 && metaData[depth - 1].tagStart === "array") {
                  metaData[depth - 1].data.push(metaData[depth].data);
                }
                if (depth > 0 && metaData[depth - 1].tagStart === "dict") {
                  metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data;
                }
              }
              metaData[depth].tagContent = "";
              metaData[depth].tagStart = "";
              metaData[depth].tagEnd = "";
            }
          }
          metaData[depth].tagEnd = "";
          inTagStart = false;
          inTagContent = false;
        }
      } else {
        if (inTagStart) {
          metaData[depth].tagStart += c;
        }
        if (inTagEnd) {
          metaData[depth].tagEnd += c;
        }
        if (inTagContent) {
          metaData[depth].tagContent += c;
        }
      }
      pos++;
    }
    return metaData[0].data;
  }
  function strIsNumeric(str) {
    return typeof str === "string" && !isNaN(str) && !isNaN(parseFloat(str));
  }
  function plistReader(output) {
    const lines = output.split(`
`);
    for (let i = 0;i < lines.length; i++) {
      if (lines[i].indexOf(" = ") >= 0) {
        const lineParts = lines[i].split(" = ");
        lineParts[0] = lineParts[0].trim();
        if (!lineParts[0].startsWith('"')) {
          lineParts[0] = '"' + lineParts[0] + '"';
        }
        lineParts[1] = lineParts[1].trim();
        if (lineParts[1].indexOf('"') === -1 && lineParts[1].endsWith(";")) {
          const valueString = lineParts[1].substring(0, lineParts[1].length - 1);
          if (!strIsNumeric(valueString)) {
            lineParts[1] = `"${valueString}";`;
          }
        }
        if (lineParts[1].indexOf('"') >= 0 && lineParts[1].endsWith(";")) {
          const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/"/g, "");
          if (strIsNumeric(valueString)) {
            lineParts[1] = `${valueString};`;
          }
        }
        lines[i] = lineParts.join(" : ");
      }
      lines[i] = lines[i].replace(/\(/g, "[").replace(/\)/g, "]").replace(/;/g, ",").trim();
      if (lines[i].startsWith("}") && lines[i - 1] && lines[i - 1].endsWith(",")) {
        lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);
      }
    }
    output = lines.join("");
    let obj = {};
    try {
      obj = JSON.parse(output);
    } catch (e) {
      noop();
    }
    return obj;
  }
  function semverCompare(v1, v2) {
    let res = 0;
    const parts1 = v1.split(".");
    const parts2 = v2.split(".");
    if (parts1[0] < parts2[0]) {
      res = 1;
    } else if (parts1[0] > parts2[0]) {
      res = -1;
    } else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {
      if (parts1[1] < parts2[1]) {
        res = 1;
      } else if (parts1[1] > parts2[1]) {
        res = -1;
      } else if (parts1[1] === parts2[1]) {
        if (parts1.length >= 3 && parts2.length >= 3) {
          if (parts1[2] < parts2[2]) {
            res = 1;
          } else if (parts1[2] > parts2[2]) {
            res = -1;
          }
        } else if (parts2.length >= 3) {
          res = 1;
        }
      }
    }
    return res;
  }
  function getAppleModel(key) {
    const appleModelIds = [
      {
        key: "Mac15,12",
        name: "MacBook Air",
        size: "13-inch",
        processor: "M3",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac14,15",
        name: "MacBook Air",
        size: "15-inch",
        processor: "M2",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac14,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "M2",
        year: "2022",
        additional: ""
      },
      {
        key: "MacBookAir10,1",
        name: "MacBook Air",
        size: "13-inch",
        processor: "M1",
        year: "2020",
        additional: ""
      },
      {
        key: "MacBookAir9,1",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "2020",
        additional: ""
      },
      {
        key: "MacBookAir8,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "2019",
        additional: ""
      },
      {
        key: "MacBookAir8,1",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "2018",
        additional: ""
      },
      {
        key: "MacBookAir7,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "2017",
        additional: ""
      },
      {
        key: "MacBookAir7,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "Early 2015",
        additional: ""
      },
      {
        key: "MacBookAir7,1",
        name: "MacBook Air",
        size: "11-inch",
        processor: "",
        year: "Early 2015",
        additional: ""
      },
      {
        key: "MacBookAir6,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "Early 2014",
        additional: ""
      },
      {
        key: "MacBookAir6,1",
        name: "MacBook Air",
        size: "11-inch",
        processor: "",
        year: "Early 2014",
        additional: ""
      },
      {
        key: "MacBookAir6,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "Mid 2013",
        additional: ""
      },
      {
        key: "MacBookAir6,1",
        name: "MacBook Air",
        size: "11-inch",
        processor: "",
        year: "Mid 2013",
        additional: ""
      },
      {
        key: "MacBookAir5,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "Mid 2012",
        additional: ""
      },
      {
        key: "MacBookAir5,1",
        name: "MacBook Air",
        size: "11-inch",
        processor: "",
        year: "Mid 2012",
        additional: ""
      },
      {
        key: "MacBookAir4,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "Mid 2011",
        additional: ""
      },
      {
        key: "MacBookAir4,1",
        name: "MacBook Air",
        size: "11-inch",
        processor: "",
        year: "Mid 2011",
        additional: ""
      },
      {
        key: "MacBookAir3,2",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "Late 2010",
        additional: ""
      },
      {
        key: "MacBookAir3,1",
        name: "MacBook Air",
        size: "11-inch",
        processor: "",
        year: "Late 2010",
        additional: ""
      },
      {
        key: "MacBookAir2,1",
        name: "MacBook Air",
        size: "13-inch",
        processor: "",
        year: "Mid 2009",
        additional: ""
      },
      {
        key: "Mac16,1",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M4",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac16,6",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M4 Pro",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac16,8",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M4 Max",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac16,5",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M4 Pro",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac16,6",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M4 Max",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac15,3",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M3",
        year: "Nov 2023",
        additional: ""
      },
      {
        key: "Mac15,6",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M3 Pro",
        year: "Nov 2023",
        additional: ""
      },
      {
        key: "Mac15,8",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M3 Pro",
        year: "Nov 2023",
        additional: ""
      },
      {
        key: "Mac15,10",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M3 Max",
        year: "Nov 2023",
        additional: ""
      },
      {
        key: "Mac15,7",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M3 Pro",
        year: "Nov 2023",
        additional: ""
      },
      {
        key: "Mac15,9",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M3 Pro",
        year: "Nov 2023",
        additional: ""
      },
      {
        key: "Mac15,11",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M3 Max",
        year: "Nov 2023",
        additional: ""
      },
      {
        key: "Mac14,5",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M2 Max",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac14,9",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M2 Max",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac14,6",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M2 Max",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac14,10",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M2 Max",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac14,7",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "M2",
        year: "2022",
        additional: ""
      },
      {
        key: "MacBookPro18,3",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M1 Pro",
        year: "2021",
        additional: ""
      },
      {
        key: "MacBookPro18,4",
        name: "MacBook Pro",
        size: "14-inch",
        processor: "M1 Max",
        year: "2021",
        additional: ""
      },
      {
        key: "MacBookPro18,1",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M1 Pro",
        year: "2021",
        additional: ""
      },
      {
        key: "MacBookPro18,2",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "M1 Max",
        year: "2021",
        additional: ""
      },
      {
        key: "MacBookPro17,1",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "M1",
        year: "2020",
        additional: ""
      },
      {
        key: "MacBookPro16,3",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2020",
        additional: "Two Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro16,2",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2020",
        additional: "Four Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro16,1",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "",
        year: "2019",
        additional: ""
      },
      {
        key: "MacBookPro16,4",
        name: "MacBook Pro",
        size: "16-inch",
        processor: "",
        year: "2019",
        additional: ""
      },
      {
        key: "MacBookPro15,3",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "2019",
        additional: ""
      },
      {
        key: "MacBookPro15,2",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2019",
        additional: ""
      },
      {
        key: "MacBookPro15,1",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "2019",
        additional: ""
      },
      {
        key: "MacBookPro15,4",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2019",
        additional: "Two Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro15,1",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "2018",
        additional: ""
      },
      {
        key: "MacBookPro15,2",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2018",
        additional: "Four Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro14,1",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2017",
        additional: "Two Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro14,2",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2017",
        additional: "Four Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro14,3",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "2017",
        additional: ""
      },
      {
        key: "MacBookPro13,1",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2016",
        additional: "Two Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro13,2",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "2016",
        additional: "Four Thunderbolt 3 ports"
      },
      {
        key: "MacBookPro13,3",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "2016",
        additional: ""
      },
      {
        key: "MacBookPro11,4",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Mid 2015",
        additional: ""
      },
      {
        key: "MacBookPro11,5",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Mid 2015",
        additional: ""
      },
      {
        key: "MacBookPro12,1",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "Early 2015",
        additional: ""
      },
      {
        key: "MacBookPro11,2",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Late 2013",
        additional: ""
      },
      {
        key: "MacBookPro11,3",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Late 2013",
        additional: ""
      },
      {
        key: "MacBookPro11,1",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "Late 2013",
        additional: ""
      },
      {
        key: "MacBookPro10,1",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Mid 2012",
        additional: ""
      },
      {
        key: "MacBookPro10,2",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "Late 2012",
        additional: ""
      },
      {
        key: "MacBookPro9,1",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Mid 2012",
        additional: ""
      },
      {
        key: "MacBookPro9,2",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "Mid 2012",
        additional: ""
      },
      {
        key: "MacBookPro8,3",
        name: "MacBook Pro",
        size: "17-inch",
        processor: "",
        year: "Early 2011",
        additional: ""
      },
      {
        key: "MacBookPro8,2",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Early 2011",
        additional: ""
      },
      {
        key: "MacBookPro8,1",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "Early 2011",
        additional: ""
      },
      {
        key: "MacBookPro6,1",
        name: "MacBook Pro",
        size: "17-inch",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "MacBookPro6,2",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "MacBookPro7,1",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "MacBookPro5,2",
        name: "MacBook Pro",
        size: "17-inch",
        processor: "",
        year: "Early 2009",
        additional: ""
      },
      {
        key: "MacBookPro5,3",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Mid 2009",
        additional: ""
      },
      {
        key: "MacBookPro5,5",
        name: "MacBook Pro",
        size: "13-inch",
        processor: "",
        year: "Mid 2009",
        additional: ""
      },
      {
        key: "MacBookPro5,1",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Late 2008",
        additional: ""
      },
      {
        key: "MacBookPro4,1",
        name: "MacBook Pro",
        size: "15-inch",
        processor: "",
        year: "Early 2008",
        additional: ""
      },
      {
        key: "MacBook10,1",
        name: "MacBook",
        size: "12-inch",
        processor: "",
        year: "2017",
        additional: ""
      },
      {
        key: "MacBook9,1",
        name: "MacBook",
        size: "12-inch",
        processor: "",
        year: "Early 2016",
        additional: ""
      },
      {
        key: "MacBook8,1",
        name: "MacBook",
        size: "12-inch",
        processor: "",
        year: "Early 2015",
        additional: ""
      },
      {
        key: "MacBook7,1",
        name: "MacBook",
        size: "13-inch",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "MacBook6,1",
        name: "MacBook",
        size: "13-inch",
        processor: "",
        year: "Late 2009",
        additional: ""
      },
      {
        key: "MacBook5,2",
        name: "MacBook",
        size: "13-inch",
        processor: "",
        year: "Early 2009",
        additional: ""
      },
      {
        key: "Mac14,13",
        name: "Mac Studio",
        size: "",
        processor: "M2 Max",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac14,14",
        name: "Mac Studio",
        size: "",
        processor: "M2 Ultra",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac15,14",
        name: "Mac Studio",
        size: "",
        processor: "M3 Ultra",
        year: "2025",
        additional: ""
      },
      {
        key: "Mac16,9",
        name: "Mac Studio",
        size: "",
        processor: "M4 Max",
        year: "2025",
        additional: ""
      },
      {
        key: "Mac13,1",
        name: "Mac Studio",
        size: "",
        processor: "M1 Max",
        year: "2022",
        additional: ""
      },
      {
        key: "Mac13,2",
        name: "Mac Studio",
        size: "",
        processor: "M1 Ultra",
        year: "2022",
        additional: ""
      },
      {
        key: "Mac16,11",
        name: "Mac mini",
        size: "",
        processor: "M4 Pro",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac16,10",
        name: "Mac mini",
        size: "",
        processor: "M4",
        year: "2024",
        additional: ""
      },
      {
        key: "Mac14,3",
        name: "Mac mini",
        size: "",
        processor: "M2",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac14,12",
        name: "Mac mini",
        size: "",
        processor: "M2 Pro",
        year: "2023",
        additional: ""
      },
      {
        key: "Macmini9,1",
        name: "Mac mini",
        size: "",
        processor: "M1",
        year: "2020",
        additional: ""
      },
      {
        key: "Macmini8,1",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Late 2018",
        additional: ""
      },
      {
        key: "Macmini7,1",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Late 2014",
        additional: ""
      },
      {
        key: "Macmini6,1",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Late 2012",
        additional: ""
      },
      {
        key: "Macmini6,2",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Late 2012",
        additional: ""
      },
      {
        key: "Macmini5,1",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Mid 2011",
        additional: ""
      },
      {
        key: "Macmini5,2",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Mid 2011",
        additional: ""
      },
      {
        key: "Macmini4,1",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "Macmini3,1",
        name: "Mac mini",
        size: "",
        processor: "",
        year: "Early 2009",
        additional: ""
      },
      {
        key: "Mac16,3",
        name: "iMac",
        size: "24-inch",
        processor: "M4",
        year: "2024",
        additional: "Four ports"
      },
      {
        key: "Mac16,2",
        name: "iMac",
        size: "24-inch",
        processor: "M4",
        year: "2024",
        additional: "Two ports"
      },
      {
        key: "Mac15,5",
        name: "iMac",
        size: "24-inch",
        processor: "M3",
        year: "2023",
        additional: "Four ports"
      },
      {
        key: "Mac15,4",
        name: "iMac",
        size: "24-inch",
        processor: "M3",
        year: "2023",
        additional: "Two ports"
      },
      {
        key: "iMac21,1",
        name: "iMac",
        size: "24-inch",
        processor: "M1",
        year: "2021",
        additional: ""
      },
      {
        key: "iMac21,2",
        name: "iMac",
        size: "24-inch",
        processor: "M1",
        year: "2021",
        additional: ""
      },
      {
        key: "iMac20,1",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "2020",
        additional: "Retina 5K"
      },
      {
        key: "iMac20,2",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "2020",
        additional: "Retina 5K"
      },
      {
        key: "iMac19,1",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "2019",
        additional: "Retina 5K"
      },
      {
        key: "iMac19,2",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "2019",
        additional: "Retina 4K"
      },
      {
        key: "iMacPro1,1",
        name: "iMac Pro",
        size: "",
        processor: "",
        year: "2017",
        additional: ""
      },
      {
        key: "iMac18,3",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "2017",
        additional: "Retina 5K"
      },
      {
        key: "iMac18,2",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "2017",
        additional: "Retina 4K"
      },
      {
        key: "iMac18,1",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "2017",
        additional: ""
      },
      {
        key: "iMac17,1",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "Late 2015",
        additional: "Retina 5K"
      },
      {
        key: "iMac16,2",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Late 2015",
        additional: "Retina 4K"
      },
      {
        key: "iMac16,1",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Late 2015",
        additional: ""
      },
      {
        key: "iMac15,1",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "Late 2014",
        additional: "Retina 5K"
      },
      {
        key: "iMac14,4",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Mid 2014",
        additional: ""
      },
      {
        key: "iMac14,2",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "Late 2013",
        additional: ""
      },
      {
        key: "iMac14,1",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Late 2013",
        additional: ""
      },
      {
        key: "iMac13,2",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "Late 2012",
        additional: ""
      },
      {
        key: "iMac13,1",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Late 2012",
        additional: ""
      },
      {
        key: "iMac12,2",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "Mid 2011",
        additional: ""
      },
      {
        key: "iMac12,1",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Mid 2011",
        additional: ""
      },
      {
        key: "iMac11,3",
        name: "iMac",
        size: "27-inch",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "iMac11,2",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "iMac10,1",
        name: "iMac",
        size: "21.5-inch",
        processor: "",
        year: "Late 2009",
        additional: ""
      },
      {
        key: "iMac9,1",
        name: "iMac",
        size: "20-inch",
        processor: "",
        year: "Early 2009",
        additional: ""
      },
      {
        key: "Mac14,8",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "2023",
        additional: ""
      },
      {
        key: "Mac14,8",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "2023",
        additional: "Rack"
      },
      {
        key: "MacPro7,1",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "2019",
        additional: ""
      },
      {
        key: "MacPro7,1",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "2019",
        additional: "Rack"
      },
      {
        key: "MacPro6,1",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "Late 2013",
        additional: ""
      },
      {
        key: "MacPro5,1",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "Mid 2012",
        additional: ""
      },
      {
        key: "MacPro5,1",
        name: "Mac Pro Server",
        size: "",
        processor: "",
        year: "Mid 2012",
        additional: "Server"
      },
      {
        key: "MacPro5,1",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "Mid 2010",
        additional: ""
      },
      {
        key: "MacPro5,1",
        name: "Mac Pro Server",
        size: "",
        processor: "",
        year: "Mid 2010",
        additional: "Server"
      },
      {
        key: "MacPro4,1",
        name: "Mac Pro",
        size: "",
        processor: "",
        year: "Early 2009",
        additional: ""
      }
    ];
    const list = appleModelIds.filter((model) => model.key === key);
    if (list.length === 0) {
      return {
        key,
        model: "Apple",
        version: "Unknown"
      };
    }
    const features = [];
    if (list[0].size) {
      features.push(list[0].size);
    }
    if (list[0].processor) {
      features.push(list[0].processor);
    }
    if (list[0].year) {
      features.push(list[0].year);
    }
    if (list[0].additional) {
      features.push(list[0].additional);
    }
    return {
      key,
      model: list[0].name,
      version: list[0].name + " (" + features.join(", ") + ")"
    };
  }
  function checkWebsite(url, timeout = 5000) {
    const http = url.startsWith("https:") || url.indexOf(":443/") > 0 || url.indexOf(":8443/") > 0 ? __require("https") : __require("http");
    const t = Date.now();
    return new Promise((resolve) => {
      const request = http.get(url, (res) => {
        res.on("data", () => {});
        res.on("end", () => {
          resolve({
            url,
            statusCode: res.statusCode,
            message: res.statusMessage,
            time: Date.now() - t
          });
        });
      }).on("error", (e) => {
        resolve({
          url,
          statusCode: 404,
          message: e.message,
          time: Date.now() - t
        });
      }).setTimeout(timeout, () => {
        request.destroy();
        resolve({
          url,
          statusCode: 408,
          message: "Request Timeout",
          time: Date.now() - t
        });
      });
    });
  }
  function cleanString(str) {
    return str.replace(/To Be Filled By O.E.M./g, "");
  }
  function noop() {}
  exports.toInt = toInt;
  exports.splitByNumber = splitByNumber;
  exports.execOptsWin = execOptsWin;
  exports.execOptsLinux = execOptsLinux;
  exports.getCodepage = getCodepage;
  exports.execWin = execWin;
  exports.isFunction = isFunction;
  exports.unique = unique;
  exports.sortByKey = sortByKey;
  exports.cores = cores;
  exports.getValue = getValue;
  exports.decodeEscapeSequence = decodeEscapeSequence;
  exports.parseDateTime = parseDateTime;
  exports.parseHead = parseHead;
  exports.findObjectByKey = findObjectByKey;
  exports.darwinXcodeExists = darwinXcodeExists;
  exports.getVboxmanage = getVboxmanage;
  exports.powerShell = powerShell;
  exports.powerShellStart = powerShellStart;
  exports.powerShellRelease = powerShellRelease;
  exports.execSafe = execSafe;
  exports.nanoSeconds = nanoSeconds;
  exports.countUniqueLines = countUniqueLines;
  exports.countLines = countLines;
  exports.noop = noop;
  exports.isRaspberry = isRaspberry;
  exports.isRaspbian = isRaspbian;
  exports.sanitizeShellString = sanitizeShellString;
  exports.isPrototypePolluted = isPrototypePolluted;
  exports.decodePiCpuinfo = decodePiCpuinfo;
  exports.getRpiGpu = getRpiGpu;
  exports.promiseAll = promiseAll;
  exports.promisify = promisify;
  exports.promisifySave = promisifySave;
  exports.smartMonToolsInstalled = smartMonToolsInstalled;
  exports.linuxVersion = linuxVersion;
  exports.plistParser = plistParser;
  exports.plistReader = plistReader;
  exports.stringObj = stringObj;
  exports.stringReplace = stringReplace;
  exports.stringToLower = stringToLower;
  exports.stringToString = stringToString;
  exports.stringSubstr = stringSubstr;
  exports.stringSubstring = stringSubstring;
  exports.stringTrim = stringTrim;
  exports.stringStartWith = stringStartWith;
  exports.mathMin = mathMin;
  exports.WINDIR = WINDIR;
  exports.getFilesInPath = getFilesInPath;
  exports.semverCompare = semverCompare;
  exports.getAppleModel = getAppleModel;
  exports.checkWebsite = checkWebsite;
  exports.cleanString = cleanString;
  exports.getPowershell = getPowershell;
});

// node_modules/systeminformation/lib/osinfo.js
var require_osinfo = __commonJS((exports) => {
  var os = __require("os");
  var fs = __require("fs");
  var util = require_util7();
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function time() {
    const t = new Date().toString().split(" ");
    let timezoneName = "";
    try {
      timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch {
      timezoneName = t.length >= 7 ? t.slice(6).join(" ").replace(/\(/g, "").replace(/\)/g, "") : "";
    }
    const result2 = {
      current: Date.now(),
      uptime: os.uptime(),
      timezone: t.length >= 7 ? t[5] : "",
      timezoneName
    };
    if (_darwin || _linux) {
      try {
        const stdout = execSync("date +%Z && date +%z && ls -l /etc/localtime 2>/dev/null", util.execOptsLinux);
        const lines = stdout.toString().split(os.EOL);
        if (lines.length > 3 && !lines[0]) {
          lines.shift();
        }
        let timezone = lines[0] || "";
        if (timezone.startsWith("+") || timezone.startsWith("-")) {
          timezone = "GMT";
        }
        return {
          current: Date.now(),
          uptime: os.uptime(),
          timezone: lines[1] ? timezone + lines[1] : timezone,
          timezoneName: lines[2] && lines[2].indexOf("/zoneinfo/") > 0 ? lines[2].split("/zoneinfo/")[1] || "" : ""
        };
      } catch {
        util.noop();
      }
    }
    return result2;
  }
  exports.time = time;
  function getLogoFile(distro) {
    distro = distro || "";
    distro = distro.toLowerCase();
    let result2 = _platform;
    if (_windows) {
      result2 = "windows";
    } else if (distro.indexOf("mac os") !== -1 || distro.indexOf("macos") !== -1) {
      result2 = "apple";
    } else if (distro.indexOf("arch") !== -1) {
      result2 = "arch";
    } else if (distro.indexOf("cachy") !== -1) {
      result2 = "cachy";
    } else if (distro.indexOf("centos") !== -1) {
      result2 = "centos";
    } else if (distro.indexOf("coreos") !== -1) {
      result2 = "coreos";
    } else if (distro.indexOf("debian") !== -1) {
      result2 = "debian";
    } else if (distro.indexOf("deepin") !== -1) {
      result2 = "deepin";
    } else if (distro.indexOf("elementary") !== -1) {
      result2 = "elementary";
    } else if (distro.indexOf("endeavour") !== -1) {
      result2 = "endeavour";
    } else if (distro.indexOf("fedora") !== -1) {
      result2 = "fedora";
    } else if (distro.indexOf("gentoo") !== -1) {
      result2 = "gentoo";
    } else if (distro.indexOf("mageia") !== -1) {
      result2 = "mageia";
    } else if (distro.indexOf("mandriva") !== -1) {
      result2 = "mandriva";
    } else if (distro.indexOf("manjaro") !== -1) {
      result2 = "manjaro";
    } else if (distro.indexOf("mint") !== -1) {
      result2 = "mint";
    } else if (distro.indexOf("mx") !== -1) {
      result2 = "mx";
    } else if (distro.indexOf("openbsd") !== -1) {
      result2 = "openbsd";
    } else if (distro.indexOf("freebsd") !== -1) {
      result2 = "freebsd";
    } else if (distro.indexOf("opensuse") !== -1) {
      result2 = "opensuse";
    } else if (distro.indexOf("pclinuxos") !== -1) {
      result2 = "pclinuxos";
    } else if (distro.indexOf("puppy") !== -1) {
      result2 = "puppy";
    } else if (distro.indexOf("popos") !== -1) {
      result2 = "popos";
    } else if (distro.indexOf("raspbian") !== -1) {
      result2 = "raspbian";
    } else if (distro.indexOf("reactos") !== -1) {
      result2 = "reactos";
    } else if (distro.indexOf("redhat") !== -1) {
      result2 = "redhat";
    } else if (distro.indexOf("slackware") !== -1) {
      result2 = "slackware";
    } else if (distro.indexOf("sugar") !== -1) {
      result2 = "sugar";
    } else if (distro.indexOf("steam") !== -1) {
      result2 = "steam";
    } else if (distro.indexOf("suse") !== -1) {
      result2 = "suse";
    } else if (distro.indexOf("mate") !== -1) {
      result2 = "ubuntu-mate";
    } else if (distro.indexOf("lubuntu") !== -1) {
      result2 = "lubuntu";
    } else if (distro.indexOf("xubuntu") !== -1) {
      result2 = "xubuntu";
    } else if (distro.indexOf("ubuntu") !== -1) {
      result2 = "ubuntu";
    } else if (distro.indexOf("solaris") !== -1) {
      result2 = "solaris";
    } else if (distro.indexOf("tails") !== -1) {
      result2 = "tails";
    } else if (distro.indexOf("feren") !== -1) {
      result2 = "ferenos";
    } else if (distro.indexOf("robolinux") !== -1) {
      result2 = "robolinux";
    } else if (_linux && distro) {
      result2 = distro.toLowerCase().trim().replace(/\s+/g, "-");
    }
    return result2;
  }
  var WINDOWS_RELEASES = [
    [26200, "25H2"],
    [26100, "24H2"],
    [22631, "23H2"],
    [22621, "22H2"],
    [19045, "22H2"],
    [22000, "21H2"],
    [19044, "21H2"],
    [19043, "21H1"],
    [19042, "20H2"],
    [19041, "2004"],
    [18363, "1909"],
    [18362, "1903"],
    [17763, "1809"],
    [17134, "1803"]
  ];
  function getWindowsRelease(build) {
    for (const [minBuild, label] of WINDOWS_RELEASES) {
      if (build >= minBuild)
        return label;
    }
    return "";
  }
  function getFQDN() {
    let fqdn = os.hostname;
    if (_linux || _darwin) {
      try {
        const stdout = execSync("hostname -f 2>/dev/null", util.execOptsLinux);
        fqdn = stdout.toString().split(os.EOL)[0];
      } catch {
        util.noop();
      }
    }
    if (_freebsd || _openbsd || _netbsd) {
      try {
        const stdout = execSync("hostname 2>/dev/null");
        fqdn = stdout.toString().split(os.EOL)[0];
      } catch {
        util.noop();
      }
    }
    if (_windows) {
      try {
        const stdout = execSync("echo %COMPUTERNAME%.%USERDNSDOMAIN%", util.execOptsWin);
        fqdn = stdout.toString().replace(".%USERDNSDOMAIN%", "").split(os.EOL)[0];
      } catch {
        util.noop();
      }
    }
    return fqdn;
  }
  function osInfo(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          platform: _platform === "win32" ? "Windows" : _platform,
          distro: "unknown",
          release: "unknown",
          codename: "",
          kernel: os.release(),
          arch: os.arch(),
          hostname: os.hostname(),
          fqdn: getFQDN(),
          codepage: "",
          logofile: "",
          serial: "",
          build: "",
          servicepack: "",
          uefi: false
        };
        if (_linux) {
          exec("cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release", (error2, stdout) => {
            let release = {};
            let lines = stdout.toString().split(`
`);
            lines.forEach((line) => {
              if (line.indexOf("=") !== -1) {
                release[line.split("=")[0].trim().toUpperCase()] = line.split("=")[1].trim();
              }
            });
            result2.distro = (release.DISTRIB_ID || release.NAME || "unknown").replace(/"/g, "");
            result2.logofile = getLogoFile(result2.distro);
            let releaseVersion = (release.VERSION || "").replace(/"/g, "");
            let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || "").replace(/"/g, "");
            const prettyName = (release.PRETTY_NAME || "").replace(/"/g, "");
            if (prettyName.indexOf(result2.distro + " ") === 0) {
              releaseVersion = prettyName.replace(result2.distro + " ", "").trim();
            }
            if (releaseVersion.indexOf("(") >= 0) {
              codename = releaseVersion.split("(")[1].replace(/[()]/g, "").trim();
              releaseVersion = releaseVersion.split("(")[0].trim();
            }
            result2.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || "unknown").replace(/"/g, "");
            result2.codename = codename;
            result2.codepage = util.getCodepage();
            result2.build = (release.BUILD_ID || "").replace(/"/g, "").trim();
            isUefiLinux().then((uefi) => {
              result2.uefi = uefi;
              uuid().then((data) => {
                result2.serial = data.os;
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            });
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml", (error2, stdout) => {
            let lines = stdout.toString().split(`
`);
            const distro = util.getValue(lines, "kern.ostype");
            const logofile = getLogoFile(distro);
            const release = util.getValue(lines, "kern.osrelease").split("-")[0];
            const serial = util.getValue(lines, "kern.uuid");
            const bootmethod = util.getValue(lines, "machdep.bootmethod");
            const uefiConf = stdout.toString().indexOf("<type>efi</type>") >= 0;
            const uefi = bootmethod ? bootmethod.toLowerCase().indexOf("uefi") >= 0 : uefiConf ? uefiConf : null;
            result2.distro = distro || result2.distro;
            result2.logofile = logofile || result2.logofile;
            result2.release = release || result2.release;
            result2.serial = serial || result2.serial;
            result2.codename = "";
            result2.codepage = util.getCodepage();
            result2.uefi = uefi || null;
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          exec("sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid", (error2, stdout) => {
            let lines = stdout.toString().split(`
`);
            result2.serial = util.getValue(lines, "kern.uuid");
            result2.distro = util.getValue(lines, "ProductName");
            result2.release = (util.getValue(lines, "ProductVersion", ":", true, true) + " " + util.getValue(lines, "ProductVersionExtra", ":", true, true)).trim();
            result2.build = util.getValue(lines, "BuildVersion");
            result2.logofile = getLogoFile(result2.distro);
            result2.codename = "macOS";
            result2.codename = result2.release.indexOf("10.4") > -1 ? "OS X Tiger" : result2.codename;
            result2.codename = result2.release.indexOf("10.5") > -1 ? "OS X Leopard" : result2.codename;
            result2.codename = result2.release.indexOf("10.6") > -1 ? "OS X Snow Leopard" : result2.codename;
            result2.codename = result2.release.indexOf("10.7") > -1 ? "OS X Lion" : result2.codename;
            result2.codename = result2.release.indexOf("10.8") > -1 ? "OS X Mountain Lion" : result2.codename;
            result2.codename = result2.release.indexOf("10.9") > -1 ? "OS X Mavericks" : result2.codename;
            result2.codename = result2.release.indexOf("10.10") > -1 ? "OS X Yosemite" : result2.codename;
            result2.codename = result2.release.indexOf("10.11") > -1 ? "OS X El Capitan" : result2.codename;
            result2.codename = result2.release.indexOf("10.12") > -1 ? "Sierra" : result2.codename;
            result2.codename = result2.release.indexOf("10.13") > -1 ? "High Sierra" : result2.codename;
            result2.codename = result2.release.indexOf("10.14") > -1 ? "Mojave" : result2.codename;
            result2.codename = result2.release.indexOf("10.15") > -1 ? "Catalina" : result2.codename;
            result2.codename = result2.release.startsWith("11.") ? "Big Sur" : result2.codename;
            result2.codename = result2.release.startsWith("12.") ? "Monterey" : result2.codename;
            result2.codename = result2.release.startsWith("13.") ? "Ventura" : result2.codename;
            result2.codename = result2.release.startsWith("14.") ? "Sonoma" : result2.codename;
            result2.codename = result2.release.startsWith("15.") ? "Sequoia" : result2.codename;
            result2.codename = result2.release.startsWith("26.") ? "Tahoe" : result2.codename;
            result2.uefi = true;
            result2.codepage = util.getCodepage();
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          result2.release = result2.kernel;
          exec("uname -o", (error2, stdout) => {
            const lines = stdout.toString().split(`
`);
            result2.distro = lines[0];
            result2.logofile = getLogoFile(result2.distro);
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          result2.logofile = getLogoFile();
          result2.release = result2.kernel;
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl"));
            workload.push(util.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
            workload.push(util.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession"));
            workload.push(util.powerShell('reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion" /v DisplayVersion'));
            util.promiseAll(workload).then((data) => {
              const lines = data.results[0] ? data.results[0].toString().split(`\r
`) : [""];
              result2.distro = util.getValue(lines, "Caption", ":").trim();
              result2.serial = util.getValue(lines, "SerialNumber", ":").trim();
              result2.build = util.getValue(lines, "BuildNumber", ":").trim();
              result2.servicepack = util.getValue(lines, "ServicePackMajorVersion", ":").trim() + "." + util.getValue(lines, "ServicePackMinorVersion", ":").trim();
              result2.codepage = util.getCodepage();
              const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : "";
              result2.hypervisor = hyperv.indexOf("true") !== -1;
              const term = data.results[2] ? data.results[2].toString() : "";
              if (data.results[3]) {
                const codenameParts = data.results[3].split("REG_SZ");
                result2.codename = codenameParts.length > 1 ? codenameParts[1].trim() : "";
              }
              if (!result2.codename) {
                const buildNum = parseInt(result2.build, 10);
                result2.codename = getWindowsRelease(buildNum);
              }
              result2.remoteSession = term.toString().toLowerCase().indexOf("true") >= 0;
              isUefiWindows().then((uefi) => {
                result2.uefi = uefi;
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.osInfo = osInfo;
  function isUefiLinux() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        fs.stat("/sys/firmware/efi", (err) => {
          if (!err) {
            return resolve(true);
          } else {
            exec('dmesg | grep -E "EFI v"', (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`);
                return resolve(lines.length > 0);
              }
              return resolve(false);
            });
          }
        });
      });
    });
  }
  function isUefiWindows() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          exec('findstr /C:"Detected boot environment" "%windir%\\Panther\\setupact.log"', util.execOptsWin, (error2, stdout) => {
            if (!error2) {
              const line = stdout.toString().split(`
\r`)[0];
              return resolve(line.toLowerCase().indexOf("efi") >= 0);
            } else {
              exec("echo %firmware_type%", util.execOptsWin, (error3, stdout2) => {
                if (!error3) {
                  const line = stdout2.toString() || "";
                  return resolve(line.toLowerCase().indexOf("efi") >= 0);
                } else {
                  return resolve(false);
                }
              });
            }
          });
        } catch {
          return resolve(false);
        }
      });
    });
  }
  function versions(apps, callback) {
    let versionObject = {
      kernel: os.release(),
      apache: "",
      bash: "",
      bun: "",
      deno: "",
      docker: "",
      dotnet: "",
      fish: "",
      gcc: "",
      git: "",
      grunt: "",
      gulp: "",
      homebrew: "",
      java: "",
      mongodb: "",
      mysql: "",
      nginx: "",
      node: "",
      npm: "",
      openssl: "",
      perl: "",
      php: "",
      pip3: "",
      pip: "",
      pm2: "",
      postfix: "",
      postgresql: "",
      powershell: "",
      python3: "",
      python: "",
      redis: "",
      systemOpenssl: "",
      systemOpensslLib: "",
      tsc: "",
      v8: process.versions.v8,
      virtualbox: "",
      yarn: "",
      zsh: ""
    };
    function checkVersionParam(apps2) {
      if (apps2 === "*") {
        return {
          versions: versionObject,
          counter: 34
        };
      }
      if (!Array.isArray(apps2)) {
        apps2 = apps2.trim().toLowerCase().replace(/,+/g, "|").replace(/ /g, "|");
        apps2 = apps2.split("|");
        const result2 = {
          versions: {},
          counter: 0
        };
        apps2.forEach((el) => {
          if (el) {
            for (let key in versionObject) {
              if ({}.hasOwnProperty.call(versionObject, key)) {
                if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result2.versions, key)) {
                  result2.versions[key] = versionObject[key];
                  if (key === "openssl") {
                    result2.versions.systemOpenssl = "";
                    result2.versions.systemOpensslLib = "";
                  }
                  if (!result2.versions[key]) {
                    result2.counter++;
                  }
                }
              }
            }
          }
        });
        return result2;
      }
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (util.isFunction(apps) && !callback) {
          callback = apps;
          apps = "*";
        } else {
          apps = apps || "*";
          if (typeof apps !== "string") {
            if (callback) {
              callback({});
            }
            return resolve({});
          }
        }
        const appsObj = checkVersionParam(apps);
        let totalFunctions = appsObj.counter;
        let functionProcessed = (() => {
          return () => {
            if (--totalFunctions === 0) {
              if (callback) {
                callback(appsObj.versions);
              }
              resolve(appsObj.versions);
            }
          };
        })();
        let cmd = "";
        try {
          if ({}.hasOwnProperty.call(appsObj.versions, "openssl")) {
            appsObj.versions.openssl = process.versions.openssl;
            exec("openssl version", (error2, stdout) => {
              if (!error2) {
                let openssl_string = stdout.toString().split(`
`)[0].trim();
                let openssl = openssl_string.split(" ");
                appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];
                appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : "openssl";
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "npm")) {
            exec("npm -v", (error2, stdout) => {
              if (!error2) {
                appsObj.versions.npm = stdout.toString().split(`
`)[0];
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "pm2")) {
            cmd = "pm2";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} -v`, (error2, stdout) => {
              if (!error2) {
                let pm2 = stdout.toString().split(`
`)[0].trim();
                if (!pm2.startsWith("[PM2]")) {
                  appsObj.versions.pm2 = pm2;
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "yarn")) {
            exec("yarn --version", (error2, stdout) => {
              if (!error2) {
                appsObj.versions.yarn = stdout.toString().split(`
`)[0];
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "gulp")) {
            cmd = "gulp";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} --version`, (error2, stdout) => {
              if (!error2) {
                const gulp = stdout.toString().split(`
`)[0] || "";
                appsObj.versions.gulp = (gulp.toLowerCase().split("version")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "homebrew")) {
            cmd = "brew";
            exec(`${cmd} --version`, (error2, stdout) => {
              if (!error2) {
                const brew = stdout.toString().split(`
`)[0] || "";
                appsObj.versions.homebrew = (brew.toLowerCase().split(" ")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "tsc")) {
            cmd = "tsc";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} --version`, (error2, stdout) => {
              if (!error2) {
                const tsc = stdout.toString().split(`
`)[0] || "";
                appsObj.versions.tsc = (tsc.toLowerCase().split("version")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "grunt")) {
            cmd = "grunt";
            if (_windows) {
              cmd += ".cmd";
            }
            exec(`${cmd} --version`, (error2, stdout) => {
              if (!error2) {
                const grunt = stdout.toString().split(`
`)[0] || "";
                appsObj.versions.grunt = (grunt.toLowerCase().split("cli v")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "git")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/git") || fs.existsSync("/opt/homebrew/bin/git");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("git --version", (error2, stdout) => {
                  if (!error2) {
                    let git = stdout.toString().split(`
`)[0] || "";
                    git = (git.toLowerCase().split("version")[1] || "").trim();
                    appsObj.versions.git = (git.split(" ")[0] || "").trim();
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("git --version", (error2, stdout) => {
                if (!error2) {
                  let git = stdout.toString().split(`
`)[0] || "";
                  git = (git.toLowerCase().split("version")[1] || "").trim();
                  appsObj.versions.git = (git.split(" ")[0] || "").trim();
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "apache")) {
            exec("apachectl -v 2>&1", (error2, stdout) => {
              if (!error2) {
                const apache = (stdout.toString().split(`
`)[0] || "").split(":");
                appsObj.versions.apache = apache.length > 1 ? apache[1].replace("Apache", "").replace("/", "").split("(")[0].trim() : "";
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "nginx")) {
            exec("nginx -v 2>&1", (error2, stdout) => {
              if (!error2) {
                const nginx = stdout.toString().split(`
`)[0] || "";
                appsObj.versions.nginx = (nginx.toLowerCase().split("/")[1] || "").trim();
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "mysql")) {
            exec("mysql -V", (error2, stdout) => {
              if (!error2) {
                let mysql = stdout.toString().split(`
`)[0] || "";
                mysql = mysql.toLowerCase();
                if (mysql.indexOf(",") > -1) {
                  mysql = (mysql.split(",")[0] || "").trim();
                  const parts = mysql.split(" ");
                  appsObj.versions.mysql = (parts[parts.length - 1] || "").trim();
                } else {
                  if (mysql.indexOf(" ver ") > -1) {
                    mysql = mysql.split(" ver ")[1];
                    appsObj.versions.mysql = mysql.split(" ")[0];
                  }
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "php")) {
            exec("php -v", (error2, stdout) => {
              if (!error2) {
                const php = stdout.toString().split(`
`)[0] || "";
                let parts = php.split("(");
                if (parts[0].indexOf("-")) {
                  parts = parts[0].split("-");
                }
                appsObj.versions.php = parts[0].replace(/[^0-9.]/g, "");
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "redis")) {
            exec("redis-server --version", (error2, stdout) => {
              if (!error2) {
                const redis = stdout.toString().split(`
`)[0] || "";
                const parts = redis.split(" ");
                appsObj.versions.redis = util.getValue(parts, "v", "=", true);
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "docker")) {
            exec("docker --version", (error2, stdout) => {
              if (!error2) {
                const docker = stdout.toString().split(`
`)[0] || "";
                const parts = docker.split(" ");
                appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(",") ? parts[2].slice(0, -1) : "";
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "postfix")) {
            exec("postconf -d | grep mail_version", (error2, stdout) => {
              if (!error2) {
                const postfix = stdout.toString().split(`
`) || [];
                appsObj.versions.postfix = util.getValue(postfix, "mail_version", "=", true);
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "mongodb")) {
            exec("mongod --version", (error2, stdout) => {
              if (!error2) {
                const mongodb = stdout.toString().split(`
`)[0] || "";
                appsObj.versions.mongodb = (mongodb.toLowerCase().split(",")[0] || "").replace(/[^0-9.]/g, "");
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "postgresql")) {
            if (_linux) {
              exec("locate bin/postgres", (error2, stdout) => {
                if (!error2) {
                  const postgresqlBin = stdout.toString().split(`
`).sort();
                  if (postgresqlBin.length) {
                    exec(postgresqlBin[postgresqlBin.length - 1] + " -V", (error3, stdout2) => {
                      if (!error3) {
                        const postgresql = stdout2.toString().split(`
`)[0].split(" ") || [];
                        appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                      }
                      functionProcessed();
                    });
                  } else {
                    functionProcessed();
                  }
                } else {
                  exec("psql -V", (error3, stdout2) => {
                    if (!error3) {
                      const postgresql = stdout2.toString().split(`
`)[0].split(" ") || [];
                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                      appsObj.versions.postgresql = appsObj.versions.postgresql.split("-")[0];
                    }
                    functionProcessed();
                  });
                }
              });
            } else {
              if (_windows) {
                util.powerShell("Get-CimInstance Win32_Service | select caption | fl").then((stdout) => {
                  let serviceSections = stdout.split(/\n\s*\n/);
                  serviceSections.forEach((item) => {
                    if (item.trim() !== "") {
                      let lines = item.trim().split(`\r
`);
                      let srvCaption = util.getValue(lines, "caption", ":", true).toLowerCase();
                      if (srvCaption.indexOf("postgresql") > -1) {
                        const parts = srvCaption.split(" server ");
                        if (parts.length > 1) {
                          appsObj.versions.postgresql = parts[1];
                        }
                      }
                    }
                  });
                  functionProcessed();
                });
              } else {
                exec("postgres -V", (error2, stdout) => {
                  if (!error2) {
                    const postgresql = stdout.toString().split(`
`)[0].split(" ") || [];
                    appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                  } else {
                    exec("pg_config --version", (error3, stdout2) => {
                      if (!error3) {
                        const postgresql = stdout2.toString().split(`
`)[0].split(" ") || [];
                        appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                      }
                    });
                  }
                  functionProcessed();
                });
              }
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "perl")) {
            exec("perl -v", (error2, stdout) => {
              if (!error2) {
                const perl = stdout.toString().split(`
`) || "";
                while (perl.length > 0 && perl[0].trim() === "") {
                  perl.shift();
                }
                if (perl.length > 0) {
                  appsObj.versions.perl = perl[0].split("(").pop().split(")")[0].replace("v", "");
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "python")) {
            if (_darwin) {
              try {
                const stdout = execSync("sw_vers");
                const lines = stdout.toString().split(`
`);
                const osVersion = util.getValue(lines, "ProductVersion", ":");
                const gitHomebrewExists1 = fs.existsSync("/usr/local/Cellar/python");
                const gitHomebrewExists2 = fs.existsSync("/opt/homebrew/bin/python");
                if (util.darwinXcodeExists() && util.semverCompare("12.0.1", osVersion) < 0 || gitHomebrewExists1 || gitHomebrewExists2) {
                  const cmd2 = gitHomebrewExists1 ? "/usr/local/Cellar/python -V 2>&1" : gitHomebrewExists2 ? "/opt/homebrew/bin/python -V 2>&1" : "python -V 2>&1";
                  exec(cmd2, (error2, stdout2) => {
                    if (!error2) {
                      const python = stdout2.toString().split(`
`)[0] || "";
                      appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } catch {
                functionProcessed();
              }
            } else {
              exec("python -V 2>&1", (error2, stdout) => {
                if (!error2) {
                  const python = stdout.toString().split(`
`)[0] || "";
                  appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "python3")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/python3") || fs.existsSync("/opt/homebrew/bin/python3");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("python3 -V 2>&1", (error2, stdout) => {
                  if (!error2) {
                    const python = stdout.toString().split(`
`)[0] || "";
                    appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("python3 -V 2>&1", (error2, stdout) => {
                if (!error2) {
                  const python = stdout.toString().split(`
`)[0] || "";
                  appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "pip")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip") || fs.existsSync("/opt/homebrew/bin/pip");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("pip -V 2>&1", (error2, stdout) => {
                  if (!error2) {
                    const pip = stdout.toString().split(`
`)[0] || "";
                    const parts = pip.split(" ");
                    appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("pip -V 2>&1", (error2, stdout) => {
                if (!error2) {
                  const pip = stdout.toString().split(`
`)[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "pip3")) {
            if (_darwin) {
              const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip3") || fs.existsSync("/opt/homebrew/bin/pip3");
              if (util.darwinXcodeExists() || gitHomebrewExists) {
                exec("pip3 -V 2>&1", (error2, stdout) => {
                  if (!error2) {
                    const pip = stdout.toString().split(`
`)[0] || "";
                    const parts = pip.split(" ");
                    appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                  }
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            } else {
              exec("pip3 -V 2>&1", (error2, stdout) => {
                if (!error2) {
                  const pip = stdout.toString().split(`
`)[0] || "";
                  const parts = pip.split(" ");
                  appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "java")) {
            if (_darwin) {
              exec("/usr/libexec/java_home -V 2>&1", (error2, stdout) => {
                if (!error2 && stdout.toString().toLowerCase().indexOf("no java runtime") === -1) {
                  exec("java -version 2>&1", (error3, stdout2) => {
                    if (!error3) {
                      const java = stdout2.toString().split(`
`)[0] || "";
                      const parts = java.split('"');
                      appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              });
            } else {
              exec("java -version 2>&1", (error2, stdout) => {
                if (!error2) {
                  const java = stdout.toString().split(`
`)[0] || "";
                  const parts = java.split('"');
                  appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                }
                functionProcessed();
              });
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "gcc")) {
            if (_darwin && util.darwinXcodeExists() || !_darwin) {
              exec("gcc -dumpversion", (error2, stdout) => {
                if (!error2) {
                  appsObj.versions.gcc = stdout.toString().split(`
`)[0].trim() || "";
                }
                if (appsObj.versions.gcc.indexOf(".") > -1) {
                  functionProcessed();
                } else {
                  exec("gcc --version", (error3, stdout2) => {
                    if (!error3) {
                      const gcc = stdout2.toString().split(`
`)[0].trim();
                      if (gcc.indexOf("gcc") > -1 && gcc.indexOf(")") > -1) {
                        const parts = gcc.split(")");
                        appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;
                      }
                    }
                    functionProcessed();
                  });
                }
              });
            } else {
              functionProcessed();
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "virtualbox")) {
            exec(util.getVboxmanage() + " -v 2>&1", (error2, stdout) => {
              if (!error2) {
                const vbox = stdout.toString().split(`
`)[0] || "";
                const parts = vbox.split("r");
                appsObj.versions.virtualbox = parts[0];
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "bash")) {
            exec("bash --version", (error2, stdout) => {
              if (!error2) {
                const line = stdout.toString().split(`
`)[0];
                const parts = line.split(" version ");
                if (parts.length > 1) {
                  appsObj.versions.bash = parts[1].split(" ")[0].split("(")[0];
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "zsh")) {
            exec("zsh --version", (error2, stdout) => {
              if (!error2) {
                const line = stdout.toString().split(`
`)[0];
                const parts = line.split("zsh ");
                if (parts.length > 1) {
                  appsObj.versions.zsh = parts[1].split(" ")[0];
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "fish")) {
            exec("fish --version", (error2, stdout) => {
              if (!error2) {
                const line = stdout.toString().split(`
`)[0];
                const parts = line.split(" version ");
                if (parts.length > 1) {
                  appsObj.versions.fish = parts[1].split(" ")[0];
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "bun")) {
            exec("bun -v", (error2, stdout) => {
              if (!error2) {
                const line = stdout.toString().split(`
`)[0].trim();
                appsObj.versions.bun = line;
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "deno")) {
            exec("deno -v", (error2, stdout) => {
              if (!error2) {
                const line = stdout.toString().split(`
`)[0].trim();
                const parts = line.split(" ");
                if (parts.length > 1) {
                  appsObj.versions.deno = parts[1];
                }
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "node")) {
            exec("node -v", (error2, stdout) => {
              if (!error2) {
                let line = stdout.toString().split(`
`)[0].trim();
                if (line.startsWith("v")) {
                  line = line.slice(1);
                }
                appsObj.versions.node = line;
              }
              functionProcessed();
            });
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "powershell")) {
            if (_windows) {
              util.powerShell("$PSVersionTable").then((stdout) => {
                const lines = stdout.toString().toLowerCase().split(`
`).map((line) => line.replace(/ +/g, " ").replace(/ +/g, ":"));
                appsObj.versions.powershell = util.getValue(lines, "psversion");
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          }
          if ({}.hasOwnProperty.call(appsObj.versions, "dotnet")) {
            if (_windows) {
              util.powerShell('gci "HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match "^(?!S)\\p{L}"} | select PSChildName, Version, Release').then((stdout) => {
                const lines = stdout.toString().split(`\r
`);
                let dotnet = "";
                lines.forEach((line) => {
                  line = line.replace(/ +/g, " ");
                  const parts = line.split(" ");
                  dotnet = dotnet || (parts[0].toLowerCase().startsWith("client") && parts.length > 2 ? parts[1].trim() : parts[0].toLowerCase().startsWith("full") && parts.length > 2 ? parts[1].trim() : "");
                });
                appsObj.versions.dotnet = dotnet.trim();
                functionProcessed();
              });
            } else {
              functionProcessed();
            }
          }
        } catch {
          if (callback) {
            callback(appsObj.versions);
          }
          resolve(appsObj.versions);
        }
      });
    });
  }
  exports.versions = versions;
  function shell(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (_windows) {
          try {
            const result2 = "CMD";
            util.powerShell(`Get-CimInstance -className win32_process | where-object {$_.ProcessId -eq ${process.ppid} } | select Name`).then((stdout) => {
              let result3 = "CMD";
              if (stdout) {
                if (stdout.toString().toLowerCase().indexOf("powershell") >= 0) {
                  result3 = "PowerShell";
                }
              }
              if (callback) {
                callback(result3);
              }
              resolve(result3);
            });
          } catch {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        } else {
          let result2 = "";
          exec("echo $SHELL", (error2, stdout) => {
            if (!error2) {
              result2 = stdout.toString().split(`
`)[0];
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
      });
    });
  }
  exports.shell = shell;
  function getUniqueMacAdresses() {
    let macs = [];
    try {
      const ifaces = os.networkInterfaces();
      for (let dev in ifaces) {
        if ({}.hasOwnProperty.call(ifaces, dev)) {
          ifaces[dev].forEach((details) => {
            if (details && details.mac && details.mac !== "00:00:00:00:00:00") {
              const mac = details.mac.toLowerCase();
              if (macs.indexOf(mac) === -1) {
                macs.push(mac);
              }
            }
          });
        }
      }
      macs = macs.sort((a, b) => {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      });
    } catch {
      macs.push("00:00:00:00:00:00");
    }
    return macs;
  }
  function uuid(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          os: "",
          hardware: "",
          macs: getUniqueMacAdresses()
        };
        let parts;
        if (_darwin) {
          exec("system_profiler SPHardwareDataType -json", (error2, stdout) => {
            if (!error2) {
              try {
                const jsonObj = JSON.parse(stdout.toString());
                if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {
                  const spHardware = jsonObj.SPHardwareDataType[0];
                  result2.os = spHardware.platform_UUID.toLowerCase();
                  result2.hardware = spHardware.serial_number;
                }
              } catch {
                util.noop();
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_linux) {
          const cmd = `echo -n "os: "; cat /var/lib/dbus/machine-id 2> /dev/null ||
cat /etc/machine-id 2> /dev/null; echo;
echo -n "hardware: "; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;
          exec(cmd, (error2, stdout) => {
            const lines = stdout.toString().split(`
`);
            result2.os = util.getValue(lines, "os").toLowerCase();
            result2.hardware = util.getValue(lines, "hardware").toLowerCase();
            if (!result2.hardware) {
              const lines2 = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split(`
`);
              const serial = util.getValue(lines2, "serial");
              result2.hardware = serial || "";
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("sysctl -i kern.hostid kern.hostuuid", (error2, stdout) => {
            const lines = stdout.toString().split(`
`);
            result2.hardware = util.getValue(lines, "kern.hostid", ":").toLowerCase();
            result2.os = util.getValue(lines, "kern.hostuuid", ":").toLowerCase();
            if (result2.os.indexOf("unknown") >= 0) {
              result2.os = "";
            }
            if (result2.hardware.indexOf("unknown") >= 0) {
              result2.hardware = "";
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          let sysdir = "%windir%\\System32";
          if (process.arch === "ia32" && Object.prototype.hasOwnProperty.call(process.env, "PROCESSOR_ARCHITEW6432")) {
            sysdir = "%windir%\\sysnative\\cmd.exe /c %windir%\\System32";
          }
          util.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl").then((stdout) => {
            let lines = stdout.split(`\r
`);
            result2.hardware = util.getValue(lines, "uuid", ":").toLowerCase();
            exec(`${sysdir}\\reg query "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography" /v MachineGuid`, util.execOptsWin, (error2, stdout2) => {
              parts = stdout2.toString().split(`
\r`)[0].split("REG_SZ");
              result2.os = parts.length > 1 ? parts[1].replace(/\r+|\n+|\s+/gi, "").toLowerCase() : "";
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          });
        }
      });
    });
  }
  exports.uuid = uuid;
});

// node_modules/systeminformation/lib/system.js
var require_system = __commonJS((exports) => {
  var fs = __require("fs");
  var os = __require("os");
  var util = require_util7();
  var { uuid } = require_osinfo();
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var execPromise = util.promisify(__require("child_process").exec);
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function system(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          manufacturer: "",
          model: "Computer",
          version: "",
          serial: "-",
          uuid: "-",
          sku: "-",
          virtual: false
        };
        if (_linux || _freebsd || _openbsd || _netbsd) {
          exec("export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL", (error2, stdout) => {
            let lines = stdout.toString().split(`
`);
            result2.manufacturer = cleanDefaults(util.getValue(lines, "manufacturer"));
            result2.model = cleanDefaults(util.getValue(lines, "product name"));
            result2.version = cleanDefaults(util.getValue(lines, "version"));
            result2.serial = cleanDefaults(util.getValue(lines, "serial number"));
            result2.uuid = cleanDefaults(util.getValue(lines, "uuid")).toLowerCase();
            result2.sku = cleanDefaults(util.getValue(lines, "sku number"));
            const cmd = `echo -n "product_name: "; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;
            echo -n "product_serial: "; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;
            echo -n "product_uuid: "; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;
            echo -n "product_version: "; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;
            echo -n "sys_vendor: "; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;
            try {
              lines = execSync(cmd, util.execOptsLinux).toString().split(`
`);
              result2.manufacturer = cleanDefaults(result2.manufacturer === "" ? util.getValue(lines, "sys_vendor") : result2.manufacturer);
              result2.model = cleanDefaults(result2.model === "" ? util.getValue(lines, "product_name") : result2.model);
              result2.version = cleanDefaults(result2.version === "" ? util.getValue(lines, "product_version") : result2.version);
              result2.serial = cleanDefaults(result2.serial === "" ? util.getValue(lines, "product_serial") : result2.serial);
              result2.uuid = cleanDefaults(result2.uuid === "" ? util.getValue(lines, "product_uuid").toLowerCase() : result2.uuid);
            } catch {
              util.noop();
            }
            if (!result2.serial) {
              result2.serial = "-";
            }
            if (!result2.manufacturer) {
              result2.manufacturer = "";
            }
            if (!result2.model) {
              result2.model = "Computer";
            }
            if (!result2.version) {
              result2.version = "";
            }
            if (!result2.sku) {
              result2.sku = "-";
            }
            if (result2.model.toLowerCase() === "virtualbox" || result2.model.toLowerCase() === "kvm" || result2.model.toLowerCase() === "virtual machine" || result2.model.toLowerCase() === "bochs" || result2.model.toLowerCase().startsWith("vmware") || result2.model.toLowerCase().startsWith("droplet")) {
              result2.virtual = true;
              switch (result2.model.toLowerCase()) {
                case "virtualbox":
                  result2.virtualHost = "VirtualBox";
                  break;
                case "vmware":
                  result2.virtualHost = "VMware";
                  break;
                case "kvm":
                  result2.virtualHost = "KVM";
                  break;
                case "bochs":
                  result2.virtualHost = "bochs";
                  break;
              }
            }
            if (result2.manufacturer.toLowerCase().startsWith("vmware") || result2.manufacturer.toLowerCase() === "xen") {
              result2.virtual = true;
              switch (result2.manufacturer.toLowerCase()) {
                case "vmware":
                  result2.virtualHost = "VMware";
                  break;
                case "xen":
                  result2.virtualHost = "Xen";
                  break;
              }
            }
            if (!result2.virtual) {
              try {
                const disksById = execSync("ls -1 /dev/disk/by-id/ 2>/dev/null; pciconf -lv  2>/dev/null", util.execOptsLinux).toString();
                if (disksById.indexOf("_QEMU_") >= 0 || disksById.indexOf("QEMU ") >= 0) {
                  result2.virtual = true;
                  result2.virtualHost = "QEMU";
                }
                if (disksById.indexOf("_VBOX_") >= 0) {
                  result2.virtual = true;
                  result2.virtualHost = "VirtualBox";
                }
              } catch {
                util.noop();
              }
            }
            if (_freebsd || _openbsd || _netbsd) {
              try {
                const lines2 = execSync("sysctl -i kern.hostuuid kern.hostid hw.model", util.execOptsLinux).toString().split(`
`);
                if (!result2.uuid) {
                  result2.uuid = util.getValue(lines2, "kern.hostuuid", ":").toLowerCase();
                }
                if (!result2.serial || result2.serial === "-") {
                  result2.serial = util.getValue(lines2, "kern.hostid", ":").toLowerCase();
                }
                if (!result2.model || result2.model === "Computer") {
                  result2.model = util.getValue(lines2, "hw.model", ":").trim();
                }
              } catch {
                util.noop();
              }
            }
            if (!result2.virtual && (os.release().toLowerCase().indexOf("microsoft") >= 0 || os.release().toLowerCase().endsWith("wsl2"))) {
              const kernelVersion = parseFloat(os.release().toLowerCase());
              result2.virtual = true;
              result2.manufacturer = "Microsoft";
              result2.model = "WSL";
              result2.version = kernelVersion < 4.19 ? "1" : "2";
            }
            if ((_freebsd || _openbsd || _netbsd) && !result2.virtualHost) {
              try {
                const procInfo = execSync("dmidecode -t 4", util.execOptsLinux);
                const procLines = procInfo.toString().split(`
`);
                const procManufacturer = util.getValue(procLines, "manufacturer", ":", true);
                switch (procManufacturer.toLowerCase()) {
                  case "virtualbox":
                    result2.virtualHost = "VirtualBox";
                    break;
                  case "vmware":
                    result2.virtualHost = "VMware";
                    break;
                  case "kvm":
                    result2.virtualHost = "KVM";
                    break;
                  case "bochs":
                    result2.virtualHost = "bochs";
                    break;
                }
              } catch {
                util.noop();
              }
            }
            if (fs.existsSync("/.dockerenv") || fs.existsSync("/.dockerinit")) {
              result2.model = "Docker Container";
            }
            try {
              const stdout2 = execSync('dmesg 2>/dev/null | grep -iE "virtual|hypervisor" | grep -iE "vmware|qemu|kvm|xen" | grep -viE "Nested Virtualization|/virtual/"');
              const lines2 = stdout2.toString().split(`
`);
              if (lines2.length > 0) {
                if (result2.model === "Computer") {
                  result2.model = "Virtual machine";
                }
                result2.virtual = true;
                if (stdout2.toString().toLowerCase().indexOf("vmware") >= 0 && !result2.virtualHost) {
                  result2.virtualHost = "VMware";
                }
                if (stdout2.toString().toLowerCase().indexOf("qemu") >= 0 && !result2.virtualHost) {
                  result2.virtualHost = "QEMU";
                }
                if (stdout2.toString().toLowerCase().indexOf("xen") >= 0 && !result2.virtualHost) {
                  result2.virtualHost = "Xen";
                }
                if (stdout2.toString().toLowerCase().indexOf("kvm") >= 0 && !result2.virtualHost) {
                  result2.virtualHost = "KVM";
                }
              }
            } catch {
              util.noop();
            }
            if (result2.manufacturer === "" && result2.model === "Computer" && result2.version === "") {
              fs.readFile("/proc/cpuinfo", (error3, stdout2) => {
                if (!error3) {
                  let lines2 = stdout2.toString().split(`
`);
                  result2.model = util.getValue(lines2, "hardware", ":", true).toUpperCase();
                  result2.version = util.getValue(lines2, "revision", ":", true).toLowerCase();
                  result2.serial = util.getValue(lines2, "serial", ":", true);
                  const model = util.getValue(lines2, "model:", ":", true);
                  if (util.isRaspberry(lines2)) {
                    const rPIRevision = util.decodePiCpuinfo(lines2);
                    result2.model = rPIRevision.model;
                    result2.version = rPIRevision.revisionCode;
                    result2.manufacturer = "Raspberry Pi Foundation";
                    result2.raspberry = {
                      manufacturer: rPIRevision.manufacturer,
                      processor: rPIRevision.processor,
                      type: rPIRevision.type,
                      revision: rPIRevision.revision
                    };
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        }
        if (_darwin) {
          exec("ioreg -c IOPlatformExpertDevice -d 2", (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().replace(/[<>"]/g, "").split(`
`);
              const model = util.getAppleModel(util.getValue(lines, "model", "=", true));
              result2.manufacturer = util.getValue(lines, "manufacturer", "=", true);
              result2.model = model.key;
              result2.type = macOsChassisType(model.version);
              result2.version = model.version;
              result2.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
              result2.uuid = util.getValue(lines, "ioplatformuuid", "=", true).toLowerCase();
              result2.sku = util.getValue(lines, "board-id", "=", true) || util.getValue(lines, "target-sub-type", "=", true);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_windows) {
          try {
            util.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl").then((stdout, error2) => {
              if (!error2) {
                const lines = stdout.split(`\r
`);
                result2.manufacturer = util.getValue(lines, "vendor", ":");
                result2.model = util.getValue(lines, "name", ":");
                result2.version = util.getValue(lines, "version", ":");
                result2.serial = util.getValue(lines, "identifyingnumber", ":");
                result2.uuid = util.getValue(lines, "uuid", ":").toLowerCase();
                const model = result2.model.toLowerCase();
                if (model === "virtualbox" || model === "kvm" || model === "virtual machine" || model === "bochs" || model.startsWith("vmware") || model.startsWith("qemu") || model.startsWith("parallels")) {
                  result2.virtual = true;
                  if (model.startsWith("virtualbox")) {
                    result2.virtualHost = "VirtualBox";
                  }
                  if (model.startsWith("vmware")) {
                    result2.virtualHost = "VMware";
                  }
                  if (model.startsWith("kvm")) {
                    result2.virtualHost = "KVM";
                  }
                  if (model.startsWith("bochs")) {
                    result2.virtualHost = "bochs";
                  }
                  if (model.startsWith("qemu")) {
                    result2.virtualHost = "KVM";
                  }
                  if (model.startsWith("parallels")) {
                    result2.virtualHost = "Parallels";
                  }
                }
                const manufacturer = result2.manufacturer.toLowerCase();
                if (manufacturer.startsWith("vmware") || manufacturer.startsWith("qemu") || manufacturer === "xen" || manufacturer.startsWith("parallels")) {
                  result2.virtual = true;
                  if (manufacturer.startsWith("vmware")) {
                    result2.virtualHost = "VMware";
                  }
                  if (manufacturer.startsWith("xen")) {
                    result2.virtualHost = "Xen";
                  }
                  if (manufacturer.startsWith("qemu")) {
                    result2.virtualHost = "KVM";
                  }
                  if (manufacturer.startsWith("parallels")) {
                    result2.virtualHost = "Parallels";
                  }
                }
                util.powerShell('Get-CimInstance MS_Systeminformation -Namespace "root/wmi" | select systemsku | fl ').then((stdout2, error3) => {
                  if (!error3) {
                    const lines2 = stdout2.split(`\r
`);
                    result2.sku = util.getValue(lines2, "systemsku", ":");
                  }
                  if (!result2.virtual) {
                    util.powerShell("Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion").then((stdout3, error4) => {
                      if (!error4) {
                        let lines2 = stdout3.toString();
                        if (lines2.indexOf("VRTUAL") >= 0 || lines2.indexOf("A M I ") >= 0 || lines2.indexOf("VirtualBox") >= 0 || lines2.indexOf("VMWare") >= 0 || lines2.indexOf("Xen") >= 0 || lines2.indexOf("Parallels") >= 0) {
                          result2.virtual = true;
                          if (lines2.indexOf("VirtualBox") >= 0 && !result2.virtualHost) {
                            result2.virtualHost = "VirtualBox";
                          }
                          if (lines2.indexOf("VMware") >= 0 && !result2.virtualHost) {
                            result2.virtualHost = "VMware";
                          }
                          if (lines2.indexOf("Xen") >= 0 && !result2.virtualHost) {
                            result2.virtualHost = "Xen";
                          }
                          if (lines2.indexOf("VRTUAL") >= 0 && !result2.virtualHost) {
                            result2.virtualHost = "Hyper-V";
                          }
                          if (lines2.indexOf("A M I") >= 0 && !result2.virtualHost) {
                            result2.virtualHost = "Virtual PC";
                          }
                          if (lines2.indexOf("Parallels") >= 0 && !result2.virtualHost) {
                            result2.virtualHost = "Parallels";
                          }
                        }
                        if (callback) {
                          callback(result2);
                        }
                        resolve(result2);
                      } else {
                        if (callback) {
                          callback(result2);
                        }
                        resolve(result2);
                      }
                    });
                  } else {
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  }
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.system = system;
  function cleanDefaults(s) {
    const cmpStr = s.toLowerCase();
    if (cmpStr.indexOf("o.e.m.") === -1 && cmpStr.indexOf("default string") === -1 && cmpStr !== "default") {
      return s || "";
    }
    return "";
  }
  function bios(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          vendor: "",
          version: "",
          releaseDate: "",
          revision: ""
        };
        let cmd = "";
        if (_linux || _freebsd || _openbsd || _netbsd) {
          if (process.arch === "arm") {
            cmd = "cat /proc/cpuinfo | grep Serial";
          } else {
            cmd = "export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL";
          }
          exec(cmd, (error2, stdout) => {
            let lines = stdout.toString().split(`
`);
            result2.vendor = util.getValue(lines, "Vendor");
            result2.version = util.getValue(lines, "Version");
            let datetime = util.getValue(lines, "Release Date");
            result2.releaseDate = util.parseDateTime(datetime).date;
            result2.revision = util.getValue(lines, "BIOS Revision");
            result2.serial = util.getValue(lines, "SerialNumber");
            let language = util.getValue(lines, "Currently Installed Language").split("|")[0];
            if (language) {
              result2.language = language;
            }
            if (lines.length && stdout.toString().indexOf("Characteristics:") >= 0) {
              const features = [];
              lines.forEach((line) => {
                if (line.indexOf(" is supported") >= 0) {
                  const feature = line.split(" is supported")[0].trim();
                  features.push(feature);
                }
              });
              result2.features = features;
            }
            const cmd2 = `echo -n "bios_date: "; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;
            echo -n "bios_vendor: "; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;
            echo -n "bios_version: "; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;
            try {
              lines = execSync(cmd2, util.execOptsLinux).toString().split(`
`);
              result2.vendor = !result2.vendor ? util.getValue(lines, "bios_vendor") : result2.vendor;
              result2.version = !result2.version ? util.getValue(lines, "bios_version") : result2.version;
              datetime = util.getValue(lines, "bios_date");
              result2.releaseDate = !result2.releaseDate ? util.parseDateTime(datetime).date : result2.releaseDate;
            } catch (e) {
              util.noop();
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          result2.vendor = "Apple Inc.";
          exec("system_profiler SPHardwareDataType -json", (error2, stdout) => {
            try {
              const hardwareData = JSON.parse(stdout.toString());
              if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {
                let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;
                bootRomVersion = bootRomVersion ? bootRomVersion.split("(")[0].trim() : null;
                result2.version = bootRomVersion;
              }
            } catch (e) {
              util.noop();
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          result2.vendor = "Sun Microsystems";
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_windows) {
          try {
            util.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n="ReleaseDate";e={$_.ReleaseDate.ToString("yyyy-MM-dd")}},BuildNumber,SerialNumber,SMBIOSBIOSVersion | fl').then((stdout, error2) => {
              if (!error2) {
                let lines = stdout.toString().split(`\r
`);
                const description = util.getValue(lines, "description", ":");
                const version = util.getValue(lines, "SMBIOSBIOSVersion", ":");
                if (description.indexOf(" Version ") !== -1) {
                  result2.vendor = description.split(" Version ")[0].trim();
                  result2.version = description.split(" Version ")[1].trim();
                } else if (description.indexOf(" Ver: ") !== -1) {
                  result2.vendor = util.getValue(lines, "manufacturer", ":");
                  result2.version = description.split(" Ver: ")[1].trim();
                } else {
                  result2.vendor = util.getValue(lines, "manufacturer", ":");
                  result2.version = version || util.getValue(lines, "version", ":");
                }
                result2.releaseDate = util.getValue(lines, "releasedate", ":");
                result2.revision = util.getValue(lines, "buildnumber", ":");
                result2.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch (e) {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.bios = bios;
  function baseboard(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result2 = {
          manufacturer: "",
          model: "",
          version: "",
          serial: "-",
          assetTag: "-",
          memMax: null,
          memSlots: null
        };
        let cmd = "";
        if (_linux || _freebsd || _openbsd || _netbsd) {
          if (process.arch === "arm") {
            cmd = "cat /proc/cpuinfo | grep Serial";
          } else {
            cmd = "export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL";
          }
          const workload = [];
          workload.push(execPromise(cmd));
          workload.push(execPromise("export LC_ALL=C; dmidecode -t memory 2>/dev/null"));
          util.promiseAll(workload).then((data) => {
            let lines = data.results[0] ? data.results[0].toString().split(`
`) : [""];
            result2.manufacturer = cleanDefaults(util.getValue(lines, "Manufacturer"));
            result2.model = cleanDefaults(util.getValue(lines, "Product Name"));
            result2.version = cleanDefaults(util.getValue(lines, "Version"));
            result2.serial = cleanDefaults(util.getValue(lines, "Serial Number"));
            result2.assetTag = cleanDefaults(util.getValue(lines, "Asset Tag"));
            const cmd2 = `echo -n "board_asset_tag: "; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;
            echo -n "board_name: "; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;
            echo -n "board_serial: "; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;
            echo -n "board_vendor: "; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;
            echo -n "board_version: "; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;
            try {
              lines = execSync(cmd2, util.execOptsLinux).toString().split(`
`);
              result2.manufacturer = cleanDefaults(!result2.manufacturer ? util.getValue(lines, "board_vendor") : result2.manufacturer);
              result2.model = cleanDefaults(!result2.model ? util.getValue(lines, "board_name") : result2.model);
              result2.version = cleanDefaults(!result2.version ? util.getValue(lines, "board_version") : result2.version);
              result2.serial = cleanDefaults(!result2.serial ? util.getValue(lines, "board_serial") : result2.serial);
              result2.assetTag = cleanDefaults(!result2.assetTag ? util.getValue(lines, "board_asset_tag") : result2.assetTag);
            } catch {
              util.noop();
            }
            lines = data.results[1] ? data.results[1].toString().split(`
`) : [""];
            result2.memMax = util.toInt(util.getValue(lines, "Maximum Capacity")) * 1024 * 1024 * 1024 || null;
            result2.memSlots = util.toInt(util.getValue(lines, "Number Of Devices")) || null;
            if (util.isRaspberry()) {
              const rpi = util.decodePiCpuinfo();
              result2.manufacturer = rpi.manufacturer;
              result2.model = "Raspberry Pi";
              result2.serial = rpi.serial;
              result2.version = rpi.type + " - " + rpi.revision;
              result2.memMax = os.totalmem();
              result2.memSlots = 0;
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          const workload = [];
          workload.push(execPromise("ioreg -c IOPlatformExpertDevice -d 2"));
          workload.push(execPromise("system_profiler SPMemoryDataType"));
          util.promiseAll(workload).then((data) => {
            const lines = data.results[0] ? data.results[0].toString().replace(/[<>"]/g, "").split(`
`) : [""];
            result2.manufacturer = util.getValue(lines, "manufacturer", "=", true);
            result2.model = util.getValue(lines, "model", "=", true);
            result2.version = util.getValue(lines, "version", "=", true);
            result2.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
            result2.assetTag = util.getValue(lines, "board-id", "=", true);
            let devices = data.results[1] ? data.results[1].toString().split("        BANK ") : [""];
            if (devices.length === 1) {
              devices = data.results[1] ? data.results[1].toString().split("        DIMM") : [""];
            }
            devices.shift();
            result2.memSlots = devices.length;
            if (os.arch() === "arm64") {
              result2.memSlots = 0;
              result2.memMax = os.totalmem();
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_windows) {
          try {
            const workload = [];
            const win10plus = parseInt(os.release()) >= 10;
            const maxCapacityAttribute = win10plus ? "MaxCapacityEx" : "MaxCapacity";
            workload.push(util.powerShell("Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl"));
            workload.push(util.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));
            util.promiseAll(workload).then((data) => {
              let lines = data.results[0] ? data.results[0].toString().split(`\r
`) : [""];
              result2.manufacturer = cleanDefaults(util.getValue(lines, "manufacturer", ":"));
              result2.model = cleanDefaults(util.getValue(lines, "model", ":"));
              if (!result2.model) {
                result2.model = cleanDefaults(util.getValue(lines, "product", ":"));
              }
              result2.version = cleanDefaults(util.getValue(lines, "version", ":"));
              result2.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
              result2.assetTag = cleanDefaults(util.getValue(lines, "partnumber", ":"));
              if (!result2.assetTag) {
                result2.assetTag = cleanDefaults(util.getValue(lines, "sku", ":"));
              }
              lines = data.results[1] ? data.results[1].toString().split(`\r
`) : [""];
              result2.memMax = util.toInt(util.getValue(lines, maxCapacityAttribute, ":")) * (win10plus ? 1024 : 1) || null;
              result2.memSlots = util.toInt(util.getValue(lines, "MemoryDevices", ":")) || null;
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.baseboard = baseboard;
  function macOsChassisType(model) {
    model = model.toLowerCase();
    if (model.indexOf("macbookair") >= 0 || model.indexOf("macbook air") >= 0) {
      return "Notebook";
    }
    if (model.indexOf("macbookpro") >= 0 || model.indexOf("macbook pro") >= 0) {
      return "Notebook";
    }
    if (model.indexOf("macbook") >= 0) {
      return "Notebook";
    }
    if (model.indexOf("macmini") >= 0 || model.indexOf("mac mini") >= 0) {
      return "Desktop";
    }
    if (model.indexOf("imac") >= 0) {
      return "Desktop";
    }
    if (model.indexOf("macstudio") >= 0 || model.indexOf("mac studio") >= 0) {
      return "Desktop";
    }
    if (model.indexOf("macpro") >= 0 || model.indexOf("mac pro") >= 0) {
      return "Tower";
    }
    return "Other";
  }
  function chassis(callback) {
    const chassisTypes = [
      "Other",
      "Unknown",
      "Desktop",
      "Low Profile Desktop",
      "Pizza Box",
      "Mini Tower",
      "Tower",
      "Portable",
      "Laptop",
      "Notebook",
      "Hand Held",
      "Docking Station",
      "All in One",
      "Sub Notebook",
      "Space-Saving",
      "Lunch Box",
      "Main System Chassis",
      "Expansion Chassis",
      "SubChassis",
      "Bus Expansion Chassis",
      "Peripheral Chassis",
      "Storage Chassis",
      "Rack Mount Chassis",
      "Sealed-Case PC",
      "Multi-System Chassis",
      "Compact PCI",
      "Advanced TCA",
      "Blade",
      "Blade Enclosure",
      "Tablet",
      "Convertible",
      "Detachable",
      "IoT Gateway ",
      "Embedded PC",
      "Mini PC",
      "Stick PC"
    ];
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          manufacturer: "",
          model: "",
          type: "",
          version: "",
          serial: "-",
          assetTag: "-",
          sku: ""
        };
        if (_linux || _freebsd || _openbsd || _netbsd) {
          const cmd = `echo -n "chassis_asset_tag: "; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;
            echo -n "chassis_serial: "; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;
            echo -n "chassis_type: "; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;
            echo -n "chassis_vendor: "; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;
            echo -n "chassis_version: "; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;
          exec(cmd, (error2, stdout) => {
            let lines = stdout.toString().split(`
`);
            result2.manufacturer = cleanDefaults(util.getValue(lines, "chassis_vendor"));
            const ctype = parseInt(util.getValue(lines, "chassis_type").replace(/\D/g, ""));
            result2.type = cleanDefaults(ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "");
            result2.version = cleanDefaults(util.getValue(lines, "chassis_version"));
            result2.serial = cleanDefaults(util.getValue(lines, "chassis_serial"));
            result2.assetTag = cleanDefaults(util.getValue(lines, "chassis_asset_tag"));
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          exec("ioreg -c IOPlatformExpertDevice -d 2", (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().replace(/[<>"]/g, "").split(`
`);
              const model = util.getAppleModel(util.getValue(lines, "model", "=", true));
              result2.manufacturer = util.getValue(lines, "manufacturer", "=", true);
              result2.model = model.key;
              result2.type = macOsChassisType(model.model);
              result2.version = model.version;
              result2.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
              result2.assetTag = util.getValue(lines, "board-id", "=", true) || util.getValue(lines, "target-type", "=", true);
              result2.sku = util.getValue(lines, "target-sub-type", "=", true);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_windows) {
          try {
            util.powerShell("Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU,SMBIOSAssetTag | fl").then((stdout, error2) => {
              if (!error2) {
                let lines = stdout.toString().split(`\r
`);
                result2.manufacturer = cleanDefaults(util.getValue(lines, "manufacturer", ":"));
                result2.model = cleanDefaults(util.getValue(lines, "model", ":"));
                const ctype = parseInt(util.getValue(lines, "ChassisTypes", ":").replace(/\D/g, ""));
                result2.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
                result2.version = cleanDefaults(util.getValue(lines, "version", ":"));
                result2.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
                result2.assetTag = cleanDefaults(util.getValue(lines, "partnumber", ":"));
                if (!result2.assetTag) {
                  result2.assetTag = cleanDefaults(util.getValue(lines, "SMBIOSAssetTag", ":"));
                }
                result2.sku = cleanDefaults(util.getValue(lines, "sku", ":"));
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.chassis = chassis;
});

// node_modules/systeminformation/lib/cpu.js
var require_cpu = __commonJS((exports) => {
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var fs = __require("fs");
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _cpu_speed = 0;
  var _current_cpu = {
    user: 0,
    nice: 0,
    system: 0,
    idle: 0,
    irq: 0,
    steal: 0,
    guest: 0,
    load: 0,
    tick: 0,
    ms: 0,
    currentLoad: 0,
    currentLoadUser: 0,
    currentLoadSystem: 0,
    currentLoadNice: 0,
    currentLoadIdle: 0,
    currentLoadIrq: 0,
    currentLoadSteal: 0,
    currentLoadGuest: 0,
    rawCurrentLoad: 0,
    rawCurrentLoadUser: 0,
    rawCurrentLoadSystem: 0,
    rawCurrentLoadNice: 0,
    rawCurrentLoadIdle: 0,
    rawCurrentLoadIrq: 0,
    rawCurrentLoadSteal: 0,
    rawCurrentLoadGuest: 0
  };
  var _cpus = [];
  var _corecount = 0;
  var AMDBaseFrequencies = {
    8346: "1.8",
    8347: "1.9",
    8350: "2.0",
    8354: "2.2",
    "8356|SE": "2.4",
    8356: "2.3",
    8360: "2.5",
    2372: "2.1",
    2373: "2.1",
    2374: "2.2",
    2376: "2.3",
    2377: "2.3",
    2378: "2.4",
    2379: "2.4",
    2380: "2.5",
    2381: "2.5",
    2382: "2.6",
    2384: "2.7",
    2386: "2.8",
    2387: "2.8",
    2389: "2.9",
    2393: "3.1",
    8374: "2.2",
    8376: "2.3",
    8378: "2.4",
    8379: "2.4",
    8380: "2.5",
    8381: "2.5",
    8382: "2.6",
    8384: "2.7",
    8386: "2.8",
    8387: "2.8",
    8389: "2.9",
    8393: "3.1",
    "2419EE": "1.8",
    "2423HE": "2.0",
    "2425HE": "2.1",
    2427: "2.2",
    2431: "2.4",
    2435: "2.6",
    "2439SE": "2.8",
    "8425HE": "2.1",
    8431: "2.4",
    8435: "2.6",
    "8439SE": "2.8",
    4122: "2.2",
    4130: "2.6",
    "4162EE": "1.7",
    "4164EE": "1.8",
    "4170HE": "2.1",
    "4174HE": "2.3",
    "4176HE": "2.4",
    4180: "2.6",
    4184: "2.8",
    "6124HE": "1.8",
    "6128HE": "2.0",
    "6132HE": "2.2",
    6128: "2.0",
    6134: "2.3",
    6136: "2.4",
    6140: "2.6",
    "6164HE": "1.7",
    "6166HE": "1.8",
    6168: "1.9",
    6172: "2.1",
    6174: "2.2",
    6176: "2.3",
    "6176SE": "2.3",
    "6180SE": "2.5",
    3250: "2.5",
    3260: "2.7",
    3280: "2.4",
    4226: "2.7",
    4228: "2.8",
    4230: "2.9",
    4234: "3.1",
    4238: "3.3",
    4240: "3.4",
    4256: "1.6",
    4274: "2.5",
    4276: "2.6",
    4280: "2.8",
    4284: "3.0",
    6204: "3.3",
    6212: "2.6",
    6220: "3.0",
    6234: "2.4",
    6238: "2.6",
    "6262HE": "1.6",
    6272: "2.1",
    6274: "2.2",
    6276: "2.3",
    6278: "2.4",
    "6282SE": "2.6",
    "6284SE": "2.7",
    6308: "3.5",
    6320: "2.8",
    6328: "3.2",
    "6338P": "2.3",
    6344: "2.6",
    6348: "2.8",
    6366: "1.8",
    "6370P": "2.0",
    6376: "2.3",
    6378: "2.4",
    6380: "2.5",
    6386: "2.8",
    "FX|4100": "3.6",
    "FX|4120": "3.9",
    "FX|4130": "3.8",
    "FX|4150": "3.8",
    "FX|4170": "4.2",
    "FX|6100": "3.3",
    "FX|6120": "3.6",
    "FX|6130": "3.6",
    "FX|6200": "3.8",
    "FX|8100": "2.8",
    "FX|8120": "3.1",
    "FX|8140": "3.2",
    "FX|8150": "3.6",
    "FX|8170": "3.9",
    "FX|4300": "3.8",
    "FX|4320": "4.0",
    "FX|4350": "4.2",
    "FX|6300": "3.5",
    "FX|6350": "3.9",
    "FX|8300": "3.3",
    "FX|8310": "3.4",
    "FX|8320": "3.5",
    "FX|8350": "4.0",
    "FX|8370": "4.0",
    "FX|9370": "4.4",
    "FX|9590": "4.7",
    "FX|8320E": "3.2",
    "FX|8370E": "3.3",
    1200: "3.1",
    "Pro 1200": "3.1",
    "1300X": "3.5",
    "Pro 1300": "3.5",
    1400: "3.2",
    "1500X": "3.5",
    "Pro 1500": "3.5",
    1600: "3.2",
    "1600X": "3.6",
    "Pro 1600": "3.2",
    1700: "3.0",
    "Pro 1700": "3.0",
    "1700X": "3.4",
    "Pro 1700X": "3.4",
    "1800X": "3.6",
    "1900X": "3.8",
    1920: "3.2",
    "1920X": "3.5",
    "1950X": "3.4",
    "200GE": "3.2",
    "Pro 200GE": "3.2",
    "220GE": "3.4",
    "240GE": "3.5",
    "3000G": "3.5",
    "300GE": "3.4",
    "3050GE": "3.4",
    "2200G": "3.5",
    "Pro 2200G": "3.5",
    "2200GE": "3.2",
    "Pro 2200GE": "3.2",
    "2400G": "3.6",
    "Pro 2400G": "3.6",
    "2400GE": "3.2",
    "Pro 2400GE": "3.2",
    "Pro 200U": "2.3",
    "300U": "2.4",
    "2200U": "2.5",
    "3200U": "2.6",
    "2300U": "2.0",
    "Pro 2300U": "2.0",
    "2500U": "2.0",
    "Pro 2500U": "2.2",
    "2600H": "3.2",
    "2700U": "2.0",
    "Pro 2700U": "2.2",
    "2800H": "3.3",
    7351: "2.4",
    "7351P": "2.4",
    7401: "2.0",
    "7401P": "2.0",
    "7551P": "2.0",
    7551: "2.0",
    7251: "2.1",
    7261: "2.5",
    7281: "2.1",
    7301: "2.2",
    7371: "3.1",
    7451: "2.3",
    7501: "2.0",
    7571: "2.2",
    7601: "2.2",
    V1500B: "2.2",
    V1780B: "3.35",
    V1202B: "2.3",
    V1404I: "2.0",
    V1605B: "2.0",
    V1756B: "3.25",
    V1807B: "3.35",
    3101: "2.1",
    3151: "2.7",
    3201: "1.5",
    3251: "2.5",
    3255: "2.5",
    3301: "2.0",
    3351: "1.9",
    3401: "1.85",
    3451: "2.15",
    "1200|AF": "3.1",
    "2300X": "3.5",
    "2500X": "3.6",
    2600: "3.4",
    "2600E": "3.1",
    "1600|AF": "3.2",
    "2600X": "3.6",
    2700: "3.2",
    "2700E": "2.8",
    "Pro 2700": "3.2",
    "2700X": "3.7",
    "Pro 2700X": "3.6",
    "2920X": "3.5",
    "2950X": "3.5",
    "2970WX": "3.0",
    "2990WX": "3.0",
    "Pro 300GE": "3.4",
    "Pro 3125GE": "3.4",
    "3150G": "3.5",
    "Pro 3150G": "3.5",
    "3150GE": "3.3",
    "Pro 3150GE": "3.3",
    "3200G": "3.6",
    "Pro 3200G": "3.6",
    "3200GE": "3.3",
    "Pro 3200GE": "3.3",
    "3350G": "3.6",
    "Pro 3350G": "3.6",
    "3350GE": "3.3",
    "Pro 3350GE": "3.3",
    "3400G": "3.7",
    "Pro 3400G": "3.7",
    "3400GE": "3.3",
    "Pro 3400GE": "3.3",
    "3300U": "2.1",
    "PRO 3300U": "2.1",
    "3450U": "2.1",
    "3500U": "2.1",
    "PRO 3500U": "2.1",
    "3500C": "2.1",
    "3550H": "2.1",
    "3580U": "2.1",
    "3700U": "2.3",
    "PRO 3700U": "2.3",
    "3700C": "2.3",
    "3750H": "2.3",
    "3780U": "2.3",
    3100: "3.6",
    "3300X": "3.8",
    3500: "3.6",
    "3500X": "3.6",
    3600: "3.6",
    "Pro 3600": "3.6",
    "3600X": "3.8",
    "3600XT": "3.8",
    "Pro 3700": "3.6",
    "3700X": "3.6",
    "3800X": "3.9",
    "3800XT": "3.9",
    3900: "3.1",
    "Pro 3900": "3.1",
    "3900X": "3.8",
    "3900XT": "3.8",
    "3950X": "3.5",
    "3960X": "3.8",
    "3970X": "3.7",
    "3990X": "2.9",
    "3945WX": "4.0",
    "3955WX": "3.9",
    "3975WX": "3.5",
    "3995WX": "2.7",
    "4300GE": "3.5",
    "Pro 4300GE": "3.5",
    "4300G": "3.8",
    "Pro 4300G": "3.8",
    "4600GE": "3.3",
    "Pro 4650GE": "3.3",
    "4600G": "3.7",
    "Pro 4650G": "3.7",
    "4700GE": "3.1",
    "Pro 4750GE": "3.1",
    "4700G": "3.6",
    "Pro 4750G": "3.6",
    "4300U": "2.7",
    "4450U": "2.5",
    "Pro 4450U": "2.5",
    "4500U": "2.3",
    "4600U": "2.1",
    "PRO 4650U": "2.1",
    "4680U": "2.1",
    "4600HS": "3.0",
    "4600H": "3.0",
    "4700U": "2.0",
    "PRO 4750U": "1.7",
    "4800U": "1.8",
    "4800HS": "2.9",
    "4800H": "2.9",
    "4900HS": "3.0",
    "4900H": "3.3",
    "5300U": "2.6",
    "5500U": "2.1",
    "5700U": "1.8",
    "7232P": "3.1",
    "7302P": "3.0",
    "7402P": "2.8",
    "7502P": "2.5",
    "7702P": "2.0",
    7252: "3.1",
    7262: "3.2",
    7272: "2.9",
    7282: "2.8",
    7302: "3.0",
    7352: "2.3",
    7402: "2.8",
    7452: "2.35",
    7502: "2.5",
    7532: "2.4",
    7542: "2.9",
    7552: "2.2",
    7642: "2.3",
    7662: "2.0",
    7702: "2.0",
    7742: "2.25",
    "7H12": "2.6",
    "7F32": "3.7",
    "7F52": "3.5",
    "7F72": "3.2",
    "7773X": "2.2",
    7763: "2.45",
    7713: "2.0",
    "7713P": "2.0",
    7663: "2.0",
    7643: "2.3",
    "7573X": "2.8",
    "75F3": "2.95",
    7543: "2.8",
    "7543P": "2.8",
    7513: "2.6",
    "7473X": "2.8",
    7453: "2.75",
    "74F3": "3.2",
    7443: "2.85",
    "7443P": "2.85",
    7413: "2.65",
    "7373X": "3.05",
    "73F3": "3.5",
    7343: "3.2",
    7313: "3.0",
    "7313P": "3.0",
    "72F3": "3.7",
    "5600X": "3.7",
    "5800X": "3.8",
    "5900X": "3.7",
    "5950X": "3.4",
    "5945WX": "4.1",
    "5955WX": "4.0",
    "5965WX": "3.8",
    "5975WX": "3.6",
    "5995WX": "2.7",
    "7960X": "4.2",
    "7970X": "4.0",
    "7980X": "3.2",
    "7965WX": "4.2",
    "7975WX": "4.0",
    "7985WX": "3.2",
    "7995WX": "2.5",
    9754: "2.25",
    "9754S": "2.25",
    9734: "2.2",
    "9684X": "2.55",
    "9384X": "3.1",
    "9184X": "3.55",
    "9654P": "2.4",
    9654: "2.4",
    9634: "2.25",
    "9554P": "3.1",
    9554: "3.1",
    9534: "2.45",
    "9474F": "3.6",
    "9454P": "2.75",
    9454: "2.75",
    "9374F": "3.85",
    "9354P": "3.25",
    9354: "3.25",
    9334: "2.7",
    "9274F": "4.05",
    9254: "2.9",
    9224: "2.5",
    "9174F": "4.1",
    9124: "3.0",
    "4124P": "3.8",
    "4244P": "3.8",
    "4344P": "3.8",
    "4364P": "4.5",
    "4464P": "3.7",
    "4484PX": "4.4",
    "4564P": "4.5",
    "4584PX": "4.2",
    "8024P": "2.4",
    "8024PN": "2.05",
    "8124P": "2.45",
    "8124PN": "2.0",
    "8224P": "2.55",
    "8224PN": "2.0",
    "8324P": "2.65",
    "8324PN": "2.05",
    "8434P": "2.5",
    "8434PN": "2.0",
    "8534P": "2.3",
    "8534PN": "2.0",
    9115: "2.6",
    9135: "3.65",
    "9175F": "4.2",
    9255: "3.25",
    "9275F": "4.1",
    9335: "3.0",
    "9355P": "3.55",
    9355: "3.55",
    "9375F": "3.8",
    9365: "3.4",
    "9455P": "3.15",
    9455: "3.15",
    "9475F": "3.65",
    9535: "2.4",
    "9555P": "3.2",
    9555: "3.2",
    "9575F": "3.3",
    9565: "3.15",
    "9655P": "2.5",
    9655: "2.5",
    9755: "2.7",
    "4245P": "3.9",
    "4345P": "3.8",
    "4465P": "3.4",
    "4545P": "3.0",
    "4565P": "4.3",
    "4585PX": "4.3",
    "5900XT": "3.3",
    5900: "3.0",
    5945: "3.0",
    "5800X3D": "3.4",
    "5800XT": "3.8",
    5800: "3.4",
    "5700X3D": "3.0",
    "5700X": "3.4",
    5845: "3.4",
    "5600X3D": "3.3",
    "5600XT": "3.7",
    "5600T": "3.5",
    5600: "3.5",
    "5600F": "3.0",
    5645: "3.7",
    "5500X3D": "3.0",
    "5980HX": "3.3",
    "5980HS": "3.0",
    "5900HX": "3.3",
    "5900HS": "3.0",
    "5800H": "3.2",
    "5800HS": "2.8",
    "5800U": "1.9",
    "5600H": "3.3",
    "5600HS": "3.0",
    "5600U": "2.3",
    "5560U": "2.3",
    "5400U": "2.7",
    "5825U": "2.0",
    "5625U": "2.3",
    "5425U": "2.7",
    "5125C": "3.0",
    "7730U": "2.0",
    "7530U": "2.0",
    "7430U": "2.3",
    "7330U": "2.3",
    7203: "2.8",
    7303: "2.4",
    "7663P": "2.0",
    "6980HX": "3.3",
    "6980HS": "3.3",
    "6900HX": "3.3",
    "6900HS": "3.3",
    "6800H": "3.2",
    "6800HS": "3.2",
    "6800U": "2.7",
    "6600H": "3.3",
    "6600HS": "3.3",
    "6600U": "2.9",
    "7735HS": "3.2",
    "7735H": "3.2",
    "7736U": "2.7",
    "7735U": "2.7",
    "7435HS": "3.1",
    "7435H": "3.1",
    "7535HS": "3.3",
    "7535H": "3.3",
    "7535U": "2.9",
    "7235HS": "3.2",
    "7235H": "3.2",
    "7335U": "3.0",
    270: "4.0",
    260: "3.8",
    250: "3.3",
    240: "4.3",
    230: "3.5",
    220: "3.0",
    210: "2.8",
    "8945HS": "4.0",
    "8845HS": "3.8",
    "8840HS": "3.3",
    "8840U": "3.3",
    "8645HS": "4.3",
    "8640HS": "3.5",
    "8640U": "3.5",
    "8540U": "3.0",
    "8440U": "2.8",
    "9950X3D": "4.3",
    "9950X": "4.3",
    "9900X3D": "4.4",
    "9900X": "4.4",
    "9800X3D": "4.7",
    "9700X": "3.8",
    "9700F": "3.8",
    "9600X": "3.9",
    9600: "3.8",
    "9500F": "3.8",
    "9995WX": "2.5",
    "9985WX": "3.2",
    "9975WX": "4.0",
    "9965WX": "4.2",
    "9955WX": "4.5",
    "9945WX": "4.7",
    "9980X": "3.2",
    "9970X": "4.0",
    "9960X": "4.2",
    "PRO HX375": "2.0",
    HX375: "2.0",
    "PRO HX370": "2.0",
    HX370: "2.0",
    365: "2.0",
    "PRO 360": "2.0",
    350: "2.0",
    "PRO 350": "2.0",
    340: "2.0",
    "PRO 340": "2.0",
    330: "2.0",
    395: "3.0",
    "PRO 395": "3.0",
    390: "3.2",
    "PRO 390": "3.2",
    385: "3.6",
    "PRO 385": "3.6",
    "PRO 380": "3.6",
    "9955HX3D": "2.3",
    "9955HX": "2.5",
    "9850HX": "3.0",
    9015: "3.6",
    9965: "2.25",
    9845: "2.1",
    9825: "2.2",
    9745: "2.4",
    9645: "2.3"
  };
  var socketTypes = {
    1: "Other",
    2: "Unknown",
    3: "Daughter Board",
    4: "ZIF Socket",
    5: "Replacement/Piggy Back",
    6: "None",
    7: "LIF Socket",
    8: "Slot 1",
    9: "Slot 2",
    10: "370 Pin Socket",
    11: "Slot A",
    12: "Slot M",
    13: "423",
    14: "A (Socket 462)",
    15: "478",
    16: "754",
    17: "940",
    18: "939",
    19: "mPGA604",
    20: "LGA771",
    21: "LGA775",
    22: "S1",
    23: "AM2",
    24: "F (1207)",
    25: "LGA1366",
    26: "G34",
    27: "AM3",
    28: "C32",
    29: "LGA1156",
    30: "LGA1567",
    31: "PGA988A",
    32: "BGA1288",
    33: "rPGA988B",
    34: "BGA1023",
    35: "BGA1224",
    36: "LGA1155",
    37: "LGA1356",
    38: "LGA2011",
    39: "FS1",
    40: "FS2",
    41: "FM1",
    42: "FM2",
    43: "LGA2011-3",
    44: "LGA1356-3",
    45: "LGA1150",
    46: "BGA1168",
    47: "BGA1234",
    48: "BGA1364",
    49: "AM4",
    50: "LGA1151",
    51: "BGA1356",
    52: "BGA1440",
    53: "BGA1515",
    54: "LGA3647-1",
    55: "SP3",
    56: "SP3r2",
    57: "LGA2066",
    58: "BGA1392",
    59: "BGA1510",
    60: "BGA1528",
    61: "LGA4189",
    62: "LGA1200",
    63: "LGA4677",
    64: "LGA1700",
    65: "BGA1744",
    66: "BGA1781",
    67: "BGA1211",
    68: "BGA2422",
    69: "LGA1211",
    70: "LGA2422",
    71: "LGA5773",
    72: "BGA5773",
    73: "AM5",
    74: "SP5",
    75: "SP6",
    76: "BGA883",
    77: "BGA1190",
    78: "BGA4129",
    79: "LGA4710",
    80: "LGA7529",
    81: "BGA1964",
    82: "BGA1792",
    83: "BGA2049",
    84: "BGA2551",
    85: "LGA1851",
    86: "BGA2114",
    87: "BGA2833"
  };
  var socketTypesByName = {
    LGA1150: "i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430",
    LGA1151: "i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400",
    1155: "G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290"
  };
  function getSocketTypesByName(str) {
    let result2 = "";
    for (const key in socketTypesByName) {
      const names = socketTypesByName[key].split(" ");
      names.forEach((element) => {
        if (str.indexOf(element) >= 0) {
          result2 = key;
        }
      });
    }
    return result2;
  }
  function cpuManufacturer(str) {
    let result2 = str;
    str = str.toLowerCase();
    if (str.indexOf("intel") >= 0) {
      result2 = "Intel";
    }
    if (str.indexOf("amd") >= 0) {
      result2 = "AMD";
    }
    if (str.indexOf("qemu") >= 0) {
      result2 = "QEMU";
    }
    if (str.indexOf("hygon") >= 0) {
      result2 = "Hygon";
    }
    if (str.indexOf("centaur") >= 0) {
      result2 = "WinChip/Via";
    }
    if (str.indexOf("vmware") >= 0) {
      result2 = "VMware";
    }
    if (str.indexOf("Xen") >= 0) {
      result2 = "Xen Hypervisor";
    }
    if (str.indexOf("tcg") >= 0) {
      result2 = "QEMU";
    }
    if (str.indexOf("apple") >= 0) {
      result2 = "Apple";
    }
    if (str.indexOf("sifive") >= 0) {
      result2 = "SiFive";
    }
    if (str.indexOf("thead") >= 0) {
      result2 = "T-Head";
    }
    if (str.indexOf("andestech") >= 0) {
      result2 = "Andes Technology";
    }
    return result2;
  }
  function cpuBrandManufacturer(res) {
    res.brand = res.brand.replace(/\(R\)+/g, "").replace(/\s+/g, " ").trim();
    res.brand = res.brand.replace(/\(TM\)+/g, "").replace(/\s+/g, " ").trim();
    res.brand = res.brand.replace(/\(C\)+/g, "").replace(/\s+/g, " ").trim();
    res.brand = res.brand.replace(/CPU+/g, "").replace(/\s+/g, " ").trim();
    res.manufacturer = cpuManufacturer(res.brand);
    let parts = res.brand.split(" ");
    parts.shift();
    res.brand = parts.join(" ");
    return res;
  }
  function getAMDSpeed(brand) {
    let result2 = "0";
    for (let key in AMDBaseFrequencies) {
      if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {
        let parts = key.split("|");
        let found = 0;
        parts.forEach((item) => {
          if (brand.indexOf(item) > -1) {
            found++;
          }
        });
        if (found === parts.length) {
          result2 = AMDBaseFrequencies[key];
        }
      }
    }
    return parseFloat(result2);
  }
  function getCpu() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const UNKNOWN = "unknown";
        let result2 = {
          manufacturer: UNKNOWN,
          brand: UNKNOWN,
          vendor: "",
          family: "",
          model: "",
          stepping: "",
          revision: "",
          voltage: "",
          speed: 0,
          speedMin: 0,
          speedMax: 0,
          governor: "",
          cores: util.cores(),
          physicalCores: util.cores(),
          performanceCores: util.cores(),
          efficiencyCores: 0,
          processors: 1,
          socket: "",
          flags: "",
          virtualization: false,
          cache: {}
        };
        cpuFlags().then((flags) => {
          result2.flags = flags;
          result2.virtualization = flags.indexOf("vmx") > -1 || flags.indexOf("svm") > -1;
          if (_darwin) {
            exec("sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily", (error2, stdout) => {
              const lines = stdout.toString().split(`
`);
              const modelline = util.getValue(lines, "machdep.cpu.brand_string");
              const modellineParts = modelline.split("@");
              result2.brand = modellineParts[0].trim();
              const speed = modellineParts[1] ? modellineParts[1].trim() : "0";
              result2.speed = parseFloat(speed.replace(/GHz+/g, ""));
              let tbFrequency = util.getValue(lines, "hw.tbfrequency") / 1e9;
              tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;
              result2.speed = result2.speed === 0 ? tbFrequency : result2.speed;
              _cpu_speed = result2.speed;
              result2 = cpuBrandManufacturer(result2);
              result2.speedMin = util.getValue(lines, "hw.cpufrequency_min") ? util.getValue(lines, "hw.cpufrequency_min") / 1e9 : result2.speed;
              result2.speedMax = util.getValue(lines, "hw.cpufrequency_max") ? util.getValue(lines, "hw.cpufrequency_max") / 1e9 : result2.speed;
              result2.vendor = util.getValue(lines, "machdep.cpu.vendor") || "Apple";
              result2.family = util.getValue(lines, "machdep.cpu.family") || util.getValue(lines, "hw.cpufamily");
              result2.model = util.getValue(lines, "machdep.cpu.model");
              result2.stepping = util.getValue(lines, "machdep.cpu.stepping") || util.getValue(lines, "hw.cpusubfamily");
              result2.virtualization = true;
              const countProcessors = util.getValue(lines, "hw.packages");
              const countCores = util.getValue(lines, "hw.physicalcpu_max");
              const countThreads = util.getValue(lines, "hw.ncpu");
              if (os.arch() === "arm64") {
                result2.socket = "SOC";
                try {
                  const clusters = execSync("ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type").toString().split(`
`);
                  const efficiencyCores = clusters.filter((line) => line.indexOf('"E"') >= 0).length;
                  const performanceCores = clusters.filter((line) => line.indexOf('"P"') >= 0).length;
                  result2.efficiencyCores = efficiencyCores;
                  result2.performanceCores = performanceCores;
                } catch {
                  util.noop();
                }
              }
              if (countProcessors) {
                result2.processors = parseInt(countProcessors, 10) || 1;
              }
              if (countCores && countThreads) {
                result2.cores = parseInt(countThreads) || util.cores();
                result2.physicalCores = parseInt(countCores) || util.cores();
              }
              cpuCache().then((res) => {
                result2.cache = res;
                resolve(result2);
              });
            });
          }
          if (_linux) {
            let modelline = "";
            let lines = [];
            if (os.cpus()[0] && os.cpus()[0].model) {
              modelline = os.cpus()[0].model;
            }
            exec('export LC_ALL=C; lscpu; echo -n "Governor: "; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', (error2, stdout) => {
              if (!error2) {
                lines = stdout.toString().split(`
`);
              }
              modelline = util.getValue(lines, "model name") || modelline;
              modelline = util.getValue(lines, "bios model name") || modelline;
              modelline = util.cleanString(modelline);
              const modellineParts = modelline.split("@");
              result2.brand = modellineParts[0].trim();
              if (result2.brand.indexOf("Unknown") >= 0) {
                result2.brand = result2.brand.split("Unknown")[0].trim();
              }
              result2.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;
              if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
                result2.speed = getAMDSpeed(result2.brand);
              }
              if (result2.speed === 0) {
                const current = getCpuCurrentSpeedSync();
                if (current.avg !== 0) {
                  result2.speed = current.avg;
                }
              }
              _cpu_speed = result2.speed;
              result2.speedMin = Math.round(parseFloat(util.getValue(lines, "cpu min mhz").replace(/,/g, ".")) / 10) / 100;
              result2.speedMax = Math.round(parseFloat(util.getValue(lines, "cpu max mhz").replace(/,/g, ".")) / 10) / 100;
              result2 = cpuBrandManufacturer(result2);
              result2.vendor = cpuManufacturer(util.getValue(lines, "vendor id"));
              result2.family = util.getValue(lines, "cpu family");
              result2.model = util.getValue(lines, "model:");
              result2.stepping = util.getValue(lines, "stepping");
              result2.revision = util.getValue(lines, "cpu revision");
              result2.cache.l1d = util.getValue(lines, "l1d cache");
              if (result2.cache.l1d) {
                result2.cache.l1d = parseInt(result2.cache.l1d) * (result2.cache.l1d.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l1d.indexOf("K") !== -1 ? 1024 : 1);
              }
              result2.cache.l1i = util.getValue(lines, "l1i cache");
              if (result2.cache.l1i) {
                result2.cache.l1i = parseInt(result2.cache.l1i) * (result2.cache.l1i.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l1i.indexOf("K") !== -1 ? 1024 : 1);
              }
              result2.cache.l2 = util.getValue(lines, "l2 cache");
              if (result2.cache.l2) {
                result2.cache.l2 = parseInt(result2.cache.l2) * (result2.cache.l2.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l2.indexOf("K") !== -1 ? 1024 : 1);
              }
              result2.cache.l3 = util.getValue(lines, "l3 cache");
              if (result2.cache.l3) {
                result2.cache.l3 = parseInt(result2.cache.l3) * (result2.cache.l3.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l3.indexOf("K") !== -1 ? 1024 : 1);
              }
              const threadsPerCore = util.getValue(lines, "thread(s) per core") || "1";
              const processors = util.getValue(lines, "socket(s)") || "1";
              const threadsPerCoreInt = parseInt(threadsPerCore, 10);
              const processorsInt = parseInt(processors, 10) || 1;
              const coresPerSocket = parseInt(util.getValue(lines, "core(s) per socket"), 10);
              result2.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result2.cores / threadsPerCoreInt;
              result2.performanceCores = threadsPerCoreInt > 1 ? result2.cores - result2.physicalCores : result2.cores;
              result2.efficiencyCores = threadsPerCoreInt > 1 ? result2.cores - threadsPerCoreInt * result2.performanceCores : 0;
              result2.processors = processorsInt;
              result2.governor = util.getValue(lines, "governor") || "";
              if (result2.vendor === "ARM" && util.isRaspberry()) {
                const rPIRevision = util.decodePiCpuinfo();
                result2.family = result2.manufacturer;
                result2.manufacturer = rPIRevision.manufacturer;
                result2.brand = rPIRevision.processor;
                result2.revision = rPIRevision.revisionCode;
                result2.socket = "SOC";
              }
              if (util.getValue(lines, "architecture") === "riscv64") {
                const linesRiscV = fs.readFileSync("/proc/cpuinfo").toString().split(`
`);
                const uarch = util.getValue(linesRiscV, "uarch") || "";
                if (uarch.indexOf(",") > -1) {
                  const split = uarch.split(",");
                  result2.manufacturer = cpuManufacturer(split[0]);
                  result2.brand = split[1];
                }
              }
              let lines2 = [];
              exec('export LC_ALL=C; dmidecode t 4 2>/dev/null | grep "Upgrade: Socket"; unset LC_ALL', (error22, stdout2) => {
                lines2 = stdout2.toString().split(`
`);
                if (lines2 && lines2.length) {
                  result2.socket = util.getValue(lines2, "Upgrade").replace("Socket", "").trim() || result2.socket;
                }
                resolve(result2);
              });
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            let modelline = "";
            let lines = [];
            if (os.cpus()[0] && os.cpus()[0].model) {
              modelline = os.cpus()[0].model;
            }
            exec("export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL", (error2, stdout) => {
              let cache = [];
              if (!error2) {
                const data = stdout.toString().split("# dmidecode");
                const processor = data.length > 1 ? data[1] : "";
                cache = data.length > 2 ? data[2].split("Cache Information") : [];
                lines = processor.split(`
`);
              }
              result2.brand = modelline.split("@")[0].trim();
              result2.speed = modelline.split("@")[1] ? parseFloat(modelline.split("@")[1].trim()) : 0;
              if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
                result2.speed = getAMDSpeed(result2.brand);
              }
              if (result2.speed === 0) {
                const current = getCpuCurrentSpeedSync();
                if (current.avg !== 0) {
                  result2.speed = current.avg;
                }
              }
              _cpu_speed = result2.speed;
              result2.speedMin = result2.speed;
              result2.speedMax = Math.round(parseFloat(util.getValue(lines, "max speed").replace(/Mhz/g, "")) / 10) / 100;
              result2 = cpuBrandManufacturer(result2);
              result2.vendor = cpuManufacturer(util.getValue(lines, "manufacturer"));
              let sig = util.getValue(lines, "signature");
              sig = sig.split(",");
              for (let i = 0;i < sig.length; i++) {
                sig[i] = sig[i].trim();
              }
              result2.family = util.getValue(sig, "Family", " ", true);
              result2.model = util.getValue(sig, "Model", " ", true);
              result2.stepping = util.getValue(sig, "Stepping", " ", true);
              result2.revision = "";
              const voltage = parseFloat(util.getValue(lines, "voltage"));
              result2.voltage = isNaN(voltage) ? "" : voltage.toFixed(2);
              for (let i = 0;i < cache.length; i++) {
                lines = cache[i].split(`
`);
                let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                cacheType = cacheType.length ? cacheType[0] : "";
                const sizeParts = util.getValue(lines, "Installed Size").split(" ");
                let size = parseInt(sizeParts[0], 10);
                const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                if (cacheType) {
                  if (cacheType === "l1") {
                    result2.cache[cacheType + "d"] = size / 2;
                    result2.cache[cacheType + "i"] = size / 2;
                  } else {
                    result2.cache[cacheType] = size;
                  }
                }
              }
              result2.socket = util.getValue(lines, "Upgrade").replace("Socket", "").trim();
              const threadCount = util.getValue(lines, "thread count").trim();
              const coreCount = util.getValue(lines, "core count").trim();
              if (coreCount && threadCount) {
                result2.cores = parseInt(threadCount, 10);
                result2.physicalCores = parseInt(coreCount, 10);
              }
              resolve(result2);
            });
          }
          if (_sunos) {
            resolve(result2);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl"));
              workload.push(util.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
              workload.push(util.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
              Promise.all(workload).then((data) => {
                let lines = data[0].split(`\r
`);
                let name = util.getValue(lines, "name", ":") || "";
                if (name.indexOf("@") >= 0) {
                  result2.brand = name.split("@")[0].trim();
                  result2.speed = name.split("@")[1] ? parseFloat(name.split("@")[1].trim()) : 0;
                  _cpu_speed = result2.speed;
                } else {
                  result2.brand = name.trim();
                  result2.speed = 0;
                }
                result2 = cpuBrandManufacturer(result2);
                result2.revision = util.getValue(lines, "revision", ":");
                result2.vendor = util.getValue(lines, "manufacturer", ":");
                result2.speedMax = Math.round(parseFloat(util.getValue(lines, "maxclockspeed", ":").replace(/,/g, ".")) / 10) / 100;
                if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
                  result2.speed = getAMDSpeed(result2.brand);
                }
                if (result2.speed === 0) {
                  result2.speed = result2.speedMax;
                }
                result2.speedMin = result2.speed;
                let description = util.getValue(lines, "description", ":").split(" ");
                for (let i = 0;i < description.length; i++) {
                  if (description[i].toLowerCase().startsWith("family") && i + 1 < description.length && description[i + 1]) {
                    result2.family = description[i + 1];
                  }
                  if (description[i].toLowerCase().startsWith("model") && i + 1 < description.length && description[i + 1]) {
                    result2.model = description[i + 1];
                  }
                  if (description[i].toLowerCase().startsWith("stepping") && i + 1 < description.length && description[i + 1]) {
                    result2.stepping = description[i + 1];
                  }
                }
                const socketId = util.getValue(lines, "UpgradeMethod", ":");
                if (socketTypes[socketId]) {
                  result2.socket = socketTypes[socketId];
                }
                const socketByName = getSocketTypesByName(name);
                if (socketByName) {
                  result2.socket = socketByName;
                }
                const countProcessors = util.countLines(lines, "Caption");
                const countThreads = util.getValue(lines, "NumberOfLogicalProcessors", ":");
                const countCores = util.getValue(lines, "NumberOfCores", ":");
                if (countProcessors) {
                  result2.processors = parseInt(countProcessors) || 1;
                }
                if (countCores && countThreads) {
                  result2.cores = parseInt(countThreads) || util.cores();
                  result2.physicalCores = parseInt(countCores) || util.cores();
                }
                if (countProcessors > 1) {
                  result2.cores = result2.cores * countProcessors;
                  result2.physicalCores = result2.physicalCores * countProcessors;
                }
                result2.cache = parseWinCache(data[0], data[1]);
                const hyperv = data[2] ? data[2].toString().toLowerCase() : "";
                result2.virtualization = hyperv.indexOf("true") !== -1;
                resolve(result2);
              });
            } catch (e) {
              resolve(result2);
            }
          }
        });
      });
    });
  }
  function cpu(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        getCpu().then((result2) => {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      });
    });
  }
  exports.cpu = cpu;
  function getCpuCurrentSpeedSync() {
    const cpus = os.cpus();
    let minFreq = 999999999;
    let maxFreq = 0;
    let avgFreq = 0;
    const cores = [];
    const speeds = [];
    if (cpus && cpus.length && Object.prototype.hasOwnProperty.call(cpus[0], "speed")) {
      for (let i in cpus) {
        speeds.push(cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1000 : cpus[i].speed / 10);
      }
    } else if (_linux) {
      try {
        const speedStrings = execSync('cat /proc/cpuinfo | grep "cpu MHz" | cut -d " " -f 3', util.execOptsLinux).toString().split(`
`).filter((line) => line.length > 0);
        for (let i in speedStrings) {
          speeds.push(Math.floor(parseInt(speedStrings[i], 10) / 10) / 100);
        }
      } catch {
        util.noop();
      }
    }
    if (speeds && speeds.length) {
      try {
        for (const i in speeds) {
          avgFreq = avgFreq + speeds[i];
          if (speeds[i] > maxFreq) {
            maxFreq = speeds[i];
          }
          if (speeds[i] < minFreq) {
            minFreq = speeds[i];
          }
          cores.push(parseFloat(speeds[i].toFixed(2)));
        }
        avgFreq = avgFreq / speeds.length;
        return {
          min: parseFloat(minFreq.toFixed(2)),
          max: parseFloat(maxFreq.toFixed(2)),
          avg: parseFloat(avgFreq.toFixed(2)),
          cores
        };
      } catch (e) {
        return {
          min: 0,
          max: 0,
          avg: 0,
          cores
        };
      }
    } else {
      return {
        min: 0,
        max: 0,
        avg: 0,
        cores
      };
    }
  }
  function cpuCurrentSpeed(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = getCpuCurrentSpeedSync();
        if (result2.avg === 0 && _cpu_speed !== 0) {
          const currCpuSpeed = parseFloat(_cpu_speed);
          result2 = {
            min: currCpuSpeed,
            max: currCpuSpeed,
            avg: currCpuSpeed,
            cores: []
          };
        }
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      });
    });
  }
  exports.cpuCurrentSpeed = cpuCurrentSpeed;
  function cpuTemperature(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          main: null,
          cores: [],
          max: null,
          socket: [],
          chipset: null
        };
        if (_linux) {
          try {
            const cmd2 = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo "-----"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';
            const parts = execSync(cmd2, util.execOptsLinux).toString().split(`-----
`);
            if (parts.length === 2) {
              const lines = parts[0].split(`
`);
              const lines2 = parts[1].split(`
`);
              for (let i = 0;i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith("acpi") && lines2[i]) {
                  result2.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);
                }
                if (line.startsWith("pch") && lines2[i]) {
                  result2.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;
                }
              }
            }
          } catch (e) {
            util.noop();
          }
          const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in "$mon"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat "$label")___$(cat "$value"); fi; done; done;';
          try {
            exec(cmd, (error2, stdout) => {
              stdout = stdout.toString();
              const tdiePos = stdout.toLowerCase().indexOf("tdie");
              if (tdiePos !== -1) {
                stdout = stdout.substring(tdiePos);
              }
              const lines = stdout.split(`
`);
              let tctl = 0;
              lines.forEach((line) => {
                const parts = line.split("___");
                const label = parts[0];
                const value = parts.length > 1 && parts[1] ? parts[1] : "0";
                if (value && label && label.toLowerCase() === "tctl") {
                  tctl = result2.main = Math.round(parseInt(value, 10) / 100) / 10;
                }
                if (value && (label === undefined || label && label.toLowerCase().startsWith("core"))) {
                  result2.cores.push(Math.round(parseInt(value, 10) / 100) / 10);
                } else if (value && label && result2.main === null && (label.toLowerCase().indexOf("package") >= 0 || label.toLowerCase().indexOf("physical") >= 0 || label.toLowerCase() === "tccd1")) {
                  result2.main = Math.round(parseInt(value, 10) / 100) / 10;
                }
              });
              if (tctl && result2.main === null) {
                result2.main = tctl;
              }
              if (result2.cores.length > 0) {
                if (result2.main === null) {
                  result2.main = Math.round(result2.cores.reduce((a, b) => a + b, 0) / result2.cores.length);
                }
                let maxtmp = Math.max.apply(Math, result2.cores);
                result2.max = maxtmp > result2.main ? maxtmp : result2.main;
              }
              if (result2.main !== null) {
                if (result2.max === null) {
                  result2.max = result2.main;
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
                return;
              }
              exec("sensors", (error3, stdout2) => {
                if (!error3) {
                  const lines2 = stdout2.toString().split(`
`);
                  let tdieTemp = null;
                  let newSectionStarts = true;
                  let section = "";
                  lines2.forEach((line) => {
                    if (line.trim() === "") {
                      newSectionStarts = true;
                    } else if (newSectionStarts) {
                      if (line.trim().toLowerCase().startsWith("acpi")) {
                        section = "acpi";
                      }
                      if (line.trim().toLowerCase().startsWith("pch")) {
                        section = "pch";
                      }
                      if (line.trim().toLowerCase().startsWith("core")) {
                        section = "core";
                      }
                      if (line.trim().toLowerCase().startsWith("k10temp")) {
                        section = "coreAMD";
                      }
                      newSectionStarts = false;
                    }
                    const regex = /[+-]([^]*)/g;
                    const temps = line.match(regex);
                    const firstPart = line.split(":")[0].toUpperCase();
                    if (section === "acpi") {
                      if (firstPart.indexOf("TEMP") !== -1) {
                        result2.socket.push(parseFloat(temps));
                      }
                    } else if (section === "pch") {
                      if (firstPart.indexOf("TEMP") !== -1 && !result2.chipset) {
                        result2.chipset = parseFloat(temps);
                      }
                    }
                    if (firstPart.indexOf("PHYSICAL") !== -1 || firstPart.indexOf("PACKAGE") !== -1 || section === "coreAMD" && firstPart.indexOf("TDIE") !== -1 || firstPart.indexOf("TEMP") !== -1) {
                      result2.main = parseFloat(temps);
                    }
                    if (firstPart.indexOf("CORE ") !== -1) {
                      result2.cores.push(parseFloat(temps));
                    }
                    if (firstPart.indexOf("TDIE") !== -1 && tdieTemp === null) {
                      tdieTemp = parseFloat(temps);
                    }
                  });
                  if (result2.cores.length > 0) {
                    result2.main = Math.round(result2.cores.reduce((a, b) => a + b, 0) / result2.cores.length);
                    const maxtmp = Math.max.apply(Math, result2.cores);
                    result2.max = maxtmp > result2.main ? maxtmp : result2.main;
                  } else {
                    if (result2.main === null && tdieTemp !== null) {
                      result2.main = tdieTemp;
                      result2.max = tdieTemp;
                    }
                  }
                  if (result2.main !== null && result2.max === null) {
                    result2.max = result2.main;
                  }
                  if (result2.main !== null || result2.max !== null) {
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                    return;
                  }
                }
                fs.stat("/sys/class/thermal/thermal_zone0/temp", (err) => {
                  if (err === null) {
                    fs.readFile("/sys/class/thermal/thermal_zone0/temp", (error4, stdout3) => {
                      if (!error4) {
                        const lines2 = stdout3.toString().split(`
`);
                        if (lines2.length > 0) {
                          result2.main = parseFloat(lines2[0]) / 1000;
                          result2.max = result2.main;
                        }
                      }
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    });
                  } else {
                    exec("/opt/vc/bin/vcgencmd measure_temp", (error4, stdout3) => {
                      if (!error4) {
                        const lines2 = stdout3.toString().split(`
`);
                        if (lines2.length > 0 && lines2[0].indexOf("=")) {
                          result2.main = parseFloat(lines2[0].split("=")[1]);
                          result2.max = result2.main;
                        }
                      }
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    });
                  }
                });
              });
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("sysctl dev.cpu | grep temp", (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              let sum = 0;
              lines.forEach((line) => {
                const parts = line.split(":");
                if (parts.length > 1) {
                  const temp = parseFloat(parts[1].replace(",", "."));
                  if (temp > result2.max) {
                    result2.max = temp;
                  }
                  sum = sum + temp;
                  result2.cores.push(temp);
                }
              });
              if (result2.cores.length) {
                result2.main = Math.round(sum / result2.cores.length * 100) / 100;
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          try {
            const osxTemp = (()=>{throw new Error("Cannot require module "+"osx-temperature-sensor");})();
            result2 = osxTemp.cpuTemperature();
            if (result2.main) {
              result2.main = Math.round(result2.main * 100) / 100;
            }
            if (result2.max) {
              result2.max = Math.round(result2.max * 100) / 100;
            }
            if (result2 && result2.cores && result2.cores.length) {
              for (let i = 0;i < result2.cores.length; i++) {
                result2.cores[i] = Math.round(result2.cores[i] * 100) / 100;
              }
            }
          } catch {
            util.noop();
          }
          try {
            const macosTemp = (()=>{throw new Error("Cannot require module "+"macos-temperature-sensor");})();
            const res = macosTemp.temperature();
            if (res.cpu) {
              result2.main = Math.round(res.cpu * 100) / 100;
              result2.max = result2.main;
            }
            if (res.soc) {
              result2.chipset = Math.round(res.soc * 100) / 100;
            }
            if (res && res.cpuDieTemps.length) {
              for (const temp of res.cpuDieTemps) {
                result2.cores.push(Math.round(temp * 100) / 100);
              }
            }
          } catch {
            util.noop();
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_windows) {
          try {
            util.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace "root/wmi" | Select CurrentTemperature').then((stdout, error2) => {
              if (!error2) {
                let sum = 0;
                const lines = stdout.split(`\r
`).filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                lines.forEach((line) => {
                  const value = (parseInt(line, 10) - 2732) / 10;
                  if (!isNaN(value)) {
                    sum = sum + value;
                    if (value > result2.max) {
                      result2.max = value;
                    }
                    result2.cores.push(value);
                  }
                });
                if (result2.cores.length) {
                  result2.main = sum / result2.cores.length;
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.cpuTemperature = cpuTemperature;
  function cpuFlags(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = "";
        if (_windows) {
          try {
            exec('reg query "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0" /v FeatureSet', util.execOptsWin, (error2, stdout) => {
              if (!error2) {
                let flag_hex = stdout.split("0x").pop().trim();
                let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);
                let flag_bin = "0".repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;
                let all_flags = [
                  "fpu",
                  "vme",
                  "de",
                  "pse",
                  "tsc",
                  "msr",
                  "pae",
                  "mce",
                  "cx8",
                  "apic",
                  "",
                  "sep",
                  "mtrr",
                  "pge",
                  "mca",
                  "cmov",
                  "pat",
                  "pse-36",
                  "psn",
                  "clfsh",
                  "",
                  "ds",
                  "acpi",
                  "mmx",
                  "fxsr",
                  "sse",
                  "sse2",
                  "ss",
                  "htt",
                  "tm",
                  "ia64",
                  "pbe"
                ];
                for (let f = 0;f < all_flags.length; f++) {
                  if (flag_bin[f] === "1" && all_flags[f] !== "") {
                    result2 += " " + all_flags[f];
                  }
                }
                result2 = result2.trim().toLowerCase();
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_linux) {
          try {
            exec("export LC_ALL=C; lscpu; unset LC_ALL", (error2, stdout) => {
              if (!error2) {
                let lines = stdout.toString().split(`
`);
                lines.forEach((line) => {
                  if (line.split(":")[0].toUpperCase().indexOf("FLAGS") !== -1) {
                    result2 = line.split(":")[1].trim().toLowerCase();
                  }
                });
              }
              if (!result2) {
                fs.readFile("/proc/cpuinfo", (error3, stdout2) => {
                  if (!error3) {
                    let lines = stdout2.toString().split(`
`);
                    result2 = util.getValue(lines, "features", ":", true).toLowerCase();
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL", (error2, stdout) => {
            const flags = [];
            if (!error2) {
              const parts = stdout.toString().split("\tFlags:");
              const lines = parts.length > 1 ? parts[1].split("\tVersion:")[0].split(`
`) : [];
              lines.forEach((line) => {
                const flag = (line.indexOf("(") ? line.split("(")[0].toLowerCase() : "").trim().replace(/\t/g, "");
                if (flag) {
                  flags.push(flag);
                }
              });
            }
            result2 = flags.join(" ").trim().toLowerCase();
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          exec("sysctl machdep.cpu.features", (error2, stdout) => {
            if (!error2) {
              let lines = stdout.toString().split(`
`);
              if (lines.length > 0 && lines[0].indexOf("machdep.cpu.features:") !== -1) {
                result2 = lines[0].split(":")[1].trim().toLowerCase();
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.cpuFlags = cpuFlags;
  function cpuCache(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          l1d: null,
          l1i: null,
          l2: null,
          l3: null
        };
        if (_linux) {
          try {
            exec("export LC_ALL=C; lscpu; unset LC_ALL", (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`);
                lines.forEach((line) => {
                  const parts = line.split(":");
                  if (parts[0].toUpperCase().indexOf("L1D CACHE") !== -1) {
                    result2.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toUpperCase().indexOf("L1I CACHE") !== -1) {
                    result2.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toUpperCase().indexOf("L2 CACHE") !== -1) {
                    result2.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toUpperCase().indexOf("L3 CACHE") !== -1) {
                    result2.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec("export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL", (error2, stdout) => {
            let cache = [];
            if (!error2) {
              const data = stdout.toString();
              cache = data.split("Cache Information");
              cache.shift();
            }
            for (let i = 0;i < cache.length; i++) {
              const lines = cache[i].split(`
`);
              let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
              cacheType = cacheType.length ? cacheType[0] : "";
              const sizeParts = util.getValue(lines, "Installed Size").split(" ");
              let size = parseInt(sizeParts[0], 10);
              const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
              size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
              if (cacheType) {
                if (cacheType === "l1") {
                  result2.cache[cacheType + "d"] = size / 2;
                  result2.cache[cacheType + "i"] = size / 2;
                } else {
                  result2.cache[cacheType] = size;
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          exec("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", (error2, stdout) => {
            if (!error2) {
              let lines = stdout.toString().split(`
`);
              lines.forEach((line) => {
                let parts = line.split(":");
                if (parts[0].toLowerCase().indexOf("hw.l1icachesize") !== -1) {
                  result2.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toLowerCase().indexOf("hw.l1dcachesize") !== -1) {
                  result2.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toLowerCase().indexOf("hw.l2cachesize") !== -1) {
                  result2.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
                if (parts[0].toLowerCase().indexOf("hw.l3cachesize") !== -1) {
                  result2.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_windows) {
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl"));
            workload.push(util.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
            Promise.all(workload).then((data) => {
              result2 = parseWinCache(data[0], data[1]);
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  function parseWinCache(linesProc, linesCache) {
    const result2 = {
      l1d: null,
      l1i: null,
      l2: null,
      l3: null
    };
    let lines = linesProc.split(`\r
`);
    result2.l1d = 0;
    result2.l1i = 0;
    result2.l2 = util.getValue(lines, "l2cachesize", ":");
    result2.l3 = util.getValue(lines, "l3cachesize", ":");
    if (result2.l2) {
      result2.l2 = parseInt(result2.l2, 10) * 1024;
    } else {
      result2.l2 = 0;
    }
    if (result2.l3) {
      result2.l3 = parseInt(result2.l3, 10) * 1024;
    } else {
      result2.l3 = 0;
    }
    const parts = linesCache.split(/\n\s*\n/);
    let l1i = 0;
    let l1d = 0;
    let l2 = 0;
    parts.forEach((part) => {
      const lines2 = part.split(`\r
`);
      const cacheType = util.getValue(lines2, "CacheType");
      const level = util.getValue(lines2, "Level");
      const installedSize = util.getValue(lines2, "InstalledSize");
      if (level === "3" && cacheType === "3") {
        result2.l1i = result2.l1i + parseInt(installedSize, 10) * 1024;
      }
      if (level === "3" && cacheType === "4") {
        result2.l1d = result2.l1d + parseInt(installedSize, 10) * 1024;
      }
      if (level === "3" && cacheType === "5") {
        l1i = parseInt(installedSize, 10) / 2;
        l1d = parseInt(installedSize, 10) / 2;
      }
      if (level === "4" && cacheType === "5") {
        l2 = l2 + parseInt(installedSize, 10) * 1024;
      }
    });
    if (!result2.l1i && !result2.l1d) {
      result2.l1i = l1i;
      result2.l1d = l1d;
    }
    if (l2) {
      result2.l2 = l2;
    }
    return result2;
  }
  exports.cpuCache = cpuCache;
  function getLoad() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const loads = os.loadavg().map((x) => {
          return x / util.cores();
        });
        const avgLoad = parseFloat(Math.max.apply(Math, loads).toFixed(2));
        let result2 = {};
        const now = Date.now() - _current_cpu.ms;
        if (now >= 200) {
          _current_cpu.ms = Date.now();
          const cpus = os.cpus().map((cpu2) => {
            cpu2.times.steal = 0;
            cpu2.times.guest = 0;
            return cpu2;
          });
          let totalUser = 0;
          let totalSystem = 0;
          let totalNice = 0;
          let totalIrq = 0;
          let totalIdle = 0;
          let totalSteal = 0;
          let totalGuest = 0;
          const cores = [];
          _corecount = cpus && cpus.length ? cpus.length : 0;
          if (_linux) {
            try {
              const lines = execSync("cat /proc/stat 2>/dev/null | grep cpu", util.execOptsLinux).toString().split(`
`);
              if (lines.length > 1) {
                lines.shift();
                if (lines.length === cpus.length) {
                  for (let i = 0;i < lines.length; i++) {
                    let parts = lines[i].split(" ");
                    if (parts.length >= 10) {
                      const steal = parseFloat(parts[8]) || 0;
                      const guest = parseFloat(parts[9]) || 0;
                      cpus[i].times.steal = steal;
                      cpus[i].times.guest = guest;
                    }
                  }
                }
              }
            } catch {
              util.noop();
            }
          }
          for (let i = 0;i < _corecount; i++) {
            const cpu2 = cpus[i].times;
            totalUser += cpu2.user;
            totalSystem += cpu2.sys;
            totalNice += cpu2.nice;
            totalIdle += cpu2.idle;
            totalIrq += cpu2.irq;
            totalSteal += cpu2.steal || 0;
            totalGuest += cpu2.guest || 0;
            const tmpTick = _cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0;
            const tmpLoad = _cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0;
            const tmpUser = _cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0;
            const tmpSystem = _cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0;
            const tmpNice = _cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0;
            const tmpIdle = _cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0;
            const tmpIrq = _cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0;
            const tmpSteal = _cpus && _cpus[i] && _cpus[i].steal ? _cpus[i].steal : 0;
            const tmpGuest = _cpus && _cpus[i] && _cpus[i].guest ? _cpus[i].guest : 0;
            _cpus[i] = cpu2;
            _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest + _cpus[i].idle;
            _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest;
            _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;
            _cpus[i].load = _cpus[i].totalLoad - tmpLoad;
            _cpus[i].loadUser = _cpus[i].user - tmpUser;
            _cpus[i].loadSystem = _cpus[i].sys - tmpSystem;
            _cpus[i].loadNice = _cpus[i].nice - tmpNice;
            _cpus[i].loadIdle = _cpus[i].idle - tmpIdle;
            _cpus[i].loadIrq = _cpus[i].irq - tmpIrq;
            _cpus[i].loadSteal = _cpus[i].steal - tmpSteal;
            _cpus[i].loadGuest = _cpus[i].guest - tmpGuest;
            cores[i] = {};
            cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
            cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
            cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
            cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
            cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
            cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
            cores[i].loadSteal = _cpus[i].loadSteal / _cpus[i].currentTick * 100;
            cores[i].loadGuest = _cpus[i].loadGuest / _cpus[i].currentTick * 100;
            cores[i].rawLoad = _cpus[i].load;
            cores[i].rawLoadUser = _cpus[i].loadUser;
            cores[i].rawLoadSystem = _cpus[i].loadSystem;
            cores[i].rawLoadNice = _cpus[i].loadNice;
            cores[i].rawLoadIdle = _cpus[i].loadIdle;
            cores[i].rawLoadIrq = _cpus[i].loadIrq;
            cores[i].rawLoadSteal = _cpus[i].loadSteal;
            cores[i].rawLoadGuest = _cpus[i].loadGuest;
          }
          const totalTick = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest + totalIdle;
          const totalLoad = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest;
          const currentTick = totalTick - _current_cpu.tick;
          result2 = {
            avgLoad,
            currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,
            currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,
            currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,
            currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,
            currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,
            currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,
            currentLoadSteal: (totalSteal - _current_cpu.steal) / currentTick * 100,
            currentLoadGuest: (totalGuest - _current_cpu.guest) / currentTick * 100,
            rawCurrentLoad: totalLoad - _current_cpu.load,
            rawCurrentLoadUser: totalUser - _current_cpu.user,
            rawCurrentLoadSystem: totalSystem - _current_cpu.system,
            rawCurrentLoadNice: totalNice - _current_cpu.nice,
            rawCurrentLoadIdle: totalIdle - _current_cpu.idle,
            rawCurrentLoadIrq: totalIrq - _current_cpu.irq,
            rawCurrentLoadSteal: totalSteal - _current_cpu.steal,
            rawCurrentLoadGuest: totalGuest - _current_cpu.guest,
            cpus: cores
          };
          _current_cpu = {
            user: totalUser,
            nice: totalNice,
            system: totalSystem,
            idle: totalIdle,
            irq: totalIrq,
            steal: totalSteal,
            guest: totalGuest,
            tick: totalTick,
            load: totalLoad,
            ms: _current_cpu.ms,
            currentLoad: result2.currentLoad,
            currentLoadUser: result2.currentLoadUser,
            currentLoadSystem: result2.currentLoadSystem,
            currentLoadNice: result2.currentLoadNice,
            currentLoadIdle: result2.currentLoadIdle,
            currentLoadIrq: result2.currentLoadIrq,
            currentLoadSteal: result2.currentLoadSteal,
            currentLoadGuest: result2.currentLoadGuest,
            rawCurrentLoad: result2.rawCurrentLoad,
            rawCurrentLoadUser: result2.rawCurrentLoadUser,
            rawCurrentLoadSystem: result2.rawCurrentLoadSystem,
            rawCurrentLoadNice: result2.rawCurrentLoadNice,
            rawCurrentLoadIdle: result2.rawCurrentLoadIdle,
            rawCurrentLoadIrq: result2.rawCurrentLoadIrq,
            rawCurrentLoadSteal: result2.rawCurrentLoadSteal,
            rawCurrentLoadGuest: result2.rawCurrentLoadGuest
          };
        } else {
          const cores = [];
          for (let i = 0;i < _corecount; i++) {
            cores[i] = {};
            cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
            cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
            cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
            cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
            cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
            cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
            cores[i].rawLoad = _cpus[i].load;
            cores[i].rawLoadUser = _cpus[i].loadUser;
            cores[i].rawLoadSystem = _cpus[i].loadSystem;
            cores[i].rawLoadNice = _cpus[i].loadNice;
            cores[i].rawLoadIdle = _cpus[i].loadIdle;
            cores[i].rawLoadIrq = _cpus[i].loadIrq;
            cores[i].rawLoadSteal = _cpus[i].loadSteal;
            cores[i].rawLoadGuest = _cpus[i].loadGuest;
          }
          result2 = {
            avgLoad,
            currentLoad: _current_cpu.currentLoad,
            currentLoadUser: _current_cpu.currentLoadUser,
            currentLoadSystem: _current_cpu.currentLoadSystem,
            currentLoadNice: _current_cpu.currentLoadNice,
            currentLoadIdle: _current_cpu.currentLoadIdle,
            currentLoadIrq: _current_cpu.currentLoadIrq,
            currentLoadSteal: _current_cpu.currentLoadSteal,
            currentLoadGuest: _current_cpu.currentLoadGuest,
            rawCurrentLoad: _current_cpu.rawCurrentLoad,
            rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,
            rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,
            rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,
            rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,
            rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,
            rawCurrentLoadSteal: _current_cpu.rawCurrentLoadSteal,
            rawCurrentLoadGuest: _current_cpu.rawCurrentLoadGuest,
            cpus: cores
          };
        }
        resolve(result2);
      });
    });
  }
  function currentLoad(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        getLoad().then((result2) => {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      });
    });
  }
  exports.currentLoad = currentLoad;
  function getFullLoad() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const cpus = os.cpus();
        let totalUser = 0;
        let totalSystem = 0;
        let totalNice = 0;
        let totalIrq = 0;
        let totalIdle = 0;
        let result2 = 0;
        if (cpus && cpus.length) {
          for (let i = 0, len = cpus.length;i < len; i++) {
            const cpu2 = cpus[i].times;
            totalUser += cpu2.user;
            totalSystem += cpu2.sys;
            totalNice += cpu2.nice;
            totalIrq += cpu2.irq;
            totalIdle += cpu2.idle;
          }
          const totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;
          result2 = (totalTicks - totalIdle) / totalTicks * 100;
        }
        resolve(result2);
      });
    });
  }
  function fullLoad(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        getFullLoad().then((result2) => {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      });
    });
  }
  exports.fullLoad = fullLoad;
});

// node_modules/systeminformation/lib/memory.js
var require_memory = __commonJS((exports) => {
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util7();
  var fs = __require("fs");
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var RAM_manufacturers = {
    "00CE": "Samsung Electronics Inc",
    "014F": "Transcend Information Inc.",
    "017A": "Apacer Technology Inc.",
    "0198": "HyperX",
    "029E": "Corsair",
    "02FE": "Elpida",
    "04CB": "A-DATA",
    "04CD": "G.Skill International Enterprise",
    "059B": "Crucial",
    1315: "Crucial",
    "2C00": "Micron Technology Inc.",
    5105: "Qimonda AG i. In.",
    "802C": "Micron Technology Inc.",
    "80AD": "Hynix Semiconductor Inc.",
    "80CE": "Samsung Electronics Inc.",
    8551: "Qimonda AG i. In.",
    "859B": "Crucial",
    AD00: "Hynix Semiconductor Inc.",
    CE00: "Samsung Electronics Inc.",
    SAMSUNG: "Samsung Electronics Inc.",
    HYNIX: "Hynix Semiconductor Inc.",
    "G-SKILL": "G-Skill International Enterprise",
    "G.SKILL": "G-Skill International Enterprise",
    TRANSCEND: "Transcend Information",
    APACER: "Apacer Technology Inc",
    MICRON: "Micron Technology Inc.",
    QIMONDA: "Qimonda AG i. In."
  };
  function mem(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          total: os.totalmem(),
          free: os.freemem(),
          used: os.totalmem() - os.freemem(),
          active: os.totalmem() - os.freemem(),
          available: os.freemem(),
          buffers: 0,
          cached: 0,
          slab: 0,
          buffcache: 0,
          reclaimable: 0,
          swaptotal: 0,
          swapused: 0,
          swapfree: 0,
          writeback: null,
          dirty: null
        };
        if (_linux) {
          try {
            fs.readFile("/proc/meminfo", (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`);
                result2.total = parseInt(util.getValue(lines, "memtotal"), 10);
                result2.total = result2.total ? result2.total * 1024 : os.totalmem();
                result2.free = parseInt(util.getValue(lines, "memfree"), 10);
                result2.free = result2.free ? result2.free * 1024 : os.freemem();
                result2.used = result2.total - result2.free;
                result2.buffers = parseInt(util.getValue(lines, "buffers"), 10);
                result2.buffers = result2.buffers ? result2.buffers * 1024 : 0;
                result2.cached = parseInt(util.getValue(lines, "cached"), 10);
                result2.cached = result2.cached ? result2.cached * 1024 : 0;
                result2.slab = parseInt(util.getValue(lines, "slab"), 10);
                result2.slab = result2.slab ? result2.slab * 1024 : 0;
                result2.buffcache = result2.buffers + result2.cached + result2.slab;
                let available = parseInt(util.getValue(lines, "memavailable"), 10);
                result2.available = available ? available * 1024 : result2.free + result2.buffcache;
                result2.active = result2.total - result2.available;
                result2.swaptotal = parseInt(util.getValue(lines, "swaptotal"), 10);
                result2.swaptotal = result2.swaptotal ? result2.swaptotal * 1024 : 0;
                result2.swapfree = parseInt(util.getValue(lines, "swapfree"), 10);
                result2.swapfree = result2.swapfree ? result2.swapfree * 1024 : 0;
                result2.swapused = result2.swaptotal - result2.swapfree;
                result2.writeback = parseInt(util.getValue(lines, "writeback"), 10);
                result2.writeback = result2.writeback ? result2.writeback * 1024 : 0;
                result2.dirty = parseInt(util.getValue(lines, "dirty"), 10);
                result2.dirty = result2.dirty ? result2.dirty * 1024 : 0;
                result2.reclaimable = parseInt(util.getValue(lines, "sreclaimable"), 10);
                result2.reclaimable = result2.reclaimable ? result2.reclaimable * 1024 : 0;
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          try {
            exec("/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size", (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`);
                const pagesize = parseInt(util.getValue(lines, "vm.stats.vm.v_page_size"), 10);
                const inactive = parseInt(util.getValue(lines, "vm.stats.vm.v_inactive_count"), 10) * pagesize;
                const cache = parseInt(util.getValue(lines, "vm.stats.vm.v_cache_count"), 10) * pagesize;
                result2.total = parseInt(util.getValue(lines, "hw.realmem"), 10);
                if (isNaN(result2.total)) {
                  result2.total = parseInt(util.getValue(lines, "hw.physmem"), 10);
                }
                result2.free = parseInt(util.getValue(lines, "vm.stats.vm.v_free_count"), 10) * pagesize;
                result2.buffcache = inactive + cache;
                result2.available = result2.buffcache + result2.free;
                result2.active = result2.total - result2.free - result2.buffcache;
                result2.swaptotal = 0;
                result2.swapfree = 0;
                result2.swapused = 0;
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_darwin) {
          let pageSize = 4096;
          try {
            let sysPpageSize = util.toInt(execSync("sysctl -n vm.pagesize").toString());
            pageSize = sysPpageSize || pageSize;
          } catch {
            util.noop();
          }
          try {
            exec('vm_stat 2>/dev/null | egrep "Pages active|Pages inactive"', (error2, stdout) => {
              if (!error2) {
                let lines = stdout.toString().split(`
`);
                result2.active = (parseInt(util.getValue(lines, "Pages active"), 10) || 0) * pageSize;
                result2.reclaimable = (parseInt(util.getValue(lines, "Pages inactive"), 10) || 0) * pageSize;
                result2.buffcache = result2.used - result2.active;
                result2.available = result2.free + result2.buffcache;
              }
              exec("sysctl -n vm.swapusage 2>/dev/null", (error3, stdout2) => {
                if (!error3) {
                  let lines = stdout2.toString().split(`
`);
                  if (lines.length > 0) {
                    let firstline = lines[0].replace(/,/g, ".").replace(/M/g, "");
                    let lineArray = firstline.trim().split("  ");
                    lineArray.forEach((line) => {
                      if (line.toLowerCase().indexOf("total") !== -1) {
                        result2.swaptotal = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                      }
                      if (line.toLowerCase().indexOf("used") !== -1) {
                        result2.swapused = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                      }
                      if (line.toLowerCase().indexOf("free") !== -1) {
                        result2.swapfree = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                      }
                    });
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_windows) {
          let swaptotal = 0;
          let swapused = 0;
          try {
            util.powerShell("Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage").then((stdout, error2) => {
              if (!error2) {
                let lines = stdout.split(`\r
`).filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                lines.forEach((line) => {
                  if (line !== "") {
                    line = line.trim().split(/\s\s+/);
                    swaptotal = swaptotal + (parseInt(line[0], 10) || 0);
                    swapused = swapused + (parseInt(line[1], 10) || 0);
                  }
                });
              }
              result2.swaptotal = swaptotal * 1024 * 1024;
              result2.swapused = swapused * 1024 * 1024;
              result2.swapfree = result2.swaptotal - result2.swapused;
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.mem = mem;
  function memLayout(callback) {
    function getManufacturer(manId) {
      const manIdSearch = manId.replace("0x", "").toUpperCase();
      if (manIdSearch.length >= 4 && {}.hasOwnProperty.call(RAM_manufacturers, manIdSearch)) {
        return RAM_manufacturers[manIdSearch];
      }
      return manId;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          exec('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE "Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number"; unset LC_ALL', (error2, stdout) => {
            if (!error2) {
              const devices = stdout.toString().split("Memory Device");
              devices.shift();
              devices.forEach((device) => {
                const lines = device.split(`
`);
                const sizeString = util.getValue(lines, "Size");
                const size = sizeString.indexOf("GB") >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;
                let bank = util.getValue(lines, "Bank Locator");
                if (bank.toLowerCase().indexOf("bad") >= 0) {
                  bank = "";
                }
                if (parseInt(util.getValue(lines, "Size"), 10) > 0) {
                  const totalWidth = util.toInt(util.getValue(lines, "Total Width"));
                  const dataWidth = util.toInt(util.getValue(lines, "Data Width"));
                  result2.push({
                    size,
                    bank,
                    type: util.getValue(lines, "Type:"),
                    ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                    clockSpeed: util.getValue(lines, "Configured Clock Speed:") ? parseInt(util.getValue(lines, "Configured Clock Speed:"), 10) : util.getValue(lines, "Speed:") ? parseInt(util.getValue(lines, "Speed:"), 10) : null,
                    formFactor: util.getValue(lines, "Form Factor:"),
                    manufacturer: getManufacturer(util.getValue(lines, "Manufacturer:")),
                    partNum: util.getValue(lines, "Part Number:"),
                    serialNum: util.getValue(lines, "Serial Number:"),
                    voltageConfigured: parseFloat(util.getValue(lines, "Configured Voltage:")) || null,
                    voltageMin: parseFloat(util.getValue(lines, "Minimum Voltage:")) || null,
                    voltageMax: parseFloat(util.getValue(lines, "Maximum Voltage:")) || null
                  });
                } else {
                  result2.push({
                    size: 0,
                    bank,
                    type: "Empty",
                    ecc: null,
                    clockSpeed: 0,
                    formFactor: util.getValue(lines, "Form Factor:"),
                    partNum: "",
                    serialNum: "",
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                }
              });
            }
            if (!result2.length) {
              result2.push({
                size: os.totalmem(),
                bank: "",
                type: "",
                ecc: null,
                clockSpeed: 0,
                formFactor: "",
                partNum: "",
                serialNum: "",
                voltageConfigured: null,
                voltageMin: null,
                voltageMax: null
              });
              try {
                let stdout2 = execSync("cat /proc/cpuinfo 2>/dev/null", util.execOptsLinux);
                let lines = stdout2.toString().split(`
`);
                let version = util.getValue(lines, "revision", ":", true).toLowerCase();
                if (util.isRaspberry(lines)) {
                  const clockSpeed = {
                    0: 400,
                    1: 450,
                    2: 450,
                    3: 3200,
                    4: 4267
                  };
                  result2[0].type = "LPDDR2";
                  result2[0].type = version && version[2] && version[2] === "3" ? "LPDDR4" : result2[0].type;
                  result2[0].type = version && version[2] && version[2] === "4" ? "LPDDR4X" : result2[0].type;
                  result2[0].ecc = false;
                  result2[0].clockSpeed = version && version[2] && clockSpeed[version[2]] || 400;
                  result2[0].clockSpeed = version && version[4] && version[4] === "d" ? 500 : result2[0].clockSpeed;
                  result2[0].formFactor = "SoC";
                  stdout2 = execSync("vcgencmd get_config sdram_freq 2>/dev/null", util.execOptsLinux);
                  lines = stdout2.toString().split(`
`);
                  let freq = parseInt(util.getValue(lines, "sdram_freq", "=", true), 10) || 0;
                  if (freq) {
                    result2[0].clockSpeed = freq;
                  }
                  stdout2 = execSync("vcgencmd measure_volts sdram_p 2>/dev/null", util.execOptsLinux);
                  lines = stdout2.toString().split(`
`);
                  let voltage = parseFloat(util.getValue(lines, "volt", "=", true)) || 0;
                  if (voltage) {
                    result2[0].voltageConfigured = voltage;
                    result2[0].voltageMin = voltage;
                    result2[0].voltageMax = voltage;
                  }
                }
              } catch {
                util.noop();
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          exec("system_profiler SPMemoryDataType", (error2, stdout) => {
            if (!error2) {
              const allLines = stdout.toString().split(`
`);
              const eccStatus = util.getValue(allLines, "ecc", ":", true).toLowerCase();
              let devices = stdout.toString().split("        BANK ");
              let hasBank = true;
              if (devices.length === 1) {
                devices = stdout.toString().split("        DIMM");
                hasBank = false;
              }
              devices.shift();
              devices.forEach((device) => {
                const lines = device.split(`
`);
                const bank = (hasBank ? "BANK " : "DIMM") + lines[0].trim().split("/")[0];
                const size = parseInt(util.getValue(lines, "          Size"));
                if (size) {
                  result2.push({
                    size: size * 1024 * 1024 * 1024,
                    bank,
                    type: util.getValue(lines, "          Type:"),
                    ecc: eccStatus ? eccStatus === "enabled" : null,
                    clockSpeed: parseInt(util.getValue(lines, "          Speed:"), 10),
                    formFactor: "",
                    manufacturer: getManufacturer(util.getValue(lines, "          Manufacturer:")),
                    partNum: util.getValue(lines, "          Part Number:"),
                    serialNum: util.getValue(lines, "          Serial Number:"),
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                } else {
                  result2.push({
                    size: 0,
                    bank,
                    type: "Empty",
                    ecc: null,
                    clockSpeed: 0,
                    formFactor: "",
                    manufacturer: "",
                    partNum: "",
                    serialNum: "",
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                }
              });
            }
            if (!result2.length) {
              const lines = stdout.toString().split(`
`);
              const size = parseInt(util.getValue(lines, "      Memory:"));
              const type = util.getValue(lines, "      Type:");
              const manufacturerId = util.getValue(lines, "      Manufacturer:");
              if (size && type) {
                result2.push({
                  size: size * 1024 * 1024 * 1024,
                  bank: "0",
                  type,
                  ecc: false,
                  clockSpeed: null,
                  formFactor: "SOC",
                  manufacturer: getManufacturer(manufacturerId),
                  partNum: "",
                  serialNum: "",
                  voltageConfigured: null,
                  voltageMin: null,
                  voltageMax: null
                });
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_windows) {
          const memoryTypes = "Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4|Logical non-volatile device|HBM|HBM2|DDR5|LPDDR5".split("|");
          const FormFactors = "Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA".split("|");
          try {
            util.powerShell("Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,Speed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage,Tag | fl").then((stdout, error2) => {
              if (!error2) {
                const devices = stdout.toString().split(/\n\s*\n/);
                devices.shift();
                devices.forEach((device) => {
                  const lines = device.split(`\r
`);
                  const dataWidth = util.toInt(util.getValue(lines, "DataWidth", ":"));
                  const totalWidth = util.toInt(util.getValue(lines, "TotalWidth", ":"));
                  const size = parseInt(util.getValue(lines, "Capacity", ":"), 10) || 0;
                  const tag = util.getValue(lines, "Tag", ":");
                  const tagInt = util.splitByNumber(tag);
                  if (size) {
                    result2.push({
                      size,
                      bank: util.getValue(lines, "BankLabel", ":") + (tagInt[1] ? "/" + tagInt[1] : ""),
                      type: memoryTypes[parseInt(util.getValue(lines, "MemoryType", ":"), 10) || parseInt(util.getValue(lines, "SMBIOSMemoryType", ":"), 10)],
                      ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                      clockSpeed: parseInt(util.getValue(lines, "ConfiguredClockSpeed", ":"), 10) || parseInt(util.getValue(lines, "Speed", ":"), 10) || 0,
                      formFactor: FormFactors[parseInt(util.getValue(lines, "FormFactor", ":"), 10) || 0],
                      manufacturer: getManufacturer(util.getValue(lines, "Manufacturer", ":")),
                      partNum: util.getValue(lines, "PartNumber", ":"),
                      serialNum: util.getValue(lines, "SerialNumber", ":"),
                      voltageConfigured: (parseInt(util.getValue(lines, "ConfiguredVoltage", ":"), 10) || 0) / 1000,
                      voltageMin: (parseInt(util.getValue(lines, "MinVoltage", ":"), 10) || 0) / 1000,
                      voltageMax: (parseInt(util.getValue(lines, "MaxVoltage", ":"), 10) || 0) / 1000
                    });
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.memLayout = memLayout;
});

// node_modules/systeminformation/lib/battery.js
var require_battery = __commonJS((exports, module) => {
  var exec = __require("child_process").exec;
  var fs = __require("fs");
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity) {
    const result2 = {};
    let status = parseInt(util.getValue(lines, "BatteryStatus", ":").trim(), 10) || 0;
    if (status >= 0) {
      const statusValue = status;
      result2.status = statusValue;
      result2.hasBattery = true;
      result2.maxCapacity = fullChargeCapacity || parseInt(util.getValue(lines, "DesignCapacity", ":") || 0);
      result2.designedCapacity = parseInt(util.getValue(lines, "DesignCapacity", ":") || designedCapacity);
      result2.voltage = (parseInt(util.getValue(lines, "DesignVoltage", ":"), 10) || 0) / 1000;
      result2.capacityUnit = "mWh";
      result2.percent = parseInt(util.getValue(lines, "EstimatedChargeRemaining", ":"), 10) || 0;
      result2.currentCapacity = parseInt(result2.maxCapacity * result2.percent / 100);
      result2.isCharging = statusValue >= 6 && statusValue <= 9 || statusValue === 11 || statusValue !== 3 && statusValue !== 1 && result2.percent < 100;
      result2.acConnected = result2.isCharging || statusValue === 2;
      result2.model = util.getValue(lines, "DeviceID", ":");
    } else {
      result2.status = -1;
    }
    return result2;
  }
  module.exports = (callback) => new Promise((resolve) => {
    process.nextTick(() => {
      let result2 = {
        hasBattery: false,
        cycleCount: 0,
        isCharging: false,
        designedCapacity: 0,
        maxCapacity: 0,
        currentCapacity: 0,
        voltage: 0,
        capacityUnit: "",
        percent: 0,
        timeRemaining: null,
        acConnected: true,
        type: "",
        model: "",
        manufacturer: "",
        serial: ""
      };
      if (_linux) {
        let battery_path = "";
        if (fs.existsSync("/sys/class/power_supply/BAT1/uevent")) {
          battery_path = "/sys/class/power_supply/BAT1/";
        } else if (fs.existsSync("/sys/class/power_supply/BAT0/uevent")) {
          battery_path = "/sys/class/power_supply/BAT0/";
        }
        let acConnected = false;
        let acPath = "";
        if (fs.existsSync("/sys/class/power_supply/AC/online")) {
          acPath = "/sys/class/power_supply/AC/online";
        } else if (fs.existsSync("/sys/class/power_supply/AC0/online")) {
          acPath = "/sys/class/power_supply/AC0/online";
        }
        if (acPath) {
          const file = fs.readFileSync(acPath);
          acConnected = file.toString().trim() === "1";
        }
        if (battery_path) {
          fs.readFile(battery_path + "uevent", (error2, stdout) => {
            if (!error2) {
              let lines = stdout.toString().split(`
`);
              result2.isCharging = util.getValue(lines, "POWER_SUPPLY_STATUS", "=").toLowerCase() === "charging";
              result2.acConnected = acConnected || result2.isCharging;
              result2.voltage = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_VOLTAGE_NOW", "="), 10) / 1e6;
              result2.capacityUnit = result2.voltage ? "mWh" : "mAh";
              result2.cycleCount = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CYCLE_COUNT", "="), 10);
              result2.maxCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL", "=", true, true), 10) / 1000 * (result2.voltage || 1));
              const desingedMinVoltage = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_VOLTAGE_MIN_DESIGN", "="), 10) / 1e6;
              result2.designedCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL_DESIGN", "=", true, true), 10) / 1000 * (desingedMinVoltage || result2.voltage || 1));
              result2.currentCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10) / 1000 * (result2.voltage || 1));
              if (!result2.maxCapacity) {
                result2.maxCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL", "=", true, true), 10) / 1000;
                result2.designedCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL_DESIGN", "=", true, true), 10) / 1000 | result2.maxCapacity;
                result2.currentCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10) / 1000;
              }
              const percent = util.getValue(lines, "POWER_SUPPLY_CAPACITY", "=");
              const energy = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10);
              const power = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_POWER_NOW", "="), 10);
              const current = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CURRENT_NOW", "="), 10);
              const charge = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10);
              result2.percent = parseInt("0" + percent, 10);
              if (result2.maxCapacity && result2.currentCapacity) {
                result2.hasBattery = true;
                if (!percent) {
                  result2.percent = 100 * result2.currentCapacity / result2.maxCapacity;
                }
              }
              if (result2.isCharging) {
                result2.hasBattery = true;
              }
              if (energy && power) {
                result2.timeRemaining = Math.floor(energy / power * 60);
              } else if (current && charge) {
                result2.timeRemaining = Math.floor(charge / current * 60);
              } else if (current && result2.currentCapacity) {
                result2.timeRemaining = Math.floor(result2.currentCapacity / current * 60);
              }
              result2.type = util.getValue(lines, "POWER_SUPPLY_TECHNOLOGY", "=");
              result2.model = util.getValue(lines, "POWER_SUPPLY_MODEL_NAME", "=");
              result2.manufacturer = util.getValue(lines, "POWER_SUPPLY_MANUFACTURER", "=");
              result2.serial = util.getValue(lines, "POWER_SUPPLY_SERIAL_NUMBER", "=");
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
      if (_freebsd || _openbsd || _netbsd) {
        exec("sysctl -i hw.acpi.battery hw.acpi.acline", (error2, stdout) => {
          let lines = stdout.toString().split(`
`);
          const batteries = parseInt("0" + util.getValue(lines, "hw.acpi.battery.units"), 10);
          const percent = parseInt("0" + util.getValue(lines, "hw.acpi.battery.life"), 10);
          result2.hasBattery = batteries > 0;
          result2.cycleCount = null;
          result2.isCharging = util.getValue(lines, "hw.acpi.acline") !== "1";
          result2.acConnected = result2.isCharging;
          result2.maxCapacity = null;
          result2.currentCapacity = null;
          result2.capacityUnit = "unknown";
          result2.percent = batteries ? percent : null;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_darwin) {
        exec('ioreg -n AppleSmartBattery -r | egrep "CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|DeviceName|BatterySerialNumber|Serial|TimeRemaining|Voltage"; pmset -g batt | grep %', (error2, stdout) => {
          if (stdout) {
            let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").replace(/-/g, "").split(`
`);
            result2.cycleCount = parseInt("0" + util.getValue(lines, "cyclecount", "="), 10);
            result2.voltage = parseInt("0" + util.getValue(lines, "voltage", "="), 10) / 1000;
            result2.capacityUnit = result2.voltage ? "mWh" : "mAh";
            result2.maxCapacity = Math.round(parseInt("0" + util.getValue(lines, "applerawmaxcapacity", "="), 10) * (result2.voltage || 1));
            result2.currentCapacity = Math.round(parseInt("0" + util.getValue(lines, "applerawcurrentcapacity", "="), 10) * (result2.voltage || 1));
            result2.designedCapacity = Math.round(parseInt("0" + util.getValue(lines, "DesignCapacity", "="), 10) * (result2.voltage || 1));
            result2.manufacturer = "Apple";
            result2.serial = util.getValue(lines, "BatterySerialNumber", "=") || util.getValue(lines, "Serial", "=");
            result2.model = util.getValue(lines, "DeviceName", "=");
            let percent = null;
            const line = util.getValue(lines, "internal", "Battery");
            let parts = line.split(";");
            if (parts && parts[0]) {
              let parts2 = parts[0].split("\t");
              if (parts2 && parts2[1]) {
                percent = parseFloat(parts2[1].trim().replace(/%/g, ""));
              }
            }
            if (parts && parts[1]) {
              result2.isCharging = parts[1].trim() === "charging";
              result2.acConnected = parts[1].trim() !== "discharging";
            } else {
              result2.isCharging = util.getValue(lines, "ischarging", "=").toLowerCase() === "yes";
              result2.acConnected = result2.isCharging;
            }
            if (result2.maxCapacity && result2.currentCapacity) {
              result2.hasBattery = true;
              result2.type = "Li-ion";
              result2.percent = percent !== null ? percent : Math.round(100 * result2.currentCapacity / result2.maxCapacity);
              if (!result2.isCharging) {
                result2.timeRemaining = parseInt("0" + util.getValue(lines, "TimeRemaining", "="), 10);
              }
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      }
      if (_sunos) {
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      }
      if (_windows) {
        try {
          const workload = [];
          workload.push(util.powerShell("Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl"));
          workload.push(util.powerShell("(Get-WmiObject -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity"));
          workload.push(util.powerShell("(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity"));
          util.promiseAll(workload).then((data) => {
            if (data) {
              const parts = data.results[0].split(/\n\s*\n/);
              const batteries = [];
              const hasValue = (value) => /\S/.test(value);
              for (let i = 0;i < parts.length; i++) {
                if (hasValue(parts[i])) {
                  batteries.push(parts[i]);
                }
              }
              const designCapacities = data.results[1].split(`\r
`).filter((e) => e);
              const fullChargeCapacities = data.results[2].split(`\r
`).filter((e) => e);
              if (batteries.length) {
                let first = false;
                const additionalBatteries = [];
                for (let i = 0;i < batteries.length; i++) {
                  const lines = batteries[i].split(`\r
`);
                  const designedCapacity = designCapacities && designCapacities.length >= i + 1 && designCapacities[i] ? util.toInt(designCapacities[i]) : 0;
                  const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= i + 1 && fullChargeCapacities[i] ? util.toInt(fullChargeCapacities[i]) : 0;
                  const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);
                  if (!first && parsed.status > 0 && parsed.status !== 10) {
                    result2.hasBattery = parsed.hasBattery;
                    result2.maxCapacity = parsed.maxCapacity;
                    result2.designedCapacity = parsed.designedCapacity;
                    result2.voltage = parsed.voltage;
                    result2.capacityUnit = parsed.capacityUnit;
                    result2.percent = parsed.percent;
                    result2.currentCapacity = parsed.currentCapacity;
                    result2.isCharging = parsed.isCharging;
                    result2.acConnected = parsed.acConnected;
                    result2.model = parsed.model;
                    first = true;
                  } else if (parsed.status !== -1) {
                    additionalBatteries.push({
                      hasBattery: parsed.hasBattery,
                      maxCapacity: parsed.maxCapacity,
                      designedCapacity: parsed.designedCapacity,
                      voltage: parsed.voltage,
                      capacityUnit: parsed.capacityUnit,
                      percent: parsed.percent,
                      currentCapacity: parsed.currentCapacity,
                      isCharging: parsed.isCharging,
                      timeRemaining: null,
                      acConnected: parsed.acConnected,
                      model: parsed.model,
                      type: "",
                      manufacturer: "",
                      serial: ""
                    });
                  }
                }
                if (!first && additionalBatteries.length) {
                  result2 = additionalBatteries[0];
                  additionalBatteries.shift();
                }
                if (additionalBatteries.length) {
                  result2.additionalBatteries = additionalBatteries;
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      }
    });
  });
});

// node_modules/systeminformation/lib/graphics.js
var require_graphics = __commonJS((exports) => {
  var fs = __require("fs");
  var path = __require("path");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util7();
  var _platform = process.platform;
  var _nvidiaSmiPath = "";
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _resolutionX = 0;
  var _resolutionY = 0;
  var _pixelDepth = 0;
  var _refreshRate = 0;
  var videoTypes = {
    "-2": "UNINITIALIZED",
    "-1": "OTHER",
    0: "HD15",
    1: "SVIDEO",
    2: "Composite video",
    3: "Component video",
    4: "DVI",
    5: "HDMI",
    6: "LVDS",
    8: "D_JPN",
    9: "SDI",
    10: "DP",
    11: "DP embedded",
    12: "UDI",
    13: "UDI embedded",
    14: "SDTVDONGLE",
    15: "MIRACAST",
    2147483648: "INTERNAL"
  };
  function getVendorFromModel(model) {
    const manufacturers = [
      { pattern: "^LG.+", manufacturer: "LG" },
      { pattern: "^BENQ.+", manufacturer: "BenQ" },
      { pattern: "^ASUS.+", manufacturer: "Asus" },
      { pattern: "^DELL.+", manufacturer: "Dell" },
      { pattern: "^SAMSUNG.+", manufacturer: "Samsung" },
      { pattern: "^VIEWSON.+", manufacturer: "ViewSonic" },
      { pattern: "^SONY.+", manufacturer: "Sony" },
      { pattern: "^ACER.+", manufacturer: "Acer" },
      { pattern: "^AOC.+", manufacturer: "AOC Monitors" },
      { pattern: "^HP.+", manufacturer: "HP" },
      { pattern: "^EIZO.?", manufacturer: "Eizo" },
      { pattern: "^PHILIPS.?", manufacturer: "Philips" },
      { pattern: "^IIYAMA.?", manufacturer: "Iiyama" },
      { pattern: "^SHARP.?", manufacturer: "Sharp" },
      { pattern: "^NEC.?", manufacturer: "NEC" },
      { pattern: "^LENOVO.?", manufacturer: "Lenovo" },
      { pattern: "COMPAQ.?", manufacturer: "Compaq" },
      { pattern: "APPLE.?", manufacturer: "Apple" },
      { pattern: "INTEL.?", manufacturer: "Intel" },
      { pattern: "AMD.?", manufacturer: "AMD" },
      { pattern: "NVIDIA.?", manufacturer: "NVDIA" }
    ];
    let result2 = "";
    if (model) {
      model = model.toUpperCase();
      manufacturers.forEach((manufacturer) => {
        const re = RegExp(manufacturer.pattern);
        if (re.test(model)) {
          result2 = manufacturer.manufacturer;
        }
      });
    }
    return result2;
  }
  function getVendorFromId(id) {
    const vendors = {
      610: "Apple",
      "1e6d": "LG",
      "10ac": "DELL",
      "4dd9": "Sony",
      "38a3": "NEC"
    };
    return vendors[id] || "";
  }
  function vendorToId(str) {
    let result2 = "";
    str = (str || "").toLowerCase();
    if (str.indexOf("apple") >= 0) {
      result2 = "0x05ac";
    } else if (str.indexOf("nvidia") >= 0) {
      result2 = "0x10de";
    } else if (str.indexOf("intel") >= 0) {
      result2 = "0x8086";
    } else if (str.indexOf("ati") >= 0 || str.indexOf("amd") >= 0) {
      result2 = "0x1002";
    }
    return result2;
  }
  function getMetalVersion(id) {
    const families = {
      spdisplays_mtlgpufamilymac1: "mac1",
      spdisplays_mtlgpufamilymac2: "mac2",
      spdisplays_mtlgpufamilyapple1: "apple1",
      spdisplays_mtlgpufamilyapple2: "apple2",
      spdisplays_mtlgpufamilyapple3: "apple3",
      spdisplays_mtlgpufamilyapple4: "apple4",
      spdisplays_mtlgpufamilyapple5: "apple5",
      spdisplays_mtlgpufamilyapple6: "apple6",
      spdisplays_mtlgpufamilyapple7: "apple7",
      spdisplays_metalfeaturesetfamily11: "family1_v1",
      spdisplays_metalfeaturesetfamily12: "family1_v2",
      spdisplays_metalfeaturesetfamily13: "family1_v3",
      spdisplays_metalfeaturesetfamily14: "family1_v4",
      spdisplays_metalfeaturesetfamily21: "family2_v1"
    };
    return families[id] || "";
  }
  function graphics(callback) {
    function parseLinesDarwin(graphicsArr) {
      const res = {
        controllers: [],
        displays: []
      };
      try {
        graphicsArr.forEach((item) => {
          const bus = (item.sppci_bus || "").indexOf("builtin") > -1 ? "Built-In" : (item.sppci_bus || "").indexOf("pcie") > -1 ? "PCIe" : "";
          const vram = (parseInt(item.spdisplays_vram || "", 10) || 0) * ((item.spdisplays_vram || "").indexOf("GB") > -1 ? 1024 : 1);
          const vramDyn = (parseInt(item.spdisplays_vram_shared || "", 10) || 0) * ((item.spdisplays_vram_shared || "").indexOf("GB") > -1 ? 1024 : 1);
          let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || "");
          res.controllers.push({
            vendor: getVendorFromModel(item.spdisplays_vendor || "") || item.spdisplays_vendor || "",
            model: item.sppci_model || "",
            bus,
            vramDynamic: bus === "Built-In",
            vram: vram || vramDyn || null,
            deviceId: item["spdisplays_device-id"] || "",
            vendorId: item["spdisplays_vendor-id"] || vendorToId((item["spdisplays_vendor"] || "") + (item.sppci_model || "")),
            external: item.sppci_device_type === "spdisplays_egpu",
            cores: item["sppci_cores"] || null,
            metalVersion
          });
          if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {
            item.spdisplays_ndrvs.forEach((displayItem) => {
              const connectionType = displayItem["spdisplays_connection_type"] || "";
              const currentResolutionParts = (displayItem["_spdisplays_resolution"] || "").split("@");
              const currentResolution = currentResolutionParts[0].split("x");
              const pixelParts = (displayItem["_spdisplays_pixels"] || "").split("x");
              const pixelDepthString = displayItem["spdisplays_depth"] || "";
              const serial = displayItem["_spdisplays_display-serial-number"] || displayItem["_spdisplays_display-serial-number2"] || null;
              res.displays.push({
                vendor: getVendorFromId(displayItem["_spdisplays_display-vendor-id"] || "") || getVendorFromModel(displayItem["_name"] || ""),
                vendorId: displayItem["_spdisplays_display-vendor-id"] || "",
                model: displayItem["_name"] || "",
                productionYear: displayItem["_spdisplays_display-year"] || null,
                serial: serial !== "0" ? serial : null,
                displayId: displayItem["_spdisplays_displayID"] || null,
                main: displayItem["spdisplays_main"] ? displayItem["spdisplays_main"] === "spdisplays_yes" : false,
                builtin: (displayItem["spdisplays_display_type"] || "").indexOf("built-in") > -1,
                connection: connectionType.indexOf("_internal") > -1 ? "Internal" : connectionType.indexOf("_displayport") > -1 ? "Display Port" : connectionType.indexOf("_hdmi") > -1 ? "HDMI" : null,
                sizeX: null,
                sizeY: null,
                pixelDepth: pixelDepthString === "CGSThirtyBitColor" ? 30 : pixelDepthString === "CGSThirtytwoBitColor" ? 32 : pixelDepthString === "CGSTwentyfourBitColor" ? 24 : null,
                resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,
                resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,
                currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,
                currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,
                positionX: 0,
                positionY: 0,
                currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null
              });
            });
          }
        });
        return res;
      } catch (e) {
        return res;
      }
    }
    function parseLinesLinuxControllers(lines) {
      let controllers = [];
      let currentController = {
        vendor: "",
        subVendor: "",
        model: "",
        bus: "",
        busAddress: "",
        vram: null,
        vramDynamic: false,
        pciID: ""
      };
      let isGraphicsController = false;
      let pciIDs = [];
      try {
        pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep "Bus Address: "', util.execOptsLinux).toString().split(`
`);
        for (let i2 = 0;i2 < pciIDs.length; i2++) {
          pciIDs[i2] = pciIDs[i2].replace("Bus Address:", "").replace("0000:", "").trim();
        }
        pciIDs = pciIDs.filter((el) => el != null && el);
      } catch {
        util.noop();
      }
      let i = 1;
      lines.forEach((line) => {
        let subsystem = "";
        if (i < lines.length && lines[i]) {
          subsystem = lines[i];
          if (subsystem.indexOf(":") > 0) {
            subsystem = subsystem.split(":")[1];
          }
        }
        if (line.trim() !== "") {
          if (line[0] !== " " && line[0] !== "\t") {
            let isExternal = pciIDs.indexOf(line.split(" ")[0]) >= 0;
            let vgapos = line.toLowerCase().indexOf(" vga ");
            let _3dcontrollerpos = line.toLowerCase().indexOf("3d controller");
            if (vgapos !== -1 || _3dcontrollerpos !== -1) {
              if (_3dcontrollerpos !== -1 && vgapos === -1) {
                vgapos = _3dcontrollerpos;
              }
              if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) {
                controllers.push(currentController);
                currentController = {
                  vendor: "",
                  model: "",
                  bus: "",
                  busAddress: "",
                  vram: null,
                  vramDynamic: false
                };
              }
              const pciIDCandidate = line.split(" ")[0];
              if (/[\da-fA-F]{2}:[\da-fA-F]{2}\.[\da-fA-F]/.test(pciIDCandidate)) {
                currentController.busAddress = pciIDCandidate;
              }
              isGraphicsController = true;
              let endpos = line.search(/\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);
              let parts = line.substr(vgapos, endpos - vgapos).split(":");
              currentController.busAddress = line.substr(0, vgapos).trim();
              if (parts.length > 1) {
                parts[1] = parts[1].trim();
                if (parts[1].toLowerCase().indexOf("corporation") >= 0) {
                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("corporation") + 11).trim();
                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("corporation") + 11, 200).split("(")[0].trim();
                  currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                  currentController.vram = null;
                  currentController.vramDynamic = false;
                } else if (parts[1].toLowerCase().indexOf(" inc.") >= 0) {
                  if ((parts[1].match(/]/g) || []).length > 1) {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                  } else {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" inc.") + 5).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" inc.") + 5, 200).trim().split("(")[0].trim();
                  }
                  currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                  currentController.vram = null;
                  currentController.vramDynamic = false;
                } else if (parts[1].toLowerCase().indexOf(" ltd.") >= 0) {
                  if ((parts[1].match(/]/g) || []).length > 1) {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                  } else {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" ltd.") + 5).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" ltd.") + 5, 200).trim().split("(")[0].trim();
                  }
                }
                if (currentController.model && subsystem.indexOf(currentController.model) !== -1) {
                  const subVendor = subsystem.split(currentController.model)[0].trim();
                  if (subVendor) {
                    currentController.subVendor = subVendor;
                  }
                }
              }
            } else {
              isGraphicsController = false;
            }
          }
          if (isGraphicsController) {
            let parts = line.split(":");
            if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("devicename") !== -1 && parts[1].toLowerCase().indexOf("onboard") !== -1) {
              currentController.bus = "Onboard";
            }
            if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("region") !== -1 && parts[1].toLowerCase().indexOf("memory") !== -1) {
              let memparts = parts[1].split("=");
              if (memparts.length > 1) {
                currentController.vram = parseInt(memparts[1]);
              }
            }
          }
        }
        i++;
      });
      if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) {
        controllers.push(currentController);
      }
      return controllers;
    }
    function parseLinesLinuxClinfo(controllers, lines) {
      const fieldPattern = /\[([^\]]+)\]\s+(\w+)\s+(.*)/;
      const devices = lines.reduce((devices2, line) => {
        const field = fieldPattern.exec(line.trim());
        if (field) {
          if (!devices2[field[1]]) {
            devices2[field[1]] = {};
          }
          devices2[field[1]][field[2]] = field[3];
        }
        return devices2;
      }, {});
      for (let deviceId in devices) {
        const device = devices[deviceId];
        if (device["CL_DEVICE_TYPE"] === "CL_DEVICE_TYPE_GPU") {
          let busAddress;
          if (device["CL_DEVICE_TOPOLOGY_AMD"]) {
            const bdf = device["CL_DEVICE_TOPOLOGY_AMD"].match(/[a-zA-Z0-9]+:\d+\.\d+/);
            if (bdf) {
              busAddress = bdf[0];
            }
          } else if (device["CL_DEVICE_PCI_BUS_ID_NV"] && device["CL_DEVICE_PCI_SLOT_ID_NV"]) {
            const bus = parseInt(device["CL_DEVICE_PCI_BUS_ID_NV"]);
            const slot = parseInt(device["CL_DEVICE_PCI_SLOT_ID_NV"]);
            if (!isNaN(bus) && !isNaN(slot)) {
              const b = bus & 255;
              const d = slot >> 3 & 255;
              const f = slot & 7;
              busAddress = `${b.toString().padStart(2, "0")}:${d.toString().padStart(2, "0")}.${f}`;
            }
          }
          if (busAddress) {
            let controller = controllers.find((controller2) => controller2.busAddress === busAddress);
            if (!controller) {
              controller = {
                vendor: "",
                model: "",
                bus: "",
                busAddress,
                vram: null,
                vramDynamic: false
              };
              controllers.push(controller);
            }
            controller.vendor = device["CL_DEVICE_VENDOR"];
            if (device["CL_DEVICE_BOARD_NAME_AMD"]) {
              controller.model = device["CL_DEVICE_BOARD_NAME_AMD"];
            } else {
              controller.model = device["CL_DEVICE_NAME"];
            }
            const memory = parseInt(device["CL_DEVICE_GLOBAL_MEM_SIZE"]);
            if (!isNaN(memory)) {
              controller.vram = Math.round(memory / 1024 / 1024);
            }
          }
        }
      }
      return controllers;
    }
    function getNvidiaSmi() {
      if (_nvidiaSmiPath) {
        return _nvidiaSmiPath;
      }
      if (_windows) {
        try {
          const basePath = path.join(util.WINDIR, "System32", "DriverStore", "FileRepository");
          const candidates = fs.readdirSync(basePath, { withFileTypes: true }).filter((dir) => dir.isDirectory()).map((dir) => {
            const nvidiaSmiPath = path.join(basePath, dir.name, "nvidia-smi.exe");
            try {
              const stats = fs.statSync(nvidiaSmiPath);
              return { path: nvidiaSmiPath, ctime: stats.ctimeMs };
            } catch {
              return null;
            }
          }).filter(Boolean);
          if (candidates.length > 0) {
            _nvidiaSmiPath = candidates.reduce((prev, curr) => curr.ctime > prev.ctime ? curr : prev).path;
          }
        } catch {
          util.noop();
        }
      } else if (_linux) {
        _nvidiaSmiPath = "nvidia-smi";
      }
      return _nvidiaSmiPath;
    }
    function nvidiaSmi(options) {
      const nvidiaSmiExe = getNvidiaSmi();
      options = options || util.execOptsWin;
      if (nvidiaSmiExe) {
        const nvidiaSmiOpts = "--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits";
        const cmd = `"${nvidiaSmiExe}" ${nvidiaSmiOpts}`;
        if (_linux) {
          options.stdio = ["pipe", "pipe", "ignore"];
        }
        try {
          const sanitized = cmd + (_linux ? "  2>/dev/null" : "") + (_windows ? "  2> nul" : "");
          const res = execSync(sanitized, options).toString();
          return res;
        } catch {
          util.noop();
        }
      }
      return "";
    }
    function nvidiaDevices() {
      function safeParseNumber(value) {
        if ([null, undefined].includes(value)) {
          return value;
        }
        return parseFloat(value);
      }
      const stdout = nvidiaSmi();
      if (!stdout) {
        return [];
      }
      const gpus = stdout.split(`
`).filter(Boolean);
      let results = gpus.map((gpu) => {
        const splittedData = gpu.split(", ").map((value) => value.includes("N/A") ? undefined : value);
        if (splittedData.length === 16) {
          return {
            driverVersion: splittedData[0],
            subDeviceId: splittedData[1],
            name: splittedData[2],
            pciBus: splittedData[3],
            fanSpeed: safeParseNumber(splittedData[4]),
            memoryTotal: safeParseNumber(splittedData[5]),
            memoryUsed: safeParseNumber(splittedData[6]),
            memoryFree: safeParseNumber(splittedData[7]),
            utilizationGpu: safeParseNumber(splittedData[8]),
            utilizationMemory: safeParseNumber(splittedData[9]),
            temperatureGpu: safeParseNumber(splittedData[10]),
            temperatureMemory: safeParseNumber(splittedData[11]),
            powerDraw: safeParseNumber(splittedData[12]),
            powerLimit: safeParseNumber(splittedData[13]),
            clockCore: safeParseNumber(splittedData[14]),
            clockMemory: safeParseNumber(splittedData[15])
          };
        } else {
          return {};
        }
      });
      results = results.filter((item) => {
        return "pciBus" in item;
      });
      return results;
    }
    function mergeControllerNvidia(controller, nvidia) {
      if (nvidia.driverVersion) {
        controller.driverVersion = nvidia.driverVersion;
      }
      if (nvidia.subDeviceId) {
        controller.subDeviceId = nvidia.subDeviceId;
      }
      if (nvidia.name) {
        controller.name = nvidia.name;
      }
      if (nvidia.pciBus) {
        controller.pciBus = nvidia.pciBus;
      }
      if (nvidia.fanSpeed) {
        controller.fanSpeed = nvidia.fanSpeed;
      }
      if (nvidia.memoryTotal) {
        controller.memoryTotal = nvidia.memoryTotal;
        controller.vram = nvidia.memoryTotal;
        controller.vramDynamic = false;
      }
      if (nvidia.memoryUsed) {
        controller.memoryUsed = nvidia.memoryUsed;
      }
      if (nvidia.memoryFree) {
        controller.memoryFree = nvidia.memoryFree;
      }
      if (nvidia.utilizationGpu) {
        controller.utilizationGpu = nvidia.utilizationGpu;
      }
      if (nvidia.utilizationMemory) {
        controller.utilizationMemory = nvidia.utilizationMemory;
      }
      if (nvidia.temperatureGpu) {
        controller.temperatureGpu = nvidia.temperatureGpu;
      }
      if (nvidia.temperatureMemory) {
        controller.temperatureMemory = nvidia.temperatureMemory;
      }
      if (nvidia.powerDraw) {
        controller.powerDraw = nvidia.powerDraw;
      }
      if (nvidia.powerLimit) {
        controller.powerLimit = nvidia.powerLimit;
      }
      if (nvidia.clockCore) {
        controller.clockCore = nvidia.clockCore;
      }
      if (nvidia.clockMemory) {
        controller.clockMemory = nvidia.clockMemory;
      }
      return controller;
    }
    function parseLinesLinuxEdid(edid) {
      const result2 = {
        vendor: "",
        model: "",
        deviceName: "",
        main: false,
        builtin: false,
        connection: "",
        sizeX: null,
        sizeY: null,
        pixelDepth: null,
        resolutionX: null,
        resolutionY: null,
        currentResX: null,
        currentResY: null,
        positionX: 0,
        positionY: 0,
        currentRefreshRate: null
      };
      let start = 108;
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      if (edid.substr(start, 6) === "000000") {
        start += 36;
      }
      result2.resolutionX = parseInt("0x0" + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));
      result2.resolutionY = parseInt("0x0" + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));
      result2.sizeX = parseInt("0x0" + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));
      result2.sizeY = parseInt("0x0" + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));
      start = edid.indexOf("000000fc00");
      if (start >= 0) {
        let model_raw = edid.substr(start + 10, 26);
        if (model_raw.indexOf("0a") !== -1) {
          model_raw = model_raw.substr(0, model_raw.indexOf("0a"));
        }
        try {
          if (model_raw.length > 2) {
            result2.model = model_raw.match(/.{1,2}/g).map((v) => String.fromCharCode(parseInt(v, 16))).join("");
          }
        } catch {
          util.noop();
        }
      } else {
        result2.model = "";
      }
      return result2;
    }
    function parseLinesLinuxDisplays(lines, depth) {
      const displays = [];
      let currentDisplay = {
        vendor: "",
        model: "",
        deviceName: "",
        main: false,
        builtin: false,
        connection: "",
        sizeX: null,
        sizeY: null,
        pixelDepth: null,
        resolutionX: null,
        resolutionY: null,
        currentResX: null,
        currentResY: null,
        positionX: 0,
        positionY: 0,
        currentRefreshRate: null
      };
      let is_edid = false;
      let is_current = false;
      let edid_raw = "";
      let start = 0;
      for (let i = 1;i < lines.length; i++) {
        if (lines[i].trim() !== "") {
          if (lines[i][0] !== " " && lines[i][0] !== "\t" && lines[i].toLowerCase().indexOf(" connected ") !== -1) {
            if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
              displays.push(currentDisplay);
              currentDisplay = {
                vendor: "",
                model: "",
                main: false,
                builtin: false,
                connection: "",
                sizeX: null,
                sizeY: null,
                pixelDepth: null,
                resolutionX: null,
                resolutionY: null,
                currentResX: null,
                currentResY: null,
                positionX: 0,
                positionY: 0,
                currentRefreshRate: null
              };
            }
            let parts = lines[i].split(" ");
            currentDisplay.connection = parts[0];
            currentDisplay.main = lines[i].toLowerCase().indexOf(" primary ") >= 0;
            currentDisplay.builtin = parts[0].toLowerCase().indexOf("edp") >= 0;
          }
          if (is_edid) {
            if (lines[i].search(/\S|$/) > start) {
              edid_raw += lines[i].toLowerCase().trim();
            } else {
              let edid_decoded = parseLinesLinuxEdid(edid_raw);
              currentDisplay.vendor = edid_decoded.vendor;
              currentDisplay.model = edid_decoded.model;
              currentDisplay.resolutionX = edid_decoded.resolutionX;
              currentDisplay.resolutionY = edid_decoded.resolutionY;
              currentDisplay.sizeX = edid_decoded.sizeX;
              currentDisplay.sizeY = edid_decoded.sizeY;
              currentDisplay.pixelDepth = depth;
              is_edid = false;
            }
          }
          if (lines[i].toLowerCase().indexOf("edid:") >= 0) {
            is_edid = true;
            start = lines[i].search(/\S|$/);
          }
          if (lines[i].toLowerCase().indexOf("*current") >= 0) {
            const parts1 = lines[i].split("(");
            if (parts1 && parts1.length > 1 && parts1[0].indexOf("x") >= 0) {
              const resParts = parts1[0].trim().split("x");
              currentDisplay.currentResX = util.toInt(resParts[0]);
              currentDisplay.currentResY = util.toInt(resParts[1]);
            }
            is_current = true;
          }
          if (is_current && lines[i].toLowerCase().indexOf("clock") >= 0 && lines[i].toLowerCase().indexOf("hz") >= 0 && lines[i].toLowerCase().indexOf("v: height") >= 0) {
            const parts1 = lines[i].split("clock");
            if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf("hz") >= 0) {
              currentDisplay.currentRefreshRate = util.toInt(parts1[1]);
            }
            is_current = false;
          }
        }
      }
      if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
        displays.push(currentDisplay);
      }
      return displays;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          controllers: [],
          displays: []
        };
        if (_darwin) {
          const cmd = "system_profiler -xml -detailLevel full SPDisplaysDataType";
          exec(cmd, (error2, stdout) => {
            if (!error2) {
              try {
                const output = stdout.toString();
                result2 = parseLinesDarwin(util.plistParser(output)[0]._items);
              } catch (e) {
                util.noop();
              }
              try {
                stdout = execSync('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo ""', { maxBuffer: 1024 * 102400 });
                const output = (stdout || "").toString();
                const obj = util.plistReader(output);
                if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"]["Configs"] && obj["DisplayAnyUserSets"]["Configs"][0] && obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"]) {
                  const current = obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"];
                  let i = 0;
                  current.forEach((o) => {
                    if (o["CurrentInfo"] && o["CurrentInfo"]["OriginX"] !== undefined && result2.displays && result2.displays[i]) {
                      result2.displays[i].positionX = o["CurrentInfo"]["OriginX"];
                    }
                    if (o["CurrentInfo"] && o["CurrentInfo"]["OriginY"] !== undefined && result2.displays && result2.displays[i]) {
                      result2.displays[i].positionY = o["CurrentInfo"]["OriginY"];
                    }
                    i++;
                  });
                }
                if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"].length > 0 && obj["DisplayAnyUserSets"][0].length > 0 && obj["DisplayAnyUserSets"][0][0]["DisplayID"]) {
                  const current = obj["DisplayAnyUserSets"][0];
                  let i = 0;
                  current.forEach((o) => {
                    if ("OriginX" in o && result2.displays && result2.displays[i]) {
                      result2.displays[i].positionX = o["OriginX"];
                    }
                    if ("OriginY" in o && result2.displays && result2.displays[i]) {
                      result2.displays[i].positionY = o["OriginY"];
                    }
                    if (o["Mode"] && o["Mode"]["BitsPerPixel"] !== undefined && result2.displays && result2.displays[i]) {
                      result2.displays[i].pixelDepth = o["Mode"]["BitsPerPixel"];
                    }
                    i++;
                  });
                }
              } catch {
                util.noop();
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_linux) {
          if (util.isRaspberry()) {
            const cmd2 = `fbset -s 2> /dev/null | grep 'mode "' ; vcgencmd get_mem gpu 2> /dev/null; tvservice -s 2> /dev/null; tvservice -n 2> /dev/null;`;
            exec(cmd2, (error2, stdout) => {
              const lines = stdout.toString().split(`
`);
              if (lines.length > 3 && lines[0].indexOf('mode "') >= -1 && lines[2].indexOf("0x12000a") > -1) {
                const parts = lines[0].replace("mode", "").replace(/"/g, "").trim().split("x");
                if (parts.length === 2) {
                  result2.displays.push({
                    vendor: "",
                    model: util.getValue(lines, "device_name", "="),
                    main: true,
                    builtin: false,
                    connection: "HDMI",
                    sizeX: null,
                    sizeY: null,
                    pixelDepth: null,
                    resolutionX: parseInt(parts[0], 10),
                    resolutionY: parseInt(parts[1], 10),
                    currentResX: null,
                    currentResY: null,
                    positionX: 0,
                    positionY: 0,
                    currentRefreshRate: null
                  });
                }
              }
              if (lines.length >= 1 && stdout.toString().indexOf("gpu=") >= -1) {
                result2.controllers.push({
                  vendor: "Broadcom",
                  model: util.getRpiGpu(),
                  bus: "",
                  vram: util.getValue(lines, "gpu", "=").replace("M", ""),
                  vramDynamic: true
                });
              }
            });
          }
          const cmd = "lspci -vvv  2>/dev/null";
          exec(cmd, (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              if (result2.controllers.length === 0) {
                result2.controllers = parseLinesLinuxControllers(lines);
                const nvidiaData = nvidiaDevices();
                result2.controllers = result2.controllers.map((controller) => {
                  return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});
                });
              }
            }
            const cmd2 = "clinfo --raw";
            exec(cmd2, (error3, stdout2) => {
              if (!error3) {
                const lines = stdout2.toString().split(`
`);
                result2.controllers = parseLinesLinuxClinfo(result2.controllers, lines);
              }
              const cmd3 = "xdpyinfo 2>/dev/null | grep 'depth of root window' | awk '{ print $5 }'";
              exec(cmd3, (error4, stdout3) => {
                let depth = 0;
                if (!error4) {
                  const lines = stdout3.toString().split(`
`);
                  depth = parseInt(lines[0]) || 0;
                }
                const cmd4 = "xrandr --verbose 2>/dev/null";
                exec(cmd4, (error5, stdout4) => {
                  if (!error5) {
                    const lines = stdout4.toString().split(`
`);
                    result2.displays = parseLinesLinuxDisplays(lines, depth);
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              });
            });
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
        if (_sunos) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
        if (_windows) {
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance win32_VideoController | fl *"));
            workload.push(util.powerShell('gp "HKLM:\\SYSTEM\\ControlSet001\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\*" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));
            workload.push(util.powerShell("Get-CimInstance win32_desktopmonitor | fl *"));
            workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams | fl"));
            workload.push(util.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens"));
            workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorConnectionParams | fl"));
            workload.push(util.powerShell('gwmi WmiMonitorID -Namespace root\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + $_.InstanceName}'));
            const nvidiaData = nvidiaDevices();
            Promise.all(workload).then((data) => {
              const csections = data[0].replace(/\r/g, "").split(/\n\s*\n/);
              const vsections = data[1].replace(/\r/g, "").split(/\n\s*\n/);
              result2.controllers = parseLinesWindowsControllers(csections, vsections);
              result2.controllers = result2.controllers.map((controller) => {
                if (controller.vendor.toLowerCase() === "nvidia") {
                  return mergeControllerNvidia(controller, nvidiaData.find((device) => {
                    let windowsSubDeviceId = (controller.subDeviceId || "").toLowerCase();
                    const nvidiaSubDeviceIdParts = device.subDeviceId.split("x");
                    let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();
                    const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);
                    if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {
                      for (let i = 0;i < lengthDifference; i++) {
                        nvidiaSubDeviceId = "0" + nvidiaSubDeviceId;
                      }
                    } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {
                      for (let i = 0;i < lengthDifference; i++) {
                        windowsSubDeviceId = "0" + windowsSubDeviceId;
                      }
                    }
                    return windowsSubDeviceId === nvidiaSubDeviceId;
                  }) || {});
                } else {
                  return controller;
                }
              });
              const dsections = data[2].replace(/\r/g, "").split(/\n\s*\n/);
              if (dsections[0].trim() === "") {
                dsections.shift();
              }
              if (dsections.length && dsections[dsections.length - 1].trim() === "") {
                dsections.pop();
              }
              const msections = data[3].replace(/\r/g, "").split("Active ");
              msections.shift();
              const ssections = data[4].replace(/\r/g, "").split("BitsPerPixel ");
              ssections.shift();
              const tsections = data[5].replace(/\r/g, "").split(/\n\s*\n/);
              tsections.shift();
              const res = data[6].replace(/\r/g, "").split(/\n/);
              const isections = [];
              res.forEach((element) => {
                const parts = element.split("|");
                if (parts.length === 5) {
                  isections.push({
                    vendor: parts[0],
                    code: parts[1],
                    model: parts[2],
                    serial: parts[3],
                    instanceId: parts[4]
                  });
                }
              });
              result2.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);
              if (result2.displays.length === 1) {
                if (_resolutionX) {
                  result2.displays[0].resolutionX = _resolutionX;
                  if (!result2.displays[0].currentResX) {
                    result2.displays[0].currentResX = _resolutionX;
                  }
                }
                if (_resolutionY) {
                  result2.displays[0].resolutionY = _resolutionY;
                  if (result2.displays[0].currentResY === 0) {
                    result2.displays[0].currentResY = _resolutionY;
                  }
                }
                if (_pixelDepth) {
                  result2.displays[0].pixelDepth = _pixelDepth;
                }
              }
              result2.displays = result2.displays.map((element) => {
                if (_refreshRate && !element.currentRefreshRate) {
                  element.currentRefreshRate = _refreshRate;
                }
                return element;
              });
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }).catch(() => {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch (e) {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
    function parseLinesWindowsControllers(sections, vections) {
      const memorySizes = {};
      for (const i in vections) {
        if ({}.hasOwnProperty.call(vections, i)) {
          if (vections[i].trim() !== "") {
            const lines = vections[i].trim().split(`
`);
            const matchingDeviceId = util.getValue(lines, "MatchingDeviceId").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
            if (matchingDeviceId) {
              const quadWordmemorySize = parseInt(util.getValue(lines, "HardwareInformation.qwMemorySize"));
              if (!isNaN(quadWordmemorySize)) {
                let deviceId = matchingDeviceId[1].toUpperCase() + "&" + matchingDeviceId[2].toUpperCase();
                if (matchingDeviceId[3]) {
                  deviceId += "&" + matchingDeviceId[3].toUpperCase();
                }
                if (matchingDeviceId[4]) {
                  deviceId += "&" + matchingDeviceId[4].toUpperCase();
                }
                memorySizes[deviceId] = quadWordmemorySize;
              }
            }
          }
        }
      }
      const controllers = [];
      for (const i in sections) {
        if ({}.hasOwnProperty.call(sections, i)) {
          if (sections[i].trim() !== "") {
            const lines = sections[i].trim().split(`
`);
            const pnpDeviceId = util.getValue(lines, "PNPDeviceID", ":").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
            let subDeviceId = null;
            let memorySize = null;
            if (pnpDeviceId) {
              subDeviceId = pnpDeviceId[3] || "";
              if (subDeviceId) {
                subDeviceId = subDeviceId.split("_")[1];
              }
              if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
              if (memorySize == null && pnpDeviceId[3]) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
              if (memorySize == null && pnpDeviceId[4]) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
              if (memorySize == null) {
                const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase();
                if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                  memorySize = memorySizes[deviceId];
                }
              }
            }
            controllers.push({
              vendor: util.getValue(lines, "AdapterCompatibility", ":"),
              model: util.getValue(lines, "name", ":"),
              bus: util.getValue(lines, "PNPDeviceID", ":").startsWith("PCI") ? "PCI" : "",
              vram: (memorySize == null ? util.toInt(util.getValue(lines, "AdapterRAM", ":")) : memorySize) / 1024 / 1024,
              vramDynamic: util.getValue(lines, "VideoMemoryType", ":") === "2",
              subDeviceId
            });
            _resolutionX = util.toInt(util.getValue(lines, "CurrentHorizontalResolution", ":")) || _resolutionX;
            _resolutionY = util.toInt(util.getValue(lines, "CurrentVerticalResolution", ":")) || _resolutionY;
            _refreshRate = util.toInt(util.getValue(lines, "CurrentRefreshRate", ":")) || _refreshRate;
            _pixelDepth = util.toInt(util.getValue(lines, "CurrentBitsPerPixel", ":")) || _pixelDepth;
          }
        }
      }
      return controllers;
    }
    function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {
      const displays = [];
      let vendor = "";
      let model = "";
      let deviceID = "";
      let resolutionX = 0;
      let resolutionY = 0;
      if (dsections && dsections.length) {
        const linesDisplay = dsections[0].split(`
`);
        vendor = util.getValue(linesDisplay, "MonitorManufacturer", ":");
        model = util.getValue(linesDisplay, "Name", ":");
        deviceID = util.getValue(linesDisplay, "PNPDeviceID", ":").replace(/&amp;/g, "&").toLowerCase();
        resolutionX = util.toInt(util.getValue(linesDisplay, "ScreenWidth", ":"));
        resolutionY = util.toInt(util.getValue(linesDisplay, "ScreenHeight", ":"));
      }
      for (let i = 0;i < ssections.length; i++) {
        if (ssections[i].trim() !== "") {
          ssections[i] = "BitsPerPixel " + ssections[i];
          msections[i] = "Active " + msections[i];
          if (tsections.length === 0 || tsections[i] === undefined) {
            tsections[i] = "Unknown";
          }
          const linesScreen = ssections[i].split(`
`);
          const linesMonitor = msections[i].split(`
`);
          const linesConnection = tsections[i].split(`
`);
          const bitsPerPixel = util.getValue(linesScreen, "BitsPerPixel");
          const bounds = util.getValue(linesScreen, "Bounds").replace("{", "").replace("}", "").replace(/=/g, ":").split(",");
          const primary = util.getValue(linesScreen, "Primary");
          const sizeX = util.getValue(linesMonitor, "MaxHorizontalImageSize");
          const sizeY = util.getValue(linesMonitor, "MaxVerticalImageSize");
          const instanceName = util.getValue(linesMonitor, "InstanceName").toLowerCase();
          const videoOutputTechnology = util.getValue(linesConnection, "VideoOutputTechnology");
          const deviceName = util.getValue(linesScreen, "DeviceName");
          let displayVendor = "";
          let displayModel = "";
          isections.forEach((element) => {
            if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith("(") && model.startsWith("PnP")) {
              displayVendor = element.vendor;
              displayModel = element.model;
            }
          });
          displays.push({
            vendor: instanceName.startsWith(deviceID) && displayVendor === "" ? vendor : displayVendor,
            model: instanceName.startsWith(deviceID) && displayModel === "" ? model : displayModel,
            deviceName,
            main: primary.toLowerCase() === "true",
            builtin: videoOutputTechnology === "2147483648",
            connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : "",
            resolutionX: util.toInt(util.getValue(bounds, "Width", ":")),
            resolutionY: util.toInt(util.getValue(bounds, "Height", ":")),
            sizeX: sizeX ? parseInt(sizeX, 10) : null,
            sizeY: sizeY ? parseInt(sizeY, 10) : null,
            pixelDepth: bitsPerPixel,
            currentResX: util.toInt(util.getValue(bounds, "Width", ":")),
            currentResY: util.toInt(util.getValue(bounds, "Height", ":")),
            positionX: util.toInt(util.getValue(bounds, "X", ":")),
            positionY: util.toInt(util.getValue(bounds, "Y", ":"))
          });
        }
      }
      if (ssections.length === 0) {
        displays.push({
          vendor,
          model,
          main: true,
          sizeX: null,
          sizeY: null,
          resolutionX,
          resolutionY,
          pixelDepth: null,
          currentResX: resolutionX,
          currentResY: resolutionY,
          positionX: 0,
          positionY: 0
        });
      }
      return displays;
    }
  }
  exports.graphics = graphics;
});

// node_modules/systeminformation/lib/filesystem.js
var require_filesystem = __commonJS((exports) => {
  var util = require_util7();
  var fs = __require("fs");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var execPromiseSave = util.promisifySave(__require("child_process").exec);
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _fs_speed = {};
  var _disk_io = {};
  function fsSize(drive, callback) {
    if (util.isFunction(drive)) {
      callback = drive;
      drive = "";
    }
    let macOsDisks = [];
    let osMounts = [];
    function getmacOsFsType(fs2) {
      if (!fs2.startsWith("/")) {
        return "NFS";
      }
      const parts = fs2.split("/");
      const fsShort = parts[parts.length - 1];
      const macOsDisksSingle = macOsDisks.filter((item) => item.indexOf(fsShort) >= 0);
      if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf("APFS") >= 0) {
        return "APFS";
      }
      return "HFS";
    }
    function isLinuxTmpFs(fs2) {
      const linuxTmpFileSystems = ["rootfs", "unionfs", "squashfs", "cramfs", "initrd", "initramfs", "devtmpfs", "tmpfs", "udev", "devfs", "specfs", "type", "appimaged"];
      let result2 = false;
      linuxTmpFileSystems.forEach((linuxFs) => {
        if (fs2.toLowerCase().indexOf(linuxFs) >= 0) {
          result2 = true;
        }
      });
      return result2;
    }
    function filterLines(stdout) {
      const lines = stdout.toString().split(`
`);
      lines.shift();
      if (stdout.toString().toLowerCase().indexOf("filesystem")) {
        let removeLines = 0;
        for (let i = 0;i < lines.length; i++) {
          if (lines[i] && lines[i].toLowerCase().startsWith("filesystem")) {
            removeLines = i;
          }
        }
        for (let i = 0;i < removeLines; i++) {
          lines.shift();
        }
      }
      return lines;
    }
    function parseDf(lines) {
      const data = [];
      lines.forEach((line) => {
        if (line !== "") {
          line = line.replace(/ +/g, " ").split(" ");
          if (line && (line[0].startsWith("/") || line[6] && line[6] === "/" || line[0].indexOf("/") > 0 || line[0].indexOf(":") === 1 || !_darwin && !isLinuxTmpFs(line[1]))) {
            const fs2 = line[0];
            const fsType = _linux || _freebsd || _openbsd || _netbsd ? line[1] : getmacOsFsType(line[0]);
            const size = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1], 10) * 1024;
            const used = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2], 10) * 1024;
            const available = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[4] : line[3], 10) * 1024;
            const use = parseFloat((100 * (used / (used + available))).toFixed(2));
            const rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs2] || false : null;
            line.splice(0, _linux || _freebsd || _openbsd || _netbsd ? 6 : 5);
            const mount = line.join(" ");
            if (!data.find((el) => el.fs === fs2 && el.type === fsType && el.mount === mount)) {
              data.push({
                fs: fs2,
                type: fsType,
                size,
                used,
                available,
                use,
                mount,
                rw
              });
            }
          }
        }
      });
      return data;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = [];
        if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
          let cmd = "";
          macOsDisks = [];
          osMounts = {};
          if (_darwin) {
            cmd = "df -kP";
            try {
              macOsDisks = execSync("diskutil list").toString().split(`
`).filter((line) => {
                return !line.startsWith("/") && line.indexOf(":") > 0;
              });
              execSync("mount").toString().split(`
`).filter((line) => {
                return line.startsWith("/");
              }).forEach((line) => {
                osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
              });
            } catch {
              util.noop();
            }
          }
          if (_linux) {
            try {
              cmd = "export LC_ALL=C; df -kPTx squashfs; unset LC_ALL";
              execSync("cat /proc/mounts 2>/dev/null", util.execOptsLinux).toString().split(`
`).filter((line) => {
                return line.startsWith("/");
              }).forEach((line) => {
                osMounts[line.split(" ")[0]] = osMounts[line.split(" ")[0]] || false;
                if (line.toLowerCase().indexOf("/snap/") === -1) {
                  osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("rw,") >= 0 || line.toLowerCase().indexOf(" rw ") >= 0;
                }
              });
            } catch {
              util.noop();
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            try {
              cmd = "df -kPT";
              execSync("mount").toString().split(`
`).forEach((line) => {
                osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
              });
            } catch {
              util.noop();
            }
          }
          exec(cmd, { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
            const lines = filterLines(stdout);
            data = parseDf(lines);
            if (drive) {
              data = data.filter((item) => {
                return item.fs.toLowerCase().indexOf(drive.toLowerCase()) >= 0 || item.mount.toLowerCase().indexOf(drive.toLowerCase()) >= 0;
              });
            }
            if ((!error2 || data.length) && stdout.toString().trim() !== "") {
              if (callback) {
                callback(data);
              }
              resolve(data);
            } else {
              exec("df -kPT 2>/dev/null", { maxBuffer: 1024 * 1024 }, (error3, stdout2) => {
                const lines2 = filterLines(stdout2);
                data = parseDf(lines2);
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            }
          });
        }
        if (_sunos) {
          if (callback) {
            callback(data);
          }
          resolve(data);
        }
        if (_windows) {
          try {
            const driveSanitized = drive ? util.sanitizeShellString(drive, true) : "";
            const cmd = `Get-WmiObject Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size ${driveSanitized ? "| where -property Caption -eq " + driveSanitized : ""} | fl`;
            util.powerShell(cmd).then((stdout, error2) => {
              if (!error2) {
                const devices = stdout.toString().split(/\n\s*\n/);
                devices.forEach((device) => {
                  const lines = device.split(`\r
`);
                  const size = util.toInt(util.getValue(lines, "size", ":"));
                  const free = util.toInt(util.getValue(lines, "freespace", ":"));
                  const caption = util.getValue(lines, "caption", ":");
                  const rwValue = util.getValue(lines, "access", ":");
                  const rw = rwValue ? util.toInt(rwValue) !== 1 : null;
                  if (size) {
                    data.push({
                      fs: caption,
                      type: util.getValue(lines, "filesystem", ":"),
                      size,
                      used: size - free,
                      available: free,
                      use: parseFloat((100 * (size - free) / size).toFixed(2)),
                      mount: caption,
                      rw
                    });
                  }
                });
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } catch {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
        }
      });
    });
  }
  exports.fsSize = fsSize;
  function fsOpenFiles(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result2 = {
          max: null,
          allocated: null,
          available: null
        };
        if (_freebsd || _openbsd || _netbsd || _darwin) {
          const cmd = "sysctl -i kern.maxfiles kern.num_files kern.open_files";
          exec(cmd, { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              result2.max = parseInt(util.getValue(lines, "kern.maxfiles", ":"), 10);
              result2.allocated = parseInt(util.getValue(lines, "kern.num_files", ":"), 10) || parseInt(util.getValue(lines, "kern.open_files", ":"), 10);
              result2.available = result2.max - result2.allocated;
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_linux) {
          fs.readFile("/proc/sys/fs/file-nr", (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              if (lines[0]) {
                const parts = lines[0].replace(/\s+/g, " ").split(" ");
                if (parts.length === 3) {
                  result2.allocated = parseInt(parts[0], 10);
                  result2.available = parseInt(parts[1], 10);
                  result2.max = parseInt(parts[2], 10);
                  if (!result2.available) {
                    result2.available = result2.max - result2.allocated;
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              fs.readFile("/proc/sys/fs/file-max", (error3, stdout2) => {
                if (!error3) {
                  const lines = stdout2.toString().split(`
`);
                  if (lines[0]) {
                    result2.max = parseInt(lines[0], 10);
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            }
          });
        }
        if (_sunos) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
        if (_windows) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
      });
    });
  }
  exports.fsOpenFiles = fsOpenFiles;
  function parseBytes(s) {
    return parseInt(s.substr(s.indexOf(" (") + 2, s.indexOf(" Bytes)") - 10), 10);
  }
  function parseDevices(lines) {
    const devices = [];
    let i = 0;
    lines.forEach((line) => {
      if (line.length > 0) {
        if (line[0] === "*") {
          i++;
        } else {
          const parts = line.split(":");
          if (parts.length > 1) {
            if (!devices[i]) {
              devices[i] = {
                name: "",
                identifier: "",
                type: "disk",
                fsType: "",
                mount: "",
                size: 0,
                physical: "HDD",
                uuid: "",
                label: "",
                model: "",
                serial: "",
                removable: false,
                protocol: "",
                group: "",
                device: ""
              };
            }
            parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, "");
            parts[1] = parts[1].trim();
            if (parts[0] === "DEVICEIDENTIFIER") {
              devices[i].identifier = parts[1];
            }
            if (parts[0] === "DEVICENODE") {
              devices[i].name = parts[1];
            }
            if (parts[0] === "VOLUMENAME") {
              if (parts[1].indexOf("Not applicable") === -1) {
                devices[i].label = parts[1];
              }
            }
            if (parts[0] === "PROTOCOL") {
              devices[i].protocol = parts[1];
            }
            if (parts[0] === "DISKSIZE") {
              devices[i].size = parseBytes(parts[1]);
            }
            if (parts[0] === "FILESYSTEMPERSONALITY") {
              devices[i].fsType = parts[1];
            }
            if (parts[0] === "MOUNTPOINT") {
              devices[i].mount = parts[1];
            }
            if (parts[0] === "VOLUMEUUID") {
              devices[i].uuid = parts[1];
            }
            if (parts[0] === "READ-ONLYMEDIA" && parts[1] === "Yes") {
              devices[i].physical = "CD/DVD";
            }
            if (parts[0] === "SOLIDSTATE" && parts[1] === "Yes") {
              devices[i].physical = "SSD";
            }
            if (parts[0] === "VIRTUAL") {
              devices[i].type = "virtual";
            }
            if (parts[0] === "REMOVABLEMEDIA") {
              devices[i].removable = parts[1] === "Removable";
            }
            if (parts[0] === "PARTITIONTYPE") {
              devices[i].type = "part";
            }
            if (parts[0] === "DEVICE/MEDIANAME") {
              devices[i].model = parts[1];
            }
          }
        }
      }
    });
    return devices;
  }
  function parseBlk(lines) {
    let data = [];
    lines.filter((line) => line !== "").forEach((line) => {
      try {
        line = decodeURIComponent(line.replace(/\\x/g, "%"));
        line = line.replace(/\\/g, "\\\\");
        const disk = JSON.parse(line);
        data.push({
          name: util.sanitizeShellString(disk.name),
          type: disk.type,
          fsType: disk.fsType,
          mount: disk.mountpoint,
          size: parseInt(disk.size, 10),
          physical: disk.type === "disk" ? disk.rota === "0" ? "SSD" : "HDD" : disk.type === "rom" ? "CD/DVD" : "",
          uuid: disk.uuid,
          label: disk.label,
          model: (disk.model || "").trim(),
          serial: disk.serial,
          removable: disk.rm === "1",
          protocol: disk.tran,
          group: disk.group || ""
        });
      } catch {
        util.noop();
      }
    });
    data = util.unique(data);
    data = util.sortByKey(data, ["type", "name"]);
    return data;
  }
  function decodeMdabmData(lines) {
    const raid = util.getValue(lines, "md_level", "=");
    const label = util.getValue(lines, "md_name", "=");
    const uuid = util.getValue(lines, "md_uuid", "=");
    const members = [];
    lines.forEach((line) => {
      if (line.toLowerCase().startsWith("md_device_dev") && line.toLowerCase().indexOf("/dev/") > 0) {
        members.push(line.split("/dev/")[1]);
      }
    });
    return {
      raid,
      label,
      uuid,
      members
    };
  }
  function raidMatchLinux(data) {
    let result2 = data;
    try {
      data.forEach((element) => {
        if (element.type.startsWith("raid")) {
          const lines = execSync(`mdadm --export --detail /dev/${element.name}`, util.execOptsLinux).toString().split(`
`);
          const mdData = decodeMdabmData(lines);
          element.label = mdData.label;
          element.uuid = mdData.uuid;
          if (mdData && mdData.members && mdData.members.length && mdData.raid === element.type) {
            result2 = result2.map((blockdevice) => {
              if (blockdevice.fsType === "linux_raid_member" && mdData.members.indexOf(blockdevice.name) >= 0) {
                blockdevice.group = element.name;
              }
              return blockdevice;
            });
          }
        }
      });
    } catch {
      util.noop();
    }
    return result2;
  }
  function getDevicesLinux(data) {
    const result2 = [];
    data.forEach((element) => {
      if (element.type.startsWith("disk")) {
        result2.push(element.name);
      }
    });
    return result2;
  }
  function matchDevicesLinux(data) {
    let result2 = data;
    try {
      const devices = getDevicesLinux(data);
      result2 = result2.map((blockdevice) => {
        if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk")) {
          devices.forEach((element) => {
            if (blockdevice.name.startsWith(element)) {
              blockdevice.device = "/dev/" + element;
            }
          });
        }
        return blockdevice;
      });
    } catch {
      util.noop();
    }
    return result2;
  }
  function getDevicesMac(data) {
    const result2 = [];
    data.forEach((element) => {
      if (element.type.startsWith("disk")) {
        result2.push({ name: element.name, model: element.model, device: element.name });
      }
      if (element.type.startsWith("virtual")) {
        let device = "";
        result2.forEach((e) => {
          if (e.model === element.model) {
            device = e.device;
          }
        });
        if (device) {
          result2.push({ name: element.name, model: element.model, device });
        }
      }
    });
    return result2;
  }
  function matchDevicesMac(data) {
    let result2 = data;
    try {
      const devices = getDevicesMac(data);
      result2 = result2.map((blockdevice) => {
        if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk") || blockdevice.type.startsWith("virtual")) {
          devices.forEach((element) => {
            if (blockdevice.name.startsWith(element.name)) {
              blockdevice.device = element.device;
            }
          });
        }
        return blockdevice;
      });
    } catch {
      util.noop();
    }
    return result2;
  }
  function getDevicesWin(diskDrives) {
    const result2 = [];
    diskDrives.forEach((element) => {
      const lines = element.split(`\r
`);
      const device = util.getValue(lines, "DeviceID", ":");
      let partitions = element.split("@{DeviceID=");
      if (partitions.length > 1) {
        partitions = partitions.slice(1);
        partitions.forEach((partition) => {
          result2.push({ name: partition.split(";")[0].toUpperCase(), device });
        });
      }
    });
    return result2;
  }
  function matchDevicesWin(data, diskDrives) {
    const devices = getDevicesWin(diskDrives);
    data.map((element) => {
      const filteresDevices = devices.filter((e) => {
        return e.name === element.name.toUpperCase();
      });
      if (filteresDevices.length > 0) {
        element.device = filteresDevices[0].device;
      }
      return element;
    });
    return data;
  }
  function blkStdoutToObject(stdout) {
    return stdout.toString().replace(/NAME=/g, '{"name":').replace(/FSTYPE=/g, ',"fsType":').replace(/TYPE=/g, ',"type":').replace(/SIZE=/g, ',"size":').replace(/MOUNTPOINT=/g, ',"mountpoint":').replace(/UUID=/g, ',"uuid":').replace(/ROTA=/g, ',"rota":').replace(/RO=/g, ',"ro":').replace(/RM=/g, ',"rm":').replace(/TRAN=/g, ',"tran":').replace(/SERIAL=/g, ',"serial":').replace(/LABEL=/g, ',"label":').replace(/MODEL=/g, ',"model":').replace(/OWNER=/g, ',"owner":').replace(/GROUP=/g, ',"group":').replace(/\n/g, `}
`);
  }
  function blockDevices(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = [];
        if (_linux) {
          const procLsblk1 = exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
            if (!error2) {
              const lines = blkStdoutToObject(stdout).split(`
`);
              data = parseBlk(lines);
              data = raidMatchLinux(data);
              data = matchDevicesLinux(data);
              if (callback) {
                callback(data);
              }
              resolve(data);
            } else {
              const procLsblk2 = exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, (error3, stdout2) => {
                if (!error3) {
                  const lines = blkStdoutToObject(stdout2).split(`
`);
                  data = parseBlk(lines);
                  data = raidMatchLinux(data);
                }
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
              procLsblk2.on("error", () => {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            }
          });
          procLsblk1.on("error", () => {
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        }
        if (_darwin) {
          const procDskutil = exec("diskutil info -all", { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              data = parseDevices(lines);
              data = matchDevicesMac(data);
            }
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
          procDskutil.on("error", () => {
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        }
        if (_sunos) {
          if (callback) {
            callback(data);
          }
          resolve(data);
        }
        if (_windows) {
          const drivetypes = ["Unknown", "NoRoot", "Removable", "Local", "Network", "CD/DVD", "RAM"];
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl"));
            workload.push(util.powerShell("Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L='Partitions'; E={$_.GetRelated('Win32_DiskPartition').GetRelated('Win32_LogicalDisk') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl"));
            util.promiseAll(workload).then((res) => {
              const logicalDisks = res.results[0].toString().split(/\n\s*\n/);
              const diskDrives = res.results[1].toString().split(/\n\s*\n/);
              logicalDisks.forEach((device) => {
                const lines = device.split(`\r
`);
                const drivetype = util.getValue(lines, "drivetype", ":");
                if (drivetype) {
                  data.push({
                    name: util.getValue(lines, "name", ":"),
                    identifier: util.getValue(lines, "caption", ":"),
                    type: "disk",
                    fsType: util.getValue(lines, "filesystem", ":").toLowerCase(),
                    mount: util.getValue(lines, "caption", ":"),
                    size: util.getValue(lines, "size", ":"),
                    physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],
                    uuid: util.getValue(lines, "volumeserialnumber", ":"),
                    label: util.getValue(lines, "volumename", ":"),
                    model: "",
                    serial: util.getValue(lines, "volumeserialnumber", ":"),
                    removable: drivetype === "2",
                    protocol: "",
                    group: "",
                    device: ""
                  });
                }
              });
              data = matchDevicesWin(data, diskDrives);
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } catch {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
        }
        if (_freebsd || _openbsd || _netbsd) {
          if (callback) {
            callback(null);
          }
          resolve(null);
        }
      });
    });
  }
  exports.blockDevices = blockDevices;
  function calcFsSpeed(rx, wx) {
    const result2 = {
      rx: 0,
      wx: 0,
      tx: 0,
      rx_sec: null,
      wx_sec: null,
      tx_sec: null,
      ms: 0
    };
    if (_fs_speed && _fs_speed.ms) {
      result2.rx = rx;
      result2.wx = wx;
      result2.tx = result2.rx + result2.wx;
      result2.ms = Date.now() - _fs_speed.ms;
      result2.rx_sec = (result2.rx - _fs_speed.bytes_read) / (result2.ms / 1000);
      result2.wx_sec = (result2.wx - _fs_speed.bytes_write) / (result2.ms / 1000);
      result2.tx_sec = result2.rx_sec + result2.wx_sec;
      _fs_speed.rx_sec = result2.rx_sec;
      _fs_speed.wx_sec = result2.wx_sec;
      _fs_speed.tx_sec = result2.tx_sec;
      _fs_speed.bytes_read = result2.rx;
      _fs_speed.bytes_write = result2.wx;
      _fs_speed.bytes_overall = result2.rx + result2.wx;
      _fs_speed.ms = Date.now();
      _fs_speed.last_ms = result2.ms;
    } else {
      result2.rx = rx;
      result2.wx = wx;
      result2.tx = result2.rx + result2.wx;
      _fs_speed.rx_sec = null;
      _fs_speed.wx_sec = null;
      _fs_speed.tx_sec = null;
      _fs_speed.bytes_read = result2.rx;
      _fs_speed.bytes_write = result2.wx;
      _fs_speed.bytes_overall = result2.rx + result2.wx;
      _fs_speed.ms = Date.now();
      _fs_speed.last_ms = 0;
    }
    return result2;
  }
  function fsStats(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (_windows || _freebsd || _openbsd || _netbsd || _sunos) {
          return resolve(null);
        }
        let result2 = {
          rx: 0,
          wx: 0,
          tx: 0,
          rx_sec: null,
          wx_sec: null,
          tx_sec: null,
          ms: 0
        };
        let rx = 0;
        let wx = 0;
        if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {
          if (_linux) {
            const procLsblk = exec("lsblk -r 2>/dev/null | grep /", { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`);
                const fs_filter = [];
                lines.forEach((line) => {
                  if (line !== "") {
                    line = line.trim().split(" ");
                    if (fs_filter.indexOf(line[0]) === -1) {
                      fs_filter.push(line[0]);
                    }
                  }
                });
                const output = fs_filter.join("|");
                const procCat = exec('cat /proc/diskstats | egrep "' + output + '"', { maxBuffer: 1024 * 1024 }, (error3, stdout2) => {
                  if (!error3) {
                    const lines2 = stdout2.toString().split(`
`);
                    lines2.forEach((line) => {
                      line = line.trim();
                      if (line !== "") {
                        line = line.replace(/ +/g, " ").split(" ");
                        rx += parseInt(line[5], 10) * 512;
                        wx += parseInt(line[9], 10) * 512;
                      }
                    });
                    result2 = calcFsSpeed(rx, wx);
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
                procCat.on("error", () => {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
            procLsblk.on("error", () => {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          }
          if (_darwin) {
            const procIoreg = exec(`ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,
"`, { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`);
                lines.forEach((line) => {
                  line = line.trim();
                  if (line !== "") {
                    line = line.split(",");
                    rx += parseInt(line[2], 10);
                    wx += parseInt(line[9], 10);
                  }
                });
                result2 = calcFsSpeed(rx, wx);
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
            procIoreg.on("error", () => {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          }
        } else {
          result2.ms = _fs_speed.last_ms;
          result2.rx = _fs_speed.bytes_read;
          result2.wx = _fs_speed.bytes_write;
          result2.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
          result2.rx_sec = _fs_speed.rx_sec;
          result2.wx_sec = _fs_speed.wx_sec;
          result2.tx_sec = _fs_speed.tx_sec;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.fsStats = fsStats;
  function calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {
    const result2 = {
      rIO: 0,
      wIO: 0,
      tIO: 0,
      rIO_sec: null,
      wIO_sec: null,
      tIO_sec: null,
      rWaitTime: 0,
      wWaitTime: 0,
      tWaitTime: 0,
      rWaitPercent: null,
      wWaitPercent: null,
      tWaitPercent: null,
      ms: 0
    };
    if (_disk_io && _disk_io.ms) {
      result2.rIO = rIO;
      result2.wIO = wIO;
      result2.tIO = rIO + wIO;
      result2.ms = Date.now() - _disk_io.ms;
      result2.rIO_sec = (result2.rIO - _disk_io.rIO) / (result2.ms / 1000);
      result2.wIO_sec = (result2.wIO - _disk_io.wIO) / (result2.ms / 1000);
      result2.tIO_sec = result2.rIO_sec + result2.wIO_sec;
      result2.rWaitTime = rWaitTime;
      result2.wWaitTime = wWaitTime;
      result2.tWaitTime = tWaitTime;
      result2.rWaitPercent = (result2.rWaitTime - _disk_io.rWaitTime) * 100 / result2.ms;
      result2.wWaitPercent = (result2.wWaitTime - _disk_io.wWaitTime) * 100 / result2.ms;
      result2.tWaitPercent = (result2.tWaitTime - _disk_io.tWaitTime) * 100 / result2.ms;
      _disk_io.rIO = rIO;
      _disk_io.wIO = wIO;
      _disk_io.rIO_sec = result2.rIO_sec;
      _disk_io.wIO_sec = result2.wIO_sec;
      _disk_io.tIO_sec = result2.tIO_sec;
      _disk_io.rWaitTime = rWaitTime;
      _disk_io.wWaitTime = wWaitTime;
      _disk_io.tWaitTime = tWaitTime;
      _disk_io.rWaitPercent = result2.rWaitPercent;
      _disk_io.wWaitPercent = result2.wWaitPercent;
      _disk_io.tWaitPercent = result2.tWaitPercent;
      _disk_io.last_ms = result2.ms;
      _disk_io.ms = Date.now();
    } else {
      result2.rIO = rIO;
      result2.wIO = wIO;
      result2.tIO = rIO + wIO;
      result2.rWaitTime = rWaitTime;
      result2.wWaitTime = wWaitTime;
      result2.tWaitTime = tWaitTime;
      _disk_io.rIO = rIO;
      _disk_io.wIO = wIO;
      _disk_io.rIO_sec = null;
      _disk_io.wIO_sec = null;
      _disk_io.tIO_sec = null;
      _disk_io.rWaitTime = rWaitTime;
      _disk_io.wWaitTime = wWaitTime;
      _disk_io.tWaitTime = tWaitTime;
      _disk_io.rWaitPercent = null;
      _disk_io.wWaitPercent = null;
      _disk_io.tWaitPercent = null;
      _disk_io.last_ms = 0;
      _disk_io.ms = Date.now();
    }
    return result2;
  }
  function disksIO(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (_windows) {
          return resolve(null);
        }
        if (_sunos) {
          return resolve(null);
        }
        let result2 = {
          rIO: 0,
          wIO: 0,
          tIO: 0,
          rIO_sec: null,
          wIO_sec: null,
          tIO_sec: null,
          rWaitTime: 0,
          wWaitTime: 0,
          tWaitTime: 0,
          rWaitPercent: null,
          wWaitPercent: null,
          tWaitPercent: null,
          ms: 0
        };
        let rIO = 0;
        let wIO = 0;
        let rWaitTime = 0;
        let wWaitTime = 0;
        let tWaitTime = 0;
        if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {
          if (_linux || _freebsd || _openbsd || _netbsd) {
            const cmd = 'for mount in `lsblk 2>/dev/null | grep " disk " | sed "s/[]//g" | awk \'{$1=$1};1\' | cut -d " " -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r "s/ +/;/g" | sed -r "s/^;//"; done';
            exec(cmd, { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
              if (!error2) {
                const lines = stdout.split(`
`);
                lines.forEach((line) => {
                  if (!line) {
                    return;
                  }
                  const stats = line.split(";");
                  rIO += parseInt(stats[0], 10);
                  wIO += parseInt(stats[4], 10);
                  rWaitTime += parseInt(stats[3], 10);
                  wWaitTime += parseInt(stats[7], 10);
                  tWaitTime += parseInt(stats[10], 10);
                });
                result2 = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          }
          if (_darwin) {
            exec(`ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,
"`, { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`);
                lines.forEach((line) => {
                  line = line.trim();
                  if (line !== "") {
                    line = line.split(",");
                    rIO += parseInt(line[10], 10);
                    wIO += parseInt(line[0], 10);
                  }
                });
                result2 = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          }
        } else {
          result2.rIO = _disk_io.rIO;
          result2.wIO = _disk_io.wIO;
          result2.tIO = _disk_io.rIO + _disk_io.wIO;
          result2.ms = _disk_io.last_ms;
          result2.rIO_sec = _disk_io.rIO_sec;
          result2.wIO_sec = _disk_io.wIO_sec;
          result2.tIO_sec = _disk_io.tIO_sec;
          result2.rWaitTime = _disk_io.rWaitTime;
          result2.wWaitTime = _disk_io.wWaitTime;
          result2.tWaitTime = _disk_io.tWaitTime;
          result2.rWaitPercent = _disk_io.rWaitPercent;
          result2.wWaitPercent = _disk_io.wWaitPercent;
          result2.tWaitPercent = _disk_io.tWaitPercent;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.disksIO = disksIO;
  function diskLayout(callback) {
    function getVendorFromModel(model) {
      const diskManufacturers = [
        { pattern: "WESTERN.*", manufacturer: "Western Digital" },
        { pattern: "^WDC.*", manufacturer: "Western Digital" },
        { pattern: "WD.*", manufacturer: "Western Digital" },
        { pattern: "TOSHIBA.*", manufacturer: "Toshiba" },
        { pattern: "HITACHI.*", manufacturer: "Hitachi" },
        { pattern: "^IC.*", manufacturer: "Hitachi" },
        { pattern: "^HTS.*", manufacturer: "Hitachi" },
        { pattern: "SANDISK.*", manufacturer: "SanDisk" },
        { pattern: "KINGSTON.*", manufacturer: "Kingston Technology" },
        { pattern: "^SONY.*", manufacturer: "Sony" },
        { pattern: "TRANSCEND.*", manufacturer: "Transcend" },
        { pattern: "SAMSUNG.*", manufacturer: "Samsung" },
        { pattern: "^ST(?!I\\ ).*", manufacturer: "Seagate" },
        { pattern: "^STI\\ .*", manufacturer: "SimpleTech" },
        { pattern: "^D...-.*", manufacturer: "IBM" },
        { pattern: "^IBM.*", manufacturer: "IBM" },
        { pattern: "^FUJITSU.*", manufacturer: "Fujitsu" },
        { pattern: "^MP.*", manufacturer: "Fujitsu" },
        { pattern: "^MK.*", manufacturer: "Toshiba" },
        { pattern: "MAXTO.*", manufacturer: "Maxtor" },
        { pattern: "PIONEER.*", manufacturer: "Pioneer" },
        { pattern: "PHILIPS.*", manufacturer: "Philips" },
        { pattern: "QUANTUM.*", manufacturer: "Quantum Technology" },
        { pattern: "FIREBALL.*", manufacturer: "Quantum Technology" },
        { pattern: "^VBOX.*", manufacturer: "VirtualBox" },
        { pattern: "CORSAIR.*", manufacturer: "Corsair Components" },
        { pattern: "CRUCIAL.*", manufacturer: "Crucial" },
        { pattern: "ECM.*", manufacturer: "ECM" },
        { pattern: "INTEL.*", manufacturer: "INTEL" },
        { pattern: "EVO.*", manufacturer: "Samsung" },
        { pattern: "APPLE.*", manufacturer: "Apple" }
      ];
      let result2 = "";
      if (model) {
        model = model.toUpperCase();
        diskManufacturers.forEach((manufacturer) => {
          const re = RegExp(manufacturer.pattern);
          if (re.test(model)) {
            result2 = manufacturer.manufacturer;
          }
        });
      }
      return result2;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        const commitResult = (res) => {
          for (let i = 0;i < res.length; i++) {
            delete res[i].BSDName;
          }
          if (callback) {
            callback(res);
          }
          resolve(res);
        };
        const result2 = [];
        let cmd = "";
        if (_linux) {
          let cmdFullSmart = "";
          exec("export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL", { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
            if (!error2) {
              try {
                const out = stdout.toString().trim();
                let devices = [];
                try {
                  const outJSON = JSON.parse(out);
                  if (outJSON && {}.hasOwnProperty.call(outJSON, "blockdevices")) {
                    devices = outJSON.blockdevices.filter((item) => {
                      return item.type === "disk" && item.size > 0 && (item.model !== null || item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf("/ram") !== 0 && item.path.indexOf("/loop") !== 0 && item["disc-max"] && item["disc-max"] !== 0);
                    });
                  }
                } catch {
                  try {
                    const out2 = execSync("export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL", util.execOptsLinux).toString();
                    const lines = blkStdoutToObject(out2).split(`
`);
                    const data = parseBlk(lines);
                    devices = data.filter((item) => {
                      return item.type === "disk" && item.size > 0 && (item.model !== null && item.model !== "" || item.mount === "" && item.label === "" && item.fsType === "");
                    });
                  } catch {
                    util.noop();
                  }
                }
                devices.forEach((device) => {
                  let mediumType = "";
                  const BSDName = "/dev/" + device.name;
                  const logical = device.name;
                  try {
                    mediumType = execSync("cat /sys/block/" + logical + "/queue/rotational 2>/dev/null", util.execOptsLinux).toString().split(`
`)[0];
                  } catch {
                    util.noop();
                  }
                  let interfaceType = device.tran ? device.tran.toUpperCase().trim() : "";
                  if (interfaceType === "NVME") {
                    mediumType = "2";
                    interfaceType = "PCIe";
                  }
                  result2.push({
                    device: BSDName,
                    type: mediumType === "0" ? "SSD" : mediumType === "1" ? "HD" : mediumType === "2" ? "NVMe" : device.model && device.model.indexOf("SSD") > -1 ? "SSD" : device.model && device.model.indexOf("NVM") > -1 ? "NVMe" : "HD",
                    name: device.model || "",
                    vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ""),
                    size: device.size || 0,
                    bytesPerSector: null,
                    totalCylinders: null,
                    totalHeads: null,
                    totalSectors: null,
                    totalTracks: null,
                    tracksPerCylinder: null,
                    sectorsPerTrack: null,
                    firmwareRevision: device.rev ? device.rev.trim() : "",
                    serialNum: device.serial ? device.serial.trim() : "",
                    interfaceType,
                    smartStatus: "unknown",
                    temperature: null,
                    BSDName
                  });
                  cmd += `printf "
${BSDName}|"; smartctl -H ${BSDName} | grep overall;`;
                  cmdFullSmart += `${cmdFullSmart ? 'printf ",";' : ""}smartctl -a -j ${BSDName};`;
                });
              } catch {
                util.noop();
              }
            }
            if (cmdFullSmart) {
              exec(cmdFullSmart, { maxBuffer: 1024 * 1024 }, (error3, stdout2) => {
                try {
                  const data = JSON.parse(`[${stdout2}]`);
                  data.forEach((disk) => {
                    const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];
                    for (let i = 0;i < result2.length; i++) {
                      if (result2[i].BSDName === diskBSDName) {
                        result2[i].smartStatus = disk.smart_status.passed ? "Ok" : disk.smart_status.passed === false ? "Predicted Failure" : "unknown";
                        if (disk.temperature && disk.temperature.current) {
                          result2[i].temperature = disk.temperature.current;
                        }
                        result2[i].smartData = disk;
                      }
                    }
                  });
                  commitResult(result2);
                } catch {
                  if (cmd) {
                    cmd = cmd + `printf "
"`;
                    exec(cmd, { maxBuffer: 1024 * 1024 }, (error4, stdout3) => {
                      const lines = stdout3.toString().split(`
`);
                      lines.forEach((line) => {
                        if (line) {
                          const parts = line.split("|");
                          if (parts.length === 2) {
                            const BSDName = parts[0];
                            parts[1] = parts[1].trim();
                            const parts2 = parts[1].split(":");
                            if (parts2.length === 2) {
                              parts2[1] = parts2[1].trim();
                              const status = parts2[1].toLowerCase();
                              for (let i = 0;i < result2.length; i++) {
                                if (result2[i].BSDName === BSDName) {
                                  result2[i].smartStatus = status === "passed" ? "Ok" : status === "failed!" ? "Predicted Failure" : "unknown";
                                }
                              }
                            }
                          }
                        }
                      });
                      commitResult(result2);
                    });
                  } else {
                    commitResult(result2);
                  }
                }
              });
            } else {
              commitResult(result2);
            }
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_sunos) {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_darwin) {
          exec("system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType", { maxBuffer: 1024 * 1024 }, (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              const linesSATA = [];
              const linesNVMe = [];
              const linesUSB = [];
              let dataType = "SATA";
              lines.forEach((line) => {
                if (line === "NVMExpress:") {
                  dataType = "NVMe";
                } else if (line === "USB:") {
                  dataType = "USB";
                } else if (line === "SATA/SATA Express:") {
                  dataType = "SATA";
                } else if (dataType === "SATA") {
                  linesSATA.push(line);
                } else if (dataType === "NVMe") {
                  linesNVMe.push(line);
                } else if (dataType === "USB") {
                  linesUSB.push(line);
                }
              });
              try {
                const devices = linesSATA.join(`
`).split(" Physical Interconnect: ");
                devices.shift();
                devices.forEach((device) => {
                  device = "InterfaceType: " + device;
                  const lines2 = device.split(`
`);
                  const mediumType = util.getValue(lines2, "Medium Type", ":", true).trim();
                  const sizeStr = util.getValue(lines2, "capacity", ":", true).trim();
                  const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                  if (sizeStr) {
                    let sizeValue = 0;
                    if (sizeStr.indexOf("(") >= 0) {
                      sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""), 10);
                    }
                    if (!sizeValue) {
                      sizeValue = parseInt(sizeStr, 10);
                    }
                    if (sizeValue) {
                      const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                      result2.push({
                        device: BSDName,
                        type: mediumType.startsWith("Solid") ? "SSD" : "HD",
                        name: util.getValue(lines2, "Model", ":", true).trim(),
                        vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()) || util.getValue(lines2, "Manufacturer", ":", true),
                        size: sizeValue,
                        bytesPerSector: null,
                        totalCylinders: null,
                        totalHeads: null,
                        totalSectors: null,
                        totalTracks: null,
                        tracksPerCylinder: null,
                        sectorsPerTrack: null,
                        firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                        serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                        interfaceType: util.getValue(lines2, "InterfaceType", ":", true).trim(),
                        smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                        temperature: null,
                        BSDName
                      });
                      cmd = cmd + `printf "
` + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                    }
                  }
                });
              } catch {
                util.noop();
              }
              try {
                const devices = linesNVMe.join(`
`).split(`

          Capacity:`);
                devices.shift();
                devices.forEach((device) => {
                  device = `!Capacity: ${device}`;
                  const lines2 = device.split(`
`);
                  const linkWidth = util.getValue(lines2, "link width", ":", true).trim();
                  const sizeStr = util.getValue(lines2, "!capacity", ":", true).trim();
                  const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                  if (sizeStr) {
                    let sizeValue = 0;
                    if (sizeStr.indexOf("(") >= 0) {
                      sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""), 10);
                    }
                    if (!sizeValue) {
                      sizeValue = parseInt(sizeStr, 10);
                    }
                    if (sizeValue) {
                      const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                      result2.push({
                        device: BSDName,
                        type: "NVMe",
                        name: util.getValue(lines2, "Model", ":", true).trim(),
                        vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()),
                        size: sizeValue,
                        bytesPerSector: null,
                        totalCylinders: null,
                        totalHeads: null,
                        totalSectors: null,
                        totalTracks: null,
                        tracksPerCylinder: null,
                        sectorsPerTrack: null,
                        firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                        serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                        interfaceType: ("PCIe " + linkWidth).trim(),
                        smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                        temperature: null,
                        BSDName
                      });
                      cmd = `${cmd}printf "
${BSDName}|"; diskutil info /dev/${BSDName} | grep SMART;`;
                    }
                  }
                });
              } catch {
                util.noop();
              }
              try {
                const devices = linesUSB.join(`
`).replaceAll(`Media:
 `, "Model:").split(`

          Product ID:`);
                devices.shift();
                devices.forEach((device) => {
                  const lines2 = device.split(`
`);
                  const sizeStr = util.getValue(lines2, "Capacity", ":", true).trim();
                  const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                  if (sizeStr) {
                    let sizeValue = 0;
                    if (sizeStr.indexOf("(") >= 0) {
                      sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""), 10);
                    }
                    if (!sizeValue) {
                      sizeValue = parseInt(sizeStr, 10);
                    }
                    if (sizeValue) {
                      const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                      result2.push({
                        device: BSDName,
                        type: "USB",
                        name: util.getValue(lines2, "Model", ":", true).trim().replaceAll(":", ""),
                        vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()),
                        size: sizeValue,
                        bytesPerSector: null,
                        totalCylinders: null,
                        totalHeads: null,
                        totalSectors: null,
                        totalTracks: null,
                        tracksPerCylinder: null,
                        sectorsPerTrack: null,
                        firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                        serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                        interfaceType: "USB",
                        smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                        temperature: null,
                        BSDName
                      });
                      cmd = cmd + `printf "
` + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                    }
                  }
                });
              } catch {
                util.noop();
              }
              if (cmd) {
                cmd = cmd + `printf "
"`;
                exec(cmd, { maxBuffer: 1024 * 1024 }, (error3, stdout2) => {
                  const lines2 = stdout2.toString().split(`
`);
                  lines2.forEach((line) => {
                    if (line) {
                      const parts = line.split("|");
                      if (parts.length === 2) {
                        const BSDName = parts[0];
                        parts[1] = parts[1].trim();
                        const parts2 = parts[1].split(":");
                        if (parts2.length === 2) {
                          parts2[1] = parts2[1].trim();
                          const status = parts2[1].toLowerCase();
                          for (let i = 0;i < result2.length; i++) {
                            if (result2[i].BSDName === BSDName) {
                              result2[i].smartStatus = status === "not supported" ? "not supported" : status === "verified" ? "Ok" : status === "failing" ? "Predicted Failure" : "unknown";
                            }
                          }
                        }
                      }
                    }
                  });
                  commitResult(result2);
                });
              } else {
                commitResult(result2);
              }
            } else {
              commitResult(result2);
            }
          });
        }
        if (_windows) {
          try {
            const workload = [];
            workload.push(util.powerShell("Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl"));
            workload.push(util.powerShell("Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl"));
            if (util.smartMonToolsInstalled()) {
              try {
                const smartDev = JSON.parse(execSync("smartctl --scan -j").toString());
                if (smartDev && smartDev.devices && smartDev.devices.length > 0) {
                  smartDev.devices.forEach((dev) => {
                    workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util.execOptsWin));
                  });
                }
              } catch {
                util.noop();
              }
            }
            util.promiseAll(workload).then((data) => {
              let devices = data.results[0].toString().split(/\n\s*\n/);
              devices.forEach((device) => {
                const lines = device.split(`\r
`);
                const size = util.getValue(lines, "Size", ":").trim();
                const status = util.getValue(lines, "Status", ":").trim().toLowerCase();
                if (size) {
                  result2.push({
                    device: util.getValue(lines, "DeviceId", ":"),
                    type: device.indexOf("SSD") > -1 ? "SSD" : "HD",
                    name: util.getValue(lines, "Caption", ":"),
                    vendor: getVendorFromModel(util.getValue(lines, "Caption", ":", true).trim()),
                    size: parseInt(size, 10),
                    bytesPerSector: parseInt(util.getValue(lines, "BytesPerSector", ":"), 10),
                    totalCylinders: parseInt(util.getValue(lines, "TotalCylinders", ":"), 10),
                    totalHeads: parseInt(util.getValue(lines, "TotalHeads", ":"), 10),
                    totalSectors: parseInt(util.getValue(lines, "TotalSectors", ":"), 10),
                    totalTracks: parseInt(util.getValue(lines, "TotalTracks", ":"), 10),
                    tracksPerCylinder: parseInt(util.getValue(lines, "TracksPerCylinder", ":"), 10),
                    sectorsPerTrack: parseInt(util.getValue(lines, "SectorsPerTrack", ":"), 10),
                    firmwareRevision: util.getValue(lines, "FirmwareRevision", ":").trim(),
                    serialNum: util.getValue(lines, "SerialNumber", ":").trim(),
                    interfaceType: util.getValue(lines, "InterfaceType", ":").trim(),
                    smartStatus: status === "ok" ? "Ok" : status === "degraded" ? "Degraded" : status === "pred fail" ? "Predicted Failure" : "Unknown",
                    temperature: null
                  });
                }
              });
              devices = data.results[1].split(/\n\s*\n/);
              devices.forEach((device) => {
                const lines = device.split(`\r
`);
                const serialNum = util.getValue(lines, "SerialNumber", ":").trim();
                const name = util.getValue(lines, "FriendlyName", ":").trim().replace("Msft ", "Microsoft");
                const size = util.getValue(lines, "Size", ":").trim();
                const model = util.getValue(lines, "Model", ":").trim();
                const interfaceType = util.getValue(lines, "BusType", ":").trim();
                let mediaType = util.getValue(lines, "MediaType", ":").trim();
                if (mediaType === "3" || mediaType === "HDD") {
                  mediaType = "HD";
                }
                if (mediaType === "4") {
                  mediaType = "SSD";
                }
                if (mediaType === "5") {
                  mediaType = "SCM";
                }
                if (mediaType === "Unspecified" && (model.toLowerCase().indexOf("virtual") > -1 || model.toLowerCase().indexOf("vbox") > -1)) {
                  mediaType = "Virtual";
                }
                if (size) {
                  let i = util.findObjectByKey(result2, "serialNum", serialNum);
                  if (i === -1 || serialNum === "") {
                    i = util.findObjectByKey(result2, "name", name);
                  }
                  if (i !== -1) {
                    result2[i].type = mediaType;
                    result2[i].interfaceType = interfaceType;
                  }
                }
              });
              data.results.shift();
              data.results.shift();
              if (data.results.length) {
                data.results.forEach((smartStr) => {
                  try {
                    const smartData = JSON.parse(smartStr);
                    if (smartData.serial_number) {
                      const serialNum = smartData.serial_number;
                      const i = util.findObjectByKey(result2, "serialNum", serialNum);
                      if (i !== -1) {
                        result2[i].smartStatus = smartData.smart_status && smartData.smart_status.passed ? "Ok" : smartData.smart_status && smartData.smart_status.passed === false ? "Predicted Failure" : "unknown";
                        if (smartData.temperature && smartData.temperature.current) {
                          result2[i].temperature = smartData.temperature.current;
                        }
                        result2[i].smartData = smartData;
                      }
                    }
                  } catch {
                    util.noop();
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.diskLayout = diskLayout;
});

// node_modules/systeminformation/lib/network.js
var require_network = __commonJS((exports) => {
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var fs = __require("fs");
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _network = {};
  var _default_iface = "";
  var _ifaces = {};
  var _dhcpNics = [];
  var _networkInterfaces = [];
  var _mac = {};
  var pathToIp;
  function getDefaultNetworkInterface() {
    let ifacename = "";
    let ifacenameFirst = "";
    try {
      const ifaces = os.networkInterfaces();
      let scopeid = 9999;
      for (let dev in ifaces) {
        if ({}.hasOwnProperty.call(ifaces, dev)) {
          ifaces[dev].forEach((details) => {
            if (details && details.internal === false) {
              ifacenameFirst = ifacenameFirst || dev;
              if (details.scopeid && details.scopeid < scopeid) {
                ifacename = dev;
                scopeid = details.scopeid;
              }
            }
          });
        }
      }
      ifacename = ifacename || ifacenameFirst || "";
      if (_windows) {
        let defaultIp = "";
        const cmd = "netstat -r";
        const result2 = execSync(cmd, util.execOptsWin);
        const lines = result2.toString().split(os.EOL);
        lines.forEach((line) => {
          line = line.replace(/\s+/g, " ").trim();
          if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
            const parts = line.split(" ");
            if (parts.length >= 5) {
              defaultIp = parts[parts.length - 2];
            }
          }
        });
        if (defaultIp) {
          for (let dev in ifaces) {
            if ({}.hasOwnProperty.call(ifaces, dev)) {
              ifaces[dev].forEach((details) => {
                if (details && details.address && details.address === defaultIp) {
                  ifacename = dev;
                }
              });
            }
          }
        }
      }
      if (_linux) {
        const cmd = "ip route 2> /dev/null | grep default";
        const result2 = execSync(cmd, util.execOptsLinux);
        const parts = result2.toString().split(`
`)[0].split(/\s+/);
        if (parts[0] === "none" && parts[5]) {
          ifacename = parts[5];
        } else if (parts[4]) {
          ifacename = parts[4];
        }
        if (ifacename.indexOf(":") > -1) {
          ifacename = ifacename.split(":")[1].trim();
        }
      }
      if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {
        let cmd = "";
        if (_linux) {
          cmd = "ip route 2> /dev/null | grep default | awk '{print $5}'";
        }
        if (_darwin) {
          cmd = "route -n get default 2>/dev/null | grep interface: | awk '{print $2}'";
        }
        if (_freebsd || _openbsd || _netbsd || _sunos) {
          cmd = "route get 0.0.0.0 | grep interface:";
        }
        const result2 = execSync(cmd);
        ifacename = result2.toString().split(`
`)[0];
        if (ifacename.indexOf(":") > -1) {
          ifacename = ifacename.split(":")[1].trim();
        }
      }
    } catch {
      util.noop();
    }
    if (ifacename) {
      _default_iface = ifacename;
    }
    return _default_iface;
  }
  exports.getDefaultNetworkInterface = getDefaultNetworkInterface;
  function getMacAddresses() {
    let iface = "";
    let mac = "";
    const result2 = {};
    if (_linux || _freebsd || _openbsd || _netbsd) {
      if (typeof pathToIp === "undefined") {
        try {
          const lines = execSync("which ip", util.execOptsLinux).toString().split(`
`);
          if (lines.length && lines[0].indexOf(":") === -1 && lines[0].indexOf("/") === 0) {
            pathToIp = lines[0];
          } else {
            pathToIp = "";
          }
        } catch {
          pathToIp = "";
        }
      }
      try {
        const cmd = "export LC_ALL=C; " + (pathToIp ? pathToIp + " link show up" : "/sbin/ifconfig") + "; unset LC_ALL";
        const res = execSync(cmd, util.execOptsLinux);
        const lines = res.toString().split(`
`);
        for (let i = 0;i < lines.length; i++) {
          if (lines[i] && lines[i][0] !== " ") {
            if (pathToIp) {
              const nextline = lines[i + 1].trim().split(" ");
              if (nextline[0] === "link/ether") {
                iface = lines[i].split(" ")[1];
                iface = iface.slice(0, iface.length - 1);
                mac = nextline[1];
              }
            } else {
              iface = lines[i].split(" ")[0];
              mac = lines[i].split("HWaddr ")[1];
            }
            if (iface && mac) {
              result2[iface] = mac.trim();
              iface = "";
              mac = "";
            }
          }
        }
      } catch {
        util.noop();
      }
    }
    if (_darwin) {
      try {
        const cmd = "/sbin/ifconfig";
        const res = execSync(cmd);
        const lines = res.toString().split(`
`);
        for (let i = 0;i < lines.length; i++) {
          if (lines[i] && lines[i][0] !== "\t" && lines[i].indexOf(":") > 0) {
            iface = lines[i].split(":")[0];
          } else if (lines[i].indexOf("\tether ") === 0) {
            mac = lines[i].split("\tether ")[1];
            if (iface && mac) {
              result2[iface] = mac.trim();
              iface = "";
              mac = "";
            }
          }
        }
      } catch {
        util.noop();
      }
    }
    return result2;
  }
  function networkInterfaceDefault(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result2 = getDefaultNetworkInterface();
        if (callback) {
          callback(result2);
        }
        resolve(result2);
      });
    });
  }
  exports.networkInterfaceDefault = networkInterfaceDefault;
  function parseLinesWindowsNics(sections, nconfigsections) {
    const nics = [];
    for (let i in sections) {
      try {
        if ({}.hasOwnProperty.call(sections, i)) {
          if (sections[i].trim() !== "") {
            const lines = sections[i].trim().split(`\r
`);
            let linesNicConfig = null;
            try {
              linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split(`\r
`) : [];
            } catch {
              util.noop();
            }
            const netEnabled = util.getValue(lines, "NetEnabled", ":");
            let adapterType = util.getValue(lines, "AdapterTypeID", ":") === "9" ? "wireless" : "wired";
            const ifacename = util.getValue(lines, "Name", ":").replace(/\]/g, ")").replace(/\[/g, "(");
            const iface = util.getValue(lines, "NetConnectionID", ":").replace(/\]/g, ")").replace(/\[/g, "(");
            if (ifacename.toLowerCase().indexOf("wi-fi") >= 0 || ifacename.toLowerCase().indexOf("wireless") >= 0) {
              adapterType = "wireless";
            }
            if (netEnabled !== "") {
              const speed = parseInt(util.getValue(lines, "speed", ":").trim(), 10) / 1e6;
              nics.push({
                mac: util.getValue(lines, "MACAddress", ":").toLowerCase(),
                dhcp: util.getValue(linesNicConfig, "dhcpEnabled", ":").toLowerCase() === "true",
                name: ifacename,
                iface,
                netEnabled: netEnabled === "TRUE",
                speed: isNaN(speed) ? null : speed,
                operstate: util.getValue(lines, "NetConnectionStatus", ":") === "2" ? "up" : "down",
                type: adapterType
              });
            }
          }
        }
      } catch {
        util.noop();
      }
    }
    return nics;
  }
  function getWindowsNics() {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let cmd = "Get-CimInstance Win32_NetworkAdapter | fl *" + "; echo '#-#-#-#';";
        cmd += "Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled" + "";
        try {
          util.powerShell(cmd).then((data) => {
            data = data.split("#-#-#-#");
            const nsections = (data[0] || "").split(/\n\s*\n/);
            const nconfigsections = (data[1] || "").split(/\n\s*\n/);
            resolve(parseLinesWindowsNics(nsections, nconfigsections));
          });
        } catch {
          resolve([]);
        }
      });
    });
  }
  function getWindowsDNSsuffixes() {
    let iface = {};
    const dnsSuffixes = {
      primaryDNS: "",
      exitCode: 0,
      ifaces: []
    };
    try {
      const ipconfig = execSync("ipconfig /all", util.execOptsWin);
      const ipconfigArray = ipconfig.split(`\r
\r
`);
      ipconfigArray.forEach((element, index) => {
        if (index === 1) {
          const longPrimaryDNS = element.split(`\r
`).filter((element2) => {
            return element2.toUpperCase().includes("DNS");
          });
          const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(":") + 1);
          dnsSuffixes.primaryDNS = primaryDNS.trim();
          if (!dnsSuffixes.primaryDNS) {
            dnsSuffixes.primaryDNS = "Not defined";
          }
        }
        if (index > 1) {
          if (index % 2 === 0) {
            const name = element.substring(element.lastIndexOf(" ") + 1).replace(":", "");
            iface.name = name;
          } else {
            const connectionSpecificDNS = element.split(`\r
`).filter((element2) => {
              return element2.toUpperCase().includes("DNS");
            });
            const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(":") + 1);
            iface.dnsSuffix = dnsSuffix.trim();
            dnsSuffixes.ifaces.push(iface);
            iface = {};
          }
        }
      });
      return dnsSuffixes;
    } catch {
      return {
        primaryDNS: "",
        exitCode: 0,
        ifaces: []
      };
    }
  }
  function getWindowsIfaceDNSsuffix(ifaces, ifacename) {
    let dnsSuffix = "";
    const interfaceName = ifacename + ".";
    try {
      const connectionDnsSuffix = ifaces.filter((iface) => {
        return interfaceName.includes(iface.name + ".");
      }).map((iface) => iface.dnsSuffix);
      if (connectionDnsSuffix[0]) {
        dnsSuffix = connectionDnsSuffix[0];
      }
      if (!dnsSuffix) {
        dnsSuffix = "";
      }
      return dnsSuffix;
    } catch {
      return "Unknown";
    }
  }
  function getWindowsWiredProfilesInformation() {
    try {
      const result2 = execSync("netsh lan show profiles", util.execOptsWin);
      const profileList = result2.split(`\r
Profile on interface`);
      return profileList;
    } catch (error2) {
      if (error2.status === 1 && error2.stdout.includes("AutoConfig")) {
        return "Disabled";
      }
      return [];
    }
  }
  function getWindowsWirelessIfaceSSID(interfaceName) {
    try {
      const result2 = execSync(`netsh wlan show  interface name="${interfaceName}" | findstr "SSID"`, util.execOptsWin);
      const SSID = result2.split(`\r
`).shift();
      const parseSSID = SSID.split(":").pop().trim();
      return parseSSID;
    } catch {
      return "Unknown";
    }
  }
  function getWindowsIEEE8021x(connectionType, iface, ifaces) {
    const i8021x = {
      state: "Unknown",
      protocol: "Unknown"
    };
    if (ifaces === "Disabled") {
      i8021x.state = "Disabled";
      i8021x.protocol = "Not defined";
      return i8021x;
    }
    if (connectionType === "wired" && ifaces.length > 0) {
      try {
        const iface8021xInfo = ifaces.find((element) => {
          return element.includes(iface + `\r
`);
        });
        const arrayIface8021xInfo = iface8021xInfo.split(`\r
`);
        const state8021x = arrayIface8021xInfo.find((element) => {
          return element.includes("802.1x");
        });
        if (state8021x.includes("Disabled")) {
          i8021x.state = "Disabled";
          i8021x.protocol = "Not defined";
        } else if (state8021x.includes("Enabled")) {
          const protocol8021x = arrayIface8021xInfo.find((element) => {
            return element.includes("EAP");
          });
          i8021x.protocol = protocol8021x.split(":").pop();
          i8021x.state = "Enabled";
        }
      } catch {
        return i8021x;
      }
    } else if (connectionType === "wireless") {
      let i8021xState = "";
      let i8021xProtocol = "";
      try {
        const SSID = getWindowsWirelessIfaceSSID(iface);
        if (SSID !== "Unknown") {
          let ifaceSanitized = "";
          const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(SSID);
          const l = util.mathMin(s.length, 32);
          for (let i = 0;i <= l; i++) {
            if (s[i] !== undefined) {
              ifaceSanitized = ifaceSanitized + s[i];
            }
          }
          const profiles = execSync(`netsh wlan show profiles "${ifaceSanitized}"`, util.execOptsWin).split(`\r
`);
          i8021xState = (profiles.find((l2) => l2.indexOf("802.1X") >= 0) || "").trim();
          i8021xProtocol = (profiles.find((l2) => l2.indexOf("EAP") >= 0) || "").trim();
        }
        if (i8021xState.includes(":") && i8021xProtocol.includes(":")) {
          i8021x.state = i8021xState.split(":").pop();
          i8021x.protocol = i8021xProtocol.split(":").pop();
        }
      } catch {
        if (error.status === 1 && error.stdout.includes("AutoConfig")) {
          i8021x.state = "Disabled";
          i8021x.protocol = "Not defined";
        }
        return i8021x;
      }
    }
    return i8021x;
  }
  function splitSectionsNics(lines) {
    const result2 = [];
    let section = [];
    lines.forEach((line) => {
      if (!line.startsWith("\t") && !line.startsWith(" ")) {
        if (section.length) {
          result2.push(section);
          section = [];
        }
      }
      section.push(line);
    });
    if (section.length) {
      result2.push(section);
    }
    return result2;
  }
  function parseLinesDarwinNics(sections) {
    const nics = [];
    sections.forEach((section) => {
      const nic = {
        iface: "",
        mtu: null,
        mac: "",
        ip6: "",
        ip4: "",
        speed: null,
        type: "",
        operstate: "",
        duplex: "",
        internal: false
      };
      const first = section[0];
      nic.iface = first.split(":")[0].trim();
      const parts = first.split("> mtu");
      nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : null;
      if (isNaN(nic.mtu)) {
        nic.mtu = null;
      }
      nic.internal = parts[0].toLowerCase().indexOf("loopback") > -1;
      section.forEach((line) => {
        if (line.trim().startsWith("ether ")) {
          nic.mac = line.split("ether ")[1].toLowerCase().trim();
        }
        if (line.trim().startsWith("inet6 ") && !nic.ip6) {
          nic.ip6 = line.split("inet6 ")[1].toLowerCase().split("%")[0].split(" ")[0];
        }
        if (line.trim().startsWith("inet ") && !nic.ip4) {
          nic.ip4 = line.split("inet ")[1].toLowerCase().split(" ")[0];
        }
      });
      let speed = util.getValue(section, "link rate");
      nic.speed = speed ? parseFloat(speed) : null;
      if (nic.speed === null) {
        speed = util.getValue(section, "uplink rate");
        nic.speed = speed ? parseFloat(speed) : null;
        if (nic.speed !== null && speed.toLowerCase().indexOf("gbps") >= 0) {
          nic.speed = nic.speed * 1000;
        }
      } else {
        if (speed.toLowerCase().indexOf("gbps") >= 0) {
          nic.speed = nic.speed * 1000;
        }
      }
      nic.type = util.getValue(section, "type").toLowerCase().indexOf("wi-fi") > -1 ? "wireless" : "wired";
      const operstate = util.getValue(section, "status").toLowerCase();
      nic.operstate = operstate === "active" ? "up" : operstate === "inactive" ? "down" : "unknown";
      nic.duplex = util.getValue(section, "media").toLowerCase().indexOf("half-duplex") > -1 ? "half" : "full";
      if (nic.ip6 || nic.ip4 || nic.mac) {
        nics.push(nic);
      }
    });
    return nics;
  }
  function getDarwinNics() {
    const cmd = "/sbin/ifconfig -v";
    try {
      const lines = execSync(cmd, { maxBuffer: 1024 * 102400 }).toString().split(`
`);
      const nsections = splitSectionsNics(lines);
      return parseLinesDarwinNics(nsections);
    } catch {
      return [];
    }
  }
  function getLinuxIfaceConnectionName(interfaceName) {
    const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;
    try {
      const result2 = execSync(cmd, util.execOptsLinux).toString();
      const resultFormat = result2.replace(/\s+/g, " ").trim();
      const connectionNameLines = resultFormat.split(" ").slice(3);
      const connectionName = connectionNameLines.join(" ");
      return connectionName !== "--" ? connectionName : "";
    } catch {
      return "";
    }
  }
  function checkLinuxDCHPInterfaces(file) {
    let result2 = [];
    try {
      const cmd = `cat ${file} 2> /dev/null | grep 'iface\\|source'`;
      const lines = execSync(cmd, util.execOptsLinux).toString().split(`
`);
      lines.forEach((line) => {
        const parts = line.replace(/\s+/g, " ").trim().split(" ");
        if (parts.length >= 4) {
          if (line.toLowerCase().indexOf(" inet ") >= 0 && line.toLowerCase().indexOf("dhcp") >= 0) {
            result2.push(parts[1]);
          }
        }
        if (line.toLowerCase().includes("source")) {
          const file2 = line.split(" ")[1];
          result2 = result2.concat(checkLinuxDCHPInterfaces(file2));
        }
      });
    } catch {
      util.noop();
    }
    return result2;
  }
  function getLinuxDHCPNics() {
    const cmd = "ip a 2> /dev/null";
    let result2 = [];
    try {
      const lines = execSync(cmd, util.execOptsLinux).toString().split(`
`);
      const nsections = splitSectionsNics(lines);
      result2 = parseLinuxDHCPNics(nsections);
    } catch {
      util.noop();
    }
    try {
      result2 = checkLinuxDCHPInterfaces("/etc/network/interfaces");
    } catch {
      util.noop();
    }
    return result2;
  }
  function parseLinuxDHCPNics(sections) {
    const result2 = [];
    if (sections && sections.length) {
      sections.forEach((lines) => {
        if (lines && lines.length) {
          const parts = lines[0].split(":");
          if (parts.length > 2) {
            for (let line of lines) {
              if (line.indexOf(" inet ") >= 0 && line.indexOf(" dynamic ") >= 0) {
                const parts2 = line.split(" ");
                const nic = parts2[parts2.length - 1].trim();
                result2.push(nic);
                break;
              }
            }
          }
        }
      });
    }
    return result2;
  }
  function getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {
    let result2 = false;
    if (connectionName) {
      const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.method;`;
      try {
        const lines = execSync(cmd, util.execOptsLinux).toString();
        const resultFormat = lines.replace(/\s+/g, " ").trim();
        const dhcStatus = resultFormat.split(" ").slice(1).toString();
        switch (dhcStatus) {
          case "auto":
            result2 = true;
            break;
          default:
            result2 = false;
            break;
        }
        return result2;
      } catch {
        return DHCPNics.indexOf(iface) >= 0;
      }
    } else {
      return DHCPNics.indexOf(iface) >= 0;
    }
  }
  function getDarwinIfaceDHCPstatus(iface) {
    let result2 = false;
    const cmd = `ipconfig getpacket "${iface}" 2>/dev/null | grep lease_time;`;
    try {
      const lines = execSync(cmd).toString().split(`
`);
      if (lines.length && lines[0].startsWith("lease_time")) {
        result2 = true;
      }
    } catch {
      util.noop();
    }
    return result2;
  }
  function getLinuxIfaceDNSsuffix(connectionName) {
    if (connectionName) {
      const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.dns-search;`;
      try {
        const result2 = execSync(cmd, util.execOptsLinux).toString();
        const resultFormat = result2.replace(/\s+/g, " ").trim();
        const dnsSuffix = resultFormat.split(" ").slice(1).toString();
        return dnsSuffix === "--" ? "Not defined" : dnsSuffix;
      } catch {
        return "Unknown";
      }
    } else {
      return "Unknown";
    }
  }
  function getLinuxIfaceIEEE8021xAuth(connectionName) {
    if (connectionName) {
      const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep 802-1x.eap;`;
      try {
        const result2 = execSync(cmd, util.execOptsLinux).toString();
        const resultFormat = result2.replace(/\s+/g, " ").trim();
        const authenticationProtocol = resultFormat.split(" ").slice(1).toString();
        return authenticationProtocol === "--" ? "" : authenticationProtocol;
      } catch {
        return "Not defined";
      }
    } else {
      return "Not defined";
    }
  }
  function getLinuxIfaceIEEE8021xState(authenticationProtocol) {
    if (authenticationProtocol) {
      if (authenticationProtocol === "Not defined") {
        return "Disabled";
      }
      return "Enabled";
    } else {
      return "Unknown";
    }
  }
  function testVirtualNic(iface, ifaceName, mac) {
    const virtualMacs = [
      "00:00:00:00:00:00",
      "00:03:FF",
      "00:05:69",
      "00:0C:29",
      "00:0F:4B",
      "00:13:07",
      "00:13:BE",
      "00:15:5d",
      "00:16:3E",
      "00:1C:42",
      "00:21:F6",
      "00:24:0B",
      "00:50:56",
      "00:A0:B1",
      "00:E0:C8",
      "08:00:27",
      "0A:00:27",
      "18:92:2C",
      "16:DF:49",
      "3C:F3:92",
      "54:52:00",
      "FC:15:97"
    ];
    if (mac) {
      return virtualMacs.filter((item) => {
        return mac.toUpperCase().toUpperCase().startsWith(item.substring(0, mac.length));
      }).length > 0 || iface.toLowerCase().indexOf(" virtual ") > -1 || ifaceName.toLowerCase().indexOf(" virtual ") > -1 || iface.toLowerCase().indexOf("vethernet ") > -1 || ifaceName.toLowerCase().indexOf("vethernet ") > -1 || iface.toLowerCase().startsWith("veth") || ifaceName.toLowerCase().startsWith("veth") || iface.toLowerCase().startsWith("vboxnet") || ifaceName.toLowerCase().startsWith("vboxnet");
    } else {
      return false;
    }
  }
  function networkInterfaces(callback, rescan, defaultString) {
    if (typeof callback === "string") {
      defaultString = callback;
      rescan = true;
      callback = null;
    }
    if (typeof callback === "boolean") {
      rescan = callback;
      callback = null;
      defaultString = "";
    }
    if (typeof rescan === "undefined") {
      rescan = true;
    }
    defaultString = defaultString || "";
    defaultString = "" + defaultString;
    return new Promise((resolve) => {
      process.nextTick(() => {
        const ifaces = os.networkInterfaces();
        let result2 = [];
        let nics = [];
        let dnsSuffixes = [];
        let nics8021xInfo = [];
        if (_darwin || _freebsd || _openbsd || _netbsd) {
          if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
            result2 = _networkInterfaces;
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          } else {
            const defaultInterface = getDefaultNetworkInterface();
            _ifaces = JSON.parse(JSON.stringify(ifaces));
            nics = getDarwinNics();
            nics.forEach((nic) => {
              let ip4link = "";
              let ip4linksubnet = "";
              let ip6link = "";
              let ip6linksubnet = "";
              nic.ip4 = "";
              nic.ip6 = "";
              if ({}.hasOwnProperty.call(ifaces, nic.iface)) {
                ifaces[nic.iface].forEach((details) => {
                  if (details.family === "IPv4" || details.family === 4) {
                    if (!nic.ip4 && !nic.ip4.match(/^169.254/i)) {
                      nic.ip4 = details.address;
                      nic.ip4subnet = details.netmask;
                    }
                    if (nic.ip4.match(/^169.254/i)) {
                      ip4link = details.address;
                      ip4linksubnet = details.netmask;
                    }
                  }
                  if (details.family === "IPv6" || details.family === 6) {
                    if (!nic.ip6 && !nic.ip6.match(/^fe80::/i)) {
                      nic.ip6 = details.address;
                      nic.ip6subnet = details.netmask;
                    }
                    if (nic.ip6.match(/^fe80::/i)) {
                      ip6link = details.address;
                      ip6linksubnet = details.netmask;
                    }
                  }
                });
              }
              if (!nic.ip4 && ip4link) {
                nic.ip4 = ip4link;
                nic.ip4subnet = ip4linksubnet;
              }
              if (!nic.ip6 && ip6link) {
                nic.ip6 = ip6link;
                nic.ip6subnet = ip6linksubnet;
              }
              let ifaceSanitized = "";
              const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(nic.iface);
              const l = util.mathMin(s.length, 2000);
              for (let i = 0;i <= l; i++) {
                if (s[i] !== undefined) {
                  ifaceSanitized = ifaceSanitized + s[i];
                }
              }
              result2.push({
                iface: nic.iface,
                ifaceName: nic.iface,
                default: nic.iface === defaultInterface,
                ip4: nic.ip4,
                ip4subnet: nic.ip4subnet || "",
                ip6: nic.ip6,
                ip6subnet: nic.ip6subnet || "",
                mac: nic.mac,
                internal: nic.internal,
                virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),
                operstate: nic.operstate,
                type: nic.type,
                duplex: nic.duplex,
                mtu: nic.mtu,
                speed: nic.speed,
                dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),
                dnsSuffix: "",
                ieee8021xAuth: "",
                ieee8021xState: "",
                carrierChanges: 0
              });
            });
            _networkInterfaces = result2;
            if (defaultString.toLowerCase().indexOf("default") >= 0) {
              result2 = result2.filter((item) => item.default);
              if (result2.length > 0) {
                result2 = result2[0];
              } else {
                result2 = [];
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_linux) {
          if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
            result2 = _networkInterfaces;
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          } else {
            _ifaces = JSON.parse(JSON.stringify(ifaces));
            _dhcpNics = getLinuxDHCPNics();
            const defaultInterface = getDefaultNetworkInterface();
            for (let dev in ifaces) {
              let ip4 = "";
              let ip4subnet = "";
              let ip6 = "";
              let ip6subnet = "";
              let mac = "";
              let duplex = "";
              let mtu = "";
              let speed = null;
              let carrierChanges = 0;
              let dhcp = false;
              let dnsSuffix = "";
              let ieee8021xAuth = "";
              let ieee8021xState = "";
              let type = "";
              let ip4link = "";
              let ip4linksubnet = "";
              let ip6link = "";
              let ip6linksubnet = "";
              if ({}.hasOwnProperty.call(ifaces, dev)) {
                const ifaceName = dev;
                ifaces[dev].forEach((details) => {
                  if (details.family === "IPv4" || details.family === 4) {
                    if (!ip4 && !ip4.match(/^169.254/i)) {
                      ip4 = details.address;
                      ip4subnet = details.netmask;
                    }
                    if (ip4.match(/^169.254/i)) {
                      ip4link = details.address;
                      ip4linksubnet = details.netmask;
                    }
                  }
                  if (details.family === "IPv6" || details.family === 6) {
                    if (!ip6 && !ip6.match(/^fe80::/i)) {
                      ip6 = details.address;
                      ip6subnet = details.netmask;
                    }
                    if (ip6.match(/^fe80::/i)) {
                      ip6link = details.address;
                      ip6linksubnet = details.netmask;
                    }
                  }
                  mac = details.mac;
                  const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                  if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                    if (Object.keys(_mac).length === 0) {
                      _mac = getMacAddresses();
                    }
                    mac = _mac[dev] || "";
                  }
                });
                if (!ip4 && ip4link) {
                  ip4 = ip4link;
                  ip4subnet = ip4linksubnet;
                }
                if (!ip6 && ip6link) {
                  ip6 = ip6link;
                  ip6subnet = ip6linksubnet;
                }
                const iface = dev.split(":")[0].trim();
                let ifaceSanitized = "";
                const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface);
                const l = util.mathMin(s.length, 2000);
                for (let i = 0;i <= l; i++) {
                  if (s[i] !== undefined) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                const cmd = `echo -n "addr_assign_type: "; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;
            echo -n "address: "; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;
            echo -n "addr_len: "; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;
            echo -n "broadcast: "; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;
            echo -n "carrier: "; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;
            echo -n "carrier_changes: "; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;
            echo -n "dev_id: "; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;
            echo -n "dev_port: "; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;
            echo -n "dormant: "; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;
            echo -n "duplex: "; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;
            echo -n "flags: "; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;
            echo -n "gro_flush_timeout: "; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;
            echo -n "ifalias: "; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;
            echo -n "ifindex: "; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;
            echo -n "iflink: "; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;
            echo -n "link_mode: "; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;
            echo -n "mtu: "; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;
            echo -n "netdev_group: "; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;
            echo -n "operstate: "; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;
            echo -n "proto_down: "; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;
            echo -n "speed: "; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;
            echo -n "tx_queue_len: "; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;
            echo -n "type: "; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;
            echo -n "wireless: "; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;
            echo -n "wirelessspeed: "; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;
                let lines = [];
                try {
                  lines = execSync(cmd, util.execOptsLinux).toString().split(`
`);
                  const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);
                  dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);
                  dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);
                  ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);
                  ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);
                } catch {
                  util.noop();
                }
                duplex = util.getValue(lines, "duplex");
                duplex = duplex.startsWith("cat") ? "" : duplex;
                mtu = parseInt(util.getValue(lines, "mtu"), 10);
                let myspeed = parseInt(util.getValue(lines, "speed"), 10);
                speed = isNaN(myspeed) ? null : myspeed;
                const wirelessspeed = util.getValue(lines, "tx bitrate");
                if (speed === null && wirelessspeed) {
                  myspeed = parseFloat(wirelessspeed);
                  speed = isNaN(myspeed) ? null : myspeed;
                }
                carrierChanges = parseInt(util.getValue(lines, "carrier_changes"), 10);
                const operstate = util.getValue(lines, "operstate");
                type = operstate === "up" ? util.getValue(lines, "wireless").trim() ? "wireless" : "wired" : "unknown";
                if (ifaceSanitized === "lo" || ifaceSanitized.startsWith("bond")) {
                  type = "virtual";
                }
                let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                  internal = true;
                }
                const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                result2.push({
                  iface: ifaceSanitized,
                  ifaceName,
                  default: iface === defaultInterface,
                  ip4,
                  ip4subnet,
                  ip6,
                  ip6subnet,
                  mac,
                  internal,
                  virtual,
                  operstate,
                  type,
                  duplex,
                  mtu,
                  speed,
                  dhcp,
                  dnsSuffix,
                  ieee8021xAuth,
                  ieee8021xState,
                  carrierChanges
                });
              }
            }
            _networkInterfaces = result2;
            if (defaultString.toLowerCase().indexOf("default") >= 0) {
              result2 = result2.filter((item) => item.default);
              if (result2.length > 0) {
                result2 = result2[0];
              } else {
                result2 = [];
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_windows) {
          if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
            result2 = _networkInterfaces;
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          } else {
            _ifaces = JSON.parse(JSON.stringify(ifaces));
            const defaultInterface = getDefaultNetworkInterface();
            getWindowsNics().then((nics2) => {
              nics2.forEach((nic) => {
                let found = false;
                Object.keys(ifaces).forEach((key) => {
                  if (!found) {
                    ifaces[key].forEach((value) => {
                      if (Object.keys(value).indexOf("mac") >= 0) {
                        found = value["mac"] === nic.mac;
                      }
                    });
                  }
                });
                if (!found) {
                  ifaces[nic.name] = [{ mac: nic.mac }];
                }
              });
              nics8021xInfo = getWindowsWiredProfilesInformation();
              dnsSuffixes = getWindowsDNSsuffixes();
              for (let dev in ifaces) {
                let ifaceSanitized = "";
                const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(dev);
                const l = util.mathMin(s.length, 2000);
                for (let i = 0;i <= l; i++) {
                  if (s[i] !== undefined) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                let iface = dev;
                let ip4 = "";
                let ip4subnet = "";
                let ip6 = "";
                let ip6subnet = "";
                let mac = "";
                let duplex = "";
                let mtu = "";
                let speed = null;
                let carrierChanges = 0;
                let operstate = "down";
                let dhcp = false;
                let dnsSuffix = "";
                let ieee8021xAuth = "";
                let ieee8021xState = "";
                let type = "";
                if ({}.hasOwnProperty.call(ifaces, dev)) {
                  let ifaceName = dev;
                  ifaces[dev].forEach((details) => {
                    if (details.family === "IPv4" || details.family === 4) {
                      ip4 = details.address;
                      ip4subnet = details.netmask;
                    }
                    if (details.family === "IPv6" || details.family === 6) {
                      if (!ip6 || ip6.match(/^fe80::/i)) {
                        ip6 = details.address;
                        ip6subnet = details.netmask;
                      }
                    }
                    mac = details.mac;
                    const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                    if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                      if (Object.keys(_mac).length === 0) {
                        _mac = getMacAddresses();
                      }
                      mac = _mac[dev] || "";
                    }
                  });
                  dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);
                  let foundFirst = false;
                  nics2.forEach((detail) => {
                    if (detail.mac === mac && !foundFirst) {
                      iface = detail.iface || iface;
                      ifaceName = detail.name;
                      dhcp = detail.dhcp;
                      operstate = detail.operstate;
                      speed = operstate === "up" ? detail.speed : 0;
                      type = detail.type;
                      foundFirst = true;
                    }
                  });
                  if (dev.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("802.11n") >= 0 || ifaceName.toLowerCase().indexOf("wireless") >= 0 || ifaceName.toLowerCase().indexOf("wi-fi") >= 0 || ifaceName.toLowerCase().indexOf("wifi") >= 0) {
                    type = "wireless";
                  }
                  const IEEE8021x = getWindowsIEEE8021x(type, ifaceSanitized, nics8021xInfo);
                  ieee8021xAuth = IEEE8021x.protocol;
                  ieee8021xState = IEEE8021x.state;
                  let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                  if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                    internal = true;
                  }
                  const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                  result2.push({
                    iface,
                    ifaceName,
                    default: iface === defaultInterface,
                    ip4,
                    ip4subnet,
                    ip6,
                    ip6subnet,
                    mac,
                    internal,
                    virtual,
                    operstate,
                    type,
                    duplex,
                    mtu,
                    speed,
                    dhcp,
                    dnsSuffix,
                    ieee8021xAuth,
                    ieee8021xState,
                    carrierChanges
                  });
                }
              }
              _networkInterfaces = result2;
              if (defaultString.toLowerCase().indexOf("default") >= 0) {
                result2 = result2.filter((item) => item.default);
                if (result2.length > 0) {
                  result2 = result2[0];
                } else {
                  result2 = [];
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          }
        }
      });
    });
  }
  exports.networkInterfaces = networkInterfaces;
  function calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {
    const result2 = {
      iface,
      operstate,
      rx_bytes,
      rx_dropped,
      rx_errors,
      tx_bytes,
      tx_dropped,
      tx_errors,
      rx_sec: null,
      tx_sec: null,
      ms: 0
    };
    if (_network[iface] && _network[iface].ms) {
      result2.ms = Date.now() - _network[iface].ms;
      result2.rx_sec = rx_bytes - _network[iface].rx_bytes >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result2.ms / 1000) : 0;
      result2.tx_sec = tx_bytes - _network[iface].tx_bytes >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result2.ms / 1000) : 0;
      _network[iface].rx_bytes = rx_bytes;
      _network[iface].tx_bytes = tx_bytes;
      _network[iface].rx_sec = result2.rx_sec;
      _network[iface].tx_sec = result2.tx_sec;
      _network[iface].ms = Date.now();
      _network[iface].last_ms = result2.ms;
      _network[iface].operstate = operstate;
    } else {
      if (!_network[iface]) {
        _network[iface] = {};
      }
      _network[iface].rx_bytes = rx_bytes;
      _network[iface].tx_bytes = tx_bytes;
      _network[iface].rx_sec = null;
      _network[iface].tx_sec = null;
      _network[iface].ms = Date.now();
      _network[iface].last_ms = 0;
      _network[iface].operstate = operstate;
    }
    return result2;
  }
  function networkStats(ifaces, callback) {
    let ifacesArray = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (util.isFunction(ifaces) && !callback) {
          callback = ifaces;
          ifacesArray = [getDefaultNetworkInterface()];
        } else {
          if (typeof ifaces !== "string" && ifaces !== undefined) {
            if (callback) {
              callback([]);
            }
            return resolve([]);
          }
          ifaces = ifaces || getDefaultNetworkInterface();
          try {
            ifaces.__proto__.toLowerCase = util.stringToLower;
            ifaces.__proto__.replace = util.stringReplace;
            ifaces.__proto__.toString = util.stringToString;
            ifaces.__proto__.substr = util.stringSubstr;
            ifaces.__proto__.substring = util.stringSubstring;
            ifaces.__proto__.trim = util.stringTrim;
            ifaces.__proto__.startsWith = util.stringStartWith;
          } catch {
            Object.setPrototypeOf(ifaces, util.stringObj);
          }
          ifaces = ifaces.trim().replace(/,+/g, "|");
          ifacesArray = ifaces.split("|");
        }
        const result2 = [];
        const workload = [];
        if (ifacesArray.length && ifacesArray[0].trim() === "*") {
          ifacesArray = [];
          networkInterfaces(false).then((allIFaces) => {
            for (let iface of allIFaces) {
              ifacesArray.push(iface.iface);
            }
            networkStats(ifacesArray.join(",")).then((result3) => {
              if (callback) {
                callback(result3);
              }
              resolve(result3);
            });
          });
        } else {
          for (let iface of ifacesArray) {
            workload.push(networkStatsSingle(iface.trim()));
          }
          if (workload.length) {
            Promise.all(workload).then((data) => {
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  function networkStatsSingle(iface) {
    function parseLinesWindowsPerfData(sections) {
      const perfData = [];
      for (let i in sections) {
        if ({}.hasOwnProperty.call(sections, i)) {
          if (sections[i].trim() !== "") {
            const lines = sections[i].trim().split(`\r
`);
            perfData.push({
              name: util.getValue(lines, "Name", ":").replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase(),
              rx_bytes: parseInt(util.getValue(lines, "BytesReceivedPersec", ":"), 10),
              rx_errors: parseInt(util.getValue(lines, "PacketsReceivedErrors", ":"), 10),
              rx_dropped: parseInt(util.getValue(lines, "PacketsReceivedDiscarded", ":"), 10),
              tx_bytes: parseInt(util.getValue(lines, "BytesSentPersec", ":"), 10),
              tx_errors: parseInt(util.getValue(lines, "PacketsOutboundErrors", ":"), 10),
              tx_dropped: parseInt(util.getValue(lines, "PacketsOutboundDiscarded", ":"), 10)
            });
          }
        }
      }
      return perfData;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let ifaceSanitized = "";
        const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface);
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (s[i] !== undefined) {
            ifaceSanitized = ifaceSanitized + s[i];
          }
        }
        let result2 = {
          iface: ifaceSanitized,
          operstate: "unknown",
          rx_bytes: 0,
          rx_dropped: 0,
          rx_errors: 0,
          tx_bytes: 0,
          tx_dropped: 0,
          tx_errors: 0,
          rx_sec: null,
          tx_sec: null,
          ms: 0
        };
        let operstate = "unknown";
        let rx_bytes = 0;
        let tx_bytes = 0;
        let rx_dropped = 0;
        let rx_errors = 0;
        let tx_dropped = 0;
        let tx_errors = 0;
        let cmd, lines, stats;
        if (!_network[ifaceSanitized] || _network[ifaceSanitized] && !_network[ifaceSanitized].ms || _network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500) {
          if (_linux) {
            if (fs.existsSync("/sys/class/net/" + ifaceSanitized)) {
              cmd = "cat /sys/class/net/" + ifaceSanitized + "/operstate; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_bytes; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_bytes; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_dropped; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_errors; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_dropped; " + "cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_errors; ";
              exec(cmd, (error2, stdout) => {
                if (!error2) {
                  lines = stdout.toString().split(`
`);
                  operstate = lines[0].trim();
                  rx_bytes = parseInt(lines[1], 10);
                  tx_bytes = parseInt(lines[2], 10);
                  rx_dropped = parseInt(lines[3], 10);
                  rx_errors = parseInt(lines[4], 10);
                  tx_dropped = parseInt(lines[5], 10);
                  tx_errors = parseInt(lines[6], 10);
                  result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
                resolve(result2);
              });
            } else {
              resolve(result2);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            cmd = "netstat -ibndI " + ifaceSanitized;
            exec(cmd, (error2, stdout) => {
              if (!error2) {
                lines = stdout.toString().split(`
`);
                for (let i = 1;i < lines.length; i++) {
                  const line = lines[i].replace(/ +/g, " ").split(" ");
                  if (line && line[0] && line[7] && line[10]) {
                    rx_bytes = rx_bytes + parseInt(line[7]);
                    if (line[6].trim() !== "-") {
                      rx_dropped = rx_dropped + parseInt(line[6]);
                    }
                    if (line[5].trim() !== "-") {
                      rx_errors = rx_errors + parseInt(line[5]);
                    }
                    tx_bytes = tx_bytes + parseInt(line[10]);
                    if (line[12].trim() !== "-") {
                      tx_dropped = tx_dropped + parseInt(line[12]);
                    }
                    if (line[9].trim() !== "-") {
                      tx_errors = tx_errors + parseInt(line[9]);
                    }
                    operstate = "up";
                  }
                }
                result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
              }
              resolve(result2);
            });
          }
          if (_darwin) {
            cmd = "ifconfig " + ifaceSanitized + ' | grep "status"';
            exec(cmd, (error2, stdout) => {
              result2.operstate = (stdout.toString().split(":")[1] || "").trim();
              result2.operstate = (result2.operstate || "").toLowerCase();
              result2.operstate = result2.operstate === "active" ? "up" : result2.operstate === "inactive" ? "down" : "unknown";
              cmd = "netstat -bdI " + ifaceSanitized;
              exec(cmd, (error3, stdout2) => {
                if (!error3) {
                  lines = stdout2.toString().split(`
`);
                  if (lines.length > 1 && lines[1].trim() !== "") {
                    stats = lines[1].replace(/ +/g, " ").split(" ");
                    const offset = stats.length > 11 ? 1 : 0;
                    rx_bytes = parseInt(stats[offset + 5]);
                    rx_dropped = parseInt(stats[offset + 10]);
                    rx_errors = parseInt(stats[offset + 4]);
                    tx_bytes = parseInt(stats[offset + 8]);
                    tx_dropped = parseInt(stats[offset + 10]);
                    tx_errors = parseInt(stats[offset + 7]);
                    result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result2.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                }
                resolve(result2);
              });
            });
          }
          if (_windows) {
            let perfData = [];
            let ifaceName = ifaceSanitized;
            util.powerShell("Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl").then((stdout, error2) => {
              if (!error2) {
                const psections = stdout.toString().split(/\n\s*\n/);
                perfData = parseLinesWindowsPerfData(psections);
              }
              networkInterfaces(false).then((interfaces) => {
                rx_bytes = 0;
                tx_bytes = 0;
                perfData.forEach((detail) => {
                  interfaces.forEach((det) => {
                    if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() || det.mac.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() || det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === ifaceSanitized.replace(/[()[\] ]+/g, "").replace("#", "_").toLowerCase()) && det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === detail.name) {
                      ifaceName = det.iface;
                      rx_bytes = detail.rx_bytes;
                      rx_dropped = detail.rx_dropped;
                      rx_errors = detail.rx_errors;
                      tx_bytes = detail.tx_bytes;
                      tx_dropped = detail.tx_dropped;
                      tx_errors = detail.tx_errors;
                      operstate = det.operstate;
                    }
                  });
                });
                if (rx_bytes && tx_bytes) {
                  result2 = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
                resolve(result2);
              });
            });
          }
        } else {
          result2.rx_bytes = _network[ifaceSanitized].rx_bytes;
          result2.tx_bytes = _network[ifaceSanitized].tx_bytes;
          result2.rx_sec = _network[ifaceSanitized].rx_sec;
          result2.tx_sec = _network[ifaceSanitized].tx_sec;
          result2.ms = _network[ifaceSanitized].last_ms;
          result2.operstate = _network[ifaceSanitized].operstate;
          resolve(result2);
        }
      });
    });
  }
  exports.networkStats = networkStats;
  function getProcessName(processes, pid) {
    let cmd = "";
    processes.forEach((line) => {
      const parts = line.split(" ");
      const id = parseInt(parts[0], 10) || -1;
      if (id === pid) {
        parts.shift();
        cmd = parts.join(" ").split(":")[0];
      }
    });
    cmd = cmd.split(" -")[0];
    cmd = cmd.split(" /")[0];
    return cmd;
  }
  function networkConnections(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result2 = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          let cmd = 'export LC_ALL=C; netstat -tunap | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
          if (_freebsd || _openbsd || _netbsd) {
            cmd = 'export LC_ALL=C; netstat -na | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
          }
          exec(cmd, { maxBuffer: 1024 * 102400 }, (error2, stdout) => {
            let lines = stdout.toString().split(`
`);
            if (!error2 && (lines.length > 1 || lines[0] !== "")) {
              lines.forEach((line) => {
                line = line.replace(/ +/g, " ").split(" ");
                if (line.length >= 7) {
                  let localip = line[3];
                  let localport = "";
                  const localaddress = line[3].split(":");
                  if (localaddress.length > 1) {
                    localport = localaddress[localaddress.length - 1];
                    localaddress.pop();
                    localip = localaddress.join(":");
                  }
                  let peerip = line[4];
                  let peerport = "";
                  const peeraddress = line[4].split(":");
                  if (peeraddress.length > 1) {
                    peerport = peeraddress[peeraddress.length - 1];
                    peeraddress.pop();
                    peerip = peeraddress.join(":");
                  }
                  const connstate = line[5];
                  const proc = line[6].split("/");
                  if (connstate) {
                    result2.push({
                      protocol: line[0],
                      localAddress: localip,
                      localPort: localport,
                      peerAddress: peerip,
                      peerPort: peerport,
                      state: connstate,
                      pid: proc[0] && proc[0] !== "-" ? parseInt(proc[0], 10) : null,
                      process: proc[1] ? proc[1].split(" ")[0].split(":")[0] : ""
                    });
                  }
                }
              });
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              cmd = 'ss -tunap | grep "ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-ACK\\|LISTEN\\|CLOSING"';
              exec(cmd, { maxBuffer: 1024 * 102400 }, (error3, stdout2) => {
                if (!error3) {
                  const lines2 = stdout2.toString().split(`
`);
                  lines2.forEach((line) => {
                    line = line.replace(/ +/g, " ").split(" ");
                    if (line.length >= 6) {
                      let localip = line[4];
                      let localport = "";
                      const localaddress = line[4].split(":");
                      if (localaddress.length > 1) {
                        localport = localaddress[localaddress.length - 1];
                        localaddress.pop();
                        localip = localaddress.join(":");
                      }
                      let peerip = line[5];
                      let peerport = "";
                      const peeraddress = line[5].split(":");
                      if (peeraddress.length > 1) {
                        peerport = peeraddress[peeraddress.length - 1];
                        peeraddress.pop();
                        peerip = peeraddress.join(":");
                      }
                      let connstate = line[1];
                      if (connstate === "ESTAB") {
                        connstate = "ESTABLISHED";
                      }
                      if (connstate === "TIME-WAIT") {
                        connstate = "TIME_WAIT";
                      }
                      let pid = null;
                      let process2 = "";
                      if (line.length >= 7 && line[6].indexOf("users:") > -1) {
                        const proc = line[6].replace('users:(("', "").replace(/"/g, "").replace("pid=", "").split(",");
                        if (proc.length > 2) {
                          process2 = proc[0];
                          const pidValue = parseInt(proc[1], 10);
                          if (pidValue > 0) {
                            pid = pidValue;
                          }
                        }
                      }
                      if (connstate) {
                        result2.push({
                          protocol: line[0],
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: connstate,
                          pid,
                          process: process2
                        });
                      }
                    }
                  });
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            }
          });
        }
        if (_darwin) {
          const cmd = 'netstat -natvln | head -n2; netstat -natvln | grep "tcp4\\|tcp6\\|udp4\\|udp6"';
          const states = "ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT_1|FIN_WAIT2|FIN_WAIT_2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN".split("|");
          exec(cmd, { maxBuffer: 1024 * 102400 }, (error2, stdout) => {
            if (!error2) {
              exec("ps -axo pid,command", { maxBuffer: 1024 * 102400 }, (err2, stdout2) => {
                let processes = stdout2.toString().split(`
`);
                processes = processes.map((line) => {
                  return line.trim().replace(/ +/g, " ");
                });
                const lines = stdout.toString().split(`
`);
                lines.shift();
                let pidPos = 8;
                if (lines.length > 1 && lines[0].indexOf("pid") > 0) {
                  const header = (lines.shift() || "").replace(/ Address/g, "_Address").replace(/process:/g, "").replace(/ +/g, " ").split(" ");
                  pidPos = header.indexOf("pid");
                }
                lines.forEach((line) => {
                  line = line.replace(/ +/g, " ").split(" ");
                  if (line.length >= 8) {
                    let localip = line[3];
                    let localport = "";
                    const localaddress = line[3].split(".");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(".");
                    }
                    let peerip = line[4];
                    let peerport = "";
                    const peeraddress = line[4].split(".");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(".");
                    }
                    const hasState = states.indexOf(line[5]) >= 0;
                    const connstate = hasState ? line[5] : "UNKNOWN";
                    let pidField = "";
                    if (line[line.length - 9].indexOf(":") >= 0) {
                      pidField = line[line.length - 9].split(":")[1];
                    } else {
                      pidField = line[pidPos + (hasState ? 0 : -1)];
                      if (pidField.indexOf(":") >= 0) {
                        pidField = pidField.split(":")[1];
                      }
                    }
                    const pid = parseInt(pidField, 10);
                    if (connstate) {
                      result2.push({
                        protocol: line[0],
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: connstate,
                        pid,
                        process: getProcessName(processes, pid)
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            }
          });
        }
        if (_windows) {
          let cmd = "netstat -nao";
          try {
            exec(cmd, util.execOptsWin, (error2, stdout) => {
              if (!error2) {
                let lines = stdout.toString().split(`\r
`);
                lines.forEach((line) => {
                  line = line.trim().replace(/ +/g, " ").split(" ");
                  if (line.length >= 4) {
                    let localip = line[1];
                    let localport = "";
                    const localaddress = line[1].split(":");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(":");
                    }
                    localip = localip.replace(/\[/g, "").replace(/\]/g, "");
                    let peerip = line[2];
                    let peerport = "";
                    const peeraddress = line[2].split(":");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(":");
                    }
                    peerip = peerip.replace(/\[/g, "").replace(/\]/g, "");
                    const pid = util.toInt(line[4]);
                    let connstate = line[3];
                    if (connstate === "HERGESTELLT") {
                      connstate = "ESTABLISHED";
                    }
                    if (connstate.startsWith("ABH")) {
                      connstate = "LISTEN";
                    }
                    if (connstate === "SCHLIESSEN_WARTEN") {
                      connstate = "CLOSE_WAIT";
                    }
                    if (connstate === "WARTEND") {
                      connstate = "TIME_WAIT";
                    }
                    if (connstate === "SYN_GESENDET") {
                      connstate = "SYN_SENT";
                    }
                    if (connstate === "LISTENING") {
                      connstate = "LISTEN";
                    }
                    if (connstate === "SYN_RECEIVED") {
                      connstate = "SYN_RECV";
                    }
                    if (connstate === "FIN_WAIT_1") {
                      connstate = "FIN_WAIT1";
                    }
                    if (connstate === "FIN_WAIT_2") {
                      connstate = "FIN_WAIT2";
                    }
                    if (line[0].toLowerCase() !== "udp" && connstate) {
                      result2.push({
                        protocol: line[0].toLowerCase(),
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: connstate,
                        pid,
                        process: ""
                      });
                    } else if (line[0].toLowerCase() === "udp") {
                      result2.push({
                        protocol: line[0].toLowerCase(),
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: "",
                        pid: parseInt(line[3], 10),
                        process: ""
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.networkConnections = networkConnections;
  function networkGatewayDefault(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = "";
        if (_linux || _freebsd || _openbsd || _netbsd) {
          const cmd = "ip route get 1";
          try {
            exec(cmd, { maxBuffer: 1024 * 102400 }, (error2, stdout) => {
              if (!error2) {
                let lines = stdout.toString().split(`
`);
                const line = lines && lines[0] ? lines[0] : "";
                let parts = line.split(" via ");
                if (parts && parts[1]) {
                  parts = parts[1].split(" ");
                  result2 = parts[0];
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_darwin) {
          let cmd = "route -n get default";
          try {
            exec(cmd, { maxBuffer: 1024 * 102400 }, (error2, stdout) => {
              if (!error2) {
                const lines = stdout.toString().split(`
`).map((line) => line.trim());
                result2 = util.getValue(lines, "gateway");
              }
              if (!result2) {
                cmd = "netstat -rn | awk '/default/ {print $2}'";
                exec(cmd, { maxBuffer: 1024 * 102400 }, (error3, stdout2) => {
                  const lines = stdout2.toString().split(`
`).map((line) => line.trim());
                  result2 = lines.find((line) => /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line));
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
        if (_windows) {
          try {
            exec("netstat -r", util.execOptsWin, (error2, stdout) => {
              const lines = stdout.toString().split(os.EOL);
              lines.forEach((line) => {
                line = line.replace(/\s+/g, " ").trim();
                if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
                  const parts = line.split(" ");
                  if (parts.length >= 5 && parts[parts.length - 3].indexOf(".") > -1) {
                    result2 = parts[parts.length - 3];
                  }
                }
              });
              if (!result2) {
                util.powerShell("Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq '0.0.0.0' -and $_.Mask -eq '0.0.0.0' }").then((data) => {
                  let lines2 = data.toString().split(`\r
`);
                  if (lines2.length > 1 && !result2) {
                    result2 = util.getValue(lines2, "NextHop");
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  }
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.networkGatewayDefault = networkGatewayDefault;
});

// node_modules/systeminformation/lib/wifi.js
var require_wifi = __commonJS((exports) => {
  var os = __require("os");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  function wifiDBFromQuality(quality) {
    const qual = parseFloat(quality);
    if (qual < 0) {
      return 0;
    }
    if (qual >= 100) {
      return -50;
    }
    return qual / 2 - 100;
  }
  function wifiQualityFromDB(db) {
    const result2 = 2 * (parseFloat(db) + 100);
    return result2 <= 100 ? result2 : 100;
  }
  var _wifi_frequencies = {
    1: 2412,
    2: 2417,
    3: 2422,
    4: 2427,
    5: 2432,
    6: 2437,
    7: 2442,
    8: 2447,
    9: 2452,
    10: 2457,
    11: 2462,
    12: 2467,
    13: 2472,
    14: 2484,
    32: 5160,
    34: 5170,
    36: 5180,
    38: 5190,
    40: 5200,
    42: 5210,
    44: 5220,
    46: 5230,
    48: 5240,
    50: 5250,
    52: 5260,
    54: 5270,
    56: 5280,
    58: 5290,
    60: 5300,
    62: 5310,
    64: 5320,
    68: 5340,
    96: 5480,
    100: 5500,
    102: 5510,
    104: 5520,
    106: 5530,
    108: 5540,
    110: 5550,
    112: 5560,
    114: 5570,
    116: 5580,
    118: 5590,
    120: 5600,
    122: 5610,
    124: 5620,
    126: 5630,
    128: 5640,
    132: 5660,
    134: 5670,
    136: 5680,
    138: 5690,
    140: 5700,
    142: 5710,
    144: 5720,
    149: 5745,
    151: 5755,
    153: 5765,
    155: 5775,
    157: 5785,
    159: 5795,
    161: 5805,
    165: 5825,
    169: 5845,
    173: 5865,
    183: 4915,
    184: 4920,
    185: 4925,
    187: 4935,
    188: 4940,
    189: 4945,
    192: 4960,
    196: 4980
  };
  function wifiFrequencyFromChannel(channel) {
    return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;
  }
  function wifiChannelFromFrequencs(frequency) {
    let channel = 0;
    for (let key in _wifi_frequencies) {
      if ({}.hasOwnProperty.call(_wifi_frequencies, key)) {
        if (_wifi_frequencies[key] === frequency) {
          channel = util.toInt(key);
        }
      }
    }
    return channel;
  }
  function ifaceListLinux() {
    const result2 = [];
    const cmd = "iw dev 2>/dev/null";
    try {
      const all = execSync(cmd, util.execOptsLinux).toString().split(`
`).map((line) => line.trim()).join(`
`);
      const parts = all.split(`
Interface `);
      parts.shift();
      parts.forEach((ifaceDetails) => {
        const lines = ifaceDetails.split(`
`);
        const iface = lines[0];
        const id = util.toInt(util.getValue(lines, "ifindex", " "));
        const mac = util.getValue(lines, "addr", " ");
        const channel = util.toInt(util.getValue(lines, "channel", " "));
        result2.push({
          id,
          iface,
          mac,
          channel
        });
      });
      return result2;
    } catch {
      try {
        const all = execSync("nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null", util.execOptsLinux).toString();
        const parts = all.split(`

`);
        let i = 1;
        parts.forEach((ifaceDetails) => {
          const lines = ifaceDetails.split(`
`);
          const iface = util.getValue(lines, "GENERAL.DEVICE");
          const type = util.getValue(lines, "GENERAL.TYPE");
          const id = i++;
          const mac = util.getValue(lines, "GENERAL.HWADDR");
          const channel = "";
          if (type.toLowerCase() === "wifi") {
            result2.push({
              id,
              iface,
              mac,
              channel
            });
          }
        });
        return result2;
      } catch {
        return [];
      }
    }
  }
  function nmiDeviceLinux(iface) {
    const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2> /dev/null`;
    try {
      const lines = execSync(cmd, util.execOptsLinux).toString().split(`
`);
      const ssid = util.getValue(lines, "GENERAL.CONNECTION");
      return {
        iface,
        type: util.getValue(lines, "GENERAL.TYPE"),
        vendor: util.getValue(lines, "GENERAL.VENDOR"),
        product: util.getValue(lines, "GENERAL.PRODUCT"),
        mac: util.getValue(lines, "GENERAL.HWADDR").toLowerCase(),
        ssid: ssid !== "--" ? ssid : null
      };
    } catch {
      return {};
    }
  }
  function nmiConnectionLinux(ssid) {
    const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;
    try {
      const lines = execSync(cmd, util.execOptsLinux).toString().split(`
`);
      const bssid = util.getValue(lines, "802-11-wireless.seen-bssids").toLowerCase();
      return {
        ssid: ssid !== "--" ? ssid : null,
        uuid: util.getValue(lines, "connection.uuid"),
        type: util.getValue(lines, "connection.type"),
        autoconnect: util.getValue(lines, "connection.autoconnect") === "yes",
        security: util.getValue(lines, "802-11-wireless-security.key-mgmt"),
        bssid: bssid !== "--" ? bssid : null
      };
    } catch {
      return {};
    }
  }
  function wpaConnectionLinux(iface) {
    if (!iface) {
      return {};
    }
    const cmd = `wpa_cli -i ${iface} status 2>&1`;
    try {
      const lines = execSync(cmd, util.execOptsLinux).toString().split(`
`);
      const freq = util.toInt(util.getValue(lines, "freq", "="));
      return {
        ssid: util.getValue(lines, "ssid", "="),
        uuid: util.getValue(lines, "uuid", "="),
        security: util.getValue(lines, "key_mgmt", "="),
        freq,
        channel: wifiChannelFromFrequencs(freq),
        bssid: util.getValue(lines, "bssid", "=").toLowerCase()
      };
    } catch {
      return {};
    }
  }
  function getWifiNetworkListNmi() {
    const result2 = [];
    const cmd = "nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null";
    try {
      const stdout = execSync(cmd, util.execOptsLinux);
      const parts = stdout.toString().split("ACTIVE:");
      parts.shift();
      parts.forEach((part) => {
        part = "ACTIVE:" + part;
        const lines = part.split(os.EOL);
        const channel = util.getValue(lines, "CHAN");
        const frequency = util.getValue(lines, "FREQ").toLowerCase().replace("mhz", "").trim();
        const security = util.getValue(lines, "SECURITY").replace("(", "").replace(")", "");
        const wpaFlags = util.getValue(lines, "WPA-FLAGS").replace("(", "").replace(")", "");
        const rsnFlags = util.getValue(lines, "RSN-FLAGS").replace("(", "").replace(")", "");
        const quality = util.getValue(lines, "SIGNAL");
        result2.push({
          ssid: util.getValue(lines, "SSID"),
          bssid: util.getValue(lines, "BSSID").toLowerCase(),
          mode: util.getValue(lines, "MODE"),
          channel: channel ? parseInt(channel, 10) : null,
          frequency: frequency ? parseInt(frequency, 10) : null,
          signalLevel: wifiDBFromQuality(quality),
          quality: quality ? parseInt(quality, 10) : null,
          security: security && security !== "none" ? security.split(" ") : [],
          wpaFlags: wpaFlags && wpaFlags !== "none" ? wpaFlags.split(" ") : [],
          rsnFlags: rsnFlags && rsnFlags !== "none" ? rsnFlags.split(" ") : []
        });
      });
      return result2;
    } catch {
      return [];
    }
  }
  function getWifiNetworkListIw(iface) {
    const result2 = [];
    try {
      let iwlistParts = execSync(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`, util.execOptsLinux).toString().split("        Cell ");
      if (iwlistParts[0].indexOf("resource busy") >= 0) {
        return -1;
      }
      if (iwlistParts.length > 1) {
        iwlistParts.shift();
        iwlistParts.forEach((element) => {
          const lines = element.split(`
`);
          const channel = util.getValue(lines, "channel", ":", true);
          const address = lines && lines.length && lines[0].indexOf("Address:") >= 0 ? lines[0].split("Address:")[1].trim().toLowerCase() : "";
          const mode = util.getValue(lines, "mode", ":", true);
          const frequency = util.getValue(lines, "frequency", ":", true);
          const qualityString = util.getValue(lines, "Quality", "=", true);
          const dbParts = qualityString.toLowerCase().split("signal level=");
          const db = dbParts.length > 1 ? util.toInt(dbParts[1]) : 0;
          const quality = db ? wifiQualityFromDB(db) : 0;
          const ssid = util.getValue(lines, "essid", ":", true);
          const isWpa = element.indexOf(" WPA ") >= 0;
          const isWpa2 = element.indexOf("WPA2 ") >= 0;
          const security = [];
          if (isWpa) {
            security.push("WPA");
          }
          if (isWpa2) {
            security.push("WPA2");
          }
          const wpaFlags = [];
          let wpaFlag = "";
          lines.forEach((line) => {
            const l = line.trim().toLowerCase();
            if (l.indexOf("group cipher") >= 0) {
              if (wpaFlag) {
                wpaFlags.push(wpaFlag);
              }
              const parts = l.split(":");
              if (parts.length > 1) {
                wpaFlag = parts[1].trim().toUpperCase();
              }
            }
            if (l.indexOf("pairwise cipher") >= 0) {
              const parts = l.split(":");
              if (parts.length > 1) {
                if (parts[1].indexOf("tkip")) {
                  wpaFlag = wpaFlag ? "TKIP/" + wpaFlag : "TKIP";
                } else if (parts[1].indexOf("ccmp")) {
                  wpaFlag = wpaFlag ? "CCMP/" + wpaFlag : "CCMP";
                } else if (parts[1].indexOf("proprietary")) {
                  wpaFlag = wpaFlag ? "PROP/" + wpaFlag : "PROP";
                }
              }
            }
            if (l.indexOf("authentication suites") >= 0) {
              const parts = l.split(":");
              if (parts.length > 1) {
                if (parts[1].indexOf("802.1x")) {
                  wpaFlag = wpaFlag ? "802.1x/" + wpaFlag : "802.1x";
                } else if (parts[1].indexOf("psk")) {
                  wpaFlag = wpaFlag ? "PSK/" + wpaFlag : "PSK";
                }
              }
            }
          });
          if (wpaFlag) {
            wpaFlags.push(wpaFlag);
          }
          result2.push({
            ssid,
            bssid: address,
            mode,
            channel: channel ? util.toInt(channel) : null,
            frequency: frequency ? util.toInt(frequency.replace(".", "")) : null,
            signalLevel: db,
            quality,
            security,
            wpaFlags,
            rsnFlags: []
          });
        });
      }
      return result2;
    } catch {
      return -1;
    }
  }
  function parseWifiDarwin(wifiStr) {
    const result2 = [];
    try {
      let wifiObj = JSON.parse(wifiStr);
      wifiObj = wifiObj.SPAirPortDataType[0].spairport_airport_interfaces[0].spairport_airport_other_local_wireless_networks;
      wifiObj.forEach((wifiItem) => {
        const security = [];
        const sm = wifiItem.spairport_security_mode || "";
        if (sm === "spairport_security_mode_wep") {
          security.push("WEP");
        } else if (sm === "spairport_security_mode_wpa2_personal") {
          security.push("WPA2");
        } else if (sm.startsWith("spairport_security_mode_wpa2_enterprise")) {
          security.push("WPA2 EAP");
        } else if (sm.startsWith("pairport_security_mode_wpa3_transition")) {
          security.push("WPA2/WPA3");
        } else if (sm.startsWith("pairport_security_mode_wpa3")) {
          security.push("WPA3");
        }
        const channel = parseInt(("" + wifiItem.spairport_network_channel).split(" ")[0]) || 0;
        const signalLevel = wifiItem.spairport_signal_noise || null;
        result2.push({
          ssid: wifiItem._name || "",
          bssid: wifiItem.spairport_network_bssid || null,
          mode: wifiItem.spairport_network_phymode,
          channel,
          frequency: wifiFrequencyFromChannel(channel),
          signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
          quality: wifiQualityFromDB(signalLevel),
          security,
          wpaFlags: [],
          rsnFlags: []
        });
      });
      return result2;
    } catch {
      return result2;
    }
  }
  function wifiNetworks(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = [];
        if (_linux) {
          result2 = getWifiNetworkListNmi();
          if (result2.length === 0) {
            try {
              const iwconfigParts = execSync("export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL", util.execOptsLinux).toString().split(`

`);
              let iface = "";
              iwconfigParts.forEach((element) => {
                if (element.indexOf("no wireless") === -1 && element.trim() !== "") {
                  iface = element.split(" ")[0];
                }
              });
              if (iface) {
                let ifaceSanitized = "";
                const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface, true);
                const l = util.mathMin(s.length, 2000);
                for (let i = 0;i <= l; i++) {
                  if (s[i] !== undefined) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                const res = getWifiNetworkListIw(ifaceSanitized);
                if (res === -1) {
                  setTimeout((iface2) => {
                    const res2 = getWifiNetworkListIw(iface2);
                    if (res2 !== -1) {
                      result2 = res2;
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  }, 4000);
                } else {
                  result2 = res;
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } catch {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } else if (_darwin) {
          const cmd = "system_profiler SPAirPortDataType -json 2>/dev/null";
          exec(cmd, { maxBuffer: 1024 * 40000 }, (error2, stdout) => {
            result2 = parseWifiDarwin(stdout.toString());
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else if (_windows) {
          const cmd = "netsh wlan show networks mode=Bssid";
          util.powerShell(cmd).then((stdout) => {
            const ssidParts = stdout.toString("utf8").split(os.EOL + os.EOL + "SSID ");
            ssidParts.shift();
            ssidParts.forEach((ssidPart) => {
              const ssidLines = ssidPart.split(os.EOL);
              if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(":") >= 0) {
                const bssidsParts = ssidPart.split(" BSSID");
                bssidsParts.shift();
                bssidsParts.forEach((bssidPart) => {
                  const bssidLines = bssidPart.split(os.EOL);
                  const bssidLine = bssidLines[0].split(":");
                  bssidLine.shift();
                  const bssid = bssidLine.join(":").trim().toLowerCase();
                  const channel = bssidLines[3].split(":").pop().trim();
                  const quality = bssidLines[1].split(":").pop().trim();
                  result2.push({
                    ssid: ssidLines[0].split(":").pop().trim(),
                    bssid,
                    mode: "",
                    channel: channel ? parseInt(channel, 10) : null,
                    frequency: wifiFrequencyFromChannel(channel),
                    signalLevel: wifiDBFromQuality(quality),
                    quality: quality ? parseInt(quality, 10) : null,
                    security: [ssidLines[2].split(":").pop().trim()],
                    wpaFlags: [ssidLines[3].split(":").pop().trim()],
                    rsnFlags: []
                  });
                });
              }
            });
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.wifiNetworks = wifiNetworks;
  function getVendor(model) {
    model = model.toLowerCase();
    let result2 = "";
    if (model.indexOf("intel") >= 0) {
      result2 = "Intel";
    } else if (model.indexOf("realtek") >= 0) {
      result2 = "Realtek";
    } else if (model.indexOf("qualcom") >= 0) {
      result2 = "Qualcom";
    } else if (model.indexOf("broadcom") >= 0) {
      result2 = "Broadcom";
    } else if (model.indexOf("cavium") >= 0) {
      result2 = "Cavium";
    } else if (model.indexOf("cisco") >= 0) {
      result2 = "Cisco";
    } else if (model.indexOf("marvel") >= 0) {
      result2 = "Marvel";
    } else if (model.indexOf("zyxel") >= 0) {
      result2 = "Zyxel";
    } else if (model.indexOf("melanox") >= 0) {
      result2 = "Melanox";
    } else if (model.indexOf("d-link") >= 0) {
      result2 = "D-Link";
    } else if (model.indexOf("tp-link") >= 0) {
      result2 = "TP-Link";
    } else if (model.indexOf("asus") >= 0) {
      result2 = "Asus";
    } else if (model.indexOf("linksys") >= 0) {
      result2 = "Linksys";
    }
    return result2;
  }
  function wifiConnections(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result2 = [];
        if (_linux) {
          const ifaces = ifaceListLinux();
          const networkList = getWifiNetworkListNmi();
          ifaces.forEach((ifaceDetail) => {
            let ifaceSanitized = "";
            const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(ifaceDetail.iface, true);
            const ll = util.mathMin(s.length, 2000);
            for (let i = 0;i <= ll; i++) {
              if (s[i] !== undefined) {
                ifaceSanitized = ifaceSanitized + s[i];
              }
            }
            const nmiDetails = nmiDeviceLinux(ifaceSanitized);
            const wpaDetails = wpaConnectionLinux(ifaceSanitized);
            const ssid = nmiDetails.ssid || wpaDetails.ssid;
            const network = networkList.filter((nw) => nw.ssid === ssid);
            let ssidSanitized = "";
            const t = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(ssid, true);
            const l = util.mathMin(t.length, 32);
            for (let i = 0;i <= l; i++) {
              if (t[i] !== undefined) {
                ssidSanitized = ssidSanitized + t[i];
              }
            }
            const nmiConnection = nmiConnectionLinux(ssidSanitized);
            const channel = network && network.length && network[0].channel ? network[0].channel : wpaDetails.channel ? wpaDetails.channel : null;
            const bssid = network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null;
            const signalLevel = network && network.length && network[0].signalLevel ? network[0].signalLevel : null;
            if (ssid && bssid) {
              result2.push({
                id: ifaceDetail.id,
                iface: ifaceDetail.iface,
                model: nmiDetails.product,
                ssid,
                bssid: network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null,
                channel,
                frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                type: nmiConnection.type ? nmiConnection.type : "802.11",
                security: nmiConnection.security ? nmiConnection.security : wpaDetails.security ? wpaDetails.security : null,
                signalLevel,
                quality: wifiQualityFromDB(signalLevel),
                txRate: null
              });
            }
          });
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        } else if (_darwin) {
          const cmd = 'system_profiler SPNetworkDataType SPAirPortDataType -xml 2>/dev/null; echo "######" ; ioreg -n AppleBCMWLANSkywalkInterface -r 2>/dev/null';
          exec(cmd, (error2, stdout) => {
            try {
              const parts = stdout.toString().split("######");
              const profilerObj = util.plistParser(parts[0]);
              const networkObj = profilerObj[0]._SPCommandLineArguments.indexOf("SPNetworkDataType") >= 0 ? profilerObj[0]._items : profilerObj[1]._items;
              const airportObj = profilerObj[0]._SPCommandLineArguments.indexOf("SPAirPortDataType") >= 0 ? profilerObj[0]._items[0].spairport_airport_interfaces : profilerObj[1]._items[0].spairport_airport_interfaces;
              let lines3 = [];
              if (parts[1].indexOf("  | {") > 0 && parts[1].indexOf("  | }") > parts[1].indexOf("  | {")) {
                lines3 = parts[1].split("  | {")[1].split("  | }")[0].replace(/ \| /g, "").replace(/"/g, "").split(`
`);
              }
              const networkWifiObj = networkObj.find((item) => {
                return item._name === "Wi-Fi";
              });
              const airportWifiObj = airportObj[0].spairport_current_network_information;
              const channel = parseInt(("" + airportWifiObj.spairport_network_channel).split(" ")[0], 10) || 0;
              const signalLevel = airportWifiObj.spairport_signal_noise || null;
              const security = [];
              const sm = airportWifiObj.spairport_security_mode || "";
              if (sm === "spairport_security_mode_wep") {
                security.push("WEP");
              } else if (sm === "spairport_security_mode_wpa2_personal") {
                security.push("WPA2");
              } else if (sm.startsWith("spairport_security_mode_wpa2_enterprise")) {
                security.push("WPA2 EAP");
              } else if (sm.startsWith("pairport_security_mode_wpa3_transition")) {
                security.push("WPA2/WPA3");
              } else if (sm.startsWith("pairport_security_mode_wpa3")) {
                security.push("WPA3");
              }
              result2.push({
                id: networkWifiObj._name || "Wi-Fi",
                iface: networkWifiObj.interface || "",
                model: networkWifiObj.hardware || "",
                ssid: (airportWifiObj._name || "").replace("&lt;", "<").replace("&gt;", ">"),
                bssid: airportWifiObj.spairport_network_bssid || "",
                channel,
                frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                type: airportWifiObj.spairport_network_phymode || "802.11",
                security,
                signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
                quality: wifiQualityFromDB(signalLevel),
                txRate: airportWifiObj.spairport_network_rate || null
              });
            } catch {
              util.noop();
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else if (_windows) {
          const cmd = "netsh wlan show interfaces";
          util.powerShell(cmd).then((stdout) => {
            const allLines = stdout.toString().split(`\r
`);
            for (let i = 0;i < allLines.length; i++) {
              allLines[i] = allLines[i].trim();
            }
            const parts = allLines.join(`\r
`).split(`:\r
\r
`);
            parts.shift();
            parts.forEach((part) => {
              const lines = part.split(`\r
`);
              if (lines.length >= 5) {
                const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                const ssid = util.getValue(lines, "SSID", ":", true);
                const bssid = util.getValue(lines, "BSSID", ":", true) || util.getValue(lines, "AP BSSID", ":", true);
                const quality = util.getValue(lines, "Signal", ":", true);
                const signalLevel = wifiDBFromQuality(quality);
                const type = util.getValue(lines, "Radio type", ":", true) || util.getValue(lines, "Type de radio", ":", true) || util.getValue(lines, "Funktyp", ":", true) || null;
                const security = util.getValue(lines, "authentication", ":", true) || util.getValue(lines, "Authentification", ":", true) || util.getValue(lines, "Authentifizierung", ":", true) || null;
                const channel = util.getValue(lines, "Channel", ":", true) || util.getValue(lines, "Canal", ":", true) || util.getValue(lines, "Kanal", ":", true) || null;
                const txRate = util.getValue(lines, "Transmit rate (mbps)", ":", true) || util.getValue(lines, "Transmission (mbit/s)", ":", true) || util.getValue(lines, "Empfangsrate (MBit/s)", ":", true) || null;
                if (model && id && ssid && bssid) {
                  result2.push({
                    id,
                    iface,
                    model,
                    ssid,
                    bssid,
                    channel: util.toInt(channel),
                    frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                    type,
                    security,
                    signalLevel,
                    quality: quality ? parseInt(quality, 10) : null,
                    txRate: util.toInt(txRate) || null
                  });
                }
              }
            });
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.wifiConnections = wifiConnections;
  function wifiInterfaces(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result2 = [];
        if (_linux) {
          const ifaces = ifaceListLinux();
          ifaces.forEach((ifaceDetail) => {
            const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);
            result2.push({
              id: ifaceDetail.id,
              iface: ifaceDetail.iface,
              model: nmiDetails.product ? nmiDetails.product : null,
              vendor: nmiDetails.vendor ? nmiDetails.vendor : null,
              mac: ifaceDetail.mac
            });
          });
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        } else if (_darwin) {
          const cmd = "system_profiler SPNetworkDataType";
          exec(cmd, (error2, stdout) => {
            const parts1 = stdout.toString().split(`

    Wi-Fi:

`);
            if (parts1.length > 1) {
              const lines = parts1[1].split(`

`)[0].split(`
`);
              const iface = util.getValue(lines, "BSD Device Name", ":", true);
              const mac = util.getValue(lines, "MAC Address", ":", true);
              const model = util.getValue(lines, "hardware", ":", true);
              result2.push({
                id: "Wi-Fi",
                iface,
                model,
                vendor: "",
                mac
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else if (_windows) {
          const cmd = "netsh wlan show interfaces";
          util.powerShell(cmd).then((stdout) => {
            const allLines = stdout.toString().split(`\r
`);
            for (let i = 0;i < allLines.length; i++) {
              allLines[i] = allLines[i].trim();
            }
            const parts = allLines.join(`\r
`).split(`:\r
\r
`);
            parts.shift();
            parts.forEach((part) => {
              const lines = part.split(`\r
`);
              if (lines.length >= 5) {
                const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                const macParts = lines[3].indexOf(":") >= 0 ? lines[3].split(":") : [];
                macParts.shift();
                const mac = macParts.join(":").trim();
                const vendor = getVendor(model);
                if (iface && model && id && mac) {
                  result2.push({
                    id,
                    iface,
                    model,
                    vendor,
                    mac
                  });
                }
              }
            });
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.wifiInterfaces = wifiInterfaces;
});

// node_modules/systeminformation/lib/processes.js
var require_processes = __commonJS((exports) => {
  var os = __require("os");
  var fs = __require("fs");
  var path = __require("path");
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var _processes_cpu = {
    all: 0,
    all_utime: 0,
    all_stime: 0,
    list: {},
    ms: 0,
    result: {}
  };
  var _services_cpu = {
    all: 0,
    all_utime: 0,
    all_stime: 0,
    list: {},
    ms: 0,
    result: {}
  };
  var _process_cpu = {
    all: 0,
    all_utime: 0,
    all_stime: 0,
    list: {},
    ms: 0,
    result: {}
  };
  var _winStatusValues = {
    0: "unknown",
    1: "other",
    2: "ready",
    3: "running",
    4: "blocked",
    5: "suspended blocked",
    6: "suspended ready",
    7: "terminated",
    8: "stopped",
    9: "growing"
  };
  function parseTimeUnix(time) {
    let result2 = time;
    let parts = time.replace(/ +/g, " ").split(" ");
    if (parts.length === 5) {
      result2 = parts[4] + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + parts[2]).slice(-2) + " " + parts[3];
    }
    return result2;
  }
  function parseElapsedTime(etime) {
    let current = new Date;
    current = new Date(current.getTime() - current.getTimezoneOffset() * 60000);
    const elapsed = etime.split("-");
    const timeIndex = elapsed.length - 1;
    const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;
    const timeStr = elapsed[timeIndex].split(":");
    const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;
    const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);
    const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);
    const ms = (((days * 24 + hours) * 60 + mins) * 60 + secs) * 1000;
    let res = new Date(current.getTime());
    let result2 = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
    try {
      res = new Date(current.getTime() - ms);
      result2 = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
    } catch (e) {
      util.noop();
    }
    return result2;
  }
  function services(srv, callback) {
    if (util.isFunction(srv) && !callback) {
      callback = srv;
      srv = "";
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (typeof srv !== "string") {
          if (callback) {
            callback([]);
          }
          return resolve([]);
        }
        if (srv) {
          let srvString = "";
          try {
            srvString.__proto__.toLowerCase = util.stringToLower;
            srvString.__proto__.replace = util.stringReplace;
            srvString.__proto__.toString = util.stringToString;
            srvString.__proto__.substr = util.stringSubstr;
            srvString.__proto__.substring = util.stringSubstring;
            srvString.__proto__.trim = util.stringTrim;
            srvString.__proto__.startsWith = util.stringStartWith;
          } catch (e) {
            Object.setPrototypeOf(srvString, util.stringObj);
          }
          const s = util.sanitizeShellString(srv);
          const l = util.mathMin(s.length, 2000);
          for (let i = 0;i <= l; i++) {
            if (s[i] !== undefined) {
              srvString = srvString + s[i];
            }
          }
          srvString = srvString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
          if (srvString === "") {
            srvString = "*";
          }
          if (util.isPrototypePolluted() && srvString !== "*") {
            srvString = "------";
          }
          let srvs = srvString.split("|");
          let result2 = [];
          let dataSrv = [];
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === "*") {
              try {
                const tmpsrv = execSync("systemctl --all --type=service --no-legend 2> /dev/null", util.execOptsLinux).toString().split(`
`);
                srvs = [];
                for (const s2 of tmpsrv) {
                  const name = s2.split(".service")[0];
                  if (name && s2.indexOf(" not-found ") === -1) {
                    srvs.push(name.trim());
                  }
                }
                srvString = srvs.join("|");
              } catch (d) {
                try {
                  srvString = "";
                  const tmpsrv = execSync("service --status-all 2> /dev/null", util.execOptsLinux).toString().split(`
`);
                  for (const s2 of tmpsrv) {
                    const parts = s2.split("]");
                    if (parts.length === 2) {
                      srvString += (srvString !== "" ? "|" : "") + parts[1].trim();
                    }
                  }
                  srvs = srvString.split("|");
                } catch (e) {
                  try {
                    const srvStr = execSync("ls /etc/init.d/ -m 2> /dev/null", util.execOptsLinux).toString().split(`
`).join("");
                    srvString = "";
                    if (srvStr) {
                      const tmpsrv = srvStr.split(",");
                      for (const s2 of tmpsrv) {
                        const name = s2.trim();
                        if (name) {
                          srvString += (srvString !== "" ? "|" : "") + name;
                        }
                      }
                      srvs = srvString.split("|");
                    }
                  } catch (f) {
                    srvString = "";
                    srvs = [];
                  }
                }
              }
            }
            if (_darwin && srvString === "*") {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
            let args = _darwin ? ["-caxo", "pcpu,pmem,pid,command"] : ["-axo", "pcpu,pmem,pid,command"];
            if (srvString !== "" && srvs.length > 0) {
              util.execSafe("ps", args).then((stdout) => {
                if (stdout) {
                  let lines = stdout.replace(/ +/g, " ").replace(/,+/g, ".").split(`
`);
                  srvs.forEach(function(srv2) {
                    let ps;
                    if (_darwin) {
                      ps = lines.filter(function(e) {
                        return e.toLowerCase().indexOf(srv2) !== -1;
                      });
                    } else {
                      ps = lines.filter(function(e) {
                        return e.toLowerCase().indexOf(" " + srv2.toLowerCase() + ":") !== -1 || e.toLowerCase().indexOf("(" + srv2.toLowerCase() + " ") !== -1 || e.toLowerCase().indexOf("(" + srv2.toLowerCase() + ")") !== -1 || e.toLowerCase().indexOf(" " + srv2.toLowerCase().replace(/[0-9.]/g, "") + ":") !== -1 || e.toLowerCase().indexOf("/" + srv2.toLowerCase()) !== -1;
                      });
                    }
                    const pids = [];
                    for (const p of ps) {
                      const pid = p.trim().split(" ")[2];
                      if (pid) {
                        pids.push(parseInt(pid, 10));
                      }
                    }
                    result2.push({
                      name: srv2,
                      running: ps.length > 0,
                      startmode: "",
                      pids,
                      cpu: parseFloat(ps.reduce(function(pv, cv) {
                        return pv + parseFloat(cv.trim().split(" ")[0]);
                      }, 0).toFixed(2)),
                      mem: parseFloat(ps.reduce(function(pv, cv) {
                        return pv + parseFloat(cv.trim().split(" ")[1]);
                      }, 0).toFixed(2))
                    });
                  });
                  if (_linux) {
                    let cmd = 'cat /proc/stat | grep "cpu "';
                    for (let i in result2) {
                      for (let j in result2[i].pids) {
                        cmd += ";cat /proc/" + result2[i].pids[j] + "/stat";
                      }
                    }
                    exec(cmd, { maxBuffer: 1024 * 102400 }, function(error2, stdout2) {
                      let curr_processes = stdout2.toString().split(`
`);
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      curr_processes.forEach((element) => {
                        resultProcess = calcProcStatLinux(element, all, _services_cpu);
                        if (resultProcess.pid) {
                          let listPos = -1;
                          for (let i in result2) {
                            for (let j in result2[i].pids) {
                              if (parseInt(result2[i].pids[j]) === parseInt(resultProcess.pid)) {
                                listPos = i;
                              }
                            }
                          }
                          if (listPos >= 0) {
                            result2[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                          }
                          list_new[resultProcess.pid] = {
                            cpuu: resultProcess.cpuu,
                            cpus: resultProcess.cpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      });
                      _services_cpu.all = all;
                      _services_cpu.list = Object.assign({}, list_new);
                      _services_cpu.ms = Date.now() - _services_cpu.ms;
                      _services_cpu.result = Object.assign({}, result2);
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    });
                  } else {
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  }
                } else {
                  args = ["-o", "comm"];
                  util.execSafe("ps", args).then((stdout2) => {
                    if (stdout2) {
                      let lines = stdout2.replace(/ +/g, " ").replace(/,+/g, ".").split(`
`);
                      srvs.forEach(function(srv2) {
                        let ps = lines.filter(function(e) {
                          return e.indexOf(srv2) !== -1;
                        });
                        result2.push({
                          name: srv2,
                          running: ps.length > 0,
                          startmode: "",
                          cpu: 0,
                          mem: 0
                        });
                      });
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    } else {
                      srvs.forEach(function(srv2) {
                        result2.push({
                          name: srv2,
                          running: false,
                          startmode: "",
                          cpu: 0,
                          mem: 0
                        });
                      });
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    }
                  });
                }
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          }
          if (_windows) {
            try {
              let wincommand = "Get-CimInstance Win32_Service";
              if (srvs[0] !== "*") {
                wincommand += ' -Filter "';
                srvs.forEach((srv2) => {
                  wincommand += `Name='${srv2}' or `;
                });
                wincommand = `${wincommand.slice(0, -4)}"`;
              }
              wincommand += " | select Name,Caption,Started,StartMode,ProcessId | fl";
              util.powerShell(wincommand).then((stdout, error2) => {
                if (!error2) {
                  let serviceSections = stdout.split(/\n\s*\n/);
                  serviceSections.forEach((element) => {
                    if (element.trim() !== "") {
                      let lines = element.trim().split(`\r
`);
                      let srvName = util.getValue(lines, "Name", ":", true).toLowerCase();
                      let srvCaption = util.getValue(lines, "Caption", ":", true).toLowerCase();
                      let started = util.getValue(lines, "Started", ":", true);
                      let startMode = util.getValue(lines, "StartMode", ":", true);
                      let pid = util.getValue(lines, "ProcessId", ":", true);
                      if (srvString === "*" || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {
                        result2.push({
                          name: srvName,
                          running: started.toLowerCase() === "true",
                          startmode: startMode,
                          pids: [pid],
                          cpu: 0,
                          mem: 0
                        });
                        dataSrv.push(srvName);
                        dataSrv.push(srvCaption);
                      }
                    }
                  });
                  if (srvString !== "*") {
                    const srvsMissing = srvs.filter((e) => dataSrv.indexOf(e) === -1);
                    srvsMissing.forEach((srvName) => {
                      result2.push({
                        name: srvName,
                        running: false,
                        startmode: "",
                        pids: [],
                        cpu: 0,
                        mem: 0
                      });
                    });
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                } else {
                  srvs.forEach((srvName) => {
                    result2.push({
                      name: srvName,
                      running: false,
                      startmode: "",
                      cpu: 0,
                      mem: 0
                    });
                  });
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              });
            } catch {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          }
        } else {
          if (callback) {
            callback([]);
          }
          resolve([]);
        }
      });
    });
  }
  exports.services = services;
  function parseProcStat(line) {
    const parts = line.replace(/ +/g, " ").split(" ");
    const user = parts.length >= 2 ? parseInt(parts[1]) : 0;
    const nice = parts.length >= 3 ? parseInt(parts[2]) : 0;
    const system = parts.length >= 4 ? parseInt(parts[3]) : 0;
    const idle = parts.length >= 5 ? parseInt(parts[4]) : 0;
    const iowait = parts.length >= 6 ? parseInt(parts[5]) : 0;
    const irq = parts.length >= 7 ? parseInt(parts[6]) : 0;
    const softirq = parts.length >= 8 ? parseInt(parts[7]) : 0;
    const steal = parts.length >= 9 ? parseInt(parts[8]) : 0;
    const guest = parts.length >= 10 ? parseInt(parts[9]) : 0;
    const guest_nice = parts.length >= 11 ? parseInt(parts[10]) : 0;
    return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
  }
  function calcProcStatLinux(line, all, _cpu_old) {
    let statparts = line.replace(/ +/g, " ").split(")");
    if (statparts.length >= 2) {
      let parts = statparts[1].split(" ");
      if (parts.length >= 16) {
        let pid = parseInt(statparts[0].split(" ")[0]);
        let utime = parseInt(parts[12]);
        let stime = parseInt(parts[13]);
        let cutime = parseInt(parts[14]);
        let cstime = parseInt(parts[15]);
        let cpuu = 0;
        let cpus = 0;
        if (_cpu_old.all > 0 && _cpu_old.list[pid]) {
          cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100;
          cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100;
        } else {
          cpuu = (utime + cutime) / all * 100;
          cpus = (stime + cstime) / all * 100;
        }
        return {
          pid,
          utime,
          stime,
          cutime,
          cstime,
          cpuu,
          cpus
        };
      } else {
        return {
          pid: 0,
          utime: 0,
          stime: 0,
          cutime: 0,
          cstime: 0,
          cpuu: 0,
          cpus: 0
        };
      }
    } else {
      return {
        pid: 0,
        utime: 0,
        stime: 0,
        cutime: 0,
        cstime: 0,
        cpuu: 0,
        cpus: 0
      };
    }
  }
  function calcProcStatWin(procStat, all, _cpu_old) {
    let cpuu = 0;
    let cpus = 0;
    if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {
      cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100;
      cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100;
    } else {
      cpuu = procStat.utime / all * 100;
      cpus = procStat.stime / all * 100;
    }
    return {
      pid: procStat.pid,
      utime: procStat.utime,
      stime: procStat.stime,
      cpuu: cpuu > 0 ? cpuu : 0,
      cpus: cpus > 0 ? cpus : 0
    };
  }
  function processes(callback) {
    let parsedhead = [];
    function getName(command) {
      command = command || "";
      let result2 = command.split(" ")[0];
      if (result2.substr(-1) === ":") {
        result2 = result2.substr(0, result2.length - 1);
      }
      if (result2.substr(0, 1) !== "[") {
        let parts = result2.split("/");
        if (isNaN(parseInt(parts[parts.length - 1]))) {
          result2 = parts[parts.length - 1];
        } else {
          result2 = parts[0];
        }
      }
      return result2;
    }
    function parseLine(line) {
      let offset = 0;
      let offset2 = 0;
      function checkColumn(i) {
        offset = offset2;
        if (parsedhead[i]) {
          offset2 = line.substring(parsedhead[i].to + offset, 1e4).indexOf(" ");
        } else {
          offset2 = 1e4;
        }
      }
      checkColumn(0);
      const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));
      checkColumn(1);
      const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));
      checkColumn(2);
      const cpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, "."));
      checkColumn(3);
      const mem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, "."));
      checkColumn(4);
      const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));
      checkColumn(5);
      const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));
      checkColumn(6);
      const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));
      checkColumn(7);
      const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;
      checkColumn(8);
      const started = !_sunos ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());
      checkColumn(9);
      let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();
      state = state[0] === "R" ? "running" : state[0] === "S" ? "sleeping" : state[0] === "T" ? "stopped" : state[0] === "W" ? "paging" : state[0] === "X" ? "dead" : state[0] === "Z" ? "zombie" : state[0] === "D" || state[0] === "U" ? "blocked" : "unknown";
      checkColumn(10);
      let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();
      if (tty === "?" || tty === "??") {
        tty = "";
      }
      checkColumn(11);
      const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();
      checkColumn(12);
      let cmdPath = "";
      let command = "";
      let params = "";
      let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();
      if (fullcommand.substr(fullcommand.length - 1) === "]") {
        fullcommand = fullcommand.slice(0, -1);
      }
      if (fullcommand.substr(0, 1) === "[") {
        command = fullcommand.substring(1);
      } else {
        const p1 = fullcommand.indexOf("(");
        const p2 = fullcommand.indexOf(")");
        const p3 = fullcommand.indexOf("/");
        const p4 = fullcommand.indexOf(":");
        if (p1 < p2 && p1 < p3 && p3 < p2) {
          command = fullcommand.split(" ")[0];
          command = command.replace(/:/g, "");
        } else {
          if (p4 > 0 && (p3 === -1 || p3 > 3)) {
            command = fullcommand.split(" ")[0];
            command = command.replace(/:/g, "");
          } else {
            let firstParamPos = fullcommand.indexOf(" -");
            let firstParamPathPos = fullcommand.indexOf(" /");
            firstParamPos = firstParamPos >= 0 ? firstParamPos : 1e4;
            firstParamPathPos = firstParamPathPos >= 0 ? firstParamPathPos : 1e4;
            const firstPos = Math.min(firstParamPos, firstParamPathPos);
            let tmpCommand = fullcommand.substr(0, firstPos);
            const tmpParams = fullcommand.substr(firstPos);
            const lastSlashPos = tmpCommand.lastIndexOf("/");
            if (lastSlashPos >= 0) {
              cmdPath = tmpCommand.substr(0, lastSlashPos);
              tmpCommand = tmpCommand.substr(lastSlashPos + 1);
            }
            if (firstPos === 1e4 && tmpCommand.indexOf(" ") > -1) {
              const parts = tmpCommand.split(" ");
              if (fs.existsSync(path.join(cmdPath, parts[0]))) {
                command = parts.shift();
                params = (parts.join(" ") + " " + tmpParams).trim();
              } else {
                command = tmpCommand.trim();
                params = tmpParams.trim();
              }
            } else {
              command = tmpCommand.trim();
              params = tmpParams.trim();
            }
          }
        }
      }
      return {
        pid,
        parentPid: ppid,
        name: _linux ? getName(command) : command,
        cpu,
        cpuu: 0,
        cpus: 0,
        mem,
        priority,
        memVsz: vsz,
        memRss: rss,
        nice,
        started,
        state,
        tty,
        user,
        command,
        params,
        path: cmdPath
      };
    }
    function parseProcesses(lines) {
      let result2 = [];
      if (lines.length > 1) {
        let head = lines[0];
        parsedhead = util.parseHead(head, 8);
        lines.shift();
        lines.forEach((line) => {
          if (line.trim() !== "") {
            result2.push(parseLine(line));
          }
        });
      }
      return result2;
    }
    function parseProcesses2(lines) {
      function formatDateTime(time) {
        const month = ("0" + (time.getMonth() + 1).toString()).slice(-2);
        const year = time.getFullYear().toString();
        const day = ("0" + time.getDate().toString()).slice(-2);
        const hours = ("0" + time.getHours().toString()).slice(-2);
        const mins = ("0" + time.getMinutes().toString()).slice(-2);
        const secs = ("0" + time.getSeconds().toString()).slice(-2);
        return year + "-" + month + "-" + day + " " + hours + ":" + mins + ":" + secs;
      }
      function parseElapsed(etime) {
        let started = "";
        if (etime.indexOf("d") >= 0) {
          const elapsed_parts = etime.split("d");
          started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1000));
        } else if (etime.indexOf("h") >= 0) {
          const elapsed_parts = etime.split("h");
          started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1000));
        } else if (etime.indexOf(":") >= 0) {
          const elapsed_parts = etime.split(":");
          started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1000 : elapsed_parts[0] * 1000)));
        }
        return started;
      }
      let result2 = [];
      lines.forEach((line) => {
        if (line.trim() !== "") {
          line = line.trim().replace(/ +/g, " ").replace(/,+/g, ".");
          const parts = line.split(" ");
          const command = parts.slice(9).join(" ");
          const pmem = parseFloat((1 * parseInt(parts[3]) * 1024 / os.totalmem()).toFixed(1));
          const started = parseElapsed(parts[5]);
          result2.push({
            pid: parseInt(parts[0]),
            parentPid: parseInt(parts[1]),
            name: getName(command),
            cpu: 0,
            cpuu: 0,
            cpus: 0,
            mem: pmem,
            priority: 0,
            memVsz: parseInt(parts[2]),
            memRss: parseInt(parts[3]),
            nice: parseInt(parts[4]),
            started,
            state: parts[6] === "R" ? "running" : parts[6] === "S" ? "sleeping" : parts[6] === "T" ? "stopped" : parts[6] === "W" ? "paging" : parts[6] === "X" ? "dead" : parts[6] === "Z" ? "zombie" : parts[6] === "D" || parts[6] === "U" ? "blocked" : "unknown",
            tty: parts[7],
            user: parts[8],
            command
          });
        }
      });
      return result2;
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          all: 0,
          running: 0,
          blocked: 0,
          sleeping: 0,
          unknown: 0,
          list: []
        };
        let cmd = "";
        if (_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500 || _processes_cpu.ms === 0) {
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
            if (_linux) {
              cmd = "export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL";
            }
            if (_freebsd || _openbsd || _netbsd) {
              cmd = "export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL";
            }
            if (_darwin) {
              cmd = "ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r";
            }
            if (_sunos) {
              cmd = "ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm";
            }
            try {
              exec(cmd, { maxBuffer: 1024 * 102400 }, (error2, stdout) => {
                if (!error2 && stdout.toString().trim()) {
                  result2.list = parseProcesses(stdout.toString().split(`
`)).slice();
                  result2.all = result2.list.length;
                  result2.running = result2.list.filter((e) => {
                    return e.state === "running";
                  }).length;
                  result2.blocked = result2.list.filter((e) => {
                    return e.state === "blocked";
                  }).length;
                  result2.sleeping = result2.list.filter((e) => {
                    return e.state === "sleeping";
                  }).length;
                  if (_linux) {
                    cmd = 'cat /proc/stat | grep "cpu "';
                    result2.list.forEach((element) => {
                      cmd += ";cat /proc/" + element.pid + "/stat";
                    });
                    exec(cmd, { maxBuffer: 1024 * 102400 }, (error3, stdout2) => {
                      let curr_processes = stdout2.toString().split(`
`);
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      curr_processes.forEach((element) => {
                        resultProcess = calcProcStatLinux(element, all, _processes_cpu);
                        if (resultProcess.pid) {
                          let listPos = result2.list.map((e) => {
                            return e.pid;
                          }).indexOf(resultProcess.pid);
                          if (listPos >= 0) {
                            result2.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                            result2.list[listPos].cpuu = resultProcess.cpuu;
                            result2.list[listPos].cpus = resultProcess.cpus;
                          }
                          list_new[resultProcess.pid] = {
                            cpuu: resultProcess.cpuu,
                            cpus: resultProcess.cpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      });
                      _processes_cpu.all = all;
                      _processes_cpu.list = Object.assign({}, list_new);
                      _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                      _processes_cpu.result = Object.assign({}, result2);
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    });
                  } else {
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  }
                } else {
                  cmd = "ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm";
                  if (_sunos) {
                    cmd = "ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm";
                  }
                  exec(cmd, { maxBuffer: 1024 * 102400 }, (error3, stdout2) => {
                    if (!error3) {
                      let lines = stdout2.toString().split(`
`);
                      lines.shift();
                      result2.list = parseProcesses2(lines).slice();
                      result2.all = result2.list.length;
                      result2.running = result2.list.filter((e) => {
                        return e.state === "running";
                      }).length;
                      result2.blocked = result2.list.filter((e) => {
                        return e.state === "blocked";
                      }).length;
                      result2.sleeping = result2.list.filter((e) => {
                        return e.state === "sleeping";
                      }).length;
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    } else {
                      if (callback) {
                        callback(result2);
                      }
                      resolve(result2);
                    }
                  });
                }
              });
            } catch {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } else if (_windows) {
            try {
              util.powerShell(`Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage,
                @{n="CreationDate";e={$_.CreationDate.ToString("yyyy-MM-dd HH:mm:ss")}} | ConvertTo-Json -compress`).then((stdout, error2) => {
                if (!error2) {
                  const procs = [];
                  const procStats = [];
                  const list_new = {};
                  let allcpuu = 0;
                  let allcpus = 0;
                  let processArray = [];
                  try {
                    stdout = stdout.trim().replace(/^\uFEFF/, "");
                    processArray = JSON.parse(stdout);
                  } catch {}
                  processArray.forEach((element) => {
                    const pid = element.ProcessId;
                    const parentPid = element.ParentProcessId;
                    const statusValue = element.ExecutionState || null;
                    const name = element.Caption;
                    const commandLine = element.CommandLine;
                    const commandPath = element.ExecutablePath;
                    const utime = element.UserModeTime;
                    const stime = element.KernelModeTime;
                    const memw = element.WorkingSetSize;
                    allcpuu = allcpuu + utime;
                    allcpus = allcpus + stime;
                    result2.all++;
                    if (!statusValue) {
                      result2.unknown++;
                    }
                    if (statusValue === "3") {
                      result2.running++;
                    }
                    if (statusValue === "4" || statusValue === "5") {
                      result2.blocked++;
                    }
                    procStats.push({
                      pid,
                      utime,
                      stime,
                      cpu: 0,
                      cpuu: 0,
                      cpus: 0
                    });
                    procs.push({
                      pid,
                      parentPid,
                      name,
                      cpu: 0,
                      cpuu: 0,
                      cpus: 0,
                      mem: memw / os.totalmem() * 100,
                      priority: element.Priority | null,
                      memVsz: element.PageFileUsage || null,
                      memRss: Math.floor((element.WorkingSetSize || 0) / 1024),
                      nice: 0,
                      started: element.CreationDate,
                      state: statusValue ? _winStatusValues[statusValue] : _winStatusValues[0],
                      tty: "",
                      user: "",
                      command: commandLine || name,
                      path: commandPath,
                      params: ""
                    });
                  });
                  result2.sleeping = result2.all - result2.running - result2.blocked - result2.unknown;
                  result2.list = procs;
                  procStats.forEach((element) => {
                    let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);
                    let listPos = result2.list.map((e) => e.pid).indexOf(resultProcess.pid);
                    if (listPos >= 0) {
                      result2.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                      result2.list[listPos].cpuu = resultProcess.cpuu;
                      result2.list[listPos].cpus = resultProcess.cpus;
                    }
                    list_new[resultProcess.pid] = {
                      cpuu: resultProcess.cpuu,
                      cpus: resultProcess.cpus,
                      utime: resultProcess.utime,
                      stime: resultProcess.stime
                    };
                  });
                  _processes_cpu.all = allcpuu + allcpus;
                  _processes_cpu.all_utime = allcpuu;
                  _processes_cpu.all_stime = allcpus;
                  _processes_cpu.list = Object.assign({}, list_new);
                  _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                  _processes_cpu.result = Object.assign({}, result2);
                }
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            } catch {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } else {
          if (callback) {
            callback(_processes_cpu.result);
          }
          resolve(_processes_cpu.result);
        }
      });
    });
  }
  exports.processes = processes;
  function processLoad(proc, callback) {
    if (util.isFunction(proc) && !callback) {
      callback = proc;
      proc = "";
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        proc = proc || "";
        if (typeof proc !== "string") {
          if (callback) {
            callback([]);
          }
          return resolve([]);
        }
        let processesString = "";
        try {
          processesString.__proto__.toLowerCase = util.stringToLower;
          processesString.__proto__.replace = util.stringReplace;
          processesString.__proto__.toString = util.stringToString;
          processesString.__proto__.substr = util.stringSubstr;
          processesString.__proto__.substring = util.stringSubstring;
          processesString.__proto__.trim = util.stringTrim;
          processesString.__proto__.startsWith = util.stringStartWith;
        } catch {
          Object.setPrototypeOf(processesString, util.stringObj);
        }
        const s = util.sanitizeShellString(proc);
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (s[i] !== undefined) {
            processesString = processesString + s[i];
          }
        }
        processesString = processesString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
        if (processesString === "") {
          processesString = "*";
        }
        if (util.isPrototypePolluted() && processesString !== "*") {
          processesString = "------";
        }
        let processes2 = processesString.split("|");
        let result2 = [];
        const procSanitized = util.isPrototypePolluted() ? "" : util.sanitizeShellString(proc) || "*";
        if (procSanitized && processes2.length && processes2[0] !== "------") {
          if (_windows) {
            try {
              util.powerShell("Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | ConvertTo-Json -compress").then((stdout, error2) => {
                if (!error2) {
                  const procStats = [];
                  const list_new = {};
                  let allcpuu = 0;
                  let allcpus = 0;
                  let processArray = [];
                  try {
                    stdout = stdout.trim().replace(/^\uFEFF/, "");
                    processArray = JSON.parse(stdout);
                  } catch {}
                  processArray.forEach((element) => {
                    const pid = element.ProcessId;
                    const name = element.Caption;
                    const utime = element.UserModeTime;
                    const stime = element.KernelModeTime;
                    const mem = element.WorkingSetSize;
                    allcpuu = allcpuu + utime;
                    allcpus = allcpus + stime;
                    procStats.push({
                      pid,
                      name,
                      utime,
                      stime,
                      cpu: 0,
                      cpuu: 0,
                      cpus: 0,
                      mem
                    });
                    let pname = "";
                    let inList = false;
                    processes2.forEach((proc2) => {
                      if (name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                        inList = true;
                        pname = proc2;
                      }
                    });
                    if (processesString === "*" || inList) {
                      let processFound = false;
                      result2.forEach((item) => {
                        if (item.proc.toLowerCase() === pname.toLowerCase()) {
                          item.pids.push(pid);
                          item.mem += mem / os.totalmem() * 100;
                          processFound = true;
                        }
                      });
                      if (!processFound) {
                        result2.push({
                          proc: pname,
                          pid,
                          pids: [pid],
                          cpu: 0,
                          mem: mem / os.totalmem() * 100
                        });
                      }
                    }
                  });
                  if (processesString !== "*") {
                    let processesMissing = processes2.filter((name) => procStats.filter((item) => item.name.toLowerCase().indexOf(name) >= 0).length === 0);
                    processesMissing.forEach((procName) => {
                      result2.push({
                        proc: procName,
                        pid: null,
                        pids: [],
                        cpu: 0,
                        mem: 0
                      });
                    });
                  }
                  procStats.forEach((element) => {
                    let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);
                    let listPos = -1;
                    for (let j = 0;j < result2.length; j++) {
                      if (result2[j].pid === resultProcess.pid || result2[j].pids.indexOf(resultProcess.pid) >= 0) {
                        listPos = j;
                      }
                    }
                    if (listPos >= 0) {
                      result2[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                    }
                    list_new[resultProcess.pid] = {
                      cpuu: resultProcess.cpuu,
                      cpus: resultProcess.cpus,
                      utime: resultProcess.utime,
                      stime: resultProcess.stime
                    };
                  });
                  _process_cpu.all = allcpuu + allcpus;
                  _process_cpu.all_utime = allcpuu;
                  _process_cpu.all_stime = allcpus;
                  _process_cpu.list = Object.assign({}, list_new);
                  _process_cpu.ms = Date.now() - _process_cpu.ms;
                  _process_cpu.result = JSON.parse(JSON.stringify(result2));
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              });
            } catch {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          }
          if (_darwin || _linux || _freebsd || _openbsd || _netbsd) {
            const params = ["-axo", "pid,ppid,pcpu,pmem,comm"];
            util.execSafe("ps", params).then((stdout) => {
              if (stdout) {
                const procStats = [];
                const lines = stdout.toString().split(`
`).filter((line) => {
                  if (processesString === "*") {
                    return true;
                  }
                  if (line.toLowerCase().indexOf("grep") !== -1) {
                    return false;
                  }
                  let found = false;
                  processes2.forEach((item) => {
                    found = found || line.toLowerCase().indexOf(item.toLowerCase()) >= 0;
                  });
                  return found;
                });
                lines.shift();
                lines.forEach((line) => {
                  const data = line.trim().replace(/ +/g, " ").split(" ");
                  if (data.length > 4) {
                    const linuxName = data[4].indexOf("/") >= 0 ? data[4].substring(0, data[4].indexOf("/")) : data[4];
                    const name = _linux ? linuxName : data[4].substring(data[4].lastIndexOf("/") + 1);
                    procStats.push({
                      name,
                      pid: parseInt(data[0]) || 0,
                      ppid: parseInt(data[1]) || 0,
                      cpu: parseFloat(data[2].replace(",", ".")),
                      mem: parseFloat(data[3].replace(",", "."))
                    });
                  }
                });
                procStats.forEach((item) => {
                  let listPos = -1;
                  let inList = false;
                  let name = item.name;
                  for (let j = 0;j < result2.length; j++) {
                    if (item.name.toLowerCase().indexOf(result2[j].proc.toLowerCase()) >= 0) {
                      listPos = j;
                    }
                  }
                  processes2.forEach((proc2) => {
                    if (item.name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                      inList = true;
                      name = proc2;
                    }
                  });
                  if (processesString === "*" || inList) {
                    if (listPos < 0) {
                      if (name) {
                        result2.push({
                          proc: name,
                          pid: item.pid,
                          pids: [item.pid],
                          cpu: item.cpu,
                          mem: item.mem
                        });
                      }
                    } else {
                      if (item.ppid < 10) {
                        result2[listPos].pid = item.pid;
                      }
                      result2[listPos].pids.push(item.pid);
                      result2[listPos].cpu += item.cpu;
                      result2[listPos].mem += item.mem;
                    }
                  }
                });
                if (processesString !== "*") {
                  let processesMissing = processes2.filter((name) => {
                    return procStats.filter((item) => {
                      return item.name.toLowerCase().indexOf(name) >= 0;
                    }).length === 0;
                  });
                  processesMissing.forEach((procName) => {
                    result2.push({
                      proc: procName,
                      pid: null,
                      pids: [],
                      cpu: 0,
                      mem: 0
                    });
                  });
                }
                if (_linux) {
                  result2.forEach((item) => {
                    item.cpu = 0;
                  });
                  let cmd = 'cat /proc/stat | grep "cpu "';
                  for (let i in result2) {
                    for (let j in result2[i].pids) {
                      cmd += ";cat /proc/" + result2[i].pids[j] + "/stat";
                    }
                  }
                  exec(cmd, { maxBuffer: 1024 * 102400 }, (error2, stdout2) => {
                    let curr_processes = stdout2.toString().split(`
`);
                    let all = parseProcStat(curr_processes.shift());
                    let list_new = {};
                    let resultProcess = {};
                    curr_processes.forEach((element) => {
                      resultProcess = calcProcStatLinux(element, all, _process_cpu);
                      if (resultProcess.pid) {
                        let resultItemId = -1;
                        for (let i in result2) {
                          if (result2[i].pids.indexOf(resultProcess.pid) >= 0) {
                            resultItemId = i;
                          }
                        }
                        if (resultItemId >= 0) {
                          result2[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;
                        }
                        list_new[resultProcess.pid] = {
                          cpuu: resultProcess.cpuu,
                          cpus: resultProcess.cpus,
                          utime: resultProcess.utime,
                          stime: resultProcess.stime,
                          cutime: resultProcess.cutime,
                          cstime: resultProcess.cstime
                        };
                      }
                    });
                    result2.forEach((item) => {
                      item.cpu = Math.round(item.cpu * 100) / 100;
                    });
                    _process_cpu.all = all;
                    _process_cpu.list = Object.assign({}, list_new);
                    _process_cpu.ms = Date.now() - _process_cpu.ms;
                    _process_cpu.result = Object.assign({}, result2);
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                }
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            });
          }
        }
      });
    });
  }
  exports.processLoad = processLoad;
});

// node_modules/systeminformation/lib/users.js
var require_users = __commonJS((exports) => {
  var exec = __require("child_process").exec;
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function parseDate(dtMon, dtDay) {
    let dt = new Date().toISOString().slice(0, 10);
    try {
      dt = "" + new Date().getFullYear() + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(dtMon.toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + dtDay).slice(-2);
      if (new Date(dt) > new Date) {
        dt = "" + (new Date().getFullYear() - 1) + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(dtMon.toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + dtDay).slice(-2);
      }
    } catch {
      util.noop();
    }
    return dt;
  }
  function parseUsersLinux(lines, phase) {
    const result2 = [];
    let result_who = [];
    const result_w = {};
    let w_first = true;
    let w_header = [];
    const w_pos = [];
    let who_line = {};
    let is_whopart = true;
    let is_whoerror = false;
    lines.forEach((line) => {
      if (line === "---") {
        is_whopart = false;
      } else {
        const l = line.replace(/ +/g, " ").split(" ");
        if (is_whopart) {
          if (line.toLowerCase().indexOf("unexpected") >= 0 || line.toLowerCase().indexOf("unrecognized") >= 0) {
            is_whoerror = true;
            result_who = [];
          }
          if (!is_whoerror) {
            const timePos = l && l.length > 4 && l[4].indexOf(":") > 0 ? 4 : 3;
            result_who.push({
              user: l[0],
              tty: l[1],
              date: timePos === 4 ? parseDate(l[2], l[3]) : l[2],
              time: l[timePos],
              ip: l && l.length > timePos + 1 ? l[timePos + 1].replace(/\(/g, "").replace(/\)/g, "") : "",
              command: ""
            });
          }
        } else {
          if (w_first) {
            if (line[0] !== " ") {
              w_header = l;
              w_header.forEach((item) => {
                w_pos.push(line.indexOf(item));
              });
              w_first = false;
            }
          } else {
            result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();
            result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();
            result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\(/g, "").replace(/\)/g, "").trim();
            result_w.command = line.substring(w_pos[7], 1000).trim();
            if (result_who.length || phase === 1) {
              who_line = result_who.filter((obj) => {
                return obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty;
              });
            } else {
              who_line = [{ user: result_w.user, tty: result_w.tty, date: "", time: "", ip: "" }];
            }
            if (who_line.length === 1 && who_line[0].user !== "") {
              result2.push({
                user: who_line[0].user,
                tty: who_line[0].tty,
                date: who_line[0].date,
                time: who_line[0].time,
                ip: who_line[0].ip,
                command: result_w.command
              });
            }
          }
        }
      }
    });
    if (result2.length === 0 && phase === 2) {
      return result_who;
    } else {
      return result2;
    }
  }
  function parseUsersDarwin(lines) {
    const result2 = [];
    const result_who = [];
    const result_w = {};
    let who_line = {};
    let is_whopart = true;
    lines.forEach((line) => {
      if (line === "---") {
        is_whopart = false;
      } else {
        const l = line.replace(/ +/g, " ").split(" ");
        if (is_whopart) {
          result_who.push({
            user: l[0],
            tty: l[1],
            date: parseDate(l[2], l[3]),
            time: l[4]
          });
        } else {
          result_w.user = l[0];
          result_w.tty = l[1];
          result_w.ip = l[2] !== "-" ? l[2] : "";
          result_w.command = l.slice(5, 1000).join(" ");
          who_line = result_who.filter((obj) => obj.user.substring(0, 10) === result_w.user.substring(0, 10) && (obj.tty.substring(3, 1000) === result_w.tty || obj.tty === result_w.tty));
          if (who_line.length === 1) {
            result2.push({
              user: who_line[0].user,
              tty: who_line[0].tty,
              date: who_line[0].date,
              time: who_line[0].time,
              ip: result_w.ip,
              command: result_w.command
            });
          }
        }
      }
    });
    return result2;
  }
  function users(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = [];
        if (_linux) {
          exec('export LC_ALL=C; who --ips; echo "---"; w; unset LC_ALL | tail -n +2', (error2, stdout) => {
            if (!error2) {
              let lines = stdout.toString().split(`
`);
              result2 = parseUsersLinux(lines, 1);
              if (result2.length === 0) {
                exec('who; echo "---"; w | tail -n +2', (error3, stdout2) => {
                  if (!error3) {
                    lines = stdout2.toString().split(`
`);
                    result2 = parseUsersLinux(lines, 2);
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        }
        if (_freebsd || _openbsd || _netbsd) {
          exec('who; echo "---"; w -ih', (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              result2 = parseUsersDarwin(lines);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          exec('who; echo "---"; w -h', (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              result2 = parseUsersDarwin(lines);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          exec('export LC_ALL=C; who; echo "---"; w -ih; unset LC_ALL', (error2, stdout) => {
            if (!error2) {
              const lines = stdout.toString().split(`
`);
              result2 = parseUsersDarwin(lines);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          try {
            let cmd = 'Get-CimInstance Win32_LogonSession | select LogonId,@{n="StartTime";e={$_.StartTime.ToString("yyyy-MM-dd HH:mm:ss")}} | fl' + "; echo '#-#-#-#';";
            cmd += "Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl " + "; echo '#-#-#-#';";
            cmd += `$process = (Get-CimInstance Win32_Process -Filter "name = 'explorer.exe'"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo '#-#-#-#';`;
            cmd += "query user";
            util.powerShell(cmd).then((data) => {
              if (data) {
                data = data.split("#-#-#-#");
                const sessions = parseWinSessions((data[0] || "").split(/\n\s*\n/));
                const loggedons = parseWinLoggedOn((data[1] || "").split(/\n\s*\n/));
                const queryUser = parseWinUsersQuery((data[3] || "").split(`\r
`));
                const users2 = parseWinUsers((data[2] || "").split(/\n\s*\n/), queryUser);
                for (let id in loggedons) {
                  if ({}.hasOwnProperty.call(loggedons, id)) {
                    loggedons[id].dateTime = {}.hasOwnProperty.call(sessions, id) ? sessions[id] : "";
                  }
                }
                users2.forEach((user) => {
                  let dateTime = "";
                  for (let id in loggedons) {
                    if ({}.hasOwnProperty.call(loggedons, id)) {
                      if (loggedons[id].user === user.user && (!dateTime || dateTime < loggedons[id].dateTime)) {
                        dateTime = loggedons[id].dateTime;
                      }
                    }
                  }
                  result2.push({
                    user: user.user,
                    tty: user.tty,
                    date: `${dateTime.substring(0, 10)}`,
                    time: `${dateTime.substring(11, 19)}`,
                    ip: "",
                    command: ""
                  });
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  function parseWinSessions(sessionParts) {
    const sessions = {};
    sessionParts.forEach((session) => {
      const lines = session.split(`\r
`);
      const id = util.getValue(lines, "LogonId");
      const starttime = util.getValue(lines, "starttime");
      if (id) {
        sessions[id] = starttime;
      }
    });
    return sessions;
  }
  function fuzzyMatch(name1, name2) {
    name1 = name1.toLowerCase();
    name2 = name2.toLowerCase();
    let eq = 0;
    let len = name1.length;
    if (name2.length > len) {
      len = name2.length;
    }
    for (let i = 0;i < len; i++) {
      const c1 = name1[i] || "";
      const c2 = name2[i] || "";
      if (c1 === c2) {
        eq++;
      }
    }
    return len > 10 ? eq / len > 0.9 : len > 0 ? eq / len > 0.8 : false;
  }
  function parseWinUsers(userParts, userQuery) {
    const users2 = [];
    userParts.forEach((user) => {
      const lines = user.split(`\r
`);
      const domain = util.getValue(lines, "domain", ":", true);
      const username = util.getValue(lines, "user", ":", true);
      const sessionid = util.getValue(lines, "sessionid", ":", true);
      if (username) {
        const quser = userQuery.filter((item) => fuzzyMatch(item.user, username));
        users2.push({
          domain,
          user: username,
          tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid
        });
      }
    });
    return users2;
  }
  function parseWinLoggedOn(loggedonParts) {
    const loggedons = {};
    loggedonParts.forEach((loggedon) => {
      const lines = loggedon.split(`\r
`);
      const antecendent = util.getValue(lines, "antecedent", ":", true);
      let parts = antecendent.split("=");
      const name = parts.length > 2 ? parts[1].split(",")[0].replace(/"/g, "").trim() : "";
      const domain = parts.length > 2 ? parts[2].replace(/"/g, "").replace(/\)/g, "").trim() : "";
      const dependent = util.getValue(lines, "dependent", ":", true);
      parts = dependent.split("=");
      const id = parts.length > 1 ? parts[1].replace(/"/g, "").replace(/\)/g, "").trim() : "";
      if (id) {
        loggedons[id] = {
          domain,
          user: name
        };
      }
    });
    return loggedons;
  }
  function parseWinUsersQuery(lines) {
    lines = lines.filter((item) => item);
    let result2 = [];
    const header = lines[0];
    const headerDelimiter = [];
    if (header) {
      const start = header[0] === " " ? 1 : 0;
      headerDelimiter.push(start - 1);
      let nextSpace = 0;
      for (let i = start + 1;i < header.length; i++) {
        if (header[i] === " " && (header[i - 1] === " " || header[i - 1] === ".")) {
          nextSpace = i;
        } else {
          if (nextSpace) {
            headerDelimiter.push(nextSpace);
            nextSpace = 0;
          }
        }
      }
      for (let i = 1;i < lines.length; i++) {
        if (lines[i].trim()) {
          const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || "";
          const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || "";
          result2.push({
            user,
            tty
          });
        }
      }
    }
    return result2;
  }
  exports.users = users;
});

// node_modules/systeminformation/lib/internet.js
var require_internet = __commonJS((exports) => {
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function inetChecksite(url, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = {
          url,
          ok: false,
          status: 404,
          ms: null
        };
        if (typeof url !== "string") {
          if (callback) {
            callback(result2);
          }
          return resolve(result2);
        }
        let urlSanitized = "";
        const s = util.sanitizeShellString(url, true);
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (s[i] !== undefined) {
            try {
              s[i].__proto__.toLowerCase = util.stringToLower;
            } catch {
              Object.setPrototypeOf(s[i], util.stringObj);
            }
            const sl = s[i].toLowerCase();
            if (sl && sl[0] && !sl[1] && sl[0].length === 1) {
              urlSanitized = urlSanitized + sl[0];
            }
          }
        }
        result2.url = urlSanitized;
        try {
          if (urlSanitized && !util.isPrototypePolluted()) {
            try {
              urlSanitized.__proto__.startsWith = util.stringStartWith;
            } catch {
              Object.setPrototypeOf(urlSanitized, util.stringObj);
            }
            if (urlSanitized.startsWith("file:") || urlSanitized.startsWith("gopher:") || urlSanitized.startsWith("telnet:") || urlSanitized.startsWith("mailto:") || urlSanitized.startsWith("news:") || urlSanitized.startsWith("nntp:")) {
              if (callback) {
                callback(result2);
              }
              return resolve(result2);
            }
            util.checkWebsite(urlSanitized).then((res) => {
              result2.status = res.statusCode;
              result2.ok = res.statusCode >= 200 && res.statusCode <= 399;
              result2.ms = result2.ok ? res.time : null;
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        } catch {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.inetChecksite = inetChecksite;
  function inetLatency(host, callback) {
    if (util.isFunction(host) && !callback) {
      callback = host;
      host = "";
    }
    host = host || "8.8.8.8";
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (typeof host !== "string") {
          if (callback) {
            callback(null);
          }
          return resolve(null);
        }
        let hostSanitized = "";
        const s = (util.isPrototypePolluted() ? "8.8.8.8" : util.sanitizeShellString(host, true)).trim();
        const l = util.mathMin(s.length, 2000);
        for (let i = 0;i <= l; i++) {
          if (!(s[i] === undefined)) {
            try {
              s[i].__proto__.toLowerCase = util.stringToLower;
            } catch {
              Object.setPrototypeOf(s[i], util.stringObj);
            }
            const sl = s[i].toLowerCase();
            if (sl && sl[0] && !sl[1]) {
              hostSanitized = hostSanitized + sl[0];
            }
          }
        }
        try {
          hostSanitized.__proto__.startsWith = util.stringStartWith;
        } catch {
          Object.setPrototypeOf(hostSanitized, util.stringObj);
        }
        if (hostSanitized.startsWith("file:") || hostSanitized.startsWith("gopher:") || hostSanitized.startsWith("telnet:") || hostSanitized.startsWith("mailto:") || hostSanitized.startsWith("news:") || hostSanitized.startsWith("nntp:")) {
          if (callback) {
            callback(null);
          }
          return resolve(null);
        }
        let params;
        if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
          if (_linux) {
            params = ["-c", "2", "-w", "3", hostSanitized];
          }
          if (_freebsd || _openbsd || _netbsd) {
            params = ["-c", "2", "-t", "3", hostSanitized];
          }
          if (_darwin) {
            params = ["-c2", "-t3", hostSanitized];
          }
          util.execSafe("ping", params).then((stdout) => {
            let result2 = null;
            if (stdout) {
              const lines = stdout.split(`
`).filter((line2) => line2.indexOf("rtt") >= 0 || line2.indexOf("round-trip") >= 0 || line2.indexOf("avg") >= 0).join(`
`);
              const line = lines.split("=");
              if (line.length > 1) {
                const parts = line[1].split("/");
                if (parts.length > 1) {
                  result2 = parseFloat(parts[1]);
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          const params2 = ["-s", "-a", hostSanitized, "56", "2"];
          const filt = "avg";
          util.execSafe("ping", params2, { timeout: 3000 }).then((stdout) => {
            let result2 = null;
            if (stdout) {
              const lines = stdout.split(`
`).filter((line2) => line2.indexOf(filt) >= 0).join(`
`);
              const line = lines.split("=");
              if (line.length > 1) {
                const parts = line[1].split("/");
                if (parts.length > 1) {
                  result2 = parseFloat(parts[1].replace(",", "."));
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          let result2 = null;
          try {
            const params2 = [hostSanitized, "-n", "1"];
            util.execSafe("ping", params2, util.execOptsWin).then((stdout) => {
              if (stdout) {
                const lines = stdout.split(`\r
`);
                lines.shift();
                lines.forEach((line) => {
                  if ((line.toLowerCase().match(/ms/g) || []).length === 3) {
                    let l2 = line.replace(/ +/g, " ").split(" ");
                    if (l2.length > 6) {
                      result2 = parseFloat(l2[l2.length - 1]);
                    }
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            });
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  exports.inetLatency = inetLatency;
});

// node_modules/systeminformation/lib/dockerSocket.js
var require_dockerSocket = __commonJS((exports, module) => {
  var net = __require("net");
  var isWin = __require("os").type() === "Windows_NT";
  var socketPath = isWin ? "//./pipe/docker_engine" : "/var/run/docker.sock";

  class DockerSocket {
    getInfo(callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write(`GET http:/info HTTP/1.0\r
\r
`);
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          const startbody = alldata.indexOf(`\r
\r
`);
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch {
            callback({});
          }
        });
      } catch {
        callback({});
      }
    }
    listImages(all, callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/images/json" + (all ? "?all=1" : "") + ` HTTP/1.0\r
\r
`);
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          const startbody = alldata.indexOf(`\r
\r
`);
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch {
            callback({});
          }
        });
      } catch {
        callback({});
      }
    }
    inspectImage(id, callback) {
      id = id || "";
      if (id) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/images/" + id + `/json?stream=0 HTTP/1.0\r
\r
`);
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            const startbody = alldata.indexOf(`\r
\r
`);
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch {
              callback({});
            }
          });
        } catch {
          callback({});
        }
      } else {
        callback({});
      }
    }
    listContainers(all, callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write("GET http:/containers/json" + (all ? "?all=1" : "") + ` HTTP/1.0\r
\r
`);
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          const startbody = alldata.indexOf(`\r
\r
`);
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch {
            callback({});
          }
        });
      } catch {
        callback({});
      }
    }
    getStats(id, callback) {
      id = id || "";
      if (id) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/" + id + `/stats?stream=0 HTTP/1.0\r
\r
`);
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            const startbody = alldata.indexOf(`\r
\r
`);
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch {
              callback({});
            }
          });
        } catch {
          callback({});
        }
      } else {
        callback({});
      }
    }
    getInspect(id, callback) {
      id = id || "";
      if (id) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/" + id + `/json?stream=0 HTTP/1.0\r
\r
`);
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            const startbody = alldata.indexOf(`\r
\r
`);
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch {
              callback({});
            }
          });
        } catch {
          callback({});
        }
      } else {
        callback({});
      }
    }
    getProcesses(id, callback) {
      id = id || "";
      if (id) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/" + id + `/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\r
\r
`);
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            const startbody = alldata.indexOf(`\r
\r
`);
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch {
              callback({});
            }
          });
        } catch {
          callback({});
        }
      } else {
        callback({});
      }
    }
    listVolumes(callback) {
      try {
        let socket = net.createConnection({ path: socketPath });
        let alldata = "";
        let data;
        socket.on("connect", () => {
          socket.write(`GET http:/volumes HTTP/1.0\r
\r
`);
        });
        socket.on("data", (data2) => {
          alldata = alldata + data2.toString();
        });
        socket.on("error", () => {
          socket = false;
          callback({});
        });
        socket.on("end", () => {
          const startbody = alldata.indexOf(`\r
\r
`);
          alldata = alldata.substring(startbody + 4);
          socket = false;
          try {
            data = JSON.parse(alldata);
            callback(data);
          } catch {
            callback({});
          }
        });
      } catch {
        callback({});
      }
    }
  }
  module.exports = DockerSocket;
});

// node_modules/systeminformation/lib/docker.js
var require_docker = __commonJS((exports) => {
  var util = require_util7();
  var DockerSocket = require_dockerSocket();
  var _platform = process.platform;
  var _windows = _platform === "win32";
  var _docker_container_stats = {};
  var _docker_socket;
  var _docker_last_read = 0;
  function dockerInfo(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        const result2 = {};
        _docker_socket.getInfo((data) => {
          result2.id = data.ID;
          result2.containers = data.Containers;
          result2.containersRunning = data.ContainersRunning;
          result2.containersPaused = data.ContainersPaused;
          result2.containersStopped = data.ContainersStopped;
          result2.images = data.Images;
          result2.driver = data.Driver;
          result2.memoryLimit = data.MemoryLimit;
          result2.swapLimit = data.SwapLimit;
          result2.kernelMemory = data.KernelMemory;
          result2.cpuCfsPeriod = data.CpuCfsPeriod;
          result2.cpuCfsQuota = data.CpuCfsQuota;
          result2.cpuShares = data.CPUShares;
          result2.cpuSet = data.CPUSet;
          result2.ipv4Forwarding = data.IPv4Forwarding;
          result2.bridgeNfIptables = data.BridgeNfIptables;
          result2.bridgeNfIp6tables = data.BridgeNfIp6tables;
          result2.debug = data.Debug;
          result2.nfd = data.NFd;
          result2.oomKillDisable = data.OomKillDisable;
          result2.ngoroutines = data.NGoroutines;
          result2.systemTime = data.SystemTime;
          result2.loggingDriver = data.LoggingDriver;
          result2.cgroupDriver = data.CgroupDriver;
          result2.nEventsListener = data.NEventsListener;
          result2.kernelVersion = data.KernelVersion;
          result2.operatingSystem = data.OperatingSystem;
          result2.osType = data.OSType;
          result2.architecture = data.Architecture;
          result2.ncpu = data.NCPU;
          result2.memTotal = data.MemTotal;
          result2.dockerRootDir = data.DockerRootDir;
          result2.httpProxy = data.HttpProxy;
          result2.httpsProxy = data.HttpsProxy;
          result2.noProxy = data.NoProxy;
          result2.name = data.Name;
          result2.labels = data.Labels;
          result2.experimentalBuild = data.ExperimentalBuild;
          result2.serverVersion = data.ServerVersion;
          result2.clusterStore = data.ClusterStore;
          result2.clusterAdvertise = data.ClusterAdvertise;
          result2.defaultRuntime = data.DefaultRuntime;
          result2.liveRestoreEnabled = data.LiveRestoreEnabled;
          result2.isolation = data.Isolation;
          result2.initBinary = data.InitBinary;
          result2.productLicense = data.ProductLicense;
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      });
    });
  }
  exports.dockerInfo = dockerInfo;
  function dockerImages(all, callback) {
    if (util.isFunction(all) && !callback) {
      callback = all;
      all = false;
    }
    if (typeof all === "string" && all === "true") {
      all = true;
    }
    if (typeof all !== "boolean" && all !== undefined) {
      all = false;
    }
    all = all || false;
    let result2 = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        const workload = [];
        _docker_socket.listImages(all, (data) => {
          let dockerImages2 = {};
          try {
            dockerImages2 = data;
            if (dockerImages2 && Object.prototype.toString.call(dockerImages2) === "[object Array]" && dockerImages2.length > 0) {
              dockerImages2.forEach((element) => {
                if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                  element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                }
                workload.push(dockerImagesInspect(element.Id.trim(), element));
              });
              if (workload.length) {
                Promise.all(workload).then((data2) => {
                  if (callback) {
                    callback(data2);
                  }
                  resolve(data2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      });
    });
  }
  function dockerImagesInspect(imageID, payload) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        imageID = imageID || "";
        if (typeof imageID !== "string") {
          return resolve();
        }
        const imageIDSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(imageID, true)).trim();
        if (imageIDSanitized) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.inspectImage(imageIDSanitized.trim(), (data) => {
            try {
              resolve({
                id: payload.Id,
                container: data.Container,
                comment: data.Comment,
                os: data.Os,
                architecture: data.Architecture,
                parent: data.Parent,
                dockerVersion: data.DockerVersion,
                size: data.Size,
                sharedSize: payload.SharedSize,
                virtualSize: data.VirtualSize,
                author: data.Author,
                created: data.Created ? Math.round(new Date(data.Created).getTime() / 1000) : 0,
                containerConfig: data.ContainerConfig ? data.ContainerConfig : {},
                graphDriver: data.GraphDriver ? data.GraphDriver : {},
                repoDigests: data.RepoDigests ? data.RepoDigests : {},
                repoTags: data.RepoTags ? data.RepoTags : {},
                config: data.Config ? data.Config : {},
                rootFS: data.RootFS ? data.RootFS : {}
              });
            } catch {
              resolve();
            }
          });
        } else {
          resolve();
        }
      });
    });
  }
  exports.dockerImages = dockerImages;
  function dockerContainers(all, callback) {
    function inContainers(containers, id) {
      const filtered = containers.filter((obj) => {
        return obj.Id && obj.Id === id;
      });
      return filtered.length > 0;
    }
    if (util.isFunction(all) && !callback) {
      callback = all;
      all = false;
    }
    if (typeof all === "string" && all === "true") {
      all = true;
    }
    if (typeof all !== "boolean" && all !== undefined) {
      all = false;
    }
    all = all || false;
    let result2 = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        const workload = [];
        _docker_socket.listContainers(all, (data) => {
          let docker_containers = {};
          try {
            docker_containers = data;
            if (docker_containers && Object.prototype.toString.call(docker_containers) === "[object Array]" && docker_containers.length > 0) {
              for (let key in _docker_container_stats) {
                if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                  if (!inContainers(docker_containers, key)) {
                    delete _docker_container_stats[key];
                  }
                }
              }
              docker_containers.forEach((element) => {
                if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                  element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                }
                workload.push(dockerContainerInspect(element.Id.trim(), element));
              });
              if (workload.length) {
                Promise.all(workload).then((data2) => {
                  if (callback) {
                    callback(data2);
                  }
                  resolve(data2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } catch (err) {
            for (let key in _docker_container_stats) {
              if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                if (!inContainers(docker_containers, key)) {
                  delete _docker_container_stats[key];
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      });
    });
  }
  function dockerContainerInspect(containerID, payload) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        containerID = containerID || "";
        if (typeof containerID !== "string") {
          return resolve();
        }
        const containerIdSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerID, true)).trim();
        if (containerIdSanitized) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.getInspect(containerIdSanitized.trim(), (data) => {
            try {
              resolve({
                id: payload.Id,
                name: payload.Name,
                image: payload.Image,
                imageID: payload.ImageID,
                command: payload.Command,
                created: payload.Created,
                started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1000) : 0,
                finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? Math.round(new Date(data.State.FinishedAt).getTime() / 1000) : 0,
                createdAt: data.Created ? data.Created : "",
                startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : "",
                finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? data.State.FinishedAt : "",
                state: payload.State,
                restartCount: data.RestartCount || 0,
                platform: data.Platform || "",
                driver: data.Driver || "",
                ports: payload.Ports,
                mounts: payload.Mounts
              });
            } catch {
              resolve();
            }
          });
        } else {
          resolve();
        }
      });
    });
  }
  exports.dockerContainers = dockerContainers;
  function docker_calcCPUPercent(cpu_stats, precpu_stats) {
    if (!_windows) {
      let cpuPercent = 0;
      let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
      let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;
      if (systemDelta > 0 && cpuDelta > 0) {
        if (precpu_stats.online_cpus) {
          cpuPercent = cpuDelta / systemDelta * precpu_stats.online_cpus * 100;
        } else {
          cpuPercent = cpuDelta / systemDelta * cpu_stats.cpu_usage.percpu_usage.length * 100;
        }
      }
      return cpuPercent;
    } else {
      let nanoSecNow = util.nanoSeconds();
      let cpuPercent = 0;
      if (_docker_last_read > 0) {
        let possIntervals = nanoSecNow - _docker_last_read;
        let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
        if (possIntervals > 0) {
          cpuPercent = 100 * intervalsUsed / possIntervals;
        }
      }
      _docker_last_read = nanoSecNow;
      return cpuPercent;
    }
  }
  function docker_calcNetworkIO(networks) {
    let rx;
    let wx;
    for (let key in networks) {
      if (!{}.hasOwnProperty.call(networks, key)) {
        continue;
      }
      const obj = networks[key];
      rx = +obj.rx_bytes;
      wx = +obj.tx_bytes;
    }
    return {
      rx,
      wx
    };
  }
  function docker_calcBlockIO(blkio_stats) {
    let result2 = {
      r: 0,
      w: 0
    };
    if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === "[object Array]" && blkio_stats.io_service_bytes_recursive.length > 0) {
      blkio_stats.io_service_bytes_recursive.forEach((element) => {
        if (element.op && element.op.toLowerCase() === "read" && element.value) {
          result2.r += element.value;
        }
        if (element.op && element.op.toLowerCase() === "write" && element.value) {
          result2.w += element.value;
        }
      });
    }
    return result2;
  }
  function dockerContainerStats(containerIDs, callback) {
    let containerArray = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (util.isFunction(containerIDs) && !callback) {
          callback = containerIDs;
          containerArray = ["*"];
        } else {
          containerIDs = containerIDs || "*";
          if (typeof containerIDs !== "string") {
            if (callback) {
              callback([]);
            }
            return resolve([]);
          }
          let containerIDsSanitized = "";
          try {
            containerIDsSanitized.__proto__.toLowerCase = util.stringToLower;
            containerIDsSanitized.__proto__.replace = util.stringReplace;
            containerIDsSanitized.__proto__.toString = util.stringToString;
            containerIDsSanitized.__proto__.substr = util.stringSubstr;
            containerIDsSanitized.__proto__.substring = util.stringSubstring;
            containerIDsSanitized.__proto__.trim = util.stringTrim;
            containerIDsSanitized.__proto__.startsWith = util.stringStartWith;
          } catch (e) {
            Object.setPrototypeOf(containerIDsSanitized, util.stringObj);
          }
          containerIDsSanitized = containerIDs;
          containerIDsSanitized = containerIDsSanitized.trim();
          if (containerIDsSanitized !== "*") {
            containerIDsSanitized = "";
            const s = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerIDs, true)).trim();
            const l = util.mathMin(s.length, 2000);
            for (let i = 0;i <= l; i++) {
              if (s[i] !== undefined) {
                s[i].__proto__.toLowerCase = util.stringToLower;
                const sl = s[i].toLowerCase();
                if (sl && sl[0] && !sl[1]) {
                  containerIDsSanitized = containerIDsSanitized + sl[0];
                }
              }
            }
          }
          containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, "|");
          containerArray = containerIDsSanitized.split("|");
        }
        const result2 = [];
        const workload = [];
        if (containerArray.length && containerArray[0].trim() === "*") {
          containerArray = [];
          dockerContainers().then((allContainers) => {
            for (let container of allContainers) {
              containerArray.push(container.id.substring(0, 12));
            }
            if (containerArray.length) {
              dockerContainerStats(containerArray.join(",")).then((result3) => {
                if (callback) {
                  callback(result3);
                }
                resolve(result3);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        } else {
          for (let containerID of containerArray) {
            workload.push(dockerContainerStatsSingle(containerID.trim()));
          }
          if (workload.length) {
            Promise.all(workload).then((data) => {
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        }
      });
    });
  }
  function dockerContainerStatsSingle(containerID) {
    containerID = containerID || "";
    const result2 = {
      id: containerID,
      memUsage: 0,
      memLimit: 0,
      memPercent: 0,
      cpuPercent: 0,
      pids: 0,
      netIO: {
        rx: 0,
        wx: 0
      },
      blockIO: {
        r: 0,
        w: 0
      },
      restartCount: 0,
      cpuStats: {},
      precpuStats: {},
      memoryStats: {},
      networks: {}
    };
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (containerID) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.getInspect(containerID, (dataInspect) => {
            try {
              _docker_socket.getStats(containerID, (data) => {
                try {
                  let stats = data;
                  if (!stats.message) {
                    if (data.id) {
                      result2.id = data.id;
                    }
                    result2.memUsage = stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0;
                    result2.memLimit = stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0;
                    result2.memPercent = stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100 : 0;
                    result2.cpuPercent = stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0;
                    result2.pids = stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0;
                    result2.restartCount = dataInspect.RestartCount ? dataInspect.RestartCount : 0;
                    if (stats.networks) {
                      result2.netIO = docker_calcNetworkIO(stats.networks);
                    }
                    if (stats.blkio_stats) {
                      result2.blockIO = docker_calcBlockIO(stats.blkio_stats);
                    }
                    result2.cpuStats = stats.cpu_stats ? stats.cpu_stats : {};
                    result2.precpuStats = stats.precpu_stats ? stats.precpu_stats : {};
                    result2.memoryStats = stats.memory_stats ? stats.memory_stats : {};
                    result2.networks = stats.networks ? stats.networks : {};
                  }
                } catch {
                  util.noop();
                }
                resolve(result2);
              });
            } catch {
              util.noop();
            }
          });
        } else {
          resolve(result2);
        }
      });
    });
  }
  exports.dockerContainerStats = dockerContainerStats;
  function dockerContainerProcesses(containerID, callback) {
    let result2 = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        containerID = containerID || "";
        if (typeof containerID !== "string") {
          return resolve(result2);
        }
        const containerIdSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerID, true)).trim();
        if (containerIdSanitized) {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket;
          }
          _docker_socket.getProcesses(containerIdSanitized, (data) => {
            try {
              if (data && data.Titles && data.Processes) {
                let titles = data.Titles.map(function(value) {
                  return value.toUpperCase();
                });
                let pos_pid = titles.indexOf("PID");
                let pos_ppid = titles.indexOf("PPID");
                let pos_pgid = titles.indexOf("PGID");
                let pos_vsz = titles.indexOf("VSZ");
                let pos_time = titles.indexOf("TIME");
                let pos_elapsed = titles.indexOf("ELAPSED");
                let pos_ni = titles.indexOf("NI");
                let pos_ruser = titles.indexOf("RUSER");
                let pos_user = titles.indexOf("USER");
                let pos_rgroup = titles.indexOf("RGROUP");
                let pos_group = titles.indexOf("GROUP");
                let pos_stat = titles.indexOf("STAT");
                let pos_rss = titles.indexOf("RSS");
                let pos_command = titles.indexOf("COMMAND");
                data.Processes.forEach((process2) => {
                  result2.push({
                    pidHost: pos_pid >= 0 ? process2[pos_pid] : "",
                    ppid: pos_ppid >= 0 ? process2[pos_ppid] : "",
                    pgid: pos_pgid >= 0 ? process2[pos_pgid] : "",
                    user: pos_user >= 0 ? process2[pos_user] : "",
                    ruser: pos_ruser >= 0 ? process2[pos_ruser] : "",
                    group: pos_group >= 0 ? process2[pos_group] : "",
                    rgroup: pos_rgroup >= 0 ? process2[pos_rgroup] : "",
                    stat: pos_stat >= 0 ? process2[pos_stat] : "",
                    time: pos_time >= 0 ? process2[pos_time] : "",
                    elapsed: pos_elapsed >= 0 ? process2[pos_elapsed] : "",
                    nice: pos_ni >= 0 ? process2[pos_ni] : "",
                    rss: pos_rss >= 0 ? process2[pos_rss] : "",
                    vsz: pos_vsz >= 0 ? process2[pos_vsz] : "",
                    command: pos_command >= 0 ? process2[pos_command] : ""
                  });
                });
              }
            } catch {
              util.noop();
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } else {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.dockerContainerProcesses = dockerContainerProcesses;
  function dockerVolumes(callback) {
    let result2 = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        if (!_docker_socket) {
          _docker_socket = new DockerSocket;
        }
        _docker_socket.listVolumes((data) => {
          let dockerVolumes2 = {};
          try {
            dockerVolumes2 = data;
            if (dockerVolumes2 && dockerVolumes2.Volumes && Object.prototype.toString.call(dockerVolumes2.Volumes) === "[object Array]" && dockerVolumes2.Volumes.length > 0) {
              dockerVolumes2.Volumes.forEach((element) => {
                result2.push({
                  name: element.Name,
                  driver: element.Driver,
                  labels: element.Labels,
                  mountpoint: element.Mountpoint,
                  options: element.Options,
                  scope: element.Scope,
                  created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1000) : 0
                });
              });
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          } catch {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      });
    });
  }
  exports.dockerVolumes = dockerVolumes;
  function dockerAll(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        dockerContainers(true).then((result2) => {
          if (result2 && Object.prototype.toString.call(result2) === "[object Array]" && result2.length > 0) {
            let l = result2.length;
            result2.forEach((element) => {
              dockerContainerStats(element.id).then((res) => {
                element.memUsage = res[0].memUsage;
                element.memLimit = res[0].memLimit;
                element.memPercent = res[0].memPercent;
                element.cpuPercent = res[0].cpuPercent;
                element.pids = res[0].pids;
                element.netIO = res[0].netIO;
                element.blockIO = res[0].blockIO;
                element.cpuStats = res[0].cpuStats;
                element.precpuStats = res[0].precpuStats;
                element.memoryStats = res[0].memoryStats;
                element.networks = res[0].networks;
                dockerContainerProcesses(element.id).then((processes) => {
                  element.processes = processes;
                  l -= 1;
                  if (l === 0) {
                    if (callback) {
                      callback(result2);
                    }
                    resolve(result2);
                  }
                });
              });
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          }
        });
      });
    });
  }
  exports.dockerAll = dockerAll;
});

// node_modules/systeminformation/lib/virtualbox.js
var require_virtualbox = __commonJS((exports) => {
  var os = __require("os");
  var exec = __require("child_process").exec;
  var util = require_util7();
  function vboxInfo(callback) {
    let result2 = [];
    return new Promise((resolve) => {
      process.nextTick(() => {
        try {
          exec(util.getVboxmanage() + " list vms --long", (error2, stdout) => {
            let parts = (os.EOL + stdout.toString()).split(os.EOL + "Name:");
            parts.shift();
            parts.forEach((part) => {
              const lines = ("Name:" + part).split(os.EOL);
              const state = util.getValue(lines, "State");
              const running = state.startsWith("running");
              const runningSinceString = running ? state.replace("running (since ", "").replace(")", "").trim() : "";
              let runningSince = 0;
              try {
                if (running) {
                  const sinceDateObj = new Date(runningSinceString);
                  const offset = sinceDateObj.getTimezoneOffset();
                  runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;
                }
              } catch {
                util.noop();
              }
              const stoppedSinceString = !running ? state.replace("powered off (since", "").replace(")", "").trim() : "";
              let stoppedSince = 0;
              try {
                if (!running) {
                  const sinceDateObj = new Date(stoppedSinceString);
                  const offset = sinceDateObj.getTimezoneOffset();
                  stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;
                }
              } catch {
                util.noop();
              }
              result2.push({
                id: util.getValue(lines, "UUID"),
                name: util.getValue(lines, "Name"),
                running,
                started: runningSinceString,
                runningSince,
                stopped: stoppedSinceString,
                stoppedSince,
                guestOS: util.getValue(lines, "Guest OS"),
                hardwareUUID: util.getValue(lines, "Hardware UUID"),
                memory: parseInt(util.getValue(lines, "Memory size", "     "), 10),
                vram: parseInt(util.getValue(lines, "VRAM size"), 10),
                cpus: parseInt(util.getValue(lines, "Number of CPUs"), 10),
                cpuExepCap: util.getValue(lines, "CPU exec cap"),
                cpuProfile: util.getValue(lines, "CPUProfile"),
                chipset: util.getValue(lines, "Chipset"),
                firmware: util.getValue(lines, "Firmware"),
                pageFusion: util.getValue(lines, "Page Fusion") === "enabled",
                configFile: util.getValue(lines, "Config file"),
                snapshotFolder: util.getValue(lines, "Snapshot folder"),
                logFolder: util.getValue(lines, "Log folder"),
                hpet: util.getValue(lines, "HPET") === "enabled",
                pae: util.getValue(lines, "PAE") === "enabled",
                longMode: util.getValue(lines, "Long Mode") === "enabled",
                tripleFaultReset: util.getValue(lines, "Triple Fault Reset") === "enabled",
                apic: util.getValue(lines, "APIC") === "enabled",
                x2Apic: util.getValue(lines, "X2APIC") === "enabled",
                acpi: util.getValue(lines, "ACPI") === "enabled",
                ioApic: util.getValue(lines, "IOAPIC") === "enabled",
                biosApicMode: util.getValue(lines, "BIOS APIC mode"),
                bootMenuMode: util.getValue(lines, "Boot menu mode"),
                bootDevice1: util.getValue(lines, "Boot Device 1"),
                bootDevice2: util.getValue(lines, "Boot Device 2"),
                bootDevice3: util.getValue(lines, "Boot Device 3"),
                bootDevice4: util.getValue(lines, "Boot Device 4"),
                timeOffset: util.getValue(lines, "Time offset"),
                rtc: util.getValue(lines, "RTC")
              });
            });
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        } catch {
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
      });
    });
  }
  exports.vboxInfo = vboxInfo;
});

// node_modules/systeminformation/lib/printer.js
var require_printer = __commonJS((exports) => {
  var exec = __require("child_process").exec;
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  var winPrinterStatus = {
    1: "Other",
    2: "Unknown",
    3: "Idle",
    4: "Printing",
    5: "Warmup",
    6: "Stopped Printing",
    7: "Offline"
  };
  function parseLinuxCupsHeader(lines) {
    const result2 = {};
    if (lines && lines.length) {
      if (lines[0].indexOf(" CUPS v") > 0) {
        const parts = lines[0].split(" CUPS v");
        result2.cupsVersion = parts[1];
      }
    }
    return result2;
  }
  function parseLinuxCupsPrinter(lines) {
    const result2 = {};
    const printerId = util.getValue(lines, "PrinterId", " ");
    result2.id = printerId ? parseInt(printerId, 10) : null;
    result2.name = util.getValue(lines, "Info", " ");
    result2.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
    result2.uri = util.getValue(lines, "DeviceURI", " ");
    result2.uuid = util.getValue(lines, "UUID", " ");
    result2.status = util.getValue(lines, "State", " ");
    result2.local = util.getValue(lines, "Location", " ").toLowerCase().startsWith("local");
    result2.default = null;
    result2.shared = util.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
    return result2;
  }
  function parseLinuxLpstatPrinter(lines, id) {
    const result2 = {};
    result2.id = id;
    result2.name = util.getValue(lines, "Description", ":", true);
    result2.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
    result2.uri = null;
    result2.uuid = null;
    result2.status = lines.length > 0 && lines[0] ? lines[0].indexOf(" idle") > 0 ? "idle" : lines[0].indexOf(" printing") > 0 ? "printing" : "unknown" : null;
    result2.local = util.getValue(lines, "Location", ":", true).toLowerCase().startsWith("local");
    result2.default = null;
    result2.shared = util.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
    return result2;
  }
  function parseDarwinPrinters(printerObject, id) {
    const result2 = {};
    const uriParts = printerObject.uri.split("/");
    result2.id = id;
    result2.name = printerObject._name;
    result2.model = uriParts.length ? uriParts[uriParts.length - 1] : "";
    result2.uri = printerObject.uri;
    result2.uuid = null;
    result2.status = printerObject.status;
    result2.local = printerObject.printserver === "local";
    result2.default = printerObject.default === "yes";
    result2.shared = printerObject.shared === "yes";
    return result2;
  }
  function parseWindowsPrinters(lines, id) {
    const result2 = {};
    const status = parseInt(util.getValue(lines, "PrinterStatus", ":"), 10);
    result2.id = id;
    result2.name = util.getValue(lines, "name", ":");
    result2.model = util.getValue(lines, "DriverName", ":");
    result2.uri = null;
    result2.uuid = null;
    result2.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;
    result2.local = util.getValue(lines, "Local", ":").toUpperCase() === "TRUE";
    result2.default = util.getValue(lines, "Default", ":").toUpperCase() === "TRUE";
    result2.shared = util.getValue(lines, "Shared", ":").toUpperCase() === "TRUE";
    return result2;
  }
  function printer(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          let cmd = "cat /etc/cups/printers.conf 2>/dev/null";
          exec(cmd, (error2, stdout) => {
            if (!error2) {
              const parts = stdout.toString().split("<Printer ");
              const printerHeader = parseLinuxCupsHeader(parts[0]);
              for (let i = 1;i < parts.length; i++) {
                const printers = parseLinuxCupsPrinter(parts[i].split(`
`));
                if (printers.name) {
                  printers.engine = "CUPS";
                  printers.engineVersion = printerHeader.cupsVersion;
                  result2.push(printers);
                }
              }
            }
            if (result2.length === 0) {
              if (_linux) {
                cmd = "export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL";
                exec(cmd, (error3, stdout2) => {
                  const parts = (`
` + stdout2.toString()).split(`
printer `);
                  for (let i = 1;i < parts.length; i++) {
                    const printers = parseLinuxLpstatPrinter(parts[i].split(`
`), i);
                    result2.push(printers);
                  }
                });
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
          });
        }
        if (_darwin) {
          let cmd = "system_profiler SPPrintersDataType -json";
          exec(cmd, (error2, stdout) => {
            if (!error2) {
              try {
                const outObj = JSON.parse(stdout.toString());
                if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {
                  for (let i = 0;i < outObj.SPPrintersDataType.length; i++) {
                    const printer2 = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);
                    result2.push(printer2);
                  }
                }
              } catch {
                util.noop();
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          util.powerShell("Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl").then((stdout, error2) => {
            if (!error2) {
              const parts = stdout.toString().split(/\n\s*\n/);
              for (let i = 0;i < parts.length; i++) {
                const printer2 = parseWindowsPrinters(parts[i].split(`
`), i);
                if (printer2.name || printer2.model) {
                  result2.push(printer2);
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          resolve(null);
        }
      });
    });
  }
  exports.printer = printer;
});

// node_modules/systeminformation/lib/usb.js
var require_usb = __commonJS((exports) => {
  var exec = __require("child_process").exec;
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function getLinuxUsbType(type, name) {
    let result2 = type;
    const str = (name + " " + type).toLowerCase();
    if (str.indexOf("camera") >= 0) {
      result2 = "Camera";
    } else if (str.indexOf("hub") >= 0) {
      result2 = "Hub";
    } else if (str.indexOf("keybrd") >= 0) {
      result2 = "Keyboard";
    } else if (str.indexOf("keyboard") >= 0) {
      result2 = "Keyboard";
    } else if (str.indexOf("mouse") >= 0) {
      result2 = "Mouse";
    } else if (str.indexOf("stora") >= 0) {
      result2 = "Storage";
    } else if (str.indexOf("microp") >= 0) {
      result2 = "Microphone";
    } else if (str.indexOf("headset") >= 0) {
      result2 = "Audio";
    } else if (str.indexOf("audio") >= 0) {
      result2 = "Audio";
    }
    return result2;
  }
  function parseLinuxUsb(usb2) {
    const result2 = {};
    const lines = usb2.split(`
`);
    if (lines && lines.length && lines[0].indexOf("Device") >= 0) {
      const parts = lines[0].split(" ");
      result2.bus = parseInt(parts[0], 10);
      if (parts[2]) {
        result2.deviceId = parseInt(parts[2], 10);
      } else {
        result2.deviceId = null;
      }
    } else {
      result2.bus = null;
      result2.deviceId = null;
    }
    const idVendor = util.getValue(lines, "idVendor", " ", true).trim();
    let vendorParts = idVendor.split(" ");
    vendorParts.shift();
    const vendor = vendorParts.join(" ");
    const idProduct = util.getValue(lines, "idProduct", " ", true).trim();
    let productParts = idProduct.split(" ");
    productParts.shift();
    const product = productParts.join(" ");
    const interfaceClass = util.getValue(lines, "bInterfaceClass", " ", true).trim();
    let interfaceClassParts = interfaceClass.split(" ");
    interfaceClassParts.shift();
    const usbType = interfaceClassParts.join(" ");
    const iManufacturer = util.getValue(lines, "iManufacturer", " ", true).trim();
    let iManufacturerParts = iManufacturer.split(" ");
    iManufacturerParts.shift();
    const manufacturer = iManufacturerParts.join(" ");
    const iSerial = util.getValue(lines, "iSerial", " ", true).trim();
    let iSerialParts = iSerial.split(" ");
    iSerialParts.shift();
    const serial = iSerialParts.join(" ");
    result2.id = (idVendor.startsWith("0x") ? idVendor.split(" ")[0].substr(2, 10) : "") + ":" + (idProduct.startsWith("0x") ? idProduct.split(" ")[0].substr(2, 10) : "");
    result2.name = product;
    result2.type = getLinuxUsbType(usbType, product);
    result2.removable = null;
    result2.vendor = vendor;
    result2.manufacturer = manufacturer;
    result2.maxPower = util.getValue(lines, "MaxPower", " ", true);
    result2.serialNumber = serial;
    return result2;
  }
  function getDarwinUsbType(name) {
    let result2 = "";
    if (name.indexOf("camera") >= 0) {
      result2 = "Camera";
    } else if (name.indexOf("touch bar") >= 0) {
      result2 = "Touch Bar";
    } else if (name.indexOf("controller") >= 0) {
      result2 = "Controller";
    } else if (name.indexOf("headset") >= 0) {
      result2 = "Audio";
    } else if (name.indexOf("keyboard") >= 0) {
      result2 = "Keyboard";
    } else if (name.indexOf("trackpad") >= 0) {
      result2 = "Trackpad";
    } else if (name.indexOf("sensor") >= 0) {
      result2 = "Sensor";
    } else if (name.indexOf("bthusb") >= 0) {
      result2 = "Bluetooth";
    } else if (name.indexOf("bth") >= 0) {
      result2 = "Bluetooth";
    } else if (name.indexOf("rfcomm") >= 0) {
      result2 = "Bluetooth";
    } else if (name.indexOf("usbhub") >= 0) {
      result2 = "Hub";
    } else if (name.indexOf(" hub") >= 0) {
      result2 = "Hub";
    } else if (name.indexOf("mouse") >= 0) {
      result2 = "Mouse";
    } else if (name.indexOf("microp") >= 0) {
      result2 = "Microphone";
    } else if (name.indexOf("removable") >= 0) {
      result2 = "Storage";
    }
    return result2;
  }
  function parseDarwinUsb(usb2, id) {
    const result2 = {};
    result2.id = id;
    usb2 = usb2.replace(/ \|/g, "");
    usb2 = usb2.trim();
    let lines = usb2.split(`
`);
    lines.shift();
    try {
      for (let i = 0;i < lines.length; i++) {
        lines[i] = lines[i].trim();
        lines[i] = lines[i].replace(/=/g, ":");
        if (lines[i] !== "{" && lines[i] !== "}" && lines[i + 1] && lines[i + 1].trim() !== "}") {
          lines[i] = lines[i] + ",";
        }
        lines[i] = lines[i].replace(":Yes,", ':"Yes",');
        lines[i] = lines[i].replace(": Yes,", ': "Yes",');
        lines[i] = lines[i].replace(": Yes", ': "Yes"');
        lines[i] = lines[i].replace(":No,", ':"No",');
        lines[i] = lines[i].replace(": No,", ': "No",');
        lines[i] = lines[i].replace(": No", ': "No"');
        lines[i] = lines[i].replace("((", "").replace("))", "");
        const match = /<(\w+)>/.exec(lines[i]);
        if (match) {
          const number = match[0];
          lines[i] = lines[i].replace(number, `"${number}"`);
        }
      }
      const usbObj = JSON.parse(lines.join(`
`));
      const removableDrive = (usbObj["Built-In"] ? usbObj["Built-In"].toLowerCase() !== "yes" : true) && (usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() === "no" : true);
      result2.bus = null;
      result2.deviceId = null;
      result2.id = usbObj["USB Address"] || null;
      result2.name = usbObj["kUSBProductString"] || usbObj["USB Product Name"] || null;
      result2.type = getDarwinUsbType((usbObj["kUSBProductString"] || usbObj["USB Product Name"] || "").toLowerCase() + (removableDrive ? " removable" : ""));
      result2.removable = usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() || false : true;
      result2.vendor = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
      result2.manufacturer = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
      result2.maxPower = null;
      result2.serialNumber = usbObj["kUSBSerialNumberString"] || null;
      if (result2.name) {
        return result2;
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  }
  function getWindowsUsbTypeCreation(creationclass, name) {
    let result2 = "";
    if (name.indexOf("storage") >= 0) {
      result2 = "Storage";
    } else if (name.indexOf("speicher") >= 0) {
      result2 = "Storage";
    } else if (creationclass.indexOf("usbhub") >= 0) {
      result2 = "Hub";
    } else if (creationclass.indexOf("storage") >= 0) {
      result2 = "Storage";
    } else if (creationclass.indexOf("usbcontroller") >= 0) {
      result2 = "Controller";
    } else if (creationclass.indexOf("keyboard") >= 0) {
      result2 = "Keyboard";
    } else if (creationclass.indexOf("pointing") >= 0) {
      result2 = "Mouse";
    } else if (creationclass.indexOf("microp") >= 0) {
      result2 = "Microphone";
    } else if (creationclass.indexOf("disk") >= 0) {
      result2 = "Storage";
    }
    return result2;
  }
  function parseWindowsUsb(lines, id) {
    const usbType = getWindowsUsbTypeCreation(util.getValue(lines, "CreationClassName", ":").toLowerCase(), util.getValue(lines, "name", ":").toLowerCase());
    if (usbType) {
      const result2 = {};
      result2.bus = null;
      result2.deviceId = util.getValue(lines, "deviceid", ":");
      result2.id = id;
      result2.name = util.getValue(lines, "name", ":");
      result2.type = usbType;
      result2.removable = null;
      result2.vendor = null;
      result2.manufacturer = util.getValue(lines, "Manufacturer", ":");
      result2.maxPower = null;
      result2.serialNumber = null;
      return result2;
    } else {
      return null;
    }
  }
  function usb(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = [];
        if (_linux) {
          const cmd = "export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL";
          exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error2, stdout) {
            if (!error2) {
              const parts = (`

` + stdout.toString()).split(`

Bus `);
              for (let i = 1;i < parts.length; i++) {
                const usb2 = parseLinuxUsb(parts[i]);
                result2.push(usb2);
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          let cmd = "ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l";
          exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error2, stdout) {
            if (!error2) {
              const parts = stdout.toString().split(" +-o ");
              for (let i = 1;i < parts.length; i++) {
                const usb2 = parseDarwinUsb(parts[i]);
                if (usb2) {
                  result2.push(usb2);
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve(result2);
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          util.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match "USB"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error2) => {
            if (!error2) {
              const parts = stdout.toString().split(/\n\s*\n/);
              for (let i = 0;i < parts.length; i++) {
                const usb2 = parseWindowsUsb(parts[i].split(`
`), i);
                if (usb2 && result2.filter((x) => x.deviceId === usb2.deviceId).length === 0) {
                  result2.push(usb2);
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos || _freebsd || _openbsd || _netbsd) {
          resolve(null);
        }
      });
    });
  }
  exports.usb = usb;
});

// node_modules/systeminformation/lib/audio.js
var require_audio = __commonJS((exports) => {
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var util = require_util7();
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function parseAudioType(str, input, output) {
    str = str.toLowerCase();
    let result2 = "";
    if (str.indexOf("input") >= 0) {
      result2 = "Microphone";
    }
    if (str.indexOf("display audio") >= 0) {
      result2 = "Speaker";
    }
    if (str.indexOf("speak") >= 0) {
      result2 = "Speaker";
    }
    if (str.indexOf("laut") >= 0) {
      result2 = "Speaker";
    }
    if (str.indexOf("loud") >= 0) {
      result2 = "Speaker";
    }
    if (str.indexOf("head") >= 0) {
      result2 = "Headset";
    }
    if (str.indexOf("mic") >= 0) {
      result2 = "Microphone";
    }
    if (str.indexOf("mikr") >= 0) {
      result2 = "Microphone";
    }
    if (str.indexOf("phone") >= 0) {
      result2 = "Phone";
    }
    if (str.indexOf("controll") >= 0) {
      result2 = "Controller";
    }
    if (str.indexOf("line o") >= 0) {
      result2 = "Line Out";
    }
    if (str.indexOf("digital o") >= 0) {
      result2 = "Digital Out";
    }
    if (str.indexOf("smart sound technology") >= 0) {
      result2 = "Digital Signal Processor";
    }
    if (str.indexOf("high definition audio") >= 0) {
      result2 = "Sound Driver";
    }
    if (!result2 && output) {
      result2 = "Speaker";
    } else if (!result2 && input) {
      result2 = "Microphone";
    }
    return result2;
  }
  function getLinuxAudioPci() {
    const cmd = "lspci -v 2>/dev/null";
    const result2 = [];
    try {
      const parts = execSync(cmd, util.execOptsLinux).toString().split(`

`);
      parts.forEach((element) => {
        const lines = element.split(`
`);
        if (lines && lines.length && lines[0].toLowerCase().indexOf("audio") >= 0) {
          const audio2 = {};
          audio2.slotId = lines[0].split(" ")[0];
          audio2.driver = util.getValue(lines, "Kernel driver in use", ":", true) || util.getValue(lines, "Kernel modules", ":", true);
          result2.push(audio2);
        }
      });
      return result2;
    } catch {
      return result2;
    }
  }
  function parseWinAudioStatus(n) {
    let status = n;
    if (n === 1) {
      status = "other";
    } else if (n === 2) {
      status = "unknown";
    } else if (n === 3) {
      status = "enabled";
    } else if (n === 4) {
      status = "disabled";
    } else if (n === 5) {
      status = "not applicable";
    }
    return status;
  }
  function parseLinuxAudioPciMM(lines, audioPCI) {
    const result2 = {};
    const slotId = util.getValue(lines, "Slot");
    const pciMatch = audioPCI.filter((item) => item.slotId === slotId);
    result2.id = slotId;
    result2.name = util.getValue(lines, "SDevice");
    result2.manufacturer = util.getValue(lines, "SVendor");
    result2.revision = util.getValue(lines, "Rev");
    result2.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : "";
    result2.default = null;
    result2.channel = "PCIe";
    result2.type = parseAudioType(result2.name, null, null);
    result2.in = null;
    result2.out = null;
    result2.status = "online";
    return result2;
  }
  function parseDarwinChannel(str) {
    let result2 = "";
    if (str.indexOf("builtin") >= 0) {
      result2 = "Built-In";
    }
    if (str.indexOf("extern") >= 0) {
      result2 = "Audio-Jack";
    }
    if (str.indexOf("hdmi") >= 0) {
      result2 = "HDMI";
    }
    if (str.indexOf("displayport") >= 0) {
      result2 = "Display-Port";
    }
    if (str.indexOf("usb") >= 0) {
      result2 = "USB";
    }
    if (str.indexOf("pci") >= 0) {
      result2 = "PCIe";
    }
    return result2;
  }
  function parseDarwinAudio(audioObject, id) {
    const result2 = {};
    const channelStr = ((audioObject.coreaudio_device_transport || "") + " " + (audioObject._name || "")).toLowerCase();
    result2.id = id;
    result2.name = audioObject._name;
    result2.manufacturer = audioObject.coreaudio_device_manufacturer;
    result2.revision = null;
    result2.driver = null;
    result2.default = !!(audioObject.coreaudio_default_audio_input_device || "") || !!(audioObject.coreaudio_default_audio_output_device || "");
    result2.channel = parseDarwinChannel(channelStr);
    result2.type = parseAudioType(result2.name, !!(audioObject.coreaudio_device_input || ""), !!(audioObject.coreaudio_device_output || ""));
    result2.in = !!(audioObject.coreaudio_device_input || "");
    result2.out = !!(audioObject.coreaudio_device_output || "");
    result2.status = "online";
    return result2;
  }
  function parseWindowsAudio(lines) {
    const result2 = {};
    const status = parseWinAudioStatus(util.getValue(lines, "StatusInfo", ":"));
    result2.id = util.getValue(lines, "DeviceID", ":");
    result2.name = util.getValue(lines, "name", ":");
    result2.manufacturer = util.getValue(lines, "manufacturer", ":");
    result2.revision = null;
    result2.driver = null;
    result2.default = null;
    result2.channel = null;
    result2.type = parseAudioType(result2.name, null, null);
    result2.in = null;
    result2.out = null;
    result2.status = status;
    return result2;
  }
  function audio(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const result2 = [];
        if (_linux || _freebsd || _openbsd || _netbsd) {
          const cmd = "lspci -vmm 2>/dev/null";
          exec(cmd, (error2, stdout) => {
            if (!error2) {
              const audioPCI = getLinuxAudioPci();
              const parts = stdout.toString().split(`

`);
              parts.forEach((element) => {
                const lines = element.split(`
`);
                if (util.getValue(lines, "class", ":", true).toLowerCase().indexOf("audio") >= 0) {
                  const audio2 = parseLinuxAudioPciMM(lines, audioPCI);
                  result2.push(audio2);
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_darwin) {
          const cmd = "system_profiler SPAudioDataType -json";
          exec(cmd, (error2, stdout) => {
            if (!error2) {
              try {
                const outObj = JSON.parse(stdout.toString());
                if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]["_items"] && outObj.SPAudioDataType[0]["_items"].length) {
                  for (let i = 0;i < outObj.SPAudioDataType[0]["_items"].length; i++) {
                    const audio2 = parseDarwinAudio(outObj.SPAudioDataType[0]["_items"][i], i);
                    result2.push(audio2);
                  }
                }
              } catch {
                util.noop();
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          util.powerShell("Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl").then((stdout, error2) => {
            if (!error2) {
              const parts = stdout.toString().split(/\n\s*\n/);
              parts.forEach((element) => {
                const lines = element.split(`
`);
                if (util.getValue(lines, "name", ":")) {
                  result2.push(parseWindowsAudio(lines));
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_sunos) {
          resolve(null);
        }
      });
    });
  }
  exports.audio = audio;
});

// node_modules/systeminformation/lib/bluetoothVendors.js
var require_bluetoothVendors = __commonJS((exports, module) => {
  module.exports = {
    0: "Ericsson Technology Licensing",
    1: "Nokia Mobile Phones",
    2: "Intel Corp.",
    3: "IBM Corp.",
    4: "Toshiba Corp.",
    5: "3Com",
    6: "Microsoft",
    7: "Lucent",
    8: "Motorola",
    9: "Infineon Technologies AG",
    10: "Cambridge Silicon Radio",
    11: "Silicon Wave",
    12: "Digianswer A/S",
    13: "Texas Instruments Inc.",
    14: "Ceva, Inc. (formerly Parthus Technologies, Inc.)",
    15: "Broadcom Corporation",
    16: "Mitel Semiconductor",
    17: "Widcomm, Inc",
    18: "Zeevo, Inc.",
    19: "Atmel Corporation",
    20: "Mitsubishi Electric Corporation",
    21: "RTX Telecom A/S",
    22: "KC Technology Inc.",
    23: "NewLogic",
    24: "Transilica, Inc.",
    25: "Rohde & Schwarz GmbH & Co. KG",
    26: "TTPCom Limited",
    27: "Signia Technologies, Inc.",
    28: "Conexant Systems Inc.",
    29: "Qualcomm",
    30: "Inventel",
    31: "AVM Berlin",
    32: "BandSpeed, Inc.",
    33: "Mansella Ltd",
    34: "NEC Corporation",
    35: "WavePlus Technology Co., Ltd.",
    36: "Alcatel",
    37: "NXP Semiconductors (formerly Philips Semiconductors)",
    38: "C Technologies",
    39: "Open Interface",
    40: "R F Micro Devices",
    41: "Hitachi Ltd",
    42: "Symbol Technologies, Inc.",
    43: "Tenovis",
    44: "Macronix International Co. Ltd.",
    45: "GCT Semiconductor",
    46: "Norwood Systems",
    47: "MewTel Technology Inc.",
    48: "ST Microelectronics",
    49: "Synopsis",
    50: "Red-M (Communications) Ltd",
    51: "Commil Ltd",
    52: "Computer Access Technology Corporation (CATC)",
    53: "Eclipse (HQ Espana) S.L.",
    54: "Renesas Electronics Corporation",
    55: "Mobilian Corporation",
    56: "Terax",
    57: "Integrated System Solution Corp.",
    58: "Matsushita Electric Industrial Co., Ltd.",
    59: "Gennum Corporation",
    60: "BlackBerry Limited (formerly Research In Motion)",
    61: "IPextreme, Inc.",
    62: "Systems and Chips, Inc.",
    63: "Bluetooth SIG, Inc.",
    64: "Seiko Epson Corporation",
    65: "Integrated Silicon Solution Taiwan, Inc.",
    66: "CONWISE Technology Corporation Ltd",
    67: "PARROT SA",
    68: "Socket Mobile",
    69: "Atheros Communications, Inc.",
    70: "MediaTek, Inc.",
    71: "Bluegiga",
    72: "Marvell Technology Group Ltd.",
    73: "3DSP Corporation",
    74: "Accel Semiconductor Ltd.",
    75: "Continental Automotive Systems",
    76: "Apple, Inc.",
    77: "Staccato Communications, Inc.",
    78: "Avago Technologies",
    79: "APT Licensing Ltd.",
    80: "SiRF Technology",
    81: "Tzero Technologies, Inc.",
    82: "J&M Corporation",
    83: "Free2move AB",
    84: "3DiJoy Corporation",
    85: "Plantronics, Inc.",
    86: "Sony Ericsson Mobile Communications",
    87: "Harman International Industries, Inc.",
    88: "Vizio, Inc.",
    89: "Nordic Semiconductor ASA",
    90: "EM Microelectronic-Marin SA",
    91: "Ralink Technology Corporation",
    92: "Belkin International, Inc.",
    93: "Realtek Semiconductor Corporation",
    94: "Stonestreet One, LLC",
    95: "Wicentric, Inc.",
    96: "RivieraWaves S.A.S",
    97: "RDA Microelectronics",
    98: "Gibson Guitars",
    99: "MiCommand Inc.",
    100: "Band XI International, LLC",
    101: "Hewlett-Packard Company",
    102: "9Solutions Oy",
    103: "GN Netcom A/S",
    104: "General Motors",
    105: "A&D Engineering, Inc.",
    106: "MindTree Ltd.",
    107: "Polar Electro OY",
    108: "Beautiful Enterprise Co., Ltd.",
    109: "BriarTek, Inc.",
    110: "Summit Data Communications, Inc.",
    111: "Sound ID",
    112: "Monster, LLC",
    113: "connectBlue AB",
    114: "ShangHai Super Smart Electronics Co. Ltd.",
    115: "Group Sense Ltd.",
    116: "Zomm, LLC",
    117: "Samsung Electronics Co. Ltd.",
    118: "Creative Technology Ltd.",
    119: "Laird Technologies",
    120: "Nike, Inc.",
    121: "lesswire AG",
    122: "MStar Semiconductor, Inc.",
    123: "Hanlynn Technologies",
    124: "A & R Cambridge",
    125: "Seers Technology Co. Ltd",
    126: "Sports Tracking Technologies Ltd.",
    127: "Autonet Mobile",
    128: "DeLorme Publishing Company, Inc.",
    129: "WuXi Vimicro",
    130: "Sennheiser Communications A/S",
    131: "TimeKeeping Systems, Inc.",
    132: "Ludus Helsinki Ltd.",
    133: "BlueRadios, Inc.",
    134: "equinox AG",
    135: "Garmin International, Inc.",
    136: "Ecotest",
    137: "GN ReSound A/S",
    138: "Jawbone",
    139: "Topcorn Positioning Systems, LLC",
    140: "Gimbal Inc. (formerly Qualcomm Labs, Inc. and Qualcomm Retail Solutions, Inc.)",
    141: "Zscan Software",
    142: "Quintic Corp.",
    143: "Stollman E+V GmbH",
    144: "Funai Electric Co., Ltd.",
    145: "Advanced PANMOBIL Systems GmbH & Co. KG",
    146: "ThinkOptics, Inc.",
    147: "Universal Electronics, Inc.",
    148: "Airoha Technology Corp.",
    149: "NEC Lighting, Ltd.",
    150: "ODM Technology, Inc.",
    151: "ConnecteDevice Ltd.",
    152: "zer01.tv GmbH",
    153: "i.Tech Dynamic Global Distribution Ltd.",
    154: "Alpwise",
    155: "Jiangsu Toppower Automotive Electronics Co., Ltd.",
    156: "Colorfy, Inc.",
    157: "Geoforce Inc.",
    158: "Bose Corporation",
    159: "Suunto Oy",
    160: "Kensington Computer Products Group",
    161: "SR-Medizinelektronik",
    162: "Vertu Corporation Limited",
    163: "Meta Watch Ltd.",
    164: "LINAK A/S",
    165: "OTL Dynamics LLC",
    166: "Panda Ocean Inc.",
    167: "Visteon Corporation",
    168: "ARP Devices Limited",
    169: "Magneti Marelli S.p.A",
    170: "CAEN RFID srl",
    171: "Ingenieur-Systemgruppe Zahn GmbH",
    172: "Green Throttle Games",
    173: "Peter Systemtechnik GmbH",
    174: "Omegawave Oy",
    175: "Cinetix",
    176: "Passif Semiconductor Corp",
    177: "Saris Cycling Group, Inc",
    178: "Bekey A/S",
    179: "Clarinox Technologies Pty. Ltd.",
    180: "BDE Technology Co., Ltd.",
    181: "Swirl Networks",
    182: "Meso international",
    183: "TreLab Ltd",
    184: "Qualcomm Innovation Center, Inc. (QuIC)",
    185: "Johnson Controls, Inc.",
    186: "Starkey Laboratories Inc.",
    187: "S-Power Electronics Limited",
    188: "Ace Sensor Inc",
    189: "Aplix Corporation",
    190: "AAMP of America",
    191: "Stalmart Technology Limited",
    192: "AMICCOM Electronics Corporation",
    193: "Shenzhen Excelsecu Data Technology Co.,Ltd",
    194: "Geneq Inc.",
    195: "adidas AG",
    196: "LG Electronics",
    197: "Onset Computer Corporation",
    198: "Selfly BV",
    199: "Quuppa Oy.",
    200: "GeLo Inc",
    201: "Evluma",
    202: "MC10",
    203: "Binauric SE",
    204: "Beats Electronics",
    205: "Microchip Technology Inc.",
    206: "Elgato Systems GmbH",
    207: "ARCHOS SA",
    208: "Dexcom, Inc.",
    209: "Polar Electro Europe B.V.",
    210: "Dialog Semiconductor B.V.",
    211: "TaixingbangTechnology (HK) Co,. LTD.",
    212: "Kawantech",
    213: "Austco Communication Systems",
    214: "Timex Group USA, Inc.",
    215: "Qualcomm Technologies, Inc.",
    216: "Qualcomm Connected Experiences, Inc.",
    217: "Voyetra Turtle Beach",
    218: "txtr GmbH",
    219: "Biosentronics",
    220: "Procter & Gamble",
    221: "Hosiden Corporation",
    222: "Muzik LLC",
    223: "Misfit Wearables Corp",
    224: "Google",
    225: "Danlers Ltd",
    226: "Semilink Inc",
    227: "inMusic Brands, Inc",
    228: "L.S. Research Inc.",
    229: "Eden Software Consultants Ltd.",
    230: "Freshtemp",
    231: "KS Technologies",
    232: "ACTS Technologies",
    233: "Vtrack Systems",
    234: "Nielsen-Kellerman Company",
    235: "Server Technology, Inc.",
    236: "BioResearch Associates",
    237: "Jolly Logic, LLC",
    238: "Above Average Outcomes, Inc.",
    239: "Bitsplitters GmbH",
    240: "PayPal, Inc.",
    241: "Witron Technology Limited",
    242: "Aether ThingsInc. (formerly Morse Project Inc.)",
    243: "Kent Displays Inc.",
    244: "Nautilus Inc.",
    245: "Smartifier Oy",
    246: "Elcometer Limited",
    247: "VSN Technologies Inc.",
    248: "AceUni Corp., Ltd.",
    249: "StickNFind",
    250: "Crystal Code AB",
    251: "KOUKAAM a.s.",
    252: "Delphi Corporation",
    253: "ValenceTech Limited",
    254: "Reserved",
    255: "Typo Products, LLC",
    256: "TomTom International BV",
    257: "Fugoo, Inc",
    258: "Keiser Corporation",
    259: "Bang & Olufsen A/S",
    260: "PLUS Locations Systems Pty Ltd",
    261: "Ubiquitous Computing Technology Corporation",
    262: "Innovative Yachtter Solutions",
    263: "William Demant Holding A/S",
    264: "Chicony Electronics Co., Ltd.",
    265: "Atus BV",
    266: "Codegate Ltd.",
    267: "ERi, Inc.",
    268: "Transducers Direct, LLC",
    269: "Fujitsu Ten Limited",
    270: "Audi AG",
    271: "HiSilicon Technologies Co., Ltd.",
    272: "Nippon Seiki Co., Ltd.",
    273: "Steelseries ApS",
    274: "vyzybl Inc.",
    275: "Openbrain Technologies, Co., Ltd.",
    276: "Xensr",
    277: "e.solutions",
    278: "1OAK Technologies",
    279: "Wimoto Technologies Inc",
    280: "Radius Networks, Inc.",
    281: "Wize Technology Co., Ltd.",
    282: "Qualcomm Labs, Inc.",
    283: "Aruba Networks",
    284: "Baidu",
    285: "Arendi AG",
    286: "Skoda Auto a.s.",
    287: "Volkswagon AG",
    288: "Porsche AG",
    289: "Sino Wealth Electronic Ltd.",
    290: "AirTurn, Inc.",
    291: "Kinsa, Inc.",
    292: "HID Global",
    293: "SEAT es",
    294: "Promethean Ltd.",
    295: "Salutica Allied Solutions",
    296: "GPSI Group Pty Ltd",
    297: "Nimble Devices Oy",
    298: "Changzhou Yongse Infotech Co., Ltd",
    299: "SportIQ",
    300: "TEMEC Instruments B.V.",
    301: "Sony Corporation",
    302: "ASSA ABLOY",
    303: "Clarion Co., Ltd.",
    304: "Warehouse Innovations",
    305: "Cypress Semiconductor Corporation",
    306: "MADS Inc",
    307: "Blue Maestro Limited",
    308: "Resolution Products, Inc.",
    309: "Airewear LLC",
    310: "Seed Labs, Inc. (formerly ETC sp. z.o.o.)",
    311: "Prestigio Plaza Ltd.",
    312: "NTEO Inc.",
    313: "Focus Systems Corporation",
    314: "Tencent Holdings Limited",
    315: "Allegion",
    316: "Murata Manufacuring Co., Ltd.",
    318: "Nod, Inc.",
    319: "B&B Manufacturing Company",
    320: "AlpineElectronics(China)Co.,Ltd",
    321: "FedEx Services",
    322: "Grape Systems Inc.",
    323: "Bkon Connect",
    324: "Lintech GmbH",
    325: "Novatel Wireless",
    326: "Ciright",
    327: "Mighty Cast, Inc.",
    328: "Ambimat Electronics",
    329: "Perytons Ltd.",
    330: "Tivoli Audio, LLC",
    331: "Master Lock",
    332: "Mesh-Net Ltd",
    333: "Huizhou Desay SV Automotive CO., LTD.",
    334: "Tangerine, Inc.",
    335: "B&W Group Ltd.",
    336: "Pioneer Corporation",
    337: "OnBeep",
    338: "Vernier Software & Technology",
    339: "ROL Ergo",
    340: "Pebble Technology",
    341: "NETATMO",
    342: "Accumulate AB",
    343: "Anhui Huami Information Technology Co., Ltd.",
    344: "Inmite s.r.o.",
    345: "ChefSteps, Inc.",
    346: "micas AG",
    347: "Biomedical Research Ltd.",
    348: "Pitius Tec S.L.",
    349: "Estimote, Inc.",
    350: "Unikey Technologies, Inc.",
    351: "Timer Cap Co.",
    352: "AwoX",
    353: "yikes",
    354: "MADSGlobal NZ Ltd.",
    355: "PCH International",
    356: "Qingdao Yeelink Information Technology Co., Ltd.",
    357: "Milwaukee Tool (formerly Milwaukee Electric Tools)",
    358: "MISHIK Pte Ltd",
    359: "Bayer HealthCare",
    360: "Spicebox LLC",
    361: "emberlight",
    362: "Cooper-Atkins Corporation",
    363: "Qblinks",
    364: "MYSPHERA",
    365: "LifeScan Inc",
    366: "Volantic AB",
    367: "Podo Labs, Inc",
    368: "Roche Diabetes Care AG",
    369: "Amazon Fulfillment Service",
    370: "Connovate Technology Private Limited",
    371: "Kocomojo, LLC",
    372: "Everykey LLC",
    373: "Dynamic Controls",
    374: "SentriLock",
    375: "I-SYST inc.",
    376: "CASIO COMPUTER CO., LTD.",
    377: "LAPIS Semiconductor Co., Ltd.",
    378: "Telemonitor, Inc.",
    379: "taskit GmbH",
    380: "Daimler AG",
    381: "BatAndCat",
    382: "BluDotz Ltd",
    383: "XTel ApS",
    384: "Gigaset Communications GmbH",
    385: "Gecko Health Innovations, Inc.",
    386: "HOP Ubiquitous",
    387: "To Be Assigned",
    388: "Nectar",
    389: "belapps LLC",
    390: "CORE Lighting Ltd",
    391: "Seraphim Sense Ltd",
    392: "Unico RBC",
    393: "Physical Enterprises Inc.",
    394: "Able Trend Technology Limited",
    395: "Konica Minolta, Inc.",
    396: "Wilo SE",
    397: "Extron Design Services",
    398: "Fitbit, Inc.",
    399: "Fireflies Systems",
    400: "Intelletto Technologies Inc.",
    401: "FDK CORPORATION",
    402: "Cloudleaf, Inc",
    403: "Maveric Automation LLC",
    404: "Acoustic Stream Corporation",
    405: "Zuli",
    406: "Paxton Access Ltd",
    407: "WiSilica Inc",
    408: "Vengit Limited",
    409: "SALTO SYSTEMS S.L.",
    410: "TRON Forum (formerly T-Engine Forum)",
    411: "CUBETECH s.r.o.",
    412: "Cokiya Incorporated",
    413: "CVS Health",
    414: "Ceruus",
    415: "Strainstall Ltd",
    416: "Channel Enterprises (HK) Ltd.",
    417: "FIAMM",
    418: "GIGALANE.CO.,LTD",
    419: "EROAD",
    420: "Mine Safety Appliances",
    421: "Icon Health and Fitness",
    422: "Asandoo GmbH",
    423: "ENERGOUS CORPORATION",
    424: "Taobao",
    425: "Canon Inc.",
    426: "Geophysical Technology Inc.",
    427: "Facebook, Inc.",
    428: "Nipro Diagnostics, Inc.",
    429: "FlightSafety International",
    430: "Earlens Corporation",
    431: "Sunrise Micro Devices, Inc.",
    432: "Star Micronics Co., Ltd.",
    433: "Netizens Sp. z o.o.",
    434: "Nymi Inc.",
    435: "Nytec, Inc.",
    436: "Trineo Sp. z o.o.",
    437: "Nest Labs Inc.",
    438: "LM Technologies Ltd",
    439: "General Electric Company",
    440: "i+D3 S.L.",
    441: "HANA Micron",
    442: "Stages Cycling LLC",
    443: "Cochlear Bone Anchored Solutions AB",
    444: "SenionLab AB",
    445: "Syszone Co., Ltd",
    446: "Pulsate Mobile Ltd.",
    447: "Hong Kong HunterSun Electronic Limited",
    448: "pironex GmbH",
    449: "BRADATECH Corp.",
    450: "Transenergooil AG",
    451: "Bunch",
    452: "DME Microelectronics",
    453: "Bitcraze AB",
    454: "HASWARE Inc.",
    455: "Abiogenix Inc.",
    456: "Poly-Control ApS",
    457: "Avi-on",
    458: "Laerdal Medical AS",
    459: "Fetch My Pet",
    460: "Sam Labs Ltd.",
    461: "Chengdu Synwing Technology Ltd",
    462: "HOUWA SYSTEM DESIGN, k.k.",
    463: "BSH",
    464: "Primus Inter Pares Ltd",
    465: "August",
    466: "Gill Electronics",
    467: "Sky Wave Design",
    468: "Newlab S.r.l.",
    469: "ELAD srl",
    470: "G-wearables inc.",
    471: "Squadrone Systems Inc.",
    472: "Code Corporation",
    473: "Savant Systems LLC",
    474: "Logitech International SA",
    475: "Innblue Consulting",
    476: "iParking Ltd.",
    477: "Koninklijke Philips Electronics N.V.",
    478: "Minelab Electronics Pty Limited",
    479: "Bison Group Ltd.",
    480: "Widex A/S",
    481: "Jolla Ltd",
    482: "Lectronix, Inc.",
    483: "Caterpillar Inc",
    484: "Freedom Innovations",
    485: "Dynamic Devices Ltd",
    486: "Technology Solutions (UK) Ltd",
    487: "IPS Group Inc.",
    488: "STIR",
    489: "Sano, Inc",
    490: "Advanced Application Design, Inc.",
    491: "AutoMap LLC",
    492: "Spreadtrum Communications Shanghai Ltd",
    493: "CuteCircuit LTD",
    494: "Valeo Service",
    495: "Fullpower Technologies, Inc.",
    496: "KloudNation",
    497: "Zebra Technologies Corporation",
    498: "Itron, Inc.",
    499: "The University of Tokyo",
    500: "UTC Fire and Security",
    501: "Cool Webthings Limited",
    502: "DJO Global",
    503: "Gelliner Limited",
    504: "Anyka (Guangzhou) Microelectronics Technology Co, LTD",
    505: "Medtronic, Inc.",
    506: "Gozio, Inc.",
    507: "Form Lifting, LLC",
    508: "Wahoo Fitness, LLC",
    509: "Kontakt Micro-Location Sp. z o.o.",
    510: "Radio System Corporation",
    511: "Freescale Semiconductor, Inc.",
    512: "Verifone Systems PTe Ltd. Taiwan Branch",
    513: "AR Timing",
    514: "Rigado LLC",
    515: "Kemppi Oy",
    516: "Tapcentive Inc.",
    517: "Smartbotics Inc.",
    518: "Otter Products, LLC",
    519: "STEMP Inc.",
    520: "LumiGeek LLC",
    521: "InvisionHeart Inc.",
    522: "Macnica Inc. ",
    523: "Jaguar Land Rover Limited",
    524: "CoroWare Technologies, Inc",
    525: "Simplo Technology Co., LTD",
    526: "Omron Healthcare Co., LTD",
    527: "Comodule GMBH",
    528: "ikeGPS",
    529: "Telink Semiconductor Co. Ltd",
    530: "Interplan Co., Ltd",
    531: "Wyler AG",
    532: "IK Multimedia Production srl",
    533: "Lukoton Experience Oy",
    534: "MTI Ltd",
    535: "Tech4home, Lda",
    536: "Hiotech AB",
    537: "DOTT Limited",
    538: "Blue Speck Labs, LLC",
    539: "Cisco Systems, Inc",
    540: "Mobicomm Inc",
    541: "Edamic",
    542: "Goodnet, Ltd",
    543: "Luster Leaf Products Inc",
    544: "Manus Machina BV",
    545: "Mobiquity Networks Inc",
    546: "Praxis Dynamics",
    547: "Philip Morris Products S.A.",
    548: "Comarch SA",
    549: "Nestl Nespresso S.A.",
    550: "Merlinia A/S",
    551: "LifeBEAM Technologies",
    552: "Twocanoes Labs, LLC",
    553: "Muoverti Limited",
    554: "Stamer Musikanlagen GMBH",
    555: "Tesla Motors",
    556: "Pharynks Corporation",
    557: "Lupine",
    558: "Siemens AG",
    559: "Huami (Shanghai) Culture Communication CO., LTD",
    560: "Foster Electric Company, Ltd",
    561: "ETA SA",
    562: "x-Senso Solutions Kft",
    563: "Shenzhen SuLong Communication Ltd",
    564: "FengFan (BeiJing) Technology Co, Ltd",
    565: "Qrio Inc",
    566: "Pitpatpet Ltd",
    567: "MSHeli s.r.l.",
    568: "Trakm8 Ltd",
    569: "JIN CO, Ltd",
    570: "Alatech Tehnology",
    571: "Beijing CarePulse Electronic Technology Co, Ltd",
    572: "Awarepoint",
    573: "ViCentra B.V.",
    574: "Raven Industries",
    575: "WaveWare Technologies Inc.",
    576: "Argenox Technologies",
    577: "Bragi GmbH",
    578: "16Lab Inc",
    579: "Masimo Corp",
    580: "Iotera Inc",
    581: "Endress+Hauser",
    582: "ACKme Networks, Inc.",
    583: "FiftyThree Inc.",
    584: "Parker Hannifin Corp",
    585: "Transcranial Ltd",
    586: "Uwatec AG",
    587: "Orlan LLC",
    588: "Blue Clover Devices",
    589: "M-Way Solutions GmbH",
    590: "Microtronics Engineering GmbH",
    591: "Schneider Schreibgerte GmbH",
    592: "Sapphire Circuits LLC",
    593: "Lumo Bodytech Inc.",
    594: "UKC Technosolution",
    595: "Xicato Inc.",
    596: "Playbrush",
    597: "Dai Nippon Printing Co., Ltd.",
    598: "G24 Power Limited",
    599: "AdBabble Local Commerce Inc.",
    600: "Devialet SA",
    601: "ALTYOR",
    602: "University of Applied Sciences Valais/Haute Ecole Valaisanne",
    603: "Five Interactive, LLC dba Zendo",
    604: "NetEaseHangzhouNetwork co.Ltd.",
    605: "Lexmark International Inc.",
    606: "Fluke Corporation",
    607: "Yardarm Technologies",
    608: "SensaRx",
    609: "SECVRE GmbH",
    610: "Glacial Ridge Technologies",
    611: "Identiv, Inc.",
    612: "DDS, Inc.",
    613: "SMK Corporation",
    614: "Schawbel Technologies LLC",
    615: "XMI Systems SA",
    616: "Cerevo",
    617: "Torrox GmbH & Co KG",
    618: "Gemalto",
    619: "DEKA Research & Development Corp.",
    620: "Domster Tadeusz Szydlowski",
    621: "Technogym SPA",
    622: "FLEURBAEY BVBA",
    623: "Aptcode Solutions",
    624: "LSI ADL Technology",
    625: "Animas Corp",
    626: "Alps Electric Co., Ltd.",
    627: "OCEASOFT",
    628: "Motsai Research",
    629: "Geotab",
    630: "E.G.O. Elektro-Gertebau GmbH",
    631: "bewhere inc",
    632: "Johnson Outdoors Inc",
    633: "steute Schaltgerate GmbH & Co. KG",
    634: "Ekomini inc.",
    635: "DEFA AS",
    636: "Aseptika Ltd",
    637: "HUAWEI Technologies Co., Ltd. ( )",
    638: "HabitAware, LLC",
    639: "ruwido austria gmbh",
    640: "ITEC corporation",
    641: "StoneL",
    642: "Sonova AG",
    643: "Maven Machines, Inc.",
    644: "Synapse Electronics",
    645: "Standard Innovation Inc.",
    646: "RF Code, Inc.",
    647: "Wally Ventures S.L.",
    648: "Willowbank Electronics Ltd",
    649: "SK Telecom",
    650: "Jetro AS",
    651: "Code Gears LTD",
    652: "NANOLINK APS",
    653: "IF, LLC",
    654: "RF Digital Corp",
    655: "Church & Dwight Co., Inc",
    656: "Multibit Oy",
    657: "CliniCloud Inc",
    658: "SwiftSensors",
    659: "Blue Bite",
    660: "ELIAS GmbH",
    661: "Sivantos GmbH",
    662: "Petzl",
    663: "storm power ltd",
    664: "EISST Ltd",
    665: "Inexess Technology Simma KG",
    666: "Currant, Inc.",
    667: "C2 Development, Inc.",
    668: "Blue Sky Scientific, LLC",
    669: "ALOTTAZS LABS, LLC",
    670: "Kupson spol. s r.o.",
    671: "Areus Engineering GmbH",
    672: "Impossible Camera GmbH",
    673: "InventureTrack Systems",
    674: "LockedUp",
    675: "Itude",
    676: "Pacific Lock Company",
    677: "Tendyron Corporation ( )",
    678: "Robert Bosch GmbH",
    679: "Illuxtron international B.V.",
    680: "miSport Ltd.",
    681: "Chargelib",
    682: "Doppler Lab",
    683: "BBPOS Limited",
    684: "RTB Elektronik GmbH & Co. KG",
    685: "Rx Networks, Inc.",
    686: "WeatherFlow, Inc.",
    687: "Technicolor USA Inc.",
    688: "Bestechnic(Shanghai),Ltd",
    689: "Raden Inc",
    690: "JouZen Oy",
    691: "CLABER S.P.A.",
    692: "Hyginex, Inc.",
    693: "HANSHIN ELECTRIC RAILWAY CO.,LTD.",
    694: "Schneider Electric",
    695: "Oort Technologies LLC",
    696: "Chrono Therapeutics",
    697: "Rinnai Corporation",
    698: "Swissprime Technologies AG",
    699: "Koha.,Co.Ltd",
    700: "Genevac Ltd",
    701: "Chemtronics",
    702: "Seguro Technology Sp. z o.o.",
    703: "Redbird Flight Simulations",
    704: "Dash Robotics",
    705: "LINE Corporation",
    706: "Guillemot Corporation",
    707: "Techtronic Power Tools Technology Limited",
    708: "Wilson Sporting Goods",
    709: "Lenovo (Singapore) Pte Ltd. ( )",
    710: "Ayatan Sensors",
    711: "Electronics Tomorrow Limited",
    712: "VASCO Data Security International, Inc.",
    713: "PayRange Inc.",
    714: "ABOV Semiconductor",
    715: "AINA-Wireless Inc.",
    716: "Eijkelkamp Soil & Water",
    717: "BMA ergonomics b.v.",
    718: "Teva Branded Pharmaceutical Products R&D, Inc.",
    719: "Anima",
    720: "3M",
    721: "Empatica Srl",
    722: "Afero, Inc.",
    723: "Powercast Corporation",
    724: "Secuyou ApS",
    725: "OMRON Corporation",
    726: "Send Solutions",
    727: "NIPPON SYSTEMWARE CO.,LTD.",
    728: "Neosfar",
    729: "Fliegl Agrartechnik GmbH",
    730: "Gilvader",
    731: "Digi International Inc (R)",
    732: "DeWalch Technologies, Inc.",
    733: "Flint Rehabilitation Devices, LLC",
    734: "Samsung SDS Co., Ltd.",
    735: "Blur Product Development",
    736: "University of Michigan",
    737: "Victron Energy BV",
    738: "NTT docomo",
    739: "Carmanah Technologies Corp.",
    740: "Bytestorm Ltd.",
    741: "Espressif Incorporated ( () )",
    742: "Unwire",
    743: "Connected Yard, Inc.",
    744: "American Music Environments",
    745: "Sensogram Technologies, Inc.",
    746: "Fujitsu Limited",
    747: "Ardic Technology",
    748: "Delta Systems, Inc",
    749: "HTC Corporation",
    750: "Citizen Holdings Co., Ltd.",
    751: "SMART-INNOVATION.inc",
    752: "Blackrat Software",
    753: "The Idea Cave, LLC",
    754: "GoPro, Inc.",
    755: "AuthAir, Inc",
    756: "Vensi, Inc.",
    757: "Indagem Tech LLC",
    758: "Intemo Technologies",
    759: "DreamVisions co., Ltd.",
    760: "Runteq Oy Ltd",
    761: "IMAGINATION TECHNOLOGIES LTD",
    762: "CoSTAR TEchnologies",
    763: "Clarius Mobile Health Corp.",
    764: "Shanghai Frequen Microelectronics Co., Ltd.",
    765: "Uwanna, Inc.",
    766: "Lierda Science & Technology Group Co., Ltd.",
    767: "Silicon Laboratories",
    768: "World Moto Inc.",
    769: "Giatec Scientific Inc.",
    770: "Loop Devices, Inc",
    771: "IACA electronique",
    772: "Martians Inc",
    773: "Swipp ApS",
    774: "Life Laboratory Inc.",
    775: "FUJI INDUSTRIAL CO.,LTD.",
    776: "Surefire, LLC",
    777: "Dolby Labs",
    778: "Ellisys",
    779: "Magnitude Lighting Converters",
    780: "Hilti AG",
    781: "Devdata S.r.l.",
    782: "Deviceworx",
    783: "Shortcut Labs",
    784: "SGL Italia S.r.l.",
    785: "PEEQ DATA",
    786: "Ducere Technologies Pvt Ltd",
    787: "DiveNav, Inc.",
    788: "RIIG AI Sp. z o.o.",
    789: "Thermo Fisher Scientific",
    790: "AG Measurematics Pvt. Ltd.",
    791: "CHUO Electronics CO., LTD.",
    792: "Aspenta International",
    793: "Eugster Frismag AG",
    794: "Amber wireless GmbH",
    795: "HQ Inc",
    796: "Lab Sensor Solutions",
    797: "Enterlab ApS",
    798: "Eyefi, Inc.",
    799: "MetaSystem S.p.A.",
    800: "SONO ELECTRONICS. CO., LTD",
    801: "Jewelbots",
    802: "Compumedics Limited",
    803: "Rotor Bike Components",
    804: "Astro, Inc.",
    805: "Amotus Solutions",
    806: "Healthwear Technologies (Changzhou)Ltd",
    807: "Essex Electronics",
    808: "Grundfos A/S",
    809: "Eargo, Inc.",
    810: "Electronic Design Lab",
    811: "ESYLUX",
    812: "NIPPON SMT.CO.,Ltd",
    813: "BM innovations GmbH",
    814: "indoormap",
    815: "OttoQ Inc",
    816: "North Pole Engineering",
    817: "3flares Technologies Inc.",
    818: "Electrocompaniet A.S.",
    819: "Mul-T-Lock",
    820: "Corentium AS",
    821: "Enlighted Inc",
    822: "GISTIC",
    823: "AJP2 Holdings, LLC",
    824: "COBI GmbH",
    825: "Blue Sky Scientific, LLC",
    826: "Appception, Inc.",
    827: "Courtney Thorne Limited",
    828: "Virtuosys",
    829: "TPV Technology Limited",
    830: "Monitra SA",
    831: "Automation Components, Inc.",
    832: "Letsense s.r.l.",
    833: "Etesian Technologies LLC",
    834: "GERTEC BRASIL LTDA.",
    835: "Drekker Development Pty. Ltd.",
    836: "Whirl Inc",
    837: "Locus Positioning",
    838: "Acuity Brands Lighting, Inc",
    839: "Prevent Biometrics",
    840: "Arioneo",
    841: "VersaMe",
    842: "Vaddio",
    843: "Libratone A/S",
    844: "HM Electronics, Inc.",
    845: "TASER International, Inc.",
    846: "SafeTrust Inc.",
    847: "Heartland Payment Systems",
    848: "Bitstrata Systems Inc.",
    849: "Pieps GmbH",
    850: "iRiding(Xiamen)Technology Co.,Ltd.",
    851: "Alpha Audiotronics, Inc.",
    852: "TOPPAN FORMS CO.,LTD.",
    853: "Sigma Designs, Inc.",
    854: "Spectrum Brands, Inc.",
    855: "Polymap Wireless",
    856: "MagniWare Ltd.",
    857: "Novotec Medical GmbH",
    858: "Medicom Innovation Partner a/s",
    859: "Matrix Inc.",
    860: "Eaton Corporation",
    861: "KYS",
    862: "Naya Health, Inc.",
    863: "Acromag",
    864: "Insulet Corporation",
    865: "Wellinks Inc.",
    866: "ON Semiconductor",
    867: "FREELAP SA",
    868: "Favero Electronics Srl",
    869: "BioMech Sensor LLC",
    870: "BOLTT Sports technologies Private limited",
    871: "Saphe International",
    872: "Metormote AB",
    873: "littleBits",
    874: "SetPoint Medical",
    875: "BRControls Products BV",
    876: "Zipcar",
    877: "AirBolt Pty Ltd",
    878: "KeepTruckin Inc",
    879: "Motiv, Inc.",
    880: "Wazombi Labs O",
    881: "ORBCOMM",
    882: "Nixie Labs, Inc.",
    883: "AppNearMe Ltd",
    884: "Holman Industries",
    885: "Expain AS",
    886: "Electronic Temperature Instruments Ltd",
    887: "Plejd AB",
    888: "Propeller Health",
    889: "Shenzhen iMCO Electronic Technology Co.,Ltd",
    890: "Algoria",
    891: "Apption Labs Inc.",
    892: "Cronologics Corporation",
    893: "MICRODIA Ltd.",
    894: "lulabytes S.L.",
    895: "Nestec S.A.",
    896: "LLC MEGA - F service",
    897: "Sharp Corporation",
    898: "Precision Outcomes Ltd",
    899: "Kronos Incorporated",
    900: "OCOSMOS Co., Ltd.",
    901: "Embedded Electronic Solutions Ltd. dba e2Solutions",
    902: "Aterica Inc.",
    903: "BluStor PMC, Inc.",
    904: "Kapsch TrafficCom AB",
    905: "ActiveBlu Corporation",
    906: "Kohler Mira Limited",
    907: "Noke",
    908: "Appion Inc.",
    909: "Resmed Ltd",
    910: "Crownstone B.V.",
    911: "Xiaomi Inc.",
    912: "INFOTECH s.r.o.",
    913: "Thingsquare AB",
    914: "T&D",
    915: "LAVAZZA S.p.A.",
    916: "Netclearance Systems, Inc.",
    917: "SDATAWAY",
    918: "BLOKS GmbH",
    919: "LEGO System A/S",
    920: "Thetatronics Ltd",
    921: "Nikon Corporation",
    922: "NeST",
    923: "South Silicon Valley Microelectronics",
    924: "ALE International",
    925: "CareView Communications, Inc.",
    926: "SchoolBoard Limited",
    927: "Molex Corporation",
    928: "IVT Wireless Limited",
    929: "Alpine Labs LLC",
    930: "Candura Instruments",
    931: "SmartMovt Technology Co., Ltd",
    932: "Token Zero Ltd",
    933: "ACE CAD Enterprise Co., Ltd. (ACECAD)",
    934: "Medela, Inc",
    935: "AeroScout",
    936: "Esrille Inc.",
    937: "THINKERLY SRL",
    938: "Exon Sp. z o.o.",
    939: "Meizu Technology Co., Ltd.",
    940: "Smablo LTD",
    941: "XiQ",
    942: "Allswell Inc.",
    943: "Comm-N-Sense Corp DBA Verigo",
    944: "VIBRADORM GmbH",
    945: "Otodata Wireless Network Inc.",
    946: "Propagation Systems Limited",
    947: "Midwest Instruments & Controls",
    948: "Alpha Nodus, inc.",
    949: "petPOMM, Inc",
    950: "Mattel",
    951: "Airbly Inc.",
    952: "A-Safe Limited",
    953: "FREDERIQUE CONSTANT SA",
    954: "Maxscend Microelectronics Company Limited",
    955: "Abbott Diabetes Care",
    956: "ASB Bank Ltd",
    957: "amadas",
    958: "Applied Science, Inc.",
    959: "iLumi Solutions Inc.",
    960: "Arch Systems Inc.",
    961: "Ember Technologies, Inc.",
    962: "Snapchat Inc",
    963: "Casambi Technologies Oy",
    964: "Pico Technology Inc.",
    965: "St. Jude Medical, Inc.",
    966: "Intricon",
    967: "Structural Health Systems, Inc.",
    968: "Avvel International",
    969: "Gallagher Group",
    970: "In2things Automation Pvt. Ltd.",
    971: "SYSDEV Srl",
    972: "Vonkil Technologies Ltd",
    973: "Wynd Technologies, Inc.",
    974: "CONTRINEX S.A.",
    975: "MIRA, Inc.",
    976: "Watteam Ltd",
    977: "Density Inc.",
    978: "IOT Pot India Private Limited",
    979: "Sigma Connectivity AB",
    980: "PEG PEREGO SPA",
    981: "Wyzelink Systems Inc.",
    982: "Yota Devices LTD",
    983: "FINSECUR",
    984: "Zen-Me Labs Ltd",
    985: "3IWare Co., Ltd.",
    986: "EnOcean GmbH",
    987: "Instabeat, Inc",
    988: "Nima Labs",
    989: "Andreas Stihl AG & Co. KG",
    990: "Nathan Rhoades LLC",
    991: "Grob Technologies, LLC",
    992: "Actions (Zhuhai) Technology Co., Limited",
    993: "SPD Development Company Ltd",
    994: "Sensoan Oy",
    995: "Qualcomm Life Inc",
    996: "Chip-ing AG",
    997: "ffly4u",
    998: "IoT Instruments Oy",
    999: "TRUE Fitness Technology",
    1000: "Reiner Kartengeraete GmbH & Co. KG.",
    1001: "SHENZHEN LEMONJOY TECHNOLOGY CO., LTD.",
    1002: "Hello Inc.",
    1003: "Evollve Inc.",
    1004: "Jigowatts Inc.",
    1005: "BASIC MICRO.COM,INC.",
    1006: "CUBE TECHNOLOGIES",
    1007: "foolography GmbH",
    1008: "CLINK",
    1009: "Hestan Smart Cooking Inc.",
    1010: "WindowMaster A/S",
    1011: "Flowscape AB",
    1012: "PAL Technologies Ltd",
    1013: "WHERE, Inc.",
    1014: "Iton Technology Corp.",
    1015: "Owl Labs Inc.",
    1016: "Rockford Corp.",
    1017: "Becon Technologies Co.,Ltd.",
    1018: "Vyassoft Technologies Inc",
    1019: "Nox Medical",
    1020: "Kimberly-Clark",
    1021: "Trimble Navigation Ltd.",
    1022: "Littelfuse",
    1023: "Withings",
    1024: "i-developer IT Beratung UG",
    1026: "Sears Holdings Corporation",
    1027: "Gantner Electronic GmbH",
    1028: "Authomate Inc",
    1029: "Vertex International, Inc.",
    1030: "Airtago",
    1031: "Swiss Audio SA",
    1032: "ToGetHome Inc.",
    1033: "AXIS",
    1034: "Openmatics",
    1035: "Jana Care Inc.",
    1036: "Senix Corporation",
    1037: "NorthStar Battery Company, LLC",
    1038: "SKF (U.K.) Limited",
    1039: "CO-AX Technology, Inc.",
    1040: "Fender Musical Instruments",
    1041: "Luidia Inc",
    1042: "SEFAM",
    1043: "Wireless Cables Inc",
    1044: "Lightning Protection International Pty Ltd",
    1045: "Uber Technologies Inc",
    1046: "SODA GmbH",
    1047: "Fatigue Science",
    1048: "Alpine Electronics Inc.",
    1049: "Novalogy LTD",
    1050: "Friday Labs Limited",
    1051: "OrthoAccel Technologies",
    1052: "WaterGuru, Inc.",
    1053: "Benning Elektrotechnik und Elektronik GmbH & Co. KG",
    1054: "Dell Computer Corporation",
    1055: "Kopin Corporation",
    1056: "TecBakery GmbH",
    1057: "Backbone Labs, Inc.",
    1058: "DELSEY SA",
    1059: "Chargifi Limited",
    1060: "Trainesense Ltd.",
    1061: "Unify Software and Solutions GmbH & Co. KG",
    1062: "Husqvarna AB",
    1063: "Focus fleet and fuel management inc",
    1064: "SmallLoop, LLC",
    1065: "Prolon Inc.",
    1066: "BD Medical",
    1067: "iMicroMed Incorporated",
    1068: "Ticto N.V.",
    1069: "Meshtech AS",
    1070: "MemCachier Inc.",
    1071: "Danfoss A/S",
    1072: "SnapStyk Inc.",
    1073: "Amyway Corporation",
    1074: "Silk Labs, Inc.",
    1075: "Pillsy Inc.",
    1076: "Hatch Baby, Inc.",
    1077: "Blocks Wearables Ltd.",
    1078: "Drayson Technologies (Europe) Limited",
    1079: "eBest IOT Inc.",
    1080: "Helvar Ltd",
    1081: "Radiance Technologies",
    1082: "Nuheara Limited",
    1083: "Appside co., ltd.",
    1084: "DeLaval",
    1085: "Coiler Corporation",
    1086: "Thermomedics, Inc.",
    1087: "Tentacle Sync GmbH",
    1088: "Valencell, Inc.",
    1089: "iProtoXi Oy",
    1090: "SECOM CO., LTD.",
    1091: "Tucker International LLC",
    1092: "Metanate Limited",
    1093: "Kobian Canada Inc.",
    1094: "NETGEAR, Inc.",
    1095: "Fabtronics Australia Pty Ltd",
    1096: "Grand Centrix GmbH",
    1097: "1UP USA.com llc",
    1098: "SHIMANO INC.",
    1099: "Nain Inc.",
    1100: "LifeStyle Lock, LLC",
    1101: "VEGA Grieshaber KG",
    1102: "Xtrava Inc.",
    1103: "TTS Tooltechnic Systems AG & Co. KG",
    1104: "Teenage Engineering AB",
    1105: "Tunstall Nordic AB",
    1106: "Svep Design Center AB",
    1107: "GreenPeak Technologies BV",
    1108: "Sphinx Electronics GmbH & Co KG",
    1109: "Atomation",
    1110: "Nemik Consulting Inc",
    1111: "RF INNOVATION",
    1112: "Mini Solution Co., Ltd.",
    1113: "Lumenetix, Inc",
    1114: "2048450 Ontario Inc",
    1115: "SPACEEK LTD",
    1116: "Delta T Corporation",
    1117: "Boston Scientific Corporation",
    1118: "Nuviz, Inc.",
    1119: "Real Time Automation, Inc.",
    1120: "Kolibree",
    1121: "vhf elektronik GmbH",
    1122: "Bonsai Systems GmbH",
    1123: "Fathom Systems Inc.",
    1124: "Bellman & Symfon",
    1125: "International Forte Group LLC",
    1126: "CycleLabs Solutions inc.",
    1127: "Codenex Oy",
    1128: "Kynesim Ltd",
    1129: "Palago AB",
    1130: "INSIGMA INC.",
    1131: "PMD Solutions",
    1132: "Qingdao Realtime Technology Co., Ltd.",
    1133: "BEGA Gantenbrink-Leuchten KG",
    1134: "Pambor Ltd.",
    65535: "SPECIAL USE/DEFAULT"
  };
});

// node_modules/systeminformation/lib/bluetooth.js
var require_bluetooth = __commonJS((exports) => {
  var exec = __require("child_process").exec;
  var execSync = __require("child_process").execSync;
  var path = __require("path");
  var util = require_util7();
  var bluetoothVendors = require_bluetoothVendors();
  var fs = __require("fs");
  var _platform = process.platform;
  var _linux = _platform === "linux" || _platform === "android";
  var _darwin = _platform === "darwin";
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  function parseBluetoothType(str) {
    let result2 = "";
    if (str.indexOf("keyboard") >= 0) {
      result2 = "Keyboard";
    }
    if (str.indexOf("mouse") >= 0) {
      result2 = "Mouse";
    }
    if (str.indexOf("trackpad") >= 0) {
      result2 = "Trackpad";
    }
    if (str.indexOf("audio") >= 0) {
      result2 = "Audio";
    }
    if (str.indexOf("sound") >= 0) {
      result2 = "Audio";
    }
    if (str.indexOf("microph") >= 0) {
      result2 = "Microphone";
    }
    if (str.indexOf("speaker") >= 0) {
      result2 = "Speaker";
    }
    if (str.indexOf("headset") >= 0) {
      result2 = "Headset";
    }
    if (str.indexOf("phone") >= 0) {
      result2 = "Phone";
    }
    if (str.indexOf("macbook") >= 0) {
      result2 = "Computer";
    }
    if (str.indexOf("imac") >= 0) {
      result2 = "Computer";
    }
    if (str.indexOf("ipad") >= 0) {
      result2 = "Tablet";
    }
    if (str.indexOf("watch") >= 0) {
      result2 = "Watch";
    }
    if (str.indexOf("headphone") >= 0) {
      result2 = "Headset";
    }
    return result2;
  }
  function parseBluetoothManufacturer(str) {
    let result2 = str.split(" ")[0];
    str = str.toLowerCase();
    if (str.indexOf("apple") >= 0) {
      result2 = "Apple";
    }
    if (str.indexOf("ipad") >= 0) {
      result2 = "Apple";
    }
    if (str.indexOf("imac") >= 0) {
      result2 = "Apple";
    }
    if (str.indexOf("iphone") >= 0) {
      result2 = "Apple";
    }
    if (str.indexOf("magic mouse") >= 0) {
      result2 = "Apple";
    }
    if (str.indexOf("magic track") >= 0) {
      result2 = "Apple";
    }
    if (str.indexOf("macbook") >= 0) {
      result2 = "Apple";
    }
    return result2;
  }
  function parseBluetoothVendor(str) {
    const id = parseInt(str);
    if (!isNaN(id))
      return bluetoothVendors[id];
  }
  function parseLinuxBluetoothInfo(lines, macAddr1, macAddr2) {
    const result2 = {};
    result2.device = null;
    result2.name = util.getValue(lines, "name", "=");
    result2.manufacturer = null;
    result2.macDevice = macAddr1;
    result2.macHost = macAddr2;
    result2.batteryPercent = null;
    result2.type = parseBluetoothType(result2.name.toLowerCase());
    result2.connected = false;
    return result2;
  }
  function parseDarwinBluetoothDevices(bluetoothObject, macAddr2) {
    const result2 = {};
    const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || "") + (bluetoothObject.device_name || "")).toLowerCase();
    result2.device = bluetoothObject.device_services || "";
    result2.name = bluetoothObject.device_name || "";
    result2.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothVendor(bluetoothObject.device_vendorID) || parseBluetoothManufacturer(bluetoothObject.device_name || "") || "";
    result2.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || "").toLowerCase().replace(/-/g, ":");
    result2.macHost = macAddr2;
    result2.batteryPercent = bluetoothObject.device_batteryPercent || null;
    result2.type = parseBluetoothType(typeStr);
    result2.connected = bluetoothObject.device_isconnected === "attrib_Yes" || false;
    return result2;
  }
  function parseWindowsBluetooth(lines) {
    const result2 = {};
    result2.device = null;
    result2.name = util.getValue(lines, "name", ":");
    result2.manufacturer = util.getValue(lines, "manufacturer", ":");
    result2.macDevice = null;
    result2.macHost = null;
    result2.batteryPercent = null;
    result2.type = parseBluetoothType(result2.name.toLowerCase());
    result2.connected = null;
    return result2;
  }
  function bluetoothDevices(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let result2 = [];
        if (_linux) {
          const btFiles = util.getFilesInPath("/var/lib/bluetooth/");
          btFiles.forEach((element) => {
            const filename = path.basename(element);
            const pathParts = element.split("/");
            const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;
            const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;
            if (filename === "info") {
              const infoFile = fs.readFileSync(element, { encoding: "utf8" }).split(`
`);
              result2.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));
            }
          });
          try {
            const hdicon = execSync("hcitool con", util.execOptsLinux).toString().toLowerCase();
            for (let i = 0;i < result2.length; i++) {
              if (result2[i].macDevice && result2[i].macDevice.length > 10 && hdicon.indexOf(result2[i].macDevice.toLowerCase()) >= 0) {
                result2[i].connected = true;
              }
            }
          } catch {
            util.noop();
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        }
        if (_darwin) {
          let cmd = "system_profiler SPBluetoothDataType -json";
          exec(cmd, (error2, stdout) => {
            if (!error2) {
              try {
                const outObj = JSON.parse(stdout.toString());
                if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_title"] && outObj.SPBluetoothDataType[0]["device_title"].length) {
                  let macAddr2 = null;
                  if (outObj.SPBluetoothDataType[0]["local_device_title"] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {
                    macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ":");
                  }
                  outObj.SPBluetoothDataType[0]["device_title"].forEach((element) => {
                    const obj = element;
                    const objKey = Object.keys(obj);
                    if (objKey && objKey.length === 1) {
                      const innerObject = obj[objKey[0]];
                      innerObject.device_name = objKey[0];
                      const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                      result2.push(bluetoothDevice);
                    }
                  });
                }
                if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_connected"] && outObj.SPBluetoothDataType[0]["device_connected"].length) {
                  const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                  outObj.SPBluetoothDataType[0]["device_connected"].forEach((element) => {
                    const obj = element;
                    const objKey = Object.keys(obj);
                    if (objKey && objKey.length === 1) {
                      const innerObject = obj[objKey[0]];
                      innerObject.device_name = objKey[0];
                      innerObject.device_isconnected = "attrib_Yes";
                      const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                      result2.push(bluetoothDevice);
                    }
                  });
                }
                if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_not_connected"] && outObj.SPBluetoothDataType[0]["device_not_connected"].length) {
                  const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                  outObj.SPBluetoothDataType[0]["device_not_connected"].forEach((element) => {
                    const obj = element;
                    const objKey = Object.keys(obj);
                    if (objKey && objKey.length === 1) {
                      const innerObject = obj[objKey[0]];
                      innerObject.device_name = objKey[0];
                      innerObject.device_isconnected = "attrib_No";
                      const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                      result2.push(bluetoothDevice);
                    }
                  });
                }
              } catch {
                util.noop();
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_windows) {
          util.powerShell("Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer, Status, Service, ConfigManagerErrorCode, Present | fl").then((stdout, error2) => {
            if (!error2) {
              const parts = stdout.toString().split(/\n\s*\n/);
              parts.forEach((part) => {
                const lines = part.split(`
`);
                const service = util.getValue(lines, "Service", ":");
                const errorCode = util.getValue(lines, "ConfigManagerErrorCode", ":");
                const pnpClass = util.getValue(lines, "PNPClass", ":").toLowerCase();
                if (pnpClass === "bluetooth" && errorCode === "0" && service === "") {
                  result2.push(parseWindowsBluetooth(lines));
                }
              });
            }
            if (callback) {
              callback(result2);
            }
            resolve(result2);
          });
        }
        if (_freebsd || _netbsd || _openbsd || _sunos) {
          resolve(null);
        }
      });
    });
  }
  exports.bluetoothDevices = bluetoothDevices;
});

// node_modules/systeminformation/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var lib_version = require_package().version;
  var util = require_util7();
  var system = require_system();
  var osInfo = require_osinfo();
  var cpu = require_cpu();
  var memory = require_memory();
  var battery = require_battery();
  var graphics = require_graphics();
  var filesystem = require_filesystem();
  var network = require_network();
  var wifi = require_wifi();
  var processes = require_processes();
  var users = require_users();
  var internet = require_internet();
  var docker = require_docker();
  var vbox = require_virtualbox();
  var printer = require_printer();
  var usb = require_usb();
  var audio = require_audio();
  var bluetooth = require_bluetooth();
  var _platform = process.platform;
  var _windows = _platform === "win32";
  var _freebsd = _platform === "freebsd";
  var _openbsd = _platform === "openbsd";
  var _netbsd = _platform === "netbsd";
  var _sunos = _platform === "sunos";
  if (_windows) {
    util.getCodepage();
    util.getPowershell();
  }
  function version() {
    return lib_version;
  }
  function getStaticData(callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const data = {};
        data.version = version();
        Promise.all([
          system.system(),
          system.bios(),
          system.baseboard(),
          system.chassis(),
          osInfo.osInfo(),
          osInfo.uuid(),
          osInfo.versions(),
          cpu.cpu(),
          cpu.cpuFlags(),
          graphics.graphics(),
          network.networkInterfaces(),
          memory.memLayout(),
          filesystem.diskLayout(),
          audio.audio(),
          bluetooth.bluetoothDevices(),
          usb.usb(),
          printer.printer()
        ]).then((res) => {
          data.system = res[0];
          data.bios = res[1];
          data.baseboard = res[2];
          data.chassis = res[3];
          data.os = res[4];
          data.uuid = res[5];
          data.versions = res[6];
          data.cpu = res[7];
          data.cpu.flags = res[8];
          data.graphics = res[9];
          data.net = res[10];
          data.memLayout = res[11];
          data.diskLayout = res[12];
          data.audio = res[13];
          data.bluetooth = res[14];
          data.usb = res[15];
          data.printer = res[16];
          if (callback) {
            callback(data);
          }
          resolve(data);
        });
      });
    });
  }
  function getDynamicData(srv, iface, callback) {
    if (util.isFunction(iface)) {
      callback = iface;
      iface = "";
    }
    if (util.isFunction(srv)) {
      callback = srv;
      srv = "";
    }
    return new Promise((resolve) => {
      process.nextTick(() => {
        iface = iface || network.getDefaultNetworkInterface();
        srv = srv || "";
        let functionProcessed = (() => {
          let totalFunctions = 15;
          if (_windows) {
            totalFunctions = 13;
          }
          if (_freebsd || _openbsd || _netbsd) {
            totalFunctions = 11;
          }
          if (_sunos) {
            totalFunctions = 6;
          }
          return function() {
            if (--totalFunctions === 0) {
              if (callback) {
                callback(data);
              }
              resolve(data);
            }
          };
        })();
        const data = {};
        data.time = osInfo.time();
        data.node = process.versions.node;
        data.v8 = process.versions.v8;
        cpu.cpuCurrentSpeed().then((res) => {
          data.cpuCurrentSpeed = res;
          functionProcessed();
        });
        users.users().then((res) => {
          data.users = res;
          functionProcessed();
        });
        processes.processes().then((res) => {
          data.processes = res;
          functionProcessed();
        });
        cpu.currentLoad().then((res) => {
          data.currentLoad = res;
          functionProcessed();
        });
        if (!_sunos) {
          cpu.cpuTemperature().then((res) => {
            data.temp = res;
            functionProcessed();
          });
        }
        if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
          network.networkStats(iface).then((res) => {
            data.networkStats = res;
            functionProcessed();
          });
        }
        if (!_sunos) {
          network.networkConnections().then((res) => {
            data.networkConnections = res;
            functionProcessed();
          });
        }
        memory.mem().then((res) => {
          data.mem = res;
          functionProcessed();
        });
        if (!_sunos) {
          battery().then((res) => {
            data.battery = res;
            functionProcessed();
          });
        }
        if (!_sunos) {
          processes.services(srv).then((res) => {
            data.services = res;
            functionProcessed();
          });
        }
        if (!_sunos) {
          filesystem.fsSize().then((res) => {
            data.fsSize = res;
            functionProcessed();
          });
        }
        if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
          filesystem.fsStats().then((res) => {
            data.fsStats = res;
            functionProcessed();
          });
        }
        if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
          filesystem.disksIO().then((res) => {
            data.disksIO = res;
            functionProcessed();
          });
        }
        if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
          wifi.wifiNetworks().then((res) => {
            data.wifiNetworks = res;
            functionProcessed();
          });
        }
        internet.inetLatency().then((res) => {
          data.inetLatency = res;
          functionProcessed();
        });
      });
    });
  }
  function getAllData(srv, iface, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        let data = {};
        if (iface && util.isFunction(iface) && !callback) {
          callback = iface;
          iface = "";
        }
        if (srv && util.isFunction(srv) && !iface && !callback) {
          callback = srv;
          srv = "";
          iface = "";
        }
        getStaticData().then((res) => {
          data = res;
          getDynamicData(srv, iface).then((res2) => {
            for (let key in res2) {
              if ({}.hasOwnProperty.call(res2, key)) {
                data[key] = res2[key];
              }
            }
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        });
      });
    });
  }
  function get(valueObject, callback) {
    return new Promise((resolve) => {
      process.nextTick(() => {
        const allPromises = Object.keys(valueObject).filter((func) => ({}).hasOwnProperty.call(exports, func)).map((func) => {
          const params = valueObject[func].substring(valueObject[func].lastIndexOf("(") + 1, valueObject[func].lastIndexOf(")"));
          let funcWithoutParams = func.indexOf(")") >= 0 ? func.split(")")[1].trim() : func;
          funcWithoutParams = func.indexOf("|") >= 0 ? func.split("|")[0].trim() : funcWithoutParams;
          if (params) {
            return exports[funcWithoutParams](params);
          } else {
            return exports[funcWithoutParams]("");
          }
        });
        Promise.all(allPromises).then((data) => {
          const result2 = {};
          let i = 0;
          for (let key in valueObject) {
            if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports, key) && data.length > i) {
              if (valueObject[key] === "*" || valueObject[key] === "all") {
                result2[key] = data[i];
              } else {
                let keys = valueObject[key];
                let filter = "";
                let filterParts = [];
                if (keys.indexOf(")") >= 0) {
                  keys = keys.split(")")[1].trim();
                }
                if (keys.indexOf("|") >= 0) {
                  filter = keys.split("|")[1].trim();
                  filterParts = filter.split(":");
                  keys = keys.split("|")[0].trim();
                }
                keys = keys.replace(/,/g, " ").replace(/ +/g, " ").split(" ");
                if (data[i]) {
                  if (Array.isArray(data[i])) {
                    const partialArray = [];
                    data[i].forEach((element) => {
                      let partialRes = {};
                      if (keys.length === 1 && (keys[0] === "*" || keys[0] === "all")) {
                        partialRes = element;
                      } else {
                        keys.forEach((k) => {
                          if ({}.hasOwnProperty.call(element, k)) {
                            partialRes[k] = element[k];
                          }
                        });
                      }
                      if (filter && filterParts.length === 2) {
                        if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {
                          const val = partialRes[filterParts[0].trim()];
                          if (typeof val === "number") {
                            if (val === parseFloat(filterParts[1].trim())) {
                              partialArray.push(partialRes);
                            }
                          } else if (typeof val === "string") {
                            if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {
                              partialArray.push(partialRes);
                            }
                          }
                        }
                      } else {
                        partialArray.push(partialRes);
                      }
                    });
                    result2[key] = partialArray;
                  } else {
                    const partialRes = {};
                    keys.forEach((k) => {
                      if ({}.hasOwnProperty.call(data[i], k)) {
                        partialRes[k] = data[i][k];
                      }
                    });
                    result2[key] = partialRes;
                  }
                } else {
                  result2[key] = {};
                }
              }
              i++;
            }
          }
          if (callback) {
            callback(result2);
          }
          resolve(result2);
        });
      });
    });
  }
  function observe(valueObject, interval, callback) {
    let _data = null;
    const result2 = setInterval(() => {
      get(valueObject).then((data) => {
        if (JSON.stringify(_data) !== JSON.stringify(data)) {
          _data = Object.assign({}, data);
          callback(data);
        }
      });
    }, interval);
    return result2;
  }
  exports.version = version;
  exports.system = system.system;
  exports.bios = system.bios;
  exports.baseboard = system.baseboard;
  exports.chassis = system.chassis;
  exports.time = osInfo.time;
  exports.osInfo = osInfo.osInfo;
  exports.versions = osInfo.versions;
  exports.shell = osInfo.shell;
  exports.uuid = osInfo.uuid;
  exports.cpu = cpu.cpu;
  exports.cpuFlags = cpu.cpuFlags;
  exports.cpuCache = cpu.cpuCache;
  exports.cpuCurrentSpeed = cpu.cpuCurrentSpeed;
  exports.cpuTemperature = cpu.cpuTemperature;
  exports.currentLoad = cpu.currentLoad;
  exports.fullLoad = cpu.fullLoad;
  exports.mem = memory.mem;
  exports.memLayout = memory.memLayout;
  exports.battery = battery;
  exports.graphics = graphics.graphics;
  exports.fsSize = filesystem.fsSize;
  exports.fsOpenFiles = filesystem.fsOpenFiles;
  exports.blockDevices = filesystem.blockDevices;
  exports.fsStats = filesystem.fsStats;
  exports.disksIO = filesystem.disksIO;
  exports.diskLayout = filesystem.diskLayout;
  exports.networkInterfaceDefault = network.networkInterfaceDefault;
  exports.networkGatewayDefault = network.networkGatewayDefault;
  exports.networkInterfaces = network.networkInterfaces;
  exports.networkStats = network.networkStats;
  exports.networkConnections = network.networkConnections;
  exports.wifiNetworks = wifi.wifiNetworks;
  exports.wifiInterfaces = wifi.wifiInterfaces;
  exports.wifiConnections = wifi.wifiConnections;
  exports.services = processes.services;
  exports.processes = processes.processes;
  exports.processLoad = processes.processLoad;
  exports.users = users.users;
  exports.inetChecksite = internet.inetChecksite;
  exports.inetLatency = internet.inetLatency;
  exports.dockerInfo = docker.dockerInfo;
  exports.dockerImages = docker.dockerImages;
  exports.dockerContainers = docker.dockerContainers;
  exports.dockerContainerStats = docker.dockerContainerStats;
  exports.dockerContainerProcesses = docker.dockerContainerProcesses;
  exports.dockerVolumes = docker.dockerVolumes;
  exports.dockerAll = docker.dockerAll;
  exports.vboxInfo = vbox.vboxInfo;
  exports.printer = printer.printer;
  exports.usb = usb.usb;
  exports.audio = audio.audio;
  exports.bluetoothDevices = bluetooth.bluetoothDevices;
  exports.getStaticData = getStaticData;
  exports.getDynamicData = getDynamicData;
  exports.getAllData = getAllData;
  exports.get = get;
  exports.observe = observe;
  exports.powerShellStart = util.powerShellStart;
  exports.powerShellRelease = util.powerShellRelease;
});

// src/main/server.ts
var import_core2 = __toESM(require_core(), 1);
import { createServer } from "node:http";

// src/main/metrics.ts
var import_core = __toESM(require_core(), 1);
var import_systeminformation = __toESM(require_lib2(), 1);

class Metrics {
  data;
  intervalMs;
  constructor() {
    this.data = { cpuLoadPercentages: [], memoryUsageMBs: [] };
    this.intervalMs = 5 * 1000;
    const intervalSecondsInput = process.env.METRICS_INTERVAL_SECONDS;
    if (intervalSecondsInput) {
      const intervalSecondsVal = parseInt(intervalSecondsInput, 10);
      if (Number.isInteger(intervalSecondsVal)) {
        this.intervalMs = intervalSecondsVal * 1000;
      }
    }
    this.append(Date.now()).catch(import_core.setFailed);
  }
  get() {
    return JSON.stringify(this.data);
  }
  async append(unixTimeMs) {
    try {
      const {
        currentLoadUser,
        currentLoadSystem
      } = await import_systeminformation.currentLoad();
      this.data.cpuLoadPercentages.push({
        unixTimeMs,
        user: currentLoadUser,
        system: currentLoadSystem
      });
      const bytesPerMB = 1024 * 1024;
      const { active, available } = await import_systeminformation.mem();
      this.data.memoryUsageMBs.push({
        unixTimeMs,
        used: active / bytesPerMB,
        free: available / bytesPerMB
      });
    } catch (error2) {
      import_core.setFailed(error2);
    } finally {
      const nextUNIXTimeMs = unixTimeMs + this.intervalMs;
      setTimeout(() => this.append(nextUNIXTimeMs).catch(import_core.setFailed), Math.max(0, nextUNIXTimeMs - Date.now()));
    }
  }
}

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result2) => {
  if (isValid(result2)) {
    return { success: true, data: result2.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result2 = this._parse(input);
    if (isAsync(result2)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result2;
  }
  _parseAsync(input) {
    const result2 = this._parse(input);
    return Promise.resolve(result2);
  }
  parse(data, params) {
    const result2 = this.safeParse(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result2);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result2 = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result2) ? {
          value: result2.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result2) => isValid(result2) ? {
      value: result2.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result2 = await this.safeParseAsync(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result2);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result2 = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result2 instanceof Promise) {
        return result2.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result2) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result3) => {
        return ParseStatus.mergeArray(status, result3);
      });
    }
    const result2 = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result2);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result2 of results) {
        if (result2.result.status === "valid") {
          return result2.result;
        }
      }
      for (const result2 of results) {
        if (result2.result.status === "dirty") {
          ctx.common.issues.push(...result2.ctx.common.issues);
          return result2.result;
        }
      }
      const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result2 = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result2.status === "valid") {
          return result2;
        } else if (result2.status === "dirty" && !dirty) {
          dirty = { result: result2, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error2.addIssue(makeArgsIssue(args, e));
          throw error2;
        });
        const result2 = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result2, params).catch((e) => {
          error2.addIssue(makeReturnsIssue(result2, e));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result2 = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result2, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result2 = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result2.status === "aborted")
            return INVALID;
          if (result2.status === "dirty")
            return DIRTY(result2.value);
          if (status.value === "dirty")
            return DIRTY(result2.value);
          return result2;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result2 = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result2.status === "aborted")
          return INVALID;
        if (result2.status === "dirty")
          return DIRTY(result2.value);
        if (status.value === "dirty")
          return DIRTY(result2.value);
        return result2;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result2 = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result2);
        }
        if (result2 instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result2 = effect.transform(base.value, checkCtx);
        if (result2 instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result2 };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({
            status: status.value,
            value: result2
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result2 = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result2)) {
      return result2.then((result3) => {
        return {
          status: "valid",
          value: result3.status === "valid" ? result3.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result2.status === "valid" ? result2.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result2 = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result2) ? result2.then((data) => freeze(data)) : freeze(result2);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// src/lib.ts
var cpuLoadPercentageSchema = exports_external.object({
  unixTimeMs: exports_external.number().finite(),
  user: exports_external.number().finite().nonnegative().max(100),
  system: exports_external.number().finite().nonnegative().max(100)
});
var cpuLoadPercentagesSchema = exports_external.array(cpuLoadPercentageSchema);
var memoryUsageMBSchema = exports_external.object({
  unixTimeMs: exports_external.number().finite(),
  used: exports_external.number().finite().nonnegative(),
  free: exports_external.number().finite().nonnegative()
});
var memoryUsageMBsSchema = exports_external.array(memoryUsageMBSchema);
var metricsDataSchema = exports_external.object({
  cpuLoadPercentages: cpuLoadPercentagesSchema,
  memoryUsageMBs: memoryUsageMBsSchema
});
var serverPort = 7777;

// src/main/server.ts
async function server() {
  const metrics = new Metrics;
  const server2 = createServer((request, response) => {
    try {
      switch (request.url) {
        case "/metrics":
          response.setHeader("Content-Type", "application/json");
          response.setHeader("Access-Control-Allow-Origin", "*");
          response.statusCode = 200;
          response.end(metrics.get());
          break;
        case "/finish":
          response.statusCode = 200;
          response.end();
          server2.close(() => process.exit(0));
          break;
      }
    } catch (error2) {
      response.statusCode = 500;
      response.setHeader("Content-Type", "application/json");
      response.end(JSON.stringify({ error: "Internal server error" }));
      import_core2.setFailed(error2);
    }
  });
  server2.on("error", import_core2.setFailed);
  server2.listen(serverPort);
}
await server();

//# debugId=6F3418B0D25E419964756E2164756E21
//# sourceMappingURL=server.bundle.js.map
